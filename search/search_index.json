{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"sPyTial","text":"<p>sPyTial helps you turn Python objects into meaningful box-and-arrow diagrams using spatial layout rules. It focuses on the structure of your data rather than UI chrome, making it ideal for debugging, teaching, and research.</p>"},{"location":"#what-you-can-do","title":"What you can do","text":"<ul> <li>Diagram any Python object in a browser tab or notebook.</li> <li>Evaluate your data as a structured payload to validate serialization.</li> <li>Annotate types or instances with spatial constraints (orientation, grouping, colors, icons, etc.).</li> <li>Build dataclass instances with a visual, copy/pasteable builder.</li> <li>Extend the serializer with custom relationalizers for domain objects.</li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install spytial-diagramming\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>import spytial\n\ndata = {\n    \"name\": \"root\",\n    \"children\": [\n        {\"value\": 1},\n        {\"value\": 2},\n        {\"value\": 3},\n    ],\n}\n\n# Open a diagram in a browser or inline notebook view.\nspytial.diagram(data)\n</code></pre>"},{"location":"#documentation-layout","title":"Documentation layout","text":"<p>Use the sections in the navigation to explore:</p> <ul> <li>Getting Started for installation and first steps.</li> <li>Usage for diagramming, evaluation, and builder workflows.</li> <li>Annotations &amp; Constraints for spatial controls.</li> <li>Custom Relationalizers to extend serialization for your own types.</li> <li>API Reference for auto-generated docs from the codebase.</li> </ul>"},{"location":"DATACLASS_BUILDER/","title":"sPyTial Dataclass Builder Widget (spytial-core Integration)","text":""},{"location":"DATACLASS_BUILDER/#overview","title":"Overview","text":"<p>The sPyTial Dataclass Builder is a Jupyter widget that provides visual, interactive construction of dataclass instances using spytial-core's <code>structured-input-graph</code> component. It enables users to build complex data structures visually with spatial constraints and immediately access the result.</p>"},{"location":"DATACLASS_BUILDER/#key-features","title":"Key Features","text":"<ul> <li>Visual Construction: Uses spytial-core's graph-based visual interface</li> <li>Spatial Annotations: Automatically includes constraints from sPyTial decorators</li> <li>No File I/O: Direct JavaScript-Python communication via postMessage</li> <li>Real-time Access: <code>widget.value</code> always contains the current dataclass instance</li> <li>No Timeouts: Immediate updates when you export data</li> </ul>"},{"location":"DATACLASS_BUILDER/#installation","title":"Installation","text":"<pre><code>pip install ipywidgets\njupyter nbextension enable --py widgetsnbextension\n</code></pre>"},{"location":"DATACLASS_BUILDER/#basic-usage","title":"Basic Usage","text":"<pre><code>from dataclasses import dataclass\nimport spytial\n\n@dataclass\nclass Person:\n    name: str = \"\"\n    age: int = 0\n    email: str = \"\"\n\n# Create the widget\nwidget = spytial.dataclass_builder(Person)\nwidget  # Display in Jupyter\n\n# After building and clicking \"Export JSON\":\nperson = widget.value\nprint(person)  # Person(name='Alice', age=30, email='alice@example.com')\n</code></pre>"},{"location":"DEVELOPMENT/","title":"sPyTial Development Guide","text":""},{"location":"DEVELOPMENT/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/sidprasad/spytial.git\ncd spytial\n</code></pre></p> </li> <li> <p>Install in development mode: <pre><code>pip install -e .\npip install pytest&gt;=7.0.0 flake8&gt;=6.0.0 black&gt;=23.0.0\n</code></pre></p> </li> <li> <p>Run tests: <pre><code>python -m pytest test/ -v\n</code></pre></p> </li> </ol>"},{"location":"DEVELOPMENT/#code-quality","title":"Code Quality","text":""},{"location":"DEVELOPMENT/#formatting","title":"Formatting","text":"<pre><code># Check formatting\npython -m black spytial/ --check\n\n# Apply formatting\npython -m black spytial/\n</code></pre>"},{"location":"DEVELOPMENT/#linting","title":"Linting","text":"<pre><code>python -m flake8 spytial/ --count --statistics\n</code></pre>"},{"location":"DEVELOPMENT/#common-development-issues","title":"Common Development Issues","text":""},{"location":"DEVELOPMENT/#erroneous-version-files","title":"Erroneous Version Files","text":"<p>If you see files like <code>=23.0.0</code>, <code>=6.0.0</code>, <code>=7.0.0</code> in your directory:</p> <p>What they are: These files are created when pip install commands are malformed, causing version specifiers to be interpreted as filenames instead of package requirements.</p> <p>How to fix: <pre><code># Remove them\nrm -f \"=*.*.*\"\n\n# They're already in .gitignore so won't be tracked\n</code></pre></p> <p>Prevention: Always use proper pip install syntax: <pre><code># \u2705 Correct\npip install \"package&gt;=1.0.0\"\n\n# \u274c Incorrect (creates =1.0.0 file)\npip install package&gt;=1.0.0\n</code></pre></p>"},{"location":"DEVELOPMENT/#publishing","title":"Publishing","text":"<p>See PUBLISHING.md for complete publishing instructions.</p>"},{"location":"DEVELOPMENT/#quick-validation","title":"Quick validation:","text":"<pre><code>python scripts/quick_publish_check.py\n</code></pre>"},{"location":"DEVELOPMENT/#git-workflow","title":"Git Workflow","text":""},{"location":"DEVELOPMENT/#branches","title":"Branches","text":"<ul> <li><code>main</code> - Production releases</li> <li><code>publishing</code> - Publishing workflow setup</li> <li><code>develop</code> - Development integration</li> </ul>"},{"location":"DEVELOPMENT/#releases","title":"Releases","text":"<pre><code>git tag v0.1.0\ngit push origin main --tags\n# Create GitHub release to trigger automated publishing\n</code></pre>"},{"location":"PERFORMANCE_METRICS/","title":"Performance Metrics and Benchmarking","text":"<p>sPyTial includes built-in performance tracking and benchmarking capabilities to help you analyze visualization performance.</p>"},{"location":"PERFORMANCE_METRICS/#basic-usage","title":"Basic Usage","text":""},{"location":"PERFORMANCE_METRICS/#single-render-with-metrics","title":"Single Render with Metrics","text":"<pre><code>import spytial\n\ndata = {'name': 'Test', 'values': [1, 2, 3]}\nresult = spytial.diagram(data, method='file', auto_open=True)\n</code></pre> <p>Performance metrics are automatically tracked and available in the browser console: - Access via <code>window.spytialPerformance.getMetrics()</code> - Includes: parse spec time, layout generation time, render time, total time</p>"},{"location":"PERFORMANCE_METRICS/#performance-benchmarking","title":"Performance Benchmarking","text":"<p>Run multiple iterations to collect statistical metrics:</p> <pre><code>import spytial\n\ndata = {'complex': 'data', 'structure': [1, 2, 3, 4, 5]}\n\n# Run 10 iterations and collect metrics\nresult = spytial.diagram(\n    data,\n    method='file',\n    auto_open=True,\n    perf_iterations=10\n)\n</code></pre> <p>This will: 1. Render the visualization 10 times 2. Collect metrics for each iteration 3. Calculate min, max, average, and median for each metric 4. Automatically trigger a download of the aggregated results</p>"},{"location":"PERFORMANCE_METRICS/#custom-download-pathname","title":"Custom Download Path/Name","text":"<p>Specify a custom filename for the performance metrics:</p> <pre><code>import spytial\n\nresult = spytial.diagram(\n    data,\n    method='file',\n    perf_path='benchmarks/my-test/results.json',\n    perf_iterations=5\n)\n</code></pre> <p>Important Notes: - The browser will download the file to your default Downloads folder - The <code>perf_path</code> parameter sets the filename (not the actual filesystem path) - This avoids CORS issues with local file:// URLs - The browser may add a parent directory name to organize downloads</p>"},{"location":"PERFORMANCE_METRICS/#performance-metrics-structure","title":"Performance Metrics Structure","text":"<p>The downloaded JSON file contains:</p> <pre><code>{\n  \"parseSpec\": {\n    \"min\": 1.2,\n    \"max\": 2.5,\n    \"avg\": 1.8,\n    \"median\": 1.7\n  },\n  \"generateLayout\": {\n    \"min\": 45.3,\n    \"max\": 52.1,\n    \"avg\": 48.2,\n    \"median\": 47.9\n  },\n  \"renderLayout\": {\n    \"min\": 12.4,\n    \"max\": 15.8,\n    \"avg\": 13.9,\n    \"median\": 13.7\n  },\n  \"totalTime\": {\n    \"min\": 58.9,\n    \"max\": 70.4,\n    \"avg\": 63.9,\n    \"median\": 63.3\n  },\n  \"timestamp\": \"2025-10-23T10:30:45.123Z\",\n  \"iterations\": 5,\n  \"dataSize\": {\n    \"atomCount\": 42,\n    \"relationCount\": 38,\n    \"typeCount\": 5\n  }\n}\n</code></pre>"},{"location":"PERFORMANCE_METRICS/#browser-console-utilities","title":"Browser Console Utilities","text":"<p>When a visualization is loaded, performance utilities are available:</p> <pre><code>// Get current metrics\nwindow.spytialPerformance.getMetrics()\n\n// Get historical metrics from localStorage\nwindow.spytialPerformance.getHistory()\n\n// Download current metrics as JSON\nwindow.spytialPerformance.downloadMetrics()\n\n// Export all history as CSV\nwindow.spytialPerformance.exportAsCSV()\n\n// Clear stored history\nwindow.spytialPerformance.clearHistory()\n</code></pre>"},{"location":"PERFORMANCE_METRICS/#example-comparing-data-structures","title":"Example: Comparing Data Structures","text":"<pre><code>import spytial\n\n# Test different data structures\ntest_cases = [\n    ('small_list', [1, 2, 3, 4, 5]),\n    ('nested_dict', {'a': {'b': {'c': {'d': 'value'}}}},\n    ('large_tree', create_tree(depth=5, branching=3))\n]\n\nfor name, data in test_cases:\n    spytial.diagram(\n        data,\n        method='file',\n        auto_open=False,\n        perf_path=f'benchmarks/{name}.json',\n        perf_iterations=10\n    )\n</code></pre>"},{"location":"PERFORMANCE_METRICS/#troubleshooting","title":"Troubleshooting","text":""},{"location":"PERFORMANCE_METRICS/#cors-policy-error","title":"\"CORS policy\" Error","text":"<p>Fixed in current version. The old implementation tried to use <code>fetch()</code> with <code>file://</code> URLs, which browsers block. The new version uses blob URLs and browser download APIs, which work without CORS issues.</p>"},{"location":"PERFORMANCE_METRICS/#download-location","title":"Download Location","text":"<p>The browser controls where files are downloaded. You cannot programmatically set the exact filesystem path from a web page for security reasons. The <code>perf_path</code> parameter sets the suggested filename.</p>"},{"location":"PERFORMANCE_METRICS/#large-benchmarks","title":"Large Benchmarks","text":"<p>For very large datasets or many iterations, the browser may become unresponsive. Consider: - Reducing <code>perf_iterations</code> (5-10 is usually sufficient) - Running benchmarks with <code>auto_open=False</code> to avoid browser overhead - Using smaller representative datasets</p>"},{"location":"PERFORMANCE_METRICS/#performance-optimization-tips","title":"Performance Optimization Tips","text":"<p>Based on metrics, you can identify bottlenecks:</p> <ul> <li>High parseSpec time: Spytial-Core specification is complex, consider simplifying constraints</li> <li>High generateLayout time: Data structure is large or constraints are expensive to solve</li> <li>High renderLayout time: Many visual elements, consider simplifying styling or reducing data</li> </ul>"},{"location":"PERFORMANCE_METRICS/#see-also","title":"See Also","text":"<ul> <li>Spatial Annotations - Learn about spatial constraint decorators</li> <li>Development Guide - Development workflow and testing</li> </ul>"},{"location":"PUBLISHING/","title":"\ud83d\ude80 sPyTial Publishing Guide","text":"<p>This guide provides complete instructions for publishing sPyTial to PyPI, with both automated and manual options.</p>"},{"location":"PUBLISHING/#quick-reference","title":"\ud83d\udccb Quick Reference","text":""},{"location":"PUBLISHING/#status-check","title":"Status Check","text":"<pre><code># Run quick validation\npython scripts/quick_publish_check.py\n\n# Run comprehensive validation (includes all tests)\npython scripts/pre_publish_check.py\n</code></pre>"},{"location":"PUBLISHING/#automated-publishing-recommended","title":"Automated Publishing (Recommended)","text":"<pre><code># 1. Commit and tag\ngit add .\ngit commit -m \"Prepare for release v0.1.0\"\ngit tag v0.1.0\ngit push origin main --tags\n\n# 2. Create GitHub release (triggers auto-publish)\n# Go to GitHub \u2192 Releases \u2192 Create new release\n</code></pre>"},{"location":"PUBLISHING/#manual-publishing","title":"Manual Publishing","text":"<pre><code># Build and publish\npython -m build\ntwine upload dist/*\n</code></pre>"},{"location":"PUBLISHING/#automated-publishing-setup","title":"\ud83e\udd16 Automated Publishing Setup","text":""},{"location":"PUBLISHING/#prerequisites","title":"Prerequisites","text":"<ol> <li>GitHub Secrets Required:</li> <li><code>PYPI_API_TOKEN</code> - Your PyPI API token (Get one here)</li> <li> <p><code>TEST_PYPI_API_TOKEN</code> - Your Test PyPI API token (Get one here)</p> </li> <li> <p>How to Add Secrets:</p> </li> <li>Go to GitHub \u2192 Repository \u2192 Settings \u2192 Secrets and Variables \u2192 Actions</li> <li>Click \"New repository secret\"</li> <li>Add both tokens</li> </ol>"},{"location":"PUBLISHING/#workflows-available","title":"Workflows Available","text":""},{"location":"PUBLISHING/#1-continuous-integration-githubworkflowsciyml","title":"1. Continuous Integration (<code>.github/workflows/ci.yml</code>)","text":"<p>Triggers: Push to main/develop, Pull Requests</p> <p>What it does: - \u2705 Tests on Python 3.8-3.12 - \u2705 Code quality checks (black, flake8) - \u2705 Full test suite - \u2705 Build validation - \u2705 Installation testing</p>"},{"location":"PUBLISHING/#2-automated-publishing-githubworkflowspublishyml","title":"2. Automated Publishing (<code>.github/workflows/publish.yml</code>)","text":"<p>Triggers: GitHub Releases, Manual dispatch</p> <p>What it does: - \u2705 All CI checks plus comprehensive validation - \u2705 Core functionality tests (from copilot instructions) - \u2705 Package building and validation - \u2705 Automatic publishing to PyPI or Test PyPI - \u2705 Release summary generation</p>"},{"location":"PUBLISHING/#publishing-process","title":"Publishing Process","text":""},{"location":"PUBLISHING/#option-a-release-triggered-publishing","title":"Option A: Release-Triggered Publishing","text":"<ol> <li> <p>Prepare release: <pre><code>git add .\ngit commit -m \"Prepare for release v0.1.0\"\ngit tag v0.1.0\ngit push origin main --tags\n</code></pre></p> </li> <li> <p>Create GitHub release:</p> </li> <li>Go to GitHub \u2192 Releases \u2192 \"Create a new release\"</li> <li>Select your tag (v0.1.0)</li> <li>Add release notes</li> <li>Click \"Publish release\"</li> <li>Publishing automatically starts!</li> </ol>"},{"location":"PUBLISHING/#option-b-manual-workflow-trigger","title":"Option B: Manual Workflow Trigger","text":"<ol> <li>Go to GitHub Actions</li> <li>Select \"Publish to PyPI\" workflow</li> <li>Click \"Run workflow\"</li> <li>Choose options:</li> <li>\u2610 Publish to Test PyPI (for testing)</li> <li>\u2611 Publish to PyPI (for production)</li> </ol>"},{"location":"PUBLISHING/#manual-publishing_1","title":"\ud83d\udee0 Manual Publishing","text":""},{"location":"PUBLISHING/#prerequisites_1","title":"Prerequisites","text":"<pre><code>pip install build twine\n</code></pre>"},{"location":"PUBLISHING/#step-by-step-process","title":"Step-by-Step Process","text":"<ol> <li> <p>Validate everything is ready: <pre><code>python scripts/quick_publish_check.py\n</code></pre></p> </li> <li> <p>Clean previous builds: <pre><code>rm -rf build/ dist/ *.egg-info/\n</code></pre></p> </li> <li> <p>Build the package: <pre><code>python -m build\n</code></pre></p> </li> <li> <p>Test on Test PyPI first (recommended): <pre><code>twine upload --repository testpypi dist/*\n\n# Test install from Test PyPI\npip install --index-url https://test.pypi.org/simple/ spytial\npython -c \"import spytial; print('Test install successful!')\"\n</code></pre></p> </li> <li> <p>Publish to real PyPI: <pre><code>twine upload dist/*\n</code></pre></p> </li> </ol>"},{"location":"PUBLISHING/#validation-details","title":"\ud83d\udd0d Validation Details","text":""},{"location":"PUBLISHING/#quick-check-scriptsquick_publish_checkpy","title":"Quick Check (<code>scripts/quick_publish_check.py</code>)","text":"<ul> <li>\u2705 Package installation</li> <li>\u2705 Code formatting</li> <li>\u2705 Package building</li> <li>\u2705 Distribution validation</li> <li>\u2705 Core functionality test</li> </ul>"},{"location":"PUBLISHING/#comprehensive-check-scriptspre_publish_checkpy","title":"Comprehensive Check (<code>scripts/pre_publish_check.py</code>)","text":"<ul> <li>\u2705 All quick checks</li> <li>\u2705 Full test suite</li> <li>\u2705 All validation scenarios from copilot instructions:</li> <li>Basic visualization test</li> <li>Class-level annotations</li> <li>Object-level annotations</li> <li>Provider system validation</li> </ul>"},{"location":"PUBLISHING/#package-information","title":"\ud83d\udce6 Package Information","text":"<p>Package Name: <code>spytial</code> Current Version: <code>0.1.0</code> Repository: <code>https://github.com/sidprasad/spytial</code></p>"},{"location":"PUBLISHING/#installation-after-publishing","title":"Installation (After Publishing)","text":"<pre><code>pip install spytial\n</code></pre>"},{"location":"PUBLISHING/#dependencies","title":"Dependencies","text":"<ul> <li><code>jinja2&gt;=3.0.0</code></li> <li><code>pyyaml&gt;=6.0</code></li> <li><code>ipython&gt;=8.0.0</code></li> </ul>"},{"location":"PUBLISHING/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":""},{"location":"PUBLISHING/#common-issues","title":"Common Issues","text":"<ol> <li>Version files (=23.0.0, etc.):</li> <li>These are from broken pip install commands</li> <li>They're now in <code>.gitignore</code></li> <li> <p>Remove with: <code>rm -f \"=*.*.*\"</code></p> </li> <li> <p>Test failures:</p> </li> <li>Some advanced features may have failing tests</li> <li>Core functionality still works</li> <li> <p>Use <code>quick_publish_check.py</code> for essential validation</p> </li> <li> <p>Authentication errors:</p> </li> <li>Ensure API tokens are correctly set in GitHub secrets</li> <li> <p>Tokens need \"Entire account\" scope for publishing</p> </li> <li> <p>Build failures:</p> </li> <li>Check <code>pyproject.toml</code> and <code>setup.py</code> are consistent</li> <li>Ensure all required files are in <code>MANIFEST.in</code></li> </ol>"},{"location":"PUBLISHING/#getting-help","title":"Getting Help","text":"<ul> <li>Check GitHub Actions logs for detailed error messages</li> <li>Test locally with <code>python scripts/quick_publish_check.py</code></li> <li>Validate distribution with <code>twine check dist/*</code></li> </ul>"},{"location":"PUBLISHING/#version-management","title":"\ud83c\udfaf Version Management","text":""},{"location":"PUBLISHING/#releasing-new-versions","title":"Releasing New Versions","text":"<ol> <li>Update version numbers in:</li> <li><code>setup.py</code> (line with <code>version=</code>)</li> <li> <p><code>pyproject.toml</code> (line with <code>version =</code>)</p> </li> <li> <p>Create and push tag: <pre><code>git tag v0.1.1\ngit push origin main --tags\n</code></pre></p> </li> <li> <p>Create GitHub release or publish manually</p> </li> </ol>"},{"location":"PUBLISHING/#version-numbering","title":"Version Numbering","text":"<ul> <li>Use semantic versioning: <code>MAJOR.MINOR.PATCH</code></li> <li><code>0.1.0</code> \u2192 <code>0.1.1</code> (patch: bug fixes)</li> <li><code>0.1.1</code> \u2192 <code>0.2.0</code> (minor: new features)</li> <li><code>0.2.0</code> \u2192 <code>1.0.0</code> (major: breaking changes)</li> </ul>"},{"location":"PUBLISHING/#after-publishing","title":"\u2728 After Publishing","text":"<p>Users can install sPyTial with: <pre><code>pip install spytial\n</code></pre></p> <p>And use it immediately: <pre><code>import spytial\n\n# Visualize any Python object\ndata = {\"name\": \"example\", \"values\": [1, 2, 3]}\nspytial.diagram(data)\n</code></pre></p> <p>\ud83c\udf89 Happy Publishing!</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#install","title":"Install","text":"<pre><code>pip install spytial-diagramming\n</code></pre>"},{"location":"getting-started/#first-diagram","title":"First diagram","text":"<pre><code>import spytial\n\nexample = {\n    \"id\": \"root\",\n    \"children\": [\n        {\"id\": \"left\"},\n        {\"id\": \"right\"},\n    ],\n}\n\nspytial.diagram(example)\n</code></pre>"},{"location":"getting-started/#display-methods","title":"Display methods","text":"<p><code>sPyTial</code> chooses a display method based on environment:</p> <ul> <li>Notebook: renders inline.</li> <li>Anywhere else: opens a browser tab.</li> </ul> <p>You can override this explicitly:</p> <pre><code>spytial.diagram(example, method=\"browser\")   # open a new tab\nspytial.diagram(example, method=\"file\")      # write an HTML file\nspytial.diagram(example, method=\"inline\")    # force inline output\n</code></pre>"},{"location":"getting-started/#when-to-use-each-tool","title":"When to use each tool","text":"Tool Best for Output <code>diagram()</code> Visualizing object structure HTML diagram (inline or browser) <code>evaluate()</code> Inspecting serialized data HTML evaluator view <code>dataclass_builder()</code> Constructing dataclass instances Interactive builder <p>Next, dive into Usage to learn about the diagram and evaluator workflows.</p>"},{"location":"operations/","title":"Operations","text":"<p>Operations define how sPyTial interprets and renders your data. They fall into two categories:</p> <ul> <li>Constraints: describe how things should be laid out.</li> <li>Directives: describe how things should be drawn.</li> </ul> <p>Most users attach operations to classes with decorators. You can also attach them to specific objects or supply them via <code>typing.Annotated</code> or <code>spytial.AnnotatedType</code>.</p>"},{"location":"operations/#constraints-layout","title":"Constraints (layout)","text":"<p>Constraints affect the structure and layout of the diagram. Think of them as statements about where boxes should go relative to each other.</p> <ul> <li>orientation: directional relationships between selected boxes (for example, <code>left</code> vs. <code>directlyLeft</code>). Use spelled-out directions like <code>left</code>/<code>right</code>/<code>above</code>/<code>below</code> (not <code>TB</code>/<code>LR</code>). The stricter forms imply alignment on the perpendicular axis.</li> <li>align: force selected boxes to share a common axis (e.g., vertical alignment means they share the same top-left <code>x</code> coordinate).</li> <li>cyclic: arrange a sequence of boxes in a polygonal pattern, derived from an adjacency relation, to reflect cycles or ordered chains.</li> <li>group: introduce a bounding region that must contain selected boxes and exclude others (optionally with keyed subgroups).</li> </ul> <p>These constraints influence the geometry the solver must satisfy, so they directly shape layout.</p>"},{"location":"operations/#directives-drawing","title":"Directives (drawing)","text":"<p>Directives control rendering details. They do not change the underlying structure, but they alter how nodes and edges are drawn.</p> <ul> <li>atomColor / edgeColor: apply color to boxes or edges.</li> <li>attribute: replace outgoing edges with labels.</li> <li>inferredEdge: add derived edges to expose implicit relationships.</li> <li>icon: attach a graphical icon (optionally alongside the label).</li> <li>hideField: suppress drawing a field edge.</li> </ul> <p>Two operations are often used alongside directives:</p> <ul> <li>hideAtom: remove selected atoms from the realized layout entirely (prunes the diagram before solving).</li> <li>size: set explicit width/height for selected boxes.</li> </ul> <p>The API Reference lists every operation and its arguments.</p>"},{"location":"operations/#primary-attachment-class-decorators","title":"Primary attachment: class decorators","text":"<p>Attach operations to a class using decorators. This is the most common and reusable approach.</p> <pre><code>import spytial\n\n@spytial.orientation(selector=\"children\", directions=[\"below\"])\n@spytial.group(selector=\"children\", name=\"Cluster A\")\nclass Node:\n    def __init__(self, value, children=None):\n        self.value = value\n        self.children = children or []\n</code></pre>"},{"location":"operations/#other-attachment-methods","title":"Other attachment methods","text":""},{"location":"operations/#object-annotations","title":"Object annotations","text":"<p>Attach operations to a single instance without modifying the class:</p> <pre><code>node = Node(\"root\")\nspytial.annotate_orientation(node, selector=\"children\", directions=[\"below\"])\nspytial.annotate_group(node, selector=\"children\", name=\"Root Group\")\n</code></pre>"},{"location":"operations/#typingannotated-annotatedtype","title":"typing.Annotated / AnnotatedType","text":"<p>Treat a plain value as an annotated type (useful for dict/list data):</p> <pre><code>from typing import Annotated, Dict, List\nfrom spytial import InferredEdge, Orientation\n\nGraph = Annotated[\n    Dict[int, List[int]],\n    InferredEdge(name=\"edge\", selector=\"values\"),\n    Orientation(selector=\"values\", directions=[\"right\"]),\n]\n\nspytial.diagram({0: [1, 2]}, as_type=Graph)\n</code></pre>"},{"location":"operations/#convenience-operations","title":"Convenience operations","text":"<p>Some operations help you express common logic without repeating boilerplate.</p>"},{"location":"operations/#apply_if","title":"<code>apply_if</code>","text":"<p>Use <code>apply_if</code> to conditionally apply operations. This is convenient when only some instances should carry a decorator or directive.</p> <pre><code>import spytial\n\n@spytial.apply_if(lambda cls: cls.__name__.endswith(\"Node\"), spytial.icon(name=\"tree\"))\nclass TreeNode:\n    def __init__(self, value):\n        self.value = value\n</code></pre> <p>Note</p> <p><code>apply_if</code> is a shorthand for conditionally attaching operations. If the predicate returns <code>False</code>, no operation is applied.</p>"},{"location":"pythonspecific/","title":"Python Integration Details","text":"<p>This document summarizes how sPyTial uses Python features to bridge spatial annotations with the Spytial-Core atom/relation data model.</p>"},{"location":"pythonspecific/#annotation-lifecycle","title":"Annotation lifecycle","text":"<p>Decorator factories defined in <code>spytial.annotations</code> create per-constraint callables that can target either classes or individual objects. The unified decorator detects whether the target is a type or an instance, initializes or locates the appropriate registry, validates keyword arguments against the allowed schema, and stores the resulting payload in a structured <code>constraints</code>/<code>directives</code> map (<code>__spytial_registry__</code> for classes or <code>__spytial_object_annotations__</code>/a global fallback for objects).\u3010F:spytial/annotations.py\u2020L204-L341\u3011</p> <p>During serialization, <code>collect_decorators</code> walks the instance\u2019s method resolution order (MRO), merging each class registry that is eligible for inheritance and layering in any per-instance annotations from both direct attributes and the fallback registry.\u3010F:spytial/annotations.py\u2020L450-L499\u3011 The collected directives can then be emitted as YAML via <code>serialize_to_yaml_string</code>, allowing Spytial-Core to consume the constraints as part of a visualization spec.\u3010F:spytial/annotations.py\u2020L502-L508\u3011</p>"},{"location":"pythonspecific/#relationalization-pipeline","title":"Relationalization pipeline","text":"<p><code>CnDDataInstanceBuilder</code> orchestrates conversion of arbitrary Python values into the atom/relation graph that Spytial-Core expects. As it traverses an object graph it records encountered objects, captures their annotations, and selects an appropriate <code>RelationalizerBase</code> implementation from the <code>RelationalizerRegistry</code> to describe each value.\u3010F:spytial/provider_system.py\u2020L84-L259\u3011 Every relationalizer returns <code>Atom</code> and <code>Relation</code> dataclasses, which the builder normalizes, augments with type hierarchies, and merges into the aggregated instance payload (<code>{\"atoms\": ..., \"relations\": ..., \"types\": ...}</code>).\u3010F:spytial/provider_system.py\u2020L262-L355\u3011\u3010F:spytial/domain_relationalizers/base.py\u2020L13-L78\u3011 ID management ensures stable references for primitives, object instances, and annotated objects so relations remain consistent across the walk.\u3010F:spytial/provider_system.py\u2020L185-L224\u3011 The builder also deduplicates atoms and attaches inherited type information so Spytial-Core receives canonical tuples for each relation.\u3010F:spytial/provider_system.py\u2020L135-L180\u3011\u3010F:spytial/provider_system.py\u2020L270-L355\u3011</p>"},{"location":"pythonspecific/#enabling-python-features","title":"Enabling Python features","text":"<p>This integration relies on dynamic capabilities that are idiomatic to Python:</p> <ul> <li>Runtime attribute injection. Decorators and annotation helpers attach registries and identifiers directly onto classes or instances, and fall back to module-level dictionaries when objects do not expose <code>__dict__</code>. This leverages Python\u2019s ability to add attributes post-definition, even for decorator-generated metadata.\u3010F:spytial/annotations.py\u2020L204-L341\u3011</li> <li>Reflection and inspection. The builder uses <code>inspect.currentframe()</code> to locate the caller\u2019s namespace so relationalizers can recover variable names for labeling, and to derive MRO-based type hierarchies for atoms.\u3010F:spytial/provider_system.py\u2020L107-L176\u3011\u3010F:spytial/domain_relationalizers/base.py\u2020L55-L91\u3011</li> <li>Duck typing with registries. Relationalizers self-register through a decorator, and the registry queries each candidate\u2019s <code>can_handle</code> method at runtime to determine how to serialize a value. This plug-in mechanism depends on Python\u2019s flexible class system and dynamic imports.\u3010F:spytial/provider_system.py\u2020L15-L63\u3011</li> </ul> <p>Together these features let sPyTial observe, annotate, and serialize live Python objects without code generation, enabling a smooth bridge between idiomatic Python data structures and CnD\u2019s declarative spatial model.</p>"},{"location":"relationalizers/","title":"Custom Relationalizers","text":"<p>Relationalizers are plug-ins that teach sPyTial how to serialize your custom objects into atoms and relations.</p>"},{"location":"relationalizers/#when-to-use-a-relationalizer","title":"When to use a relationalizer","text":"<p>Use a relationalizer when:</p> <ul> <li>You want fine-grained control of how an object becomes nodes and edges.</li> <li>Your objects are not handled well by the built-in defaults.</li> <li>You need to emit domain-specific relations (e.g., <code>\"depends_on\"</code>, <code>\"flows_to\"</code>).</li> </ul>"},{"location":"relationalizers/#anatomy-of-a-relationalizer","title":"Anatomy of a relationalizer","text":"<p>A relationalizer is a class that inherits from <code>RelationalizerBase</code> and implements two methods:</p> <ul> <li><code>can_handle(obj)</code> \u2014 return <code>True</code> when the relationalizer should handle the object.</li> <li><code>relationalize(obj, builder)</code> \u2014 return <code>Atom</code> and <code>Relation</code> instances for the object.</li> </ul> <pre><code>from spytial import RelationalizerBase, relationalizer, Atom, Relation\n\n@relationalizer(priority=100)\nclass WidgetRelationalizer(RelationalizerBase):\n    def can_handle(self, obj):\n        return hasattr(obj, \"widget_id\")\n\n    def relationalize(self, obj, builder):\n        atom = Atom(\n            id=f\"widget:{obj.widget_id}\",\n            type=\"Widget\",\n            name=obj.widget_id,\n            attrs={\"label\": obj.label},\n        )\n        return [atom], []\n</code></pre>"},{"location":"relationalizers/#priorities","title":"Priorities","text":"<p>Relationalizers with higher priorities are checked first. Priorities from 0\u201399 are reserved for built-ins, so custom relationalizers should use 100 or higher.</p>"},{"location":"relationalizers/#registering-at-runtime","title":"Registering at runtime","text":"<p>The <code>@relationalizer</code> decorator registers the class automatically when the module is imported. If you want to register manually, you can call <code>RelationalizerRegistry.register()</code>.</p>"},{"location":"relationalizers/#inspecting-the-registry","title":"Inspecting the registry","text":"<pre><code>from spytial import RelationalizerRegistry\n\nprint(RelationalizerRegistry.list_relationalizers())\n</code></pre>"},{"location":"relationalizers/#next-steps","title":"Next steps","text":"<p>Once your relationalizer is in place, use <code>spytial.diagram()</code> or <code>spytial.evaluate()</code> to test how it behaves.</p>"},{"location":"reference/api/","title":"API Reference","text":"<p>This section is generated directly from the sPyTial source code using <code>mkdocstrings</code>.</p>"},{"location":"reference/api/#public-package","title":"Public package","text":""},{"location":"reference/api/#spytial","title":"<code>spytial</code>","text":""},{"location":"reference/api/#spytial.RelationalizerBase","title":"<code>RelationalizerBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for relationalizers.</p> <p>Relationalizers convert Python objects into atoms and relations for spatial visualization. They define how objects are represented as atoms and how relationships between objects are expressed as spatial relations.</p>"},{"location":"reference/api/#spytial.RelationalizerBase.can_handle","title":"<code>can_handle(obj)</code>  <code>abstractmethod</code>","text":"<p>Return True if this relationalizer can handle the given object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The Python object to test</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this relationalizer can process the object, False otherwise</p>"},{"location":"reference/api/#spytial.RelationalizerBase.relationalize","title":"<code>relationalize(obj, walker_func)</code>  <code>abstractmethod</code>","text":"<p>Convert object to atoms and relations using structured types.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to convert</p> required <code>walker_func</code> <code>Any</code> <p>Function to recursively walk nested objects</p> required <p>Returns:</p> Name Type Description <code>List[Atom]</code> <p>Tuple of (atoms_list, relations_list)</p> <code>atoms_list</code> <code>List[Relation]</code> <p>List of Atom instances representing the object</p> <code>relations_list</code> <code>Tuple[List[Atom], List[Relation]]</code> <p>List of Relation instances connecting this object to others</p>"},{"location":"reference/api/#spytial.RelationalizerRegistry","title":"<code>RelationalizerRegistry</code>","text":"<p>Registry for relationalizers.</p>"},{"location":"reference/api/#spytial.RelationalizerRegistry.register","title":"<code>register(relationalizer_cls, priority=0)</code>  <code>classmethod</code>","text":"<p>Register a relationalizer class with given priority.</p>"},{"location":"reference/api/#spytial.RelationalizerRegistry.find_relationalizer","title":"<code>find_relationalizer(obj)</code>  <code>classmethod</code>","text":"<p>Find the first relationalizer that can handle the given object.</p>"},{"location":"reference/api/#spytial.RelationalizerRegistry.list_relationalizers","title":"<code>list_relationalizers()</code>  <code>classmethod</code>","text":"<p>List all registered relationalizers with their priorities.</p> <p>Returns:</p> Type Description <code>List[Tuple[int, str]]</code> <p>List of (priority, relationalizer_class_name) tuples, sorted by priority (highest first)</p>"},{"location":"reference/api/#spytial.RelationalizerRegistry.clear","title":"<code>clear()</code>  <code>classmethod</code>","text":"<p>Clear all registered relationalizers (for testing).</p>"},{"location":"reference/api/#spytial.AnnotatedType","title":"<code>AnnotatedType</code>","text":"<p>A callable type alias that preserves spytial annotations.</p> <p>This provides a clean syntax for reusable annotated types:</p> <pre><code># Define once\nGraph = AnnotatedType(Dict[int, List[int]],\n    InferredEdge(selector=EDGE_SEL, name=\" \"))\n\n# Use naturally - Graph() wraps the value with type info\ng = Graph({0: [1], 1: [2], 2: []})\ndiagram(g)  # Annotations applied automatically!\n</code></pre> <p>The AnnotatedType acts as both: - A type hint (for documentation/type checkers) - A constructor (wraps values with the type info)</p>"},{"location":"reference/api/#spytial.AnnotatedType.__init__","title":"<code>__init__(base_type, *annotations)</code>","text":"<p>Create an annotated type alias.</p> <p>Parameters:</p> Name Type Description Default <code>base_type</code> <code>Any</code> <p>The underlying type (e.g., Dict[int, List[int]])</p> required <code>*annotations</code> <code>Any</code> <p>SpytialAnnotation instances (Orientation, InferredEdge, etc.)</p> <code>()</code>"},{"location":"reference/api/#spytial.AnnotatedType.__call__","title":"<code>__call__(value)</code>","text":"<p>Wrap a value with this type's annotations.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to wrap</p> required <p>Returns:</p> Name Type Description <code>Typed</code> <code>Typed</code> <p>A wrapper that diagram() will recognize</p>"},{"location":"reference/api/#spytial.SpytialAnnotation","title":"<code>SpytialAnnotation</code>","text":"<p>Base class for spytial type annotations.</p> <p>Subclasses represent specific constraints or directives that can be attached to type aliases using typing.Annotated.</p>"},{"location":"reference/api/#spytial.SpytialAnnotation.to_entry","title":"<code>to_entry()</code>","text":"<p>Convert to the internal registry format.</p>"},{"location":"reference/api/#spytial.Orientation","title":"<code>Orientation</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Orientation constraint for spatial layout.</p> Usage <p>from typing import Annotated IntList = Annotated[list[int], Orientation(selector='items', directions=['horizontal'])]</p>"},{"location":"reference/api/#spytial.Cyclic","title":"<code>Cyclic</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Cyclic constraint for circular layouts.</p> Usage <p>NodeRing = Annotated[list[Node], Cyclic(selector='items', direction='clockwise')]</p>"},{"location":"reference/api/#spytial.Align","title":"<code>Align</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Alignment constraint.</p> Usage <p>AlignedList = Annotated[list[int], Align(selector='items', direction='left')]</p>"},{"location":"reference/api/#spytial.Group","title":"<code>Group</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Grouping constraint.</p> <p>Usage (field-based):     Tree = Annotated[TreeNode, Group(field='children', groupOn=0, addToGroup=1)]</p> <p>Usage (selector-based):     Grouped = Annotated[MyType, Group(selector='items', name='mygroup')]</p>"},{"location":"reference/api/#spytial.AtomColor","title":"<code>AtomColor</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Atom color directive.</p> Usage <p>ColoredList = Annotated[list[int], AtomColor(selector='self', value='blue')]</p>"},{"location":"reference/api/#spytial.Size","title":"<code>Size</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Size directive.</p> Usage <p>SizedList = Annotated[list[int], Size(selector='items', height=50, width=50)]</p>"},{"location":"reference/api/#spytial.Icon","title":"<code>Icon</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Icon directive.</p> Usage <p>IconList = Annotated[list[int], Icon(selector='items', path='icon.svg', showLabels=True)]</p>"},{"location":"reference/api/#spytial.EdgeColor","title":"<code>EdgeColor</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Edge color directive.</p> Usage <p>ColoredEdges = Annotated[Tree, EdgeColor(field='children', value='red')]</p>"},{"location":"reference/api/#spytial.HideField","title":"<code>HideField</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Hide field directive.</p> Usage <p>CleanView = Annotated[MyClass, HideField(field='_private')]</p>"},{"location":"reference/api/#spytial.HideAtom","title":"<code>HideAtom</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Hide atom directive.</p> Usage <p>Filtered = Annotated[list[int], HideAtom(selector='hidden')]</p>"},{"location":"reference/api/#spytial.Projection","title":"<code>Projection</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Projection directive.</p> Usage <p>Projected = Annotated[MyType, Projection(sig='MySig')]</p>"},{"location":"reference/api/#spytial.Attribute","title":"<code>Attribute</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Attribute directive.</p> Usage <p>WithAttr = Annotated[MyType, Attribute(field='value')]</p>"},{"location":"reference/api/#spytial.InferredEdge","title":"<code>InferredEdge</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Inferred edge directive.</p> Usage <p>WithEdges = Annotated[Graph, InferredEdge(name='connection', selector='nodes')]</p>"},{"location":"reference/api/#spytial.Flag","title":"<code>Flag</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Flag directive.</p> Usage <p>Flagged = Annotated[MyType, Flag(name='debug')]</p>"},{"location":"reference/api/#spytial.Flag.to_entry","title":"<code>to_entry()</code>","text":"<p>Flags store just the name as a scalar.</p>"},{"location":"reference/api/#spytial.relationalizer","title":"<code>relationalizer(cls=None, *, priority=0)</code>","text":"<p>Decorator to register a class as a relationalizer.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>Higher priority relationalizers are tried first.      Priorities 0-99 are reserved for built-in relationalizers.</p> <code>0</code>"},{"location":"reference/api/#spytial.diagram","title":"<code>diagram(obj, method=None, auto_open=True, width=None, height=None, title=None, perf_path=None, perf_iterations=None, headless=False, timeout=None, as_type=None)</code>","text":"<p>Display a Python object in the sPyTial visualizer.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Any Python object to visualize.</p> required <code>method</code> <code>Optional[str]</code> <p>Display method - \"inline\" (Jupyter), \"browser\" (new tab), \"file\" (save to file), or \"headless\" (headless browser for testing)     If None (default), automatically selects \"inline\" in notebooks or \"browser\" otherwise.</p> <code>None</code> <code>auto_open</code> <code>bool</code> <p>Whether to automatically open browser (for \"browser\" method)</p> <code>True</code> <code>width</code> <code>Optional[int]</code> <p>Width of the visualization container in pixels (default: auto-detected)</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>Height of the visualization container in pixels (default: auto-detected)</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the browser tab/page (default: \"sPyTial Visualization\")</p> <code>None</code> <code>perf_path</code> <code>Optional[Union[str, Path]]</code> <p>Optional path to save performance metrics JSON file.        If None, metrics are not saved (unless perf_iterations is set).</p> <code>None</code> <code>perf_iterations</code> <code>Optional[int]</code> <p>Optional number of times to render for performance benchmarking.             If provided, the visualization will be rendered N times and metrics             will be aggregated. Works with method=\"browser\", \"file\", or \"headless\".</p> <code>None</code> <code>headless</code> <code>bool</code> <p>Run in headless Chrome for testing/benchmarking (requires selenium and chromedriver).       If True, method is automatically set to \"headless\".</p> <code>False</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout in seconds for headless mode. If None, automatically calculated based on      perf_iterations (default: max(120, perf_iterations * 5)). For large/complex      visualizations, set this higher (e.g., timeout=600 for 10 minutes).</p> <code>None</code> <code>as_type</code> <code>Optional[Any]</code> <p>Optional annotated type to treat the object as. Annotations from this type      will be applied in addition to any introspected from the object itself.      Use AnnotatedType() or typing.Annotated to define types with spytial annotations.</p> <code>None</code> <p>Examples:</p>"},{"location":"reference/api/#spytial.diagram--define-an-annotated-type","title":"Define an annotated type","text":"<p>Graph = AnnotatedType(Dict[int, List[int]], InferredEdge(...), Orientation(...))</p>"},{"location":"reference/api/#spytial.diagram--display-a-dict-as-a-graph","title":"Display a dict as a Graph","text":"<p>g = {0: [1], 1: [2]} diagram(g, as_type=Graph)</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[Union[str, Dict[str, Any]]]</code> <p>Path to the generated HTML file (if method=\"file\", \"browser\", or \"headless\")</p> <code>dict</code> <code>Optional[Union[str, Dict[str, Any]]]</code> <p>Performance metrics (if method=\"headless\" and perf_iterations &gt; 0)</p>"},{"location":"reference/api/#spytial.evaluate","title":"<code>evaluate(obj, method=None, auto_open=True, width=None, height=None, as_type=None)</code>","text":"<p>Evaluate a Python object using the sPyTial evaluator.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Any Python object to evaluate.</p> required <code>method</code> <code>Optional[str]</code> <p>Display method - \"inline\" (Jupyter), \"browser\" (new tab), or \"file\" (save to file).     If None (default), automatically selects \"inline\" in notebooks or \"browser\" otherwise.</p> <code>None</code> <code>auto_open</code> <code>bool</code> <p>Whether to automatically open the browser (for \"browser\" method).</p> <code>True</code> <code>width</code> <code>Optional[int]</code> <p>Width of the evaluation container in pixels (default: auto-detected).</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>Height of the evaluation container in pixels (default: auto-detected).</p> <code>None</code> <code>as_type</code> <code>Optional[Any]</code> <p>Optional annotated type to treat the object as. Annotations from this type      will be applied in addition to any introspected from the object itself.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>Path to the generated HTML file (if method=\"file\" or \"browser\").</p>"},{"location":"reference/api/#spytial.annotate","title":"<code>annotate(obj, annotation_type, **kwargs)</code>","text":"<p>Apply any annotation type to a specific object. :param obj: The object to annotate. :param annotation_type: The type of annotation (e.g., 'orientation', 'cyclic'). :param kwargs: The annotation parameters. :return: The annotated object (for chaining).</p>"},{"location":"reference/api/#spytial.annotate_orientation","title":"<code>annotate_orientation(obj, **kwargs)</code>","text":"<p>Apply orientation annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_cyclic","title":"<code>annotate_cyclic(obj, **kwargs)</code>","text":"<p>Apply cyclic annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_align","title":"<code>annotate_align(obj, **kwargs)</code>","text":"<p>Apply align annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_group","title":"<code>annotate_group(obj, **kwargs)</code>","text":"<p>Apply group annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_atomColor","title":"<code>annotate_atomColor(obj, **kwargs)</code>","text":"<p>Apply atomColor annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_size","title":"<code>annotate_size(obj, **kwargs)</code>","text":"<p>Apply size annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_icon","title":"<code>annotate_icon(obj, **kwargs)</code>","text":"<p>Apply icon annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_edgeColor","title":"<code>annotate_edgeColor(obj, **kwargs)</code>","text":"<p>Apply edgeColor annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_projection","title":"<code>annotate_projection(obj, **kwargs)</code>","text":"<p>Apply projection annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_attribute","title":"<code>annotate_attribute(obj, **kwargs)</code>","text":"<p>Apply attribute annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_hideField","title":"<code>annotate_hideField(obj, **kwargs)</code>","text":"<p>Apply hideField annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_hideAtom","title":"<code>annotate_hideAtom(obj, **kwargs)</code>","text":"<p>Apply hideAtom annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_inferredEdge","title":"<code>annotate_inferredEdge(obj, **kwargs)</code>","text":"<p>Apply inferredEdge annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotate_flag","title":"<code>annotate_flag(obj, **kwargs)</code>","text":"<p>Apply flag annotation to a specific object.</p>"},{"location":"reference/api/#spytial.extract_spytial_annotations","title":"<code>extract_spytial_annotations(type_hint)</code>","text":"<p>Extract spytial annotations from a typing.Annotated type hint.</p> <p>:param type_hint: A type hint, possibly Annotated with spytial markers. :return: A dict with 'constraints' and 'directives' lists, or None if no annotations.</p>"},{"location":"reference/api/#spytial.get_base_type","title":"<code>get_base_type(type_hint)</code>","text":"<p>Get the base type from an Annotated type hint.</p> <p>:param type_hint: A type hint, possibly Annotated. :return: The base type (unwrapped from Annotated if applicable).</p>"},{"location":"reference/api/#spytial.annotate_type_alias","title":"<code>annotate_type_alias(type_alias, annotation_type, **kwargs)</code>","text":"<p>Attach a spytial annotation to a type alias.</p> <p>This function allows you to annotate type aliases (e.g., list[int], MyTypeAlias) with spatial constraints and directives. When objects are visualized, if their type annotation matches a registered type alias, these annotations are applied.</p> Usage <p>:param type_alias: The type alias to annotate (e.g., list[int], MyClass, etc.) :param annotation_type: The type of annotation ('orientation', 'group', etc.) :param kwargs: The annotation parameters. :return: The type alias (for chaining).</p>"},{"location":"reference/api/#spytial.annotate_type_alias--define-a-type-alias","title":"Define a type alias","text":"<p>IntList = list[int]</p>"},{"location":"reference/api/#spytial.annotate_type_alias--annotate-it","title":"Annotate it","text":"<p>annotate_type_alias(IntList, 'orientation', selector='items', directions=['horizontal']) annotate_type_alias(IntList, 'atomColor', selector='self', value='blue')</p>"},{"location":"reference/api/#spytial.annotate_type_alias--or-use-the-convenience-functions","title":"Or use the convenience functions:","text":"<p>annotate_type_alias_orientation(IntList, selector='items', directions=['horizontal'])</p>"},{"location":"reference/api/#spytial.get_type_alias_annotations","title":"<code>get_type_alias_annotations(type_alias)</code>","text":"<p>Retrieve annotations registered for a type alias.</p> <p>:param type_alias: The type alias to look up. :return: A dictionary with 'constraints' and 'directives' lists, or None if not found.</p>"},{"location":"reference/api/#spytial.clear_type_alias_annotations","title":"<code>clear_type_alias_annotations(type_alias=None)</code>","text":"<p>Clear annotations for a specific type alias or all type aliases.</p> <p>Note: This only clears the legacy registry-based annotations. Annotations using typing.Annotated are immutable and don't need clearing.</p> <p>:param type_alias: If provided, clear only this type alias's annotations.                    If None, clear all type alias annotations.</p>"},{"location":"reference/api/#spytial.list_type_alias_annotations","title":"<code>list_type_alias_annotations()</code>","text":"<p>List all registered type alias annotations (legacy registry).</p> <p>:return: A dictionary mapping type alias keys to their annotation registries.</p>"},{"location":"reference/api/#spytial.dont_inherit_constraints","title":"<code>dont_inherit_constraints(cls)</code>","text":"<p>Mark a class to not inherit constraints from parent classes.</p> <p>This is useful when you want to override a parent class's constraints. Constraints applied directly to this class are still included.</p> Example <p>@orientation(selector='children', directions=['below']) class Parent:     pass</p> <p>@dont_inherit_constraints class Child(Parent):     # Will NOT have Parent's orientation constraint     pass</p> <p>:param cls: The class to mark as not inheriting constraints. :return: The class (for chaining).</p>"},{"location":"reference/api/#spytial.dont_inherit_directives","title":"<code>dont_inherit_directives(cls)</code>","text":"<p>Mark a class to not inherit directives from parent classes.</p> <p>This is useful when you want to override a parent class's directives. Directives applied directly to this class are still included.</p> Example <p>@atomColor(selector='root', value='red') class Parent:     pass</p> <p>@dont_inherit_directives class Child(Parent):     # Will NOT have Parent's atomColor directive     pass</p> <p>:param cls: The class to mark as not inheriting directives. :return: The class (for chaining).</p>"},{"location":"reference/api/#spytial.dont_inherit_annotations","title":"<code>dont_inherit_annotations(cls)</code>","text":"<p>Mark a class to not inherit any annotations from parent classes.</p> <p>Shorthand for applying both dont_inherit_constraints and dont_inherit_directives.</p> Example <p>@orientation(selector='children', directions=['below']) @atomColor(selector='root', value='red') class Parent:     pass</p> <p>@dont_inherit_annotations class Child(Parent):     # Will NOT have any annotations from Parent     pass</p> <p>:param cls: The class to mark as not inheriting annotations. :return: The class (for chaining).</p>"},{"location":"reference/api/#spytial.collect_decorators","title":"<code>collect_decorators(obj, type_hint=None)</code>","text":"<p>Collect all decorators applied to the class of the given object, as well as any annotations applied directly to the object instance, and any annotations registered for matching type aliases. Respects inheritance control flags (dont_inherit_constraints, dont_inherit_directives). :param obj: The object whose class decorators and object annotations should be collected. :param type_hint: Optional type hint to look up type alias annotations. :return: A combined dictionary of constraints and directives.</p>"},{"location":"reference/api/#spytial.serialize_to_yaml_string","title":"<code>serialize_to_yaml_string(decorators)</code>","text":"<p>Serialize the collected constraints and directives to a YAML string. :param decorators: The collected decorators (constraints and directives). :return: YAML string representation of the decorators.</p>"},{"location":"reference/api/#spytial.reset_object_ids","title":"<code>reset_object_ids()</code>","text":"<p>Reset the global object ID state. Useful for testing or when you need deterministic object ID generation across multiple runs.</p> <p>Warning: This will clear all existing object ID mappings, so existing selectors that depend on previous object IDs may no longer work.</p>"},{"location":"reference/api/#spytial.apply_if","title":"<code>apply_if(condition, *decorators)</code>","text":"<p>Conditional decorator macro for sPyTial. Usage:     @apply_if(CONDITION,         orientation(...),         hideField(...),         attribute(...),         ...     )     class MyClass: ... If CONDITION is True, applies all decorators in order to the class. If CONDITION is False, returns the class unchanged.</p>"},{"location":"reference/api/#diagramming","title":"Diagramming","text":""},{"location":"reference/api/#spytial.visualizer","title":"<code>spytial.visualizer</code>","text":"<p>sPyTial Visualization Display Module</p> <p>This module provides functions to display Python objects using the sPyTial visualizer.</p>"},{"location":"reference/api/#spytial.visualizer.diagram","title":"<code>diagram(obj, method=None, auto_open=True, width=None, height=None, title=None, perf_path=None, perf_iterations=None, headless=False, timeout=None, as_type=None)</code>","text":"<p>Display a Python object in the sPyTial visualizer.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Any Python object to visualize.</p> required <code>method</code> <code>Optional[str]</code> <p>Display method - \"inline\" (Jupyter), \"browser\" (new tab), \"file\" (save to file), or \"headless\" (headless browser for testing)     If None (default), automatically selects \"inline\" in notebooks or \"browser\" otherwise.</p> <code>None</code> <code>auto_open</code> <code>bool</code> <p>Whether to automatically open browser (for \"browser\" method)</p> <code>True</code> <code>width</code> <code>Optional[int]</code> <p>Width of the visualization container in pixels (default: auto-detected)</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>Height of the visualization container in pixels (default: auto-detected)</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for the browser tab/page (default: \"sPyTial Visualization\")</p> <code>None</code> <code>perf_path</code> <code>Optional[Union[str, Path]]</code> <p>Optional path to save performance metrics JSON file.        If None, metrics are not saved (unless perf_iterations is set).</p> <code>None</code> <code>perf_iterations</code> <code>Optional[int]</code> <p>Optional number of times to render for performance benchmarking.             If provided, the visualization will be rendered N times and metrics             will be aggregated. Works with method=\"browser\", \"file\", or \"headless\".</p> <code>None</code> <code>headless</code> <code>bool</code> <p>Run in headless Chrome for testing/benchmarking (requires selenium and chromedriver).       If True, method is automatically set to \"headless\".</p> <code>False</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout in seconds for headless mode. If None, automatically calculated based on      perf_iterations (default: max(120, perf_iterations * 5)). For large/complex      visualizations, set this higher (e.g., timeout=600 for 10 minutes).</p> <code>None</code> <code>as_type</code> <code>Optional[Any]</code> <p>Optional annotated type to treat the object as. Annotations from this type      will be applied in addition to any introspected from the object itself.      Use AnnotatedType() or typing.Annotated to define types with spytial annotations.</p> <code>None</code> <p>Examples:</p>"},{"location":"reference/api/#spytial.visualizer.diagram--define-an-annotated-type","title":"Define an annotated type","text":"<p>Graph = AnnotatedType(Dict[int, List[int]], InferredEdge(...), Orientation(...))</p>"},{"location":"reference/api/#spytial.visualizer.diagram--display-a-dict-as-a-graph","title":"Display a dict as a Graph","text":"<p>g = {0: [1], 1: [2]} diagram(g, as_type=Graph)</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[Union[str, Dict[str, Any]]]</code> <p>Path to the generated HTML file (if method=\"file\", \"browser\", or \"headless\")</p> <code>dict</code> <code>Optional[Union[str, Dict[str, Any]]]</code> <p>Performance metrics (if method=\"headless\" and perf_iterations &gt; 0)</p>"},{"location":"reference/api/#evaluator","title":"Evaluator","text":""},{"location":"reference/api/#spytial.evaluator","title":"<code>spytial.evaluator</code>","text":"<p>sPyTial Evaluator Module</p> <p>This module provides functions to evaluate expressions using the sPyTial evaluator.</p>"},{"location":"reference/api/#spytial.evaluator.evaluate","title":"<code>evaluate(obj, method=None, auto_open=True, width=None, height=None, as_type=None)</code>","text":"<p>Evaluate a Python object using the sPyTial evaluator.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Any Python object to evaluate.</p> required <code>method</code> <code>Optional[str]</code> <p>Display method - \"inline\" (Jupyter), \"browser\" (new tab), or \"file\" (save to file).     If None (default), automatically selects \"inline\" in notebooks or \"browser\" otherwise.</p> <code>None</code> <code>auto_open</code> <code>bool</code> <p>Whether to automatically open the browser (for \"browser\" method).</p> <code>True</code> <code>width</code> <code>Optional[int]</code> <p>Width of the evaluation container in pixels (default: auto-detected).</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>Height of the evaluation container in pixels (default: auto-detected).</p> <code>None</code> <code>as_type</code> <code>Optional[Any]</code> <p>Optional annotated type to treat the object as. Annotations from this type      will be applied in addition to any introspected from the object itself.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>Path to the generated HTML file (if method=\"file\" or \"browser\").</p>"},{"location":"reference/api/#dataclass-builder","title":"Dataclass builder","text":""},{"location":"reference/api/#spytial.dataclass_builder","title":"<code>spytial.dataclass_builder</code>","text":"<p>sPyTial Dataclass Builder with spytial-core Integration</p> <p>A simple function for building dataclass instances interactively using spytial-core's visual structured-input-graph component. Generates Python constructor code that you can copy and paste.</p>"},{"location":"reference/api/#spytial.dataclass_builder.dataclass_builder","title":"<code>dataclass_builder(instance, method='inline', auto_open=True)</code>","text":"<p>Create a visual builder interface for a dataclass instance using spytial-core.</p> <p>Opens an HTML interface where you can build/modify instances visually. Click \"Export\" to get Python constructor code to copy/paste.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>A dataclass instance to start with (can be empty or pre-populated)</p> required <code>method</code> <code>str</code> <p>'browser' to open in browser, 'file' to save HTML file, 'inline' for notebook</p> <code>'inline'</code> <code>auto_open</code> <code>bool</code> <p>Whether to automatically open the result (for 'browser' and 'file' methods)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[Union[str, HTML]]</code> <p>Path to the generated HTML file (for 'file' and 'browser' methods)</p> <code>Optional[Union[str, HTML]]</code> <p>IPython.HTML: HTML widget for inline display ('inline' method)</p> Example <p>@dataclass class TreeNode:     value: int = 0     left: Optional['TreeNode'] = None     right: Optional['TreeNode'] = None</p>"},{"location":"reference/api/#spytial.dataclass_builder.dataclass_builder--start-with-empty-instance","title":"Start with empty instance","text":"<p>spytial.dataclass_builder(TreeNode())</p>"},{"location":"reference/api/#spytial.dataclass_builder.dataclass_builder--or-start-with-pre-populated-data","title":"Or start with pre-populated data","text":"<p>initial_tree = TreeNode(value=42, left=TreeNode(value=21)) spytial.dataclass_builder(initial_tree)</p>"},{"location":"reference/api/#spytial.dataclass_builder.dataclass_builder--build-your-tree-visually-click-export-copy-the-python-code","title":"Build your tree visually, click Export, copy the Python code","text":""},{"location":"reference/api/#spytial.dataclass_builder.dataclass_builder--then-paste-result-treenodevalue42-lefttreenodevalue21","title":"Then paste: result = TreeNode(value=42, left=TreeNode(value=21, ...))","text":""},{"location":"reference/api/#annotations","title":"Annotations","text":""},{"location":"reference/api/#spytial.annotations","title":"<code>spytial.annotations</code>","text":""},{"location":"reference/api/#spytial.annotations.SpytialAnnotation","title":"<code>SpytialAnnotation</code>","text":"<p>Base class for spytial type annotations.</p> <p>Subclasses represent specific constraints or directives that can be attached to type aliases using typing.Annotated.</p>"},{"location":"reference/api/#spytial.annotations.SpytialAnnotation.to_entry","title":"<code>to_entry()</code>","text":"<p>Convert to the internal registry format.</p>"},{"location":"reference/api/#spytial.annotations.Orientation","title":"<code>Orientation</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Orientation constraint for spatial layout.</p> Usage <p>from typing import Annotated IntList = Annotated[list[int], Orientation(selector='items', directions=['horizontal'])]</p>"},{"location":"reference/api/#spytial.annotations.Cyclic","title":"<code>Cyclic</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Cyclic constraint for circular layouts.</p> Usage <p>NodeRing = Annotated[list[Node], Cyclic(selector='items', direction='clockwise')]</p>"},{"location":"reference/api/#spytial.annotations.Align","title":"<code>Align</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Alignment constraint.</p> Usage <p>AlignedList = Annotated[list[int], Align(selector='items', direction='left')]</p>"},{"location":"reference/api/#spytial.annotations.Group","title":"<code>Group</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Grouping constraint.</p> <p>Usage (field-based):     Tree = Annotated[TreeNode, Group(field='children', groupOn=0, addToGroup=1)]</p> <p>Usage (selector-based):     Grouped = Annotated[MyType, Group(selector='items', name='mygroup')]</p>"},{"location":"reference/api/#spytial.annotations.AtomColor","title":"<code>AtomColor</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Atom color directive.</p> Usage <p>ColoredList = Annotated[list[int], AtomColor(selector='self', value='blue')]</p>"},{"location":"reference/api/#spytial.annotations.Size","title":"<code>Size</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Size directive.</p> Usage <p>SizedList = Annotated[list[int], Size(selector='items', height=50, width=50)]</p>"},{"location":"reference/api/#spytial.annotations.Icon","title":"<code>Icon</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Icon directive.</p> Usage <p>IconList = Annotated[list[int], Icon(selector='items', path='icon.svg', showLabels=True)]</p>"},{"location":"reference/api/#spytial.annotations.EdgeColor","title":"<code>EdgeColor</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Edge color directive.</p> Usage <p>ColoredEdges = Annotated[Tree, EdgeColor(field='children', value='red')]</p>"},{"location":"reference/api/#spytial.annotations.HideField","title":"<code>HideField</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Hide field directive.</p> Usage <p>CleanView = Annotated[MyClass, HideField(field='_private')]</p>"},{"location":"reference/api/#spytial.annotations.HideAtom","title":"<code>HideAtom</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Hide atom directive.</p> Usage <p>Filtered = Annotated[list[int], HideAtom(selector='hidden')]</p>"},{"location":"reference/api/#spytial.annotations.Projection","title":"<code>Projection</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Projection directive.</p> Usage <p>Projected = Annotated[MyType, Projection(sig='MySig')]</p>"},{"location":"reference/api/#spytial.annotations.Attribute","title":"<code>Attribute</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Attribute directive.</p> Usage <p>WithAttr = Annotated[MyType, Attribute(field='value')]</p>"},{"location":"reference/api/#spytial.annotations.InferredEdge","title":"<code>InferredEdge</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Inferred edge directive.</p> Usage <p>WithEdges = Annotated[Graph, InferredEdge(name='connection', selector='nodes')]</p>"},{"location":"reference/api/#spytial.annotations.Flag","title":"<code>Flag</code>","text":"<p>               Bases: <code>SpytialAnnotation</code></p> <p>Flag directive.</p> Usage <p>Flagged = Annotated[MyType, Flag(name='debug')]</p>"},{"location":"reference/api/#spytial.annotations.Flag.to_entry","title":"<code>to_entry()</code>","text":"<p>Flags store just the name as a scalar.</p>"},{"location":"reference/api/#spytial.annotations.extract_spytial_annotations","title":"<code>extract_spytial_annotations(type_hint)</code>","text":"<p>Extract spytial annotations from a typing.Annotated type hint.</p> <p>:param type_hint: A type hint, possibly Annotated with spytial markers. :return: A dict with 'constraints' and 'directives' lists, or None if no annotations.</p>"},{"location":"reference/api/#spytial.annotations.get_base_type","title":"<code>get_base_type(type_hint)</code>","text":"<p>Get the base type from an Annotated type hint.</p> <p>:param type_hint: A type hint, possibly Annotated. :return: The base type (unwrapped from Annotated if applicable).</p>"},{"location":"reference/api/#spytial.annotations.annotate_type_alias","title":"<code>annotate_type_alias(type_alias, annotation_type, **kwargs)</code>","text":"<p>Attach a spytial annotation to a type alias.</p> <p>This function allows you to annotate type aliases (e.g., list[int], MyTypeAlias) with spatial constraints and directives. When objects are visualized, if their type annotation matches a registered type alias, these annotations are applied.</p> Usage <p>:param type_alias: The type alias to annotate (e.g., list[int], MyClass, etc.) :param annotation_type: The type of annotation ('orientation', 'group', etc.) :param kwargs: The annotation parameters. :return: The type alias (for chaining).</p>"},{"location":"reference/api/#spytial.annotations.annotate_type_alias--define-a-type-alias","title":"Define a type alias","text":"<p>IntList = list[int]</p>"},{"location":"reference/api/#spytial.annotations.annotate_type_alias--annotate-it","title":"Annotate it","text":"<p>annotate_type_alias(IntList, 'orientation', selector='items', directions=['horizontal']) annotate_type_alias(IntList, 'atomColor', selector='self', value='blue')</p>"},{"location":"reference/api/#spytial.annotations.annotate_type_alias--or-use-the-convenience-functions","title":"Or use the convenience functions:","text":"<p>annotate_type_alias_orientation(IntList, selector='items', directions=['horizontal'])</p>"},{"location":"reference/api/#spytial.annotations.get_type_alias_annotations","title":"<code>get_type_alias_annotations(type_alias)</code>","text":"<p>Retrieve annotations registered for a type alias.</p> <p>:param type_alias: The type alias to look up. :return: A dictionary with 'constraints' and 'directives' lists, or None if not found.</p>"},{"location":"reference/api/#spytial.annotations.clear_type_alias_annotations","title":"<code>clear_type_alias_annotations(type_alias=None)</code>","text":"<p>Clear annotations for a specific type alias or all type aliases.</p> <p>Note: This only clears the legacy registry-based annotations. Annotations using typing.Annotated are immutable and don't need clearing.</p> <p>:param type_alias: If provided, clear only this type alias's annotations.                    If None, clear all type alias annotations.</p>"},{"location":"reference/api/#spytial.annotations.list_type_alias_annotations","title":"<code>list_type_alias_annotations()</code>","text":"<p>List all registered type alias annotations (legacy registry).</p> <p>:return: A dictionary mapping type alias keys to their annotation registries.</p>"},{"location":"reference/api/#spytial.annotations.reset_object_ids","title":"<code>reset_object_ids()</code>","text":"<p>Reset the global object ID state. Useful for testing or when you need deterministic object ID generation across multiple runs.</p> <p>Warning: This will clear all existing object ID mappings, so existing selectors that depend on previous object IDs may no longer work.</p>"},{"location":"reference/api/#spytial.annotations.validate_fields","title":"<code>validate_fields(type_, kwargs, valid_fields)</code>","text":"<p>Validate that the required fields for a given type are present in kwargs. For constraints that support multiple parameter sets (like group), try each set. :param type_: The type of constraint or directive. :param kwargs: The provided fields for the decorator. :param valid_fields: The list of required fields for the type, or a list of alternative field sets. :raises ValueError: If no valid field set matches the provided kwargs.</p>"},{"location":"reference/api/#spytial.annotations.annotate_orientation","title":"<code>annotate_orientation(obj, **kwargs)</code>","text":"<p>Apply orientation annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_cyclic","title":"<code>annotate_cyclic(obj, **kwargs)</code>","text":"<p>Apply cyclic annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_align","title":"<code>annotate_align(obj, **kwargs)</code>","text":"<p>Apply align annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_group","title":"<code>annotate_group(obj, **kwargs)</code>","text":"<p>Apply group annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_atomColor","title":"<code>annotate_atomColor(obj, **kwargs)</code>","text":"<p>Apply atomColor annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_size","title":"<code>annotate_size(obj, **kwargs)</code>","text":"<p>Apply size annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_icon","title":"<code>annotate_icon(obj, **kwargs)</code>","text":"<p>Apply icon annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_edgeColor","title":"<code>annotate_edgeColor(obj, **kwargs)</code>","text":"<p>Apply edgeColor annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_projection","title":"<code>annotate_projection(obj, **kwargs)</code>","text":"<p>Apply projection annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_attribute","title":"<code>annotate_attribute(obj, **kwargs)</code>","text":"<p>Apply attribute annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_hideField","title":"<code>annotate_hideField(obj, **kwargs)</code>","text":"<p>Apply hideField annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_hideAtom","title":"<code>annotate_hideAtom(obj, **kwargs)</code>","text":"<p>Apply hideAtom annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_inferredEdge","title":"<code>annotate_inferredEdge(obj, **kwargs)</code>","text":"<p>Apply inferredEdge annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate_flag","title":"<code>annotate_flag(obj, **kwargs)</code>","text":"<p>Apply flag annotation to a specific object.</p>"},{"location":"reference/api/#spytial.annotations.annotate","title":"<code>annotate(obj, annotation_type, **kwargs)</code>","text":"<p>Apply any annotation type to a specific object. :param obj: The object to annotate. :param annotation_type: The type of annotation (e.g., 'orientation', 'cyclic'). :param kwargs: The annotation parameters. :return: The annotated object (for chaining).</p>"},{"location":"reference/api/#spytial.annotations.apply_if","title":"<code>apply_if(condition, *decorators)</code>","text":"<p>Conditional decorator macro for sPyTial. Usage:     @apply_if(CONDITION,         orientation(...),         hideField(...),         attribute(...),         ...     )     class MyClass: ... If CONDITION is True, applies all decorators in order to the class. If CONDITION is False, returns the class unchanged.</p>"},{"location":"reference/api/#spytial.annotations.collect_decorators","title":"<code>collect_decorators(obj, type_hint=None)</code>","text":"<p>Collect all decorators applied to the class of the given object, as well as any annotations applied directly to the object instance, and any annotations registered for matching type aliases. Respects inheritance control flags (dont_inherit_constraints, dont_inherit_directives). :param obj: The object whose class decorators and object annotations should be collected. :param type_hint: Optional type hint to look up type alias annotations. :return: A combined dictionary of constraints and directives.</p>"},{"location":"reference/api/#spytial.annotations.serialize_to_yaml_string","title":"<code>serialize_to_yaml_string(decorators)</code>","text":"<p>Serialize the collected constraints and directives to a YAML string. :param decorators: The collected decorators (constraints and directives). :return: YAML string representation of the decorators.</p>"},{"location":"reference/api/#spytial.annotations.dont_inherit_constraints","title":"<code>dont_inherit_constraints(cls)</code>","text":"<p>Mark a class to not inherit constraints from parent classes.</p> <p>This is useful when you want to override a parent class's constraints. Constraints applied directly to this class are still included.</p> Example <p>@orientation(selector='children', directions=['below']) class Parent:     pass</p> <p>@dont_inherit_constraints class Child(Parent):     # Will NOT have Parent's orientation constraint     pass</p> <p>:param cls: The class to mark as not inheriting constraints. :return: The class (for chaining).</p>"},{"location":"reference/api/#spytial.annotations.dont_inherit_directives","title":"<code>dont_inherit_directives(cls)</code>","text":"<p>Mark a class to not inherit directives from parent classes.</p> <p>This is useful when you want to override a parent class's directives. Directives applied directly to this class are still included.</p> Example <p>@atomColor(selector='root', value='red') class Parent:     pass</p> <p>@dont_inherit_directives class Child(Parent):     # Will NOT have Parent's atomColor directive     pass</p> <p>:param cls: The class to mark as not inheriting directives. :return: The class (for chaining).</p>"},{"location":"reference/api/#spytial.annotations.dont_inherit_annotations","title":"<code>dont_inherit_annotations(cls)</code>","text":"<p>Mark a class to not inherit any annotations from parent classes.</p> <p>Shorthand for applying both dont_inherit_constraints and dont_inherit_directives.</p> Example <p>@orientation(selector='children', directions=['below']) @atomColor(selector='root', value='red') class Parent:     pass</p> <p>@dont_inherit_annotations class Child(Parent):     # Will NOT have any annotations from Parent     pass</p> <p>:param cls: The class to mark as not inheriting annotations. :return: The class (for chaining).</p>"},{"location":"reference/api/#provider-system","title":"Provider system","text":""},{"location":"reference/api/#spytial.provider_system","title":"<code>spytial.provider_system</code>","text":"<p>Spytial-Core Data Instance Relationalizer Architecture</p> <p>This module provides a pluggable system for converting Python objects into CnD-compatible atom/relation representations using relationalizers.</p>"},{"location":"reference/api/#spytial.provider_system.RelationalizerRegistry","title":"<code>RelationalizerRegistry</code>","text":"<p>Registry for relationalizers.</p>"},{"location":"reference/api/#spytial.provider_system.RelationalizerRegistry.register","title":"<code>register(relationalizer_cls, priority=0)</code>  <code>classmethod</code>","text":"<p>Register a relationalizer class with given priority.</p>"},{"location":"reference/api/#spytial.provider_system.RelationalizerRegistry.find_relationalizer","title":"<code>find_relationalizer(obj)</code>  <code>classmethod</code>","text":"<p>Find the first relationalizer that can handle the given object.</p>"},{"location":"reference/api/#spytial.provider_system.RelationalizerRegistry.list_relationalizers","title":"<code>list_relationalizers()</code>  <code>classmethod</code>","text":"<p>List all registered relationalizers with their priorities.</p> <p>Returns:</p> Type Description <code>List[Tuple[int, str]]</code> <p>List of (priority, relationalizer_class_name) tuples, sorted by priority (highest first)</p>"},{"location":"reference/api/#spytial.provider_system.RelationalizerRegistry.clear","title":"<code>clear()</code>  <code>classmethod</code>","text":"<p>Clear all registered relationalizers (for testing).</p>"},{"location":"reference/api/#spytial.provider_system.CnDDataInstanceBuilder","title":"<code>CnDDataInstanceBuilder</code>","text":"<p>Main builder that composes providers to build data instances.</p>"},{"location":"reference/api/#spytial.provider_system.CnDDataInstanceBuilder.build_instance","title":"<code>build_instance(obj, as_type=None)</code>","text":"<p>Build a complete data instance from an object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The Python object to build an instance from.</p> required <code>as_type</code> <code>Optional[Any]</code> <p>Optional annotated type to treat the object as. Annotations      from this type will be applied in addition to introspected ones.</p> <code>None</code>"},{"location":"reference/api/#spytial.provider_system.CnDDataInstanceBuilder.get_collected_decorators","title":"<code>get_collected_decorators()</code>","text":"<p>Get all decorators collected during the build process.</p>"},{"location":"reference/api/#spytial.provider_system.CnDDataInstanceBuilder.__call__","title":"<code>__call__(obj)</code>","text":"<p>Allow the builder to be called as a function for recursive walking.</p>"},{"location":"reference/api/#spytial.provider_system.CnDDataInstanceBuilder.build_types","title":"<code>build_types(atoms)</code>","text":"<p>Build the <code>types</code> field for the data instance.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>List[Dict]</code> <p>List of atoms, each containing a \"type\" field with the most specific type.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List of type definitions, each matching the desired format.</p>"},{"location":"reference/api/#spytial.provider_system.CnDDataInstanceBuilder.reify","title":"<code>reify(data_instance)</code>","text":"<p>Reconstruct Python objects from a Spytial-Core data instance.</p> <p>This method reverses the build_instance operation, converting atoms and relations back into Python objects.</p> <p>Parameters:</p> Name Type Description Default <code>data_instance</code> <code>Dict</code> <p>Dictionary containing 'atoms', 'relations', and 'types'           as returned by build_instance()</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The reconstructed Python object corresponding to the root atom</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data instance is malformed or cannot be reconstructed</p>"},{"location":"reference/api/#spytial.provider_system.CnDDataInstanceBuilder.can_reify","title":"<code>can_reify(data_instance)</code>","text":"<p>Check if a data instance can be reified.</p> <p>Parameters:</p> Name Type Description Default <code>data_instance</code> <code>Dict</code> <p>Dictionary to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the data instance appears to be valid for reification</p>"},{"location":"reference/api/#spytial.provider_system.CnDDataInstanceBuilder.register_reifier","title":"<code>register_reifier(type_name, reifier_func)</code>","text":"<p>Register a custom reifier function for a specific type.</p> <p>This provides an extensibility mechanism for complex reconstruction scenarios.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The atom type name to handle (e.g., \"MyCustomClass\")</p> required <code>reifier_func</code> <code>Callable[..., Any]</code> <p>Function with signature (atom, relations, reify_atom) -&gt; object          where:          - atom: Dict containing atom information (id, type, label, etc.)          - relations: Dict mapping relation names to lists of target atom IDs          - reify_atom: Function to recursively reify other atoms by ID</p> required Example <p>def custom_reifier(atom, relations, reify_atom):     # Custom reconstruction logic     obj = MyCustomClass()     for rel_name, target_ids in relations.items():         setattr(obj, rel_name, [reify_atom(tid) for tid in target_ids])     return obj</p> <p>builder.register_reifier(\"MyCustomClass\", custom_reifier)</p>"},{"location":"reference/api/#spytial.provider_system.CnDDataInstanceBuilder.unregister_reifier","title":"<code>unregister_reifier(type_name)</code>","text":"<p>Remove a custom reifier for a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The atom type name to remove the reifier for</p> required"},{"location":"reference/api/#spytial.provider_system.CnDDataInstanceBuilder.list_reifiers","title":"<code>list_reifiers()</code>","text":"<p>List all registered custom reifier type names.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of type names that have custom reifiers registered</p>"},{"location":"reference/api/#spytial.provider_system.relationalizer","title":"<code>relationalizer(cls=None, *, priority=0)</code>","text":"<p>Decorator to register a class as a relationalizer.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>Higher priority relationalizers are tried first.      Priorities 0-99 are reserved for built-in relationalizers.</p> <code>0</code>"},{"location":"reference/api/#utilities","title":"Utilities","text":""},{"location":"reference/api/#spytial.utils","title":"<code>spytial.utils</code>","text":"<p>Shared utilities for sPyTial.</p>"},{"location":"reference/api/#spytial.utils.Typed","title":"<code>Typed</code>","text":"<p>A wrapper that preserves type hint information for values.</p> <p>Use this when you want to pass annotated type information to diagram() without explicitly passing type_hint=.</p> Example <p>Graph = Annotated[Dict[int, List[int]], Orientation(...)] g = {0: [1], 1: [2]} diagram(Typed(g, Graph))  # Annotations from Graph will be applied</p>"},{"location":"reference/api/#spytial.utils.AnnotatedType","title":"<code>AnnotatedType</code>","text":"<p>A callable type alias that preserves spytial annotations.</p> <p>This provides a clean syntax for reusable annotated types:</p> <pre><code># Define once\nGraph = AnnotatedType(Dict[int, List[int]],\n    InferredEdge(selector=EDGE_SEL, name=\" \"))\n\n# Use naturally - Graph() wraps the value with type info\ng = Graph({0: [1], 1: [2], 2: []})\ndiagram(g)  # Annotations applied automatically!\n</code></pre> <p>The AnnotatedType acts as both: - A type hint (for documentation/type checkers) - A constructor (wraps values with the type info)</p>"},{"location":"reference/api/#spytial.utils.AnnotatedType.__init__","title":"<code>__init__(base_type, *annotations)</code>","text":"<p>Create an annotated type alias.</p> <p>Parameters:</p> Name Type Description Default <code>base_type</code> <code>Any</code> <p>The underlying type (e.g., Dict[int, List[int]])</p> required <code>*annotations</code> <code>Any</code> <p>SpytialAnnotation instances (Orientation, InferredEdge, etc.)</p> <code>()</code>"},{"location":"reference/api/#spytial.utils.AnnotatedType.__call__","title":"<code>__call__(value)</code>","text":"<p>Wrap a value with this type's annotations.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to wrap</p> required <p>Returns:</p> Name Type Description <code>Typed</code> <code>Typed</code> <p>A wrapper that diagram() will recognize</p>"},{"location":"reference/api/#spytial.utils.is_notebook","title":"<code>is_notebook()</code>","text":"<p>Detect if we're running in a Jupyter notebook environment. Returns True if in a notebook, False otherwise.</p>"},{"location":"reference/api/#spytial.utils.default_method","title":"<code>default_method()</code>","text":"<p>Return the default display method based on environment. Returns 'inline' in notebooks, 'browser' otherwise.</p>"},{"location":"usage/dataclass-builder/","title":"Dataclass Builder","text":"<p><code>spytial.dataclass_builder()</code> opens an interactive builder for a dataclass instance. It lets you visually edit the structure and export the resulting constructor code.</p>"},{"location":"usage/dataclass-builder/#example","title":"Example","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Optional\nimport spytial\n\n@dataclass\nclass TreeNode:\n    value: int = 0\n    left: Optional[\"TreeNode\"] = None\n    right: Optional[\"TreeNode\"] = None\n\n# Start with an empty instance\nspytial.dataclass_builder(TreeNode())\n</code></pre>"},{"location":"usage/dataclass-builder/#methods","title":"Methods","text":"<pre><code>spytial.dataclass_builder(TreeNode(), method=\"browser\")\nspytial.dataclass_builder(TreeNode(), method=\"file\")\nspytial.dataclass_builder(TreeNode(), method=\"inline\")\n</code></pre>"},{"location":"usage/dataclass-builder/#output","title":"Output","text":"<p>Use the Export button in the UI to copy the generated Python constructor code. Paste it back into your codebase to recreate the edited structure.</p> <p>Tip</p> <p>For large models, start with a minimal instance and build up visually before exporting the final constructor.</p>"},{"location":"usage/diagramming/","title":"Diagramming","text":"<p><code>spytial.diagram()</code> turns Python objects into a spatial diagram. You can invoke it with any object: dicts, lists, dataclasses, custom classes, and graph-like structures.</p>"},{"location":"usage/diagramming/#basic-usage","title":"Basic usage","text":"<pre><code>import spytial\n\nspytial.diagram({\"a\": 1, \"b\": [1, 2, 3]})\n</code></pre>"},{"location":"usage/diagramming/#display-options","title":"Display options","text":"<pre><code>spytial.diagram(data, method=\"browser\")  # open a new tab\nspytial.diagram(data, method=\"file\")     # save as spytial_visualization.html\nspytial.diagram(data, method=\"inline\")   # force notebook output\n</code></pre>"},{"location":"usage/diagramming/#sizing-and-title","title":"Sizing and title","text":"<pre><code>spytial.diagram(data, width=900, height=600, title=\"My Diagram\")\n</code></pre>"},{"location":"usage/diagramming/#passing-annotations-with-as_type","title":"Passing annotations with <code>as_type</code>","text":"<p>Use <code>AnnotatedType</code> (or <code>typing.Annotated</code>) to attach spatial constraints to a type you want the object treated as.</p> <pre><code>from typing import Dict, List\nfrom spytial import AnnotatedType, InferredEdge, Orientation\n\nGraph = AnnotatedType(\n    Dict[int, List[int]],\n    InferredEdge(name=\"edge\", selector=\"values\"),\n    Orientation(selector=\"values\", directions=[\"right\"]),\n)\n\ngraph = {0: [1, 2], 1: [3]}\nspytial.diagram(graph, as_type=Graph)\n</code></pre>"},{"location":"usage/diagramming/#performance-benchmarking","title":"Performance benchmarking","text":"<p>For large structures, you can render multiple times and save aggregated timing.</p> <pre><code>spytial.diagram(\n    data,\n    method=\"file\",\n    perf_path=\"perf.json\",\n    perf_iterations=5,\n)\n</code></pre>"},{"location":"usage/diagramming/#headless-mode","title":"Headless mode","text":"<p>Headless mode uses a Chrome driver to render without opening a browser.</p> <pre><code>spytial.diagram(\n    data,\n    headless=True,\n    perf_iterations=3,\n    timeout=300,\n)\n</code></pre> <p>Note</p> <p>Headless mode requires Selenium and a Chrome/Chromedriver installation. Use <code>pip install spytial_diagramming[headless]</code> and ensure the driver is on your PATH.</p>"},{"location":"usage/diagramming/#return-values","title":"Return values","text":"<ul> <li><code>method=\"browser\"</code> and <code>method=\"file\"</code> return the HTML file path.</li> <li><code>method=\"headless\"</code> returns performance metrics if you set <code>perf_iterations</code>.</li> </ul>"},{"location":"usage/evaluator/","title":"Evaluator","text":"<p><code>spytial.evaluate()</code> renders a lightweight evaluator view that shows the serialized data structure. It's useful for validating how your object is being interpreted before diagramming or when debugging relationalizers.</p>"},{"location":"usage/evaluator/#basic-usage","title":"Basic usage","text":"<pre><code>import spytial\n\nspytial.evaluate({\"total\": 3, \"items\": [1, 2, 3]})\n</code></pre>"},{"location":"usage/evaluator/#display-methods","title":"Display methods","text":"<pre><code>spytial.evaluate(data, method=\"browser\")  # open a new tab\nspytial.evaluate(data, method=\"file\")     # save as cnd_evaluator.html\nspytial.evaluate(data, method=\"inline\")   # force notebook output\n</code></pre>"},{"location":"usage/evaluator/#size-options","title":"Size options","text":"<pre><code>spytial.evaluate(data, width=800, height=300)\n</code></pre>"},{"location":"usage/evaluator/#using-annotated-types","title":"Using annotated types","text":"<pre><code>from typing import Annotated, Dict\nfrom spytial import Attribute\n\nTyped = Annotated[Dict[str, int], Attribute(label=\"Totals\")]\nspytial.evaluate({\"apples\": 2}, as_type=Typed)\n</code></pre>"}]}