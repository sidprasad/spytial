"use strict";
var IntegratedDemo = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type2) {
          if (null == type2) return null;
          if ("function" === typeof type2)
            return type2.$$typeof === REACT_CLIENT_REFERENCE ? null : type2.displayName || type2.name || null;
          if ("string" === typeof type2) return type2;
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type2)
            switch ("number" === typeof type2.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type2.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return (type2.displayName || "Context") + ".Provider";
              case REACT_CONSUMER_TYPE:
                return (type2._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type2.render;
                type2 = type2.displayName;
                type2 || (type2 = innerType.displayName || innerType.name || "", type2 = "" !== type2 ? "ForwardRef(" + type2 + ")" : "ForwardRef");
                return type2;
              case REACT_MEMO_TYPE:
                return innerType = type2.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type2._payload;
                type2 = type2._init;
                try {
                  return getComponentNameFromType(type2(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getTaskName(type2) {
          if (type2 === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type2 && null !== type2 && type2.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type2);
            return name ? "<" + name + ">" : "<...>";
          } catch (x) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type2, key, self2, source, owner, props, debugStack, debugTask) {
          self2 = props.ref;
          type2 = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type2,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type2, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type2, "ref", { enumerable: false, value: null });
          type2._store = {};
          Object.defineProperty(type2._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type2, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type2, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type2, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type2.props), Object.freeze(type2));
          return type2;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement(
            oldElement.type,
            newKey,
            void 0,
            void 0,
            oldElement._owner,
            oldElement.props,
            oldElement._debugStack,
            oldElement._debugTask
          );
          oldElement._store && (newKey._store.validated = oldElement._store.validated);
          return newKey;
        }
        function isValidElement(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function escape(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match) {
            return escaperLookup[match];
          });
        }
        function getElementKey(element, index) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
        }
        function noop$1() {
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type2 = typeof children;
          if ("undefined" === type2 || "boolean" === type2) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type2) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback = callback(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
              return c;
            })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
              callback,
              escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i = 0; i < children.length; i++)
              nameSoFar = children[i], type2 = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type2,
                callback
              );
          else if (i = getIteratorFn(children), "function" === typeof i)
            for (i === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type2 = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type2,
                callback
              );
          else if ("object" === type2) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
            array = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren(children, func, context) {
          if (null == children) return children;
          var result = [], count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ctor = payload._result;
            ctor = ctor();
            ctor.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status)
                  payload._status = 1, payload._result = moduleObject;
              },
              function(error) {
                if (0 === payload._status || -1 === payload._status)
                  payload._status = 2, payload._result = error;
              }
            );
            -1 === payload._status && (payload._status = 0, payload._result = ctor);
          }
          if (1 === payload._status)
            return ctor = payload._result, void 0 === ctor && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ctor
            ), "default" in ctor || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ctor
            ), ctor.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function noop() {
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module && module[requireString]).call(
                module,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors) {
          return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
                return;
              } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (; i < queue.length; i++) {
                var callback = queue[i];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i] = callback;
                      queue.splice(0, i);
                      return;
                    }
                    callback = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error) {
              queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        Symbol.for("react.provider");
        var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        }, fnName;
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign(deprecatedAPIs, Component.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          V: null,
          actQueue: null,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null,
          recentlyCreatedOwnerStacks: 0
        }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        deprecatedAPIs = {
          "react-stack-bottom-frame": function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = deprecatedAPIs["react-stack-bottom-frame"].bind(deprecatedAPIs, UnknownOwner)();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
          queueMicrotask(function() {
            return queueMicrotask(callback);
          });
        } : enqueueTask;
        deprecatedAPIs = Object.freeze({
          __proto__: null,
          c: function(size) {
            return resolveDispatcher().useMemoCache(size);
          }
        });
        exports.Children = {
          map: mapChildren,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          },
          toArray: function(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports.__COMPILER_RUNTIME = deprecatedAPIs;
        exports.act = function(callback) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback();
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve, reject) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve,
                            reject
                          );
                        });
                      } catch (error$0) {
                        ReactSharedInternals.thrownErrors.push(error$0);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject(_thrownError);
                      }
                    } else resolve(returnValue);
                  },
                  function(error) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve,
                  reject
                );
              })) : resolve(returnValue$jscomp$0);
            }
          };
        };
        exports.cache = function(fn) {
          return function() {
            return fn.apply(null, arguments);
          };
        };
        exports.captureOwnerStack = function() {
          var getCurrentStack = ReactSharedInternals.getCurrentStack;
          return null === getCurrentStack ? null : getCurrentStack();
        };
        exports.cloneElement = function(element, config, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign({}, element.props), key = element.key, owner = element._owner;
          if (null != config) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
            for (propName in config)
              !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i = 0; i < propName; i++)
              JSCompiler_inline_result[i] = arguments[i + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement(
            element.type,
            key,
            void 0,
            void 0,
            owner,
            props,
            element._debugStack,
            element._debugTask
          );
          for (key = 2; key < arguments.length; key++)
            owner = arguments[key], isValidElement(owner) && owner._store && (owner._store.validated = 1);
          return props;
        };
        exports.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports.createElement = function(type2, config, children) {
          for (var i = 2; i < arguments.length; i++) {
            var node = arguments[i];
            isValidElement(node) && node._store && (node._store.validated = 1);
          }
          i = {};
          node = null;
          if (null != config)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = "" + config.key), config)
              hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i.children = childArray;
          }
          if (type2 && type2.defaultProps)
            for (propName in childrenLength = type2.defaultProps, childrenLength)
              void 0 === i[propName] && (i[propName] = childrenLength[propName]);
          node && defineKeyPropWarningGetter(
            i,
            "function" === typeof type2 ? type2.displayName || type2.name || "Unknown" : type2
          );
          var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return ReactElement(
            type2,
            node,
            void 0,
            void 0,
            getOwner(),
            i,
            propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            propName ? createTask(getTaskName(type2)) : unknownOwnerDebugTask
          );
        };
        exports.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports.forwardRef = function(render) {
          null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render ? "null" : typeof render
          ) : 0 !== render.length && 2 !== render.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render && null != render.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
            }
          });
          return elementType;
        };
        exports.isValidElement = isValidElement;
        exports.lazy = function(ctor) {
          return {
            $$typeof: REACT_LAZY_TYPE,
            _payload: { _status: -1, _result: ctor },
            _init: lazyInitializer
          };
        };
        exports.memo = function(type2, compare) {
          null == type2 && console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type2 ? "null" : typeof type2
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE,
            type: type2,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type2.name || type2.displayName || (Object.defineProperty(type2, "name", { value: name }), type2.displayName = name);
            }
          });
          return compare;
        };
        exports.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
          } catch (error) {
            reportGlobalError(error);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), ReactSharedInternals.T = prevTransition;
          }
        };
        exports.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports.useActionState = function(action, initialState, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState,
            permalink
          );
        };
        exports.useCallback = function(callback, deps) {
          return resolveDispatcher().useCallback(callback, deps);
        };
        exports.useContext = function(Context) {
          var dispatcher = resolveDispatcher();
          Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context);
        };
        exports.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports.useEffect = function(create, createDeps, update) {
          null == create && console.warn(
            "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          var dispatcher = resolveDispatcher();
          if ("function" === typeof update)
            throw Error(
              "useEffect CRUD overload is not enabled in this build of React."
            );
          return dispatcher.useEffect(create, createDeps);
        };
        exports.useId = function() {
          return resolveDispatcher().useId();
        };
        exports.useImperativeHandle = function(ref, create, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create, deps);
        };
        exports.useInsertionEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useInsertionEffect(create, deps);
        };
        exports.useLayoutEffect = function(create, deps) {
          null == create && console.warn(
            "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
          );
          return resolveDispatcher().useLayoutEffect(create, deps);
        };
        exports.useMemo = function(create, deps) {
          return resolveDispatcher().useMemo(create, deps);
        };
        exports.useOptimistic = function(passthrough, reducer) {
          return resolveDispatcher().useOptimistic(passthrough, reducer);
        };
        exports.useReducer = function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        };
        exports.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports.useState = function(initialState) {
          return resolveDispatcher().useState(initialState);
        };
        exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports.version = "19.1.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      (function() {
        function performWorkUntilDeadline() {
          needsPaint = false;
          if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback = currentTask.callback;
                      if ("function" === typeof callback) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          a: for (; 0 < index; ) {
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node))
              heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else break a;
          }
        }
        function peek(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first = heap[0], last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
              var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
              else if (rightIndex < length && 0 > compare(right, last))
                heap[index] = right, heap[rightIndex] = last, index = rightIndex;
              else break a;
            }
          }
          return first;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        function advanceTimers(currentTime) {
          for (var timer = peek(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek(taskQueue))
              isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer && requestHostTimeout(
                handleTimeout,
                firstTimer.startTime - currentTime
              );
            }
        }
        function shouldYieldToHost() {
          return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        exports.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        if ("function" === typeof localSetImmediate)
          var schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        exports.unstable_IdlePriority = 5;
        exports.unstable_ImmediatePriority = 1;
        exports.unstable_LowPriority = 4;
        exports.unstable_NormalPriority = 3;
        exports.unstable_Profiling = null;
        exports.unstable_UserBlockingPriority = 2;
        exports.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_requestPaint = function() {
          needsPaint = true;
        };
        exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout = -1;
              break;
            case 2:
              timeout = 250;
              break;
            case 5:
              timeout = 1073741823;
              break;
            case 4:
              timeout = 1e4;
              break;
            default:
              timeout = 5e3;
          }
          timeout = options + timeout;
          priorityLevel = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: options,
            expirationTime: timeout,
            sortIndex: -1
          };
          options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
          return priorityLevel;
        };
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = function(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      (function() {
        function noop() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function createPortal$1(children, containerInfo, implementation) {
          var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          try {
            testStringCoercion(key);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          JSCompiler_inline_result && (console.error(
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
          ), testStringCoercion(key));
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        function getCrossOriginStringAs(as, input) {
          if ("font" === as) return "";
          if ("string" === typeof input)
            return "use-credentials" === input ? input : "";
        }
        function getValueDescriptorExpectingObjectForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
        }
        function getValueDescriptorExpectingEnumForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React13 = require_react(), Internals = {
          d: {
            f: noop,
            r: function() {
              throw Error(
                "Invalid form element. requestFormReset must be passed a form that was rendered by React."
              );
            },
            D: noop,
            C: noop,
            L: noop,
            m: noop,
            X: noop,
            S: noop,
            M: noop
          },
          p: 0,
          findDOMNode: null
        }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React13.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
        );
        exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
        exports.createPortal = function(children, container) {
          var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
            throw Error("Target container is not a DOM element.");
          return createPortal$1(children, container, null, key);
        };
        exports.flushSync = function(fn) {
          var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
          try {
            if (ReactSharedInternals.T = null, Internals.p = 2, fn)
              return fn();
          } finally {
            ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
          }
        };
        exports.preconnect = function(href, options) {
          "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
            "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : null != options && "string" !== typeof options.crossOrigin && console.error(
            "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
            getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
          ) : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
        };
        exports.prefetchDNS = function(href) {
          if ("string" !== typeof href || !href)
            console.error(
              "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href)
            );
          else if (1 < arguments.length) {
            var options = arguments[1];
            "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            ) : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options)
            );
          }
          "string" === typeof href && Internals.d.D(href);
        };
        exports.preinit = function(href, options) {
          "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
            "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : "style" !== options.as && "script" !== options.as && console.error(
            'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
            getValueDescriptorExpectingEnumForWarning(options.as)
          ) : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
          if ("string" === typeof href && options && "string" === typeof options.as) {
            var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
            "style" === as ? Internals.d.S(
              href,
              "string" === typeof options.precedence ? options.precedence : void 0,
              {
                crossOrigin,
                integrity,
                fetchPriority
              }
            ) : "script" === as && Internals.d.X(href, {
              crossOrigin,
              integrity,
              fetchPriority,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        };
        exports.preinitModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
          if (encountered)
            console.error(
              "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
              encountered
            );
          else
            switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
              case "script":
                break;
              default:
                encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                  'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                  encountered,
                  href
                );
            }
          if ("string" === typeof href)
            if ("object" === typeof options && null !== options) {
              if (null == options.as || "script" === options.as)
                encountered = getCrossOriginStringAs(
                  options.as,
                  options.crossOrigin
                ), Internals.d.M(href, {
                  crossOrigin: encountered,
                  integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                  nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
            } else null == options && Internals.d.M(href);
        };
        exports.preload = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
            encountered
          );
          if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
            encountered = options.as;
            var crossOrigin = getCrossOriginStringAs(
              encountered,
              options.crossOrigin
            );
            Internals.d.L(href, encountered, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0,
              type: "string" === typeof options.type ? options.type : void 0,
              fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
              referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
              imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
              imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
              media: "string" === typeof options.media ? options.media : void 0
            });
          }
        };
        exports.preloadModule = function(href, options) {
          var encountered = "";
          "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
          void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
          encountered && console.error(
            'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
            encountered
          );
          "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          ), Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin: encountered,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          })) : Internals.d.m(href));
        };
        exports.requestFormReset = function(form) {
          Internals.d.r(form);
        };
        exports.unstable_batchedUpdates = function(fn, a) {
          return fn(a);
        };
        exports.useFormState = function(action, initialState, permalink) {
          return resolveDispatcher().useFormState(action, initialState, permalink);
        };
        exports.useFormStatus = function() {
          return resolveDispatcher().useHostTransitionStatus();
        };
        exports.version = "19.1.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-client.development.js
  var require_react_dom_client_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom-client.development.js"(exports) {
      "use strict";
      (function() {
        function findHook(fiber, id) {
          for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
            fiber = fiber.next, id--;
          return fiber;
        }
        function copyWithSetImpl(obj, path, index, value) {
          if (index >= path.length) return value;
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
          return updated;
        }
        function copyWithRename(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length)
            console.warn("copyWithRename() expects paths of the same length");
          else {
            for (var i = 0; i < newPath.length - 1; i++)
              if (oldPath[i] !== newPath[i]) {
                console.warn(
                  "copyWithRename() expects paths to be the same except for the deepest key"
                );
                return;
              }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          }
        }
        function copyWithRenameImpl(obj, oldPath, newPath, index) {
          var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index + 1
          );
          return updated;
        }
        function copyWithDeleteImpl(obj, path, index) {
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
          if (index + 1 === path.length)
            return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
          updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
          return updated;
        }
        function shouldSuspendImpl() {
          return false;
        }
        function shouldErrorImpl() {
          return null;
        }
        function warnForMissingKey() {
        }
        function warnInvalidHookAccess() {
          console.error(
            "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
          );
        }
        function warnInvalidContextAccess() {
          console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        }
        function noop$2() {
        }
        function setToSortedString(set2) {
          var array = [];
          set2.forEach(function(value) {
            array.push(value);
          });
          return array.sort().join(", ");
        }
        function createFiber(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        }
        function scheduleRoot(root2, element) {
          root2.context === emptyContextObject && (updateContainerImpl(root2.current, 2, element, root2, null, null), flushSyncWork$1());
        }
        function scheduleRefresh(root2, update) {
          if (null !== resolveFamily) {
            var staleFamilies = update.staleFamilies;
            update = update.updatedFamilies;
            flushPendingEffects();
            scheduleFibersWithFamiliesRecursively(
              root2.current,
              update,
              staleFamilies
            );
            flushSyncWork$1();
          }
        }
        function setRefreshHandler(handler) {
          resolveFamily = handler;
        }
        function isValidContainer(node) {
          return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
        }
        function getNearestMountedFiber(fiber) {
          var node = fiber, nearestMounted = fiber;
          if (fiber.alternate) for (; node.return; ) node = node.return;
          else {
            fiber = node;
            do
              node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
            while (fiber);
          }
          return 3 === node.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
            if (null !== suspenseState) return suspenseState.dehydrated;
          }
          return null;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber)
            throw Error("Unable to find node on an unmounted component.");
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            alternate = getNearestMountedFiber(fiber);
            if (null === alternate)
              throw Error("Unable to find node on an unmounted component.");
            return alternate !== fiber ? null : fiber;
          }
          for (var a = fiber, b = alternate; ; ) {
            var parentA = a.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
              b = parentA.return;
              if (null !== b) {
                a = b;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              for (parentB = parentA.child; parentB; ) {
                if (parentB === a) return assertIsMounted(parentA), fiber;
                if (parentB === b) return assertIsMounted(parentA), alternate;
                parentB = parentB.sibling;
              }
              throw Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) a = parentA, b = parentB;
            else {
              for (var didFindChild = false, _child = parentA.child; _child; ) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                for (_child = parentB.child; _child; ) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild)
                  throw Error(
                    "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                  );
              }
            }
            if (a.alternate !== b)
              throw Error(
                "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
              );
          }
          if (3 !== a.tag)
            throw Error("Unable to find node on an unmounted component.");
          return a.stateNode.current === a ? fiber : alternate;
        }
        function findCurrentHostFiberImpl(node) {
          var tag = node.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
          for (node = node.child; null !== node; ) {
            tag = findCurrentHostFiberImpl(node);
            if (null !== tag) return tag;
            node = node.sibling;
          }
          return null;
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function getComponentNameFromType(type2) {
          if (null == type2) return null;
          if ("function" === typeof type2)
            return type2.$$typeof === REACT_CLIENT_REFERENCE ? null : type2.displayName || type2.name || null;
          if ("string" === typeof type2) return type2;
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type2)
            switch ("number" === typeof type2.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type2.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return (type2.displayName || "Context") + ".Provider";
              case REACT_CONSUMER_TYPE:
                return (type2._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type2.render;
                type2 = type2.displayName;
                type2 || (type2 = innerType.displayName || innerType.name || "", type2 = "" !== type2 ? "ForwardRef(" + type2 + ")" : "ForwardRef");
                return type2;
              case REACT_MEMO_TYPE:
                return innerType = type2.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type2._payload;
                type2 = type2._init;
                try {
                  return getComponentNameFromType(type2(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function getComponentNameFromOwner(owner) {
          return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
        }
        function getComponentNameFromFiber(fiber) {
          var type2 = fiber.type;
          switch (fiber.tag) {
            case 31:
              return "Activity";
            case 24:
              return "Cache";
            case 9:
              return (type2._context.displayName || "Context") + ".Consumer";
            case 10:
              return (type2.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return fiber = type2.render, fiber = fiber.displayName || fiber.name || "", type2.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 26:
            case 27:
            case 5:
              return type2;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return getComponentNameFromType(type2);
            case 8:
              return type2 === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 14:
            case 15:
              if ("function" === typeof type2)
                return type2.displayName || type2.name || null;
              if ("string" === typeof type2) return type2;
              break;
            case 29:
              type2 = fiber._debugInfo;
              if (null != type2) {
                for (var i = type2.length - 1; 0 <= i; i--)
                  if ("string" === typeof type2[i].name) return type2[i].name;
              }
              if (null !== fiber.return)
                return getComponentNameFromFiber(fiber.return);
          }
          return null;
        }
        function createCursor(defaultValue) {
          return { current: defaultValue };
        }
        function pop(cursor, fiber) {
          0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
        }
        function push(cursor, value, fiber) {
          index$jscomp$0++;
          valueStack[index$jscomp$0] = cursor.current;
          fiberStack[index$jscomp$0] = fiber;
          cursor.current = value;
        }
        function requiredContext(c) {
          null === c && console.error(
            "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
          );
          return c;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor, null, fiber);
          var nextRootContext = nextRootInstance.nodeType;
          switch (nextRootContext) {
            case 9:
            case 11:
              nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
              nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
              break;
            default:
              if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
                nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
                  nextRootInstance,
                  nextRootContext
                );
              else
                switch (nextRootContext) {
                  case "svg":
                    nextRootInstance = HostContextNamespaceSvg;
                    break;
                  case "math":
                    nextRootInstance = HostContextNamespaceMath;
                    break;
                  default:
                    nextRootInstance = HostContextNamespaceNone;
                }
          }
          nextRootContext = nextRootContext.toLowerCase();
          nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
          nextRootContext = {
            context: nextRootInstance,
            ancestorInfo: nextRootContext
          };
          pop(contextStackCursor, fiber);
          push(contextStackCursor, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          return requiredContext(contextStackCursor.current);
        }
        function pushHostContext(fiber) {
          null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
          var context = requiredContext(contextStackCursor.current);
          var type2 = fiber.type;
          var nextContext = getChildHostContextProd(context.context, type2);
          type2 = updatedAncestorInfoDev(context.ancestorInfo, type2);
          nextContext = { context: nextContext, ancestorInfo: type2 };
          context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
        }
        function popHostContext(fiber) {
          contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
          hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
        }
        function typeName(value) {
          return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        }
        function willCoercionThrow(value) {
          try {
            return testStringCoercion(value), false;
          } catch (e) {
            return true;
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
              attributeName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
              propName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkFormFieldValueStringCoercion(value) {
          if (willCoercionThrow(value))
            return console.error(
              "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
              typeName(value)
            ), testStringCoercion(value);
        }
        function injectInternals(internals) {
          if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) return true;
          if (!hook.supportsFiber)
            return console.error(
              "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
            ), true;
          try {
            rendererID = hook.inject(internals), injectedHook = hook;
          } catch (err) {
            console.error("React instrumentation encountered an error: %s.", err);
          }
          return hook.checkDCE ? true : false;
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
          if (injectedHook && "function" === typeof injectedHook.setStrictMode)
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
        }
        function injectProfilingHooks(profilingHooks) {
          injectedProfilingHooks = profilingHooks;
        }
        function markCommitStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();
        }
        function markComponentRenderStarted(fiber) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);
        }
        function markComponentRenderStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();
        }
        function markRenderStarted(lanes) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);
        }
        function markRenderStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();
        }
        function markStateUpdateScheduled(fiber, lane) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
        }
        function clz32Fallback(x) {
          x >>>= 0;
          return 0 === x ? 32 : 31 - (log3(x) / LN2 | 0) | 0;
        }
        function getLabelForLane(lane) {
          if (lane & 1) return "SyncHydrationLane";
          if (lane & 2) return "Sync";
          if (lane & 4) return "InputContinuousHydration";
          if (lane & 8) return "InputContinuous";
          if (lane & 16) return "DefaultHydration";
          if (lane & 32) return "Default";
          if (lane & 128) return "TransitionHydration";
          if (lane & 4194048) return "Transition";
          if (lane & 62914560) return "Retry";
          if (lane & 67108864) return "SelectiveHydration";
          if (lane & 134217728) return "IdleHydration";
          if (lane & 268435456) return "Idle";
          if (lane & 536870912) return "Offscreen";
          if (lane & 1073741824) return "Deferred";
        }
        function getHighestPriorityLanes(lanes) {
          var pendingSyncLanes = lanes & 42;
          if (0 !== pendingSyncLanes) return pendingSyncLanes;
          switch (lanes & -lanes) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
              return 128;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return lanes & 4194048;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return lanes & 62914560;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), lanes;
          }
        }
        function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
          var pendingLanes = root2.pendingLanes;
          if (0 === pendingLanes) return 0;
          var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
          root2 = root2.warmLanes;
          var nonIdlePendingLanes = pendingLanes & 134217727;
          0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
          return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
        }
        function checkIfRootIsPrerendering(root2, renderLanes2) {
          return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case 1:
            case 2:
            case 4:
            case 8:
            case 64:
              return currentTime + 250;
            case 16:
            case 32:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return currentTime + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), -1;
          }
        }
        function claimNextTransitionLane() {
          var lane = nextTransitionLane;
          nextTransitionLane <<= 1;
          0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
          return lane;
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
          return lane;
        }
        function createLaneMap(initial) {
          for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
          return laneMap;
        }
        function markRootUpdated$1(root2, updateLane) {
          root2.pendingLanes |= updateLane;
          268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
        }
        function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
          var previouslyPendingLanes = root2.pendingLanes;
          root2.pendingLanes = remainingLanes;
          root2.suspendedLanes = 0;
          root2.pingedLanes = 0;
          root2.warmLanes = 0;
          root2.expiredLanes &= remainingLanes;
          root2.entangledLanes &= remainingLanes;
          root2.errorRecoveryDisabledLanes &= remainingLanes;
          root2.shellSuspendCounter = 0;
          var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
          for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
            var index = 31 - clz32(remainingLanes), lane = 1 << index;
            entanglements[index] = 0;
            expirationTimes[index] = -1;
            var hiddenUpdatesForLane = hiddenUpdates[index];
            if (null !== hiddenUpdatesForLane)
              for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
                var update = hiddenUpdatesForLane[index];
                null !== update && (update.lane &= -536870913);
              }
            remainingLanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
          0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
        }
        function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
          root2.pendingLanes |= spawnedLane;
          root2.suspendedLanes &= ~spawnedLane;
          var spawnedLaneIndex = 31 - clz32(spawnedLane);
          root2.entangledLanes |= spawnedLane;
          root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
        }
        function markRootEntangled(root2, entangledLanes) {
          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
          for (root2 = root2.entanglements; rootEntangledLanes; ) {
            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
            lane & entangledLanes | root2[index] & entangledLanes && (root2[index] |= entangledLanes);
            rootEntangledLanes &= ~lane;
          }
        }
        function getBumpedLaneForHydrationByLane(lane) {
          switch (lane) {
            case 2:
              lane = 1;
              break;
            case 8:
              lane = 4;
              break;
            case 32:
              lane = 16;
              break;
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              lane = 128;
              break;
            case 268435456:
              lane = 134217728;
              break;
            default:
              lane = 0;
          }
          return lane;
        }
        function addFiberToLanesMap(root2, fiber, lanes) {
          if (isDevToolsPresent)
            for (root2 = root2.pendingUpdatersLaneMap; 0 < lanes; ) {
              var index = 31 - clz32(lanes), lane = 1 << index;
              root2[index].add(fiber);
              lanes &= ~lane;
            }
        }
        function movePendingFibersToMemoized(root2, lanes) {
          if (isDevToolsPresent)
            for (var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap, memoizedUpdaters = root2.memoizedUpdaters; 0 < lanes; ) {
              var index = 31 - clz32(lanes);
              root2 = 1 << index;
              index = pendingUpdatersLaneMap[index];
              0 < index.size && (index.forEach(function(fiber) {
                var alternate = fiber.alternate;
                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
              }), index.clear());
              lanes &= ~root2;
            }
        }
        function lanesToEventPriority(lanes) {
          lanes &= -lanes;
          return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
        }
        function resolveUpdatePriority() {
          var updatePriority = ReactDOMSharedInternals.p;
          if (0 !== updatePriority) return updatePriority;
          updatePriority = window.event;
          return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
        }
        function runWithPriority(priority, fn) {
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            return ReactDOMSharedInternals.p = priority, fn();
          } finally {
            ReactDOMSharedInternals.p = previousPriority;
          }
        }
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) return targetInst;
          for (var parentNode = targetNode.parentNode; parentNode; ) {
            if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
              parentNode = targetInst.alternate;
              if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
                for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                  if (parentNode = targetNode[internalInstanceKey])
                    return parentNode;
                  targetNode = getParentSuspenseInstance(targetNode);
                }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
            var tag = node.tag;
            if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
              return node;
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          var tag = inst.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
            return inst.stateNode;
          throw Error("getNodeFromInstance: Invalid argument.");
        }
        function getResourcesFromRoot(root2) {
          var resources = root2[internalRootNodeResourcesKey];
          resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
          return resources;
        }
        function markNodeAsHoistable(node) {
          node[internalHoistableMarker] = true;
        }
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          registrationNameDependencies[registrationName] && console.error(
            "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
            registrationName
          );
          registrationNameDependencies[registrationName] = dependencies;
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
          for (registrationName = 0; registrationName < dependencies.length; registrationName++)
            allNativeEvents.add(dependencies[registrationName]);
        }
        function checkControlledValueProps(tagName, props) {
          hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
          ) : console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
          ));
          props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
            "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
          );
        }
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
            return true;
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
            return false;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return validatedAttributeNameCache[attributeName] = true;
          illegalAttributeNameCache[attributeName] = true;
          console.error("Invalid attribute name: `%s`", attributeName);
          return false;
        }
        function getValueForAttributeOnCustomComponent(node, name, expected) {
          if (isAttributeNameSafe(name)) {
            if (!node.hasAttribute(name)) {
              switch (typeof expected) {
                case "symbol":
                case "object":
                  return expected;
                case "function":
                  return expected;
                case "boolean":
                  if (false === expected) return expected;
              }
              return void 0 === expected ? void 0 : null;
            }
            node = node.getAttribute(name);
            if ("" === node && true === expected) return true;
            checkAttributeStringCoercion(expected, name);
            return node === "" + expected ? expected : node;
          }
        }
        function setValueForAttribute(node, name, value) {
          if (isAttributeNameSafe(name))
            if (null === value) node.removeAttribute(name);
            else {
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                  node.removeAttribute(name);
                  return;
                case "boolean":
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  if ("data-" !== prefix2 && "aria-" !== prefix2) {
                    node.removeAttribute(name);
                    return;
                  }
              }
              checkAttributeStringCoercion(value, name);
              node.setAttribute(name, "" + value);
            }
        }
        function setValueForKnownAttribute(node, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttribute(name, "" + value);
          }
        }
        function setValueForNamespacedAttribute(node, namespace, name, value) {
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node.setAttributeNS(namespace, name, "" + value);
          }
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign({}, props, { value: prevLog }),
              info: assign({}, props, { value: prevInfo }),
              warn: assign({}, props, { value: prevWarn }),
              error: assign({}, props, { value: prevError }),
              group: assign({}, props, { value: prevGroup }),
              groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
              suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher2 = null;
          previousDispatcher2 = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x) {
                        var control = x;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample) {
                  if (sample && control && "string" === typeof sample.stack)
                    return [sample.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function formatOwnerStack(error) {
          var prevPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          error = error.stack;
          Error.prepareStackTrace = prevPrepareStackTrace;
          error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
          prevPrepareStackTrace = error.indexOf("\n");
          -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
          prevPrepareStackTrace = error.indexOf("react-stack-bottom-frame");
          -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
            "\n",
            prevPrepareStackTrace
          ));
          if (-1 !== prevPrepareStackTrace)
            error = error.slice(0, prevPrepareStackTrace);
          else return "";
          return error;
        }
        function describeFiber(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return describeBuiltInComponentFrame(fiber.type);
            case 16:
              return describeBuiltInComponentFrame("Lazy");
            case 13:
              return describeBuiltInComponentFrame("Suspense");
            case 19:
              return describeBuiltInComponentFrame("SuspenseList");
            case 0:
            case 15:
              return describeNativeComponentFrame(fiber.type, false);
            case 11:
              return describeNativeComponentFrame(fiber.type.render, false);
            case 1:
              return describeNativeComponentFrame(fiber.type, true);
            case 31:
              return describeBuiltInComponentFrame("Activity");
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            do {
              info += describeFiber(workInProgress2);
              var debugInfo = workInProgress2._debugInfo;
              if (debugInfo)
                for (var i = debugInfo.length - 1; 0 <= i; i--) {
                  var entry = debugInfo[i];
                  if ("string" === typeof entry.name) {
                    var JSCompiler_temp_const = info, env = entry.env;
                    var JSCompiler_inline_result = describeBuiltInComponentFrame(
                      entry.name + (env ? " [" + env + "]" : "")
                    );
                    info = JSCompiler_temp_const + JSCompiler_inline_result;
                  }
                }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        function describeFunctionComponentFrameWithoutLineNumber(fn) {
          return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
        }
        function getCurrentFiberOwnerNameInDevOrNull() {
          if (null === current) return null;
          var owner = current._debugOwner;
          return null != owner ? getComponentNameFromOwner(owner) : null;
        }
        function getCurrentFiberStackInDev() {
          if (null === current) return "";
          var workInProgress2 = current;
          try {
            var info = "";
            6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
            switch (workInProgress2.tag) {
              case 26:
              case 27:
              case 5:
                info += describeBuiltInComponentFrame(workInProgress2.type);
                break;
              case 13:
                info += describeBuiltInComponentFrame("Suspense");
                break;
              case 19:
                info += describeBuiltInComponentFrame("SuspenseList");
                break;
              case 31:
                info += describeBuiltInComponentFrame("Activity");
                break;
              case 30:
              case 0:
              case 15:
              case 1:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type
                ));
                break;
              case 11:
                workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
                  workInProgress2.type.render
                ));
            }
            for (; workInProgress2; )
              if ("number" === typeof workInProgress2.tag) {
                var fiber = workInProgress2;
                workInProgress2 = fiber._debugOwner;
                var debugStack = fiber._debugStack;
                workInProgress2 && debugStack && ("string" !== typeof debugStack && (fiber._debugStack = debugStack = formatOwnerStack(debugStack)), "" !== debugStack && (info += "\n" + debugStack));
              } else if (null != workInProgress2.debugStack) {
                var ownerStack = workInProgress2.debugStack;
                (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
              } else break;
            var JSCompiler_inline_result = info;
          } catch (x) {
            JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
          }
          return JSCompiler_inline_result;
        }
        function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
          var previousFiber = current;
          setCurrentFiber(fiber);
          try {
            return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
              callback.bind(null, arg0, arg1, arg2, arg3, arg4)
            ) : callback(arg0, arg1, arg2, arg3, arg4);
          } finally {
            setCurrentFiber(previousFiber);
          }
          throw Error(
            "runWithFiberInDEV should never be called in production. This is a bug in React."
          );
        }
        function setCurrentFiber(fiber) {
          ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
          isRendering = false;
          current = fiber;
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              return checkFormFieldValueStringCoercion(value), value;
            default:
              return "";
          }
        }
        function isCheckable(elem) {
          var type2 = elem.type;
          return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type2 || "radio" === type2);
        }
        function trackValueOnNode(node) {
          var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
            node.constructor.prototype,
            valueField
          );
          checkFormFieldValueStringCoercion(node[valueField]);
          var currentValue = "" + node[valueField];
          if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
            var get = descriptor.get, set2 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get.call(this);
              },
              set: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
                set2.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            return {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
              },
              stopTracking: function() {
                node._valueTracker = null;
                delete node[valueField];
              }
            };
          }
        }
        function track(node) {
          node._valueTracker || (node._valueTracker = trackValueOnNode(node));
        }
        function updateValueIfChanged(node) {
          if (!node) return false;
          var tracker = node._valueTracker;
          if (!tracker) return true;
          var lastValue = tracker.getValue();
          var value = "";
          node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
          node = value;
          return node !== lastValue ? (tracker.setValue(node), true) : false;
        }
        function getActiveElement(doc) {
          doc = doc || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof doc) return null;
          try {
            return doc.activeElement || doc.body;
          } catch (e) {
            return doc.body;
          }
        }
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
          return value.replace(
            escapeSelectorAttributeValueInsideDoubleQuotesRegex,
            function(ch) {
              return "\\" + ch.charCodeAt(0).toString(16) + " ";
            }
          );
        }
        function validateInputProps(element, props) {
          void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
            "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnCheckedDefaultChecked = true);
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
            "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnValueDefaultValue$1 = true);
        }
        function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type2, name) {
          element.name = "";
          null != type2 && "function" !== typeof type2 && "symbol" !== typeof type2 && "boolean" !== typeof type2 ? (checkAttributeStringCoercion(type2, "type"), element.type = type2) : element.removeAttribute("type");
          if (null != value)
            if ("number" === type2) {
              if (0 === value && "" === element.value || element.value != value)
                element.value = "" + getToStringValue(value);
            } else
              element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
          else
            "submit" !== type2 && "reset" !== type2 || element.removeAttribute("value");
          null != value ? setDefaultValue(element, type2, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type2, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
          null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
          null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
        }
        function initInput(element, value, defaultValue, checked, defaultChecked, type2, name, isHydrating2) {
          null != type2 && "function" !== typeof type2 && "symbol" !== typeof type2 && "boolean" !== typeof type2 && (checkAttributeStringCoercion(type2, "type"), element.type = type2);
          if (null != value || null != defaultValue) {
            if (!("submit" !== type2 && "reset" !== type2 || void 0 !== value && null !== value))
              return;
            defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
            value = null != value ? "" + getToStringValue(value) : defaultValue;
            isHydrating2 || value === element.value || (element.value = value);
            element.defaultValue = value;
          }
          checked = null != checked ? checked : defaultChecked;
          checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
          element.checked = isHydrating2 ? element.checked : !!checked;
          element.defaultChecked = !!checked;
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
        }
        function setDefaultValue(node, type2, value) {
          "number" === type2 && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
        }
        function validateOptionProps(element, props) {
          null == props.value && ("object" === typeof props.children && null !== props.children ? React13.Children.forEach(props.children, function(child) {
            null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            ));
          }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
            "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
          )));
          null == props.selected || didWarnSelectedSetOnOption || (console.error(
            "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
          ), didWarnSelectedSetOnOption = true);
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          node = node.options;
          if (multiple) {
            multiple = {};
            for (var i = 0; i < propValue.length; i++)
              multiple["$" + propValue[i]] = true;
            for (propValue = 0; propValue < node.length; propValue++)
              i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
          } else {
            propValue = "" + getToStringValue(propValue);
            multiple = null;
            for (i = 0; i < node.length; i++) {
              if (node[i].value === propValue) {
                node[i].selected = true;
                setDefaultSelected && (node[i].defaultSelected = true);
                return;
              }
              null !== multiple || node[i].disabled || (multiple = node[i]);
            }
            null !== multiple && (multiple.selected = true);
          }
        }
        function validateSelectProps(element, props) {
          for (element = 0; element < valuePropNames.length; element++) {
            var propName = valuePropNames[element];
            if (null != props[propName]) {
              var propNameIsArray = isArrayImpl(props[propName]);
              props.multiple && !propNameIsArray ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              ) : !props.multiple && propNameIsArray && console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
            }
          }
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
            "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
          ), didWarnValueDefaultValue = true);
        }
        function validateTextareaProps(element, props) {
          void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
            "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component"
          ), didWarnValDefaultVal = true);
          null != props.children && null == props.value && console.error(
            "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
          );
        }
        function updateTextarea(element, value, defaultValue) {
          if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
            element.defaultValue !== value && (element.defaultValue = value);
            return;
          }
          element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        }
        function initTextarea(element, value, defaultValue, children) {
          if (null == value) {
            if (null != children) {
              if (null != defaultValue)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children)) {
                if (1 < children.length)
                  throw Error("<textarea> can only have at most one child.");
                children = children[0];
              }
              defaultValue = children;
            }
            null == defaultValue && (defaultValue = "");
            value = defaultValue;
          }
          defaultValue = getToStringValue(value);
          element.defaultValue = defaultValue;
          children = element.textContent;
          children === defaultValue && "" !== children && null !== children && (element.value = children);
        }
        function findNotableNode(node, indent) {
          return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
        }
        function indentation(indent) {
          return "  " + "  ".repeat(indent);
        }
        function added(indent) {
          return "+ " + "  ".repeat(indent);
        }
        function removed(indent) {
          return "- " + "  ".repeat(indent);
        }
        function describeFiberType(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return fiber.type;
            case 16:
              return "Lazy";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 0:
            case 15:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            case 11:
              return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
            case 1:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            default:
              return null;
          }
        }
        function describeTextNode(content, maxLength) {
          return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
        }
        function describeTextDiff(clientText, serverProps, indent) {
          var maxLength = 120 - 2 * indent;
          if (null === serverProps)
            return added(indent) + describeTextNode(clientText, maxLength) + "\n";
          if ("string" === typeof serverProps) {
            for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
            return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
          }
          return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
        }
        function objectName(object) {
          return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
            return p0;
          });
        }
        function describeValue(value, maxLength) {
          switch (typeof value) {
            case "string":
              return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
            case "object":
              if (null === value) return "null";
              if (isArrayImpl(value)) return "[...]";
              if (value.$$typeof === REACT_ELEMENT_TYPE)
                return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
              var name = objectName(value);
              if ("Object" === name) {
                name = "";
                maxLength -= 2;
                for (var propName in value)
                  if (value.hasOwnProperty(propName)) {
                    var jsonPropName = JSON.stringify(propName);
                    jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                    maxLength -= propName.length - 2;
                    jsonPropName = describeValue(
                      value[propName],
                      15 > maxLength ? maxLength : 15
                    );
                    maxLength -= jsonPropName.length;
                    if (0 > maxLength) {
                      name += "" === name ? "..." : ", ...";
                      break;
                    }
                    name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                  }
                return "{" + name + "}";
              }
              return name;
            case "function":
              return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
            default:
              return String(value);
          }
        }
        function describePropValue(value, maxLength) {
          return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
        }
        function describeExpandedElement(type2, props, rowPrefix) {
          var remainingRowLength = 120 - rowPrefix.length - type2.length, properties = [], propName;
          for (propName in props)
            if (props.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(
                props[propName],
                120 - rowPrefix.length - propName.length - 1
              );
              remainingRowLength -= propName.length + propValue.length + 2;
              properties.push(propName + "=" + propValue);
            }
          return 0 === properties.length ? rowPrefix + "<" + type2 + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type2 + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type2 + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
        }
        function describePropertiesDiff(clientObject, serverObject, indent) {
          var properties = "", remainingServerProperties = assign({}, serverObject), propName;
          for (propName in clientObject)
            if (clientObject.hasOwnProperty(propName)) {
              delete remainingServerProperties[propName];
              var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
              serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
            }
          for (var _propName in remainingServerProperties)
            remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
              remainingServerProperties[_propName],
              120 - 2 * indent - _propName.length - 2
            ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
          return properties;
        }
        function describeElementDiff(type2, clientProps, serverProps, indent) {
          var content = "", serverPropNames = /* @__PURE__ */ new Map();
          for (propName$jscomp$0 in serverProps)
            serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
              propName$jscomp$0.toLowerCase(),
              propName$jscomp$0
            );
          if (1 === serverPropNames.size && serverPropNames.has("children"))
            content += describeExpandedElement(
              type2,
              clientProps,
              indentation(indent)
            );
          else {
            for (var _propName2 in clientProps)
              if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
                if (void 0 !== serverPropName) {
                  serverPropNames.delete(_propName2.toLowerCase());
                  var propName$jscomp$0 = clientProps[_propName2];
                  serverPropName = serverProps[serverPropName];
                  var clientPropValue = describePropValue(
                    propName$jscomp$0,
                    maxLength$jscomp$0
                  );
                  maxLength$jscomp$0 = describePropValue(
                    serverPropName,
                    maxLength$jscomp$0
                  );
                  "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                    propName$jscomp$0,
                    serverPropName,
                    indent + 2
                  ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
                } else
                  content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
              }
            serverPropNames.forEach(function(propName) {
              if ("children" !== propName) {
                var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
                content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
              }
            });
            content = "" === content ? indentation(indent) + "<" + type2 + ">\n" : indentation(indent) + "<" + type2 + "\n" + content + indentation(indent) + ">\n";
          }
          type2 = serverProps.children;
          clientProps = clientProps.children;
          if ("string" === typeof type2 || "number" === typeof type2 || "bigint" === typeof type2) {
            serverPropNames = "";
            if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
              serverPropNames = "" + clientProps;
            content += describeTextDiff(serverPropNames, "" + type2, indent + 1);
          } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
            content = null == type2 ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
          return content;
        }
        function describeSiblingFiber(fiber, indent) {
          var type2 = describeFiberType(fiber);
          if (null === type2) {
            type2 = "";
            for (fiber = fiber.child; fiber; )
              type2 += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
            return type2;
          }
          return indentation(indent) + "<" + type2 + ">\n";
        }
        function describeNode(node, indent) {
          var skipToNode = findNotableNode(node, indent);
          if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode))
            return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
          skipToNode = "";
          var debugInfo = node.fiber._debugInfo;
          if (debugInfo)
            for (var i = 0; i < debugInfo.length; i++) {
              var serverComponentName = debugInfo[i].name;
              "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
            }
          debugInfo = "";
          i = node.fiber.pendingProps;
          if (6 === node.fiber.tag)
            debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
          else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName)
            if (void 0 === node.serverProps) {
              debugInfo = indent;
              var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
              for (propName in i)
                if (i.hasOwnProperty(propName) && "children" !== propName) {
                  var propValue = describePropValue(i[propName], 15);
                  maxLength -= propName.length + propValue.length + 2;
                  if (0 > maxLength) {
                    content += " ...";
                    break;
                  }
                  content += " " + propName + "=" + propValue;
                }
              debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
              indent++;
            } else
              null === node.serverProps ? (debugInfo = describeExpandedElement(
                serverComponentName,
                i,
                added(indent)
              ), indent++) : "string" === typeof node.serverProps ? console.error(
                "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
              ) : (debugInfo = describeElementDiff(
                serverComponentName,
                i,
                node.serverProps,
                indent
              ), indent++);
          var propName = "";
          i = node.fiber.child;
          for (serverComponentName = 0; i && serverComponentName < node.children.length; )
            maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
          i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
          i = node.serverTail;
          null === node.serverProps && indent--;
          for (node = 0; node < i.length; node++)
            serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
              serverComponentName.type,
              serverComponentName.props,
              removed(indent)
            );
          return skipToNode + debugInfo + propName;
        }
        function describeDiff(rootNode) {
          try {
            return "\n\n" + describeNode(rootNode, 0);
          } catch (x) {
            return "";
          }
        }
        function describeAncestors(ancestor, child, props) {
          for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
            fiber === ancestor && (distanceFromLeaf = 0), node = {
              fiber,
              children: null !== node ? [node] : [],
              serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
              serverTail: [],
              distanceFromLeaf
            }, distanceFromLeaf++, fiber = fiber.return;
          return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
        }
        function updatedAncestorInfoDev(oldInfo, tag) {
          var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev), info = { tag };
          -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
          -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
          -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
          ancestorInfo.current = info;
          "form" === tag && (ancestorInfo.formTag = info);
          "a" === tag && (ancestorInfo.aTagInScope = info);
          "button" === tag && (ancestorInfo.buttonTagInScope = info);
          "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
          "p" === tag && (ancestorInfo.pTagInButtonScope = info);
          "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
          if ("dd" === tag || "dt" === tag)
            ancestorInfo.dlItemTagAutoclosing = info;
          "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
          null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? true === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
          return ancestorInfo;
        }
        function isTagValidWithParent(tag, parentTag, implicitRootScope) {
          switch (parentTag) {
            case "select":
              return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
            case "optgroup":
              return "option" === tag || "#text" === tag;
            case "option":
              return "#text" === tag;
            case "tr":
              return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "tbody":
            case "thead":
            case "tfoot":
              return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "colgroup":
              return "col" === tag || "template" === tag;
            case "table":
              return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "head":
              return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "html":
              if (implicitRootScope) break;
              return "head" === tag || "body" === tag || "frameset" === tag;
            case "frameset":
              return "frame" === tag;
            case "#document":
              if (!implicitRootScope) return "html" === tag;
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
            case "rp":
            case "rt":
              return -1 === impliedEndTags.indexOf(parentTag);
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return null == parentTag;
            case "head":
              return implicitRootScope || null === parentTag;
            case "html":
              return implicitRootScope && "#document" === parentTag || null === parentTag;
            case "body":
              return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
          }
          return true;
        }
        function findInvalidAncestorForTag(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        }
        function findAncestor(parent, tagName) {
          for (; parent; ) {
            switch (parent.tag) {
              case 5:
              case 26:
              case 27:
                if (parent.type === tagName) return parent;
            }
            parent = parent.return;
          }
          return null;
        }
        function validateDOMNesting(childTag, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
          var parentInfo = ancestorInfo.current;
          ancestorInfo = (parentInfo = isTagValidWithParent(
            childTag,
            parentInfo && parentInfo.tag,
            ancestorInfo.implicitRootScope
          ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          ancestorInfo = parentInfo || ancestorInfo;
          if (!ancestorInfo) return true;
          var ancestorTag = ancestorInfo.tag;
          ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
          if (didWarn[ancestorInfo]) return false;
          didWarn[ancestorInfo] = true;
          var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
          parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            parentInfo,
            ancestorDescription
          )) : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            tagDisplayName,
            ancestorTag,
            ancestorDescription
          );
          ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
            console.error(
              "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
              ancestorTag,
              tagDisplayName
            );
          }));
          return false;
        }
        function validateTextNesting(childText, parentTag, implicitRootScope) {
          if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
            return true;
          implicitRootScope = "#text|" + parentTag;
          if (didWarn[implicitRootScope]) return false;
          didWarn[implicitRootScope] = true;
          var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
          implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(
            ancestor,
            implicitRootScope,
            6 !== implicitRootScope.tag ? { children: null } : null
          ) : "";
          /\S/.test(childText) ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          ) : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            implicitRootScope
          );
          return false;
        }
        function setTextContent(node, text) {
          if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node.textContent = text;
        }
        function camelize(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        }
        function setValueForStyle(style2, styleName, value) {
          var isCustomProperty = 0 === styleName.indexOf("--");
          isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported style property %s. Did you mean %s?",
            styleName,
            camelize(styleName.replace(msPattern, "ms-"))
          )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported vendor-prefixed style property %s. Did you mean %s?",
            styleName,
            styleName.charAt(0).toUpperCase() + styleName.slice(1)
          )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            styleName,
            value.replace(badStyleValueWithSemicolonPattern, "")
          )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
            "`NaN` is an invalid value for the `%s` css style property.",
            styleName
          )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
            "`Infinity` is an invalid value for the `%s` css style property.",
            styleName
          ))));
          null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style2[styleName] = ("" + value).trim()) : style2[styleName] = value + "px";
        }
        function setValueForStyles(node, styles, prevStyles) {
          if (null != styles && "object" !== typeof styles)
            throw Error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          styles && Object.freeze(styles);
          node = node.style;
          if (null != prevStyles) {
            if (styles) {
              var expandedUpdates = {};
              if (prevStyles) {
                for (var key in prevStyles)
                  if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
                    for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++)
                      expandedUpdates[longhands[i]] = key;
              }
              for (var _key in styles)
                if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key]))
                  for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
                    expandedUpdates[key[longhands]] = _key;
              _key = {};
              for (var key$jscomp$0 in styles)
                for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
                  _key[key[longhands]] = key$jscomp$0;
              key$jscomp$0 = {};
              for (var _key2 in expandedUpdates)
                if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
                  key$jscomp$0[i] = true;
                  i = console;
                  var value = styles[key];
                  i.error.call(
                    i,
                    "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                    null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
                    key,
                    longhands
                  );
                }
            }
            for (var styleName in prevStyles)
              !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
            for (var _styleName in styles)
              _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
          } else
            for (expandedUpdates in styles)
              styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
        }
        function isCustomElement(tagName) {
          if (-1 === tagName.indexOf("-")) return false;
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        function getAttributeAlias(name) {
          return aliases.get(name) || name;
        }
        function validateProperty$1(tagName, name) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return true;
          if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                name
              ), warnedProperties$1[name] = true;
            if (name !== tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true;
          }
          if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = true, false;
            name !== tagName && (console.error(
              "Unknown ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true);
          }
          return true;
        }
        function validateProperties$2(type2, props) {
          var invalidProps = [], key;
          for (key in props)
            validateProperty$1(type2, key) || invalidProps.push(key);
          props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === invalidProps.length ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type2
          ) : 1 < invalidProps.length && console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type2
          );
        }
        function validateProperty(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
            return true;
          var lowerCasedName = name.toLowerCase();
          if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
            return console.error(
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
            ), warnedProperties[name] = true;
          if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
            return true;
          if (null != eventRegistry) {
            tagName = eventRegistry.possibleRegistrationNames;
            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
              return true;
            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry)
              return console.error(
                "Invalid event handler property `%s`. Did you mean `%s`?",
                name,
                eventRegistry
              ), warnedProperties[name] = true;
            if (EVENT_NAME_REGEX.test(name))
              return console.error(
                "Unknown event handler property `%s`. It will be ignored.",
                name
              ), warnedProperties[name] = true;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ), warnedProperties[name] = true;
          if (rARIA.test(name) || rARIACamel.test(name)) return true;
          if ("innerhtml" === lowerCasedName)
            return console.error(
              "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
            ), warnedProperties[name] = true;
          if ("aria" === lowerCasedName)
            return console.error(
              "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
            ), warnedProperties[name] = true;
          if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
            return console.error(
              "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
              typeof value
            ), warnedProperties[name] = true;
          if ("number" === typeof value && isNaN(value))
            return console.error(
              "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
              name
            ), warnedProperties[name] = true;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
              return console.error(
                "Invalid DOM property `%s`. Did you mean `%s`?",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
          } else if (name !== lowerCasedName)
            return console.error(
              "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
          switch (name) {
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              return true;
            case "innerText":
            case "textContent":
              return true;
          }
          switch (typeof value) {
            case "boolean":
              switch (name) {
                case "autoFocus":
                case "checked":
                case "multiple":
                case "muted":
                case "selected":
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "capture":
                case "download":
                case "inert":
                  return true;
                default:
                  lowerCasedName = name.toLowerCase().slice(0, 5);
                  if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                    return true;
                  value ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  ) : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
                  return warnedProperties[name] = true;
              }
            case "function":
            case "symbol":
              return warnedProperties[name] = true, false;
            case "string":
              if ("false" === value || "true" === value) {
                switch (name) {
                  case "checked":
                  case "selected":
                  case "multiple":
                  case "muted":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "inert":
                    break;
                  default:
                    return true;
                }
                console.error(
                  "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                  value,
                  name,
                  "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                  name,
                  value
                );
                warnedProperties[name] = true;
              }
          }
          return true;
        }
        function warnUnknownProperties(type2, props, eventRegistry) {
          var unknownProps = [], key;
          for (key in props)
            validateProperty(type2, key, props[key], eventRegistry) || unknownProps.push(key);
          props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === unknownProps.length ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type2
          ) : 1 < unknownProps.length && console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type2
          );
        }
        function sanitizeURL(url) {
          return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
        }
        function getEventTarget(nativeEvent) {
          nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
          nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
          return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
        }
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (internalInstance && (target = internalInstance.stateNode)) {
            var props = target[internalPropsKey] || null;
            a: switch (target = internalInstance.stateNode, internalInstance.type) {
              case "input":
                updateInput(
                  target,
                  props.value,
                  props.defaultValue,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name
                );
                internalInstance = props.name;
                if ("radio" === props.type && null != internalInstance) {
                  for (props = target; props.parentNode; ) props = props.parentNode;
                  checkAttributeStringCoercion(internalInstance, "name");
                  props = props.querySelectorAll(
                    'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                      "" + internalInstance
                    ) + '"][type="radio"]'
                  );
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                    var otherNode = props[internalInstance];
                    if (otherNode !== target && otherNode.form === target.form) {
                      var otherProps = otherNode[internalPropsKey] || null;
                      if (!otherProps)
                        throw Error(
                          "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                        );
                      updateInput(
                        otherNode,
                        otherProps.value,
                        otherProps.defaultValue,
                        otherProps.defaultValue,
                        otherProps.checked,
                        otherProps.defaultChecked,
                        otherProps.type,
                        otherProps.name
                      );
                    }
                  }
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                    otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                }
                break a;
              case "textarea":
                updateTextarea(target, props.value, props.defaultValue);
                break a;
              case "select":
                internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
            }
          }
        }
        function batchedUpdates$1(fn, a, b) {
          if (isInsideEventHandler) return fn(a, b);
          isInsideEventHandler = true;
          try {
            var JSCompiler_inline_result = fn(a);
            return JSCompiler_inline_result;
          } finally {
            if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
              if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
                for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
            }
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (null === stateNode) return null;
          var props = stateNode[internalPropsKey] || null;
          if (null === props) return null;
          stateNode = props[registrationName];
          a: switch (registrationName) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
              inst = !props;
              break a;
            default:
              inst = false;
          }
          if (inst) return null;
          if (stateNode && "function" !== typeof stateNode)
            throw Error(
              "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
            );
          return stateNode;
        }
        function getData() {
          if (fallbackText) return fallbackText;
          var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
          for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
          return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
        }
        function getEventCharCode(nativeEvent) {
          var keyCode = nativeEvent.keyCode;
          "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
          10 === nativeEvent && (nativeEvent = 13);
          return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var propName in Interface)
              Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
            this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        function modifierStateGetter(keyArg) {
          var nativeEvent = this.nativeEvent;
          return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
        }
        function getEventModifierState() {
          return modifierStateGetter;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          nativeEvent = nativeEvent.detail;
          return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              if (nativeEvent.which !== SPACEBAR_CODE) return null;
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing)
            return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                if (nativeEvent.char && 1 < nativeEvent.char.length)
                  return nativeEvent.char;
                if (nativeEvent.which)
                  return String.fromCharCode(nativeEvent.which);
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) return false;
          eventNameSuffix = "on" + eventNameSuffix;
          var isSupported = eventNameSuffix in document;
          isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
          return isSupported;
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
          inst = accumulateTwoPhaseListeners(inst, "onChange");
          0 < inst.length && (nativeEvent = new SyntheticEvent(
            "onChange",
            "change",
            null,
            nativeEvent,
            target
          ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) return targetInst;
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if ("change" === domEventName) return targetInst;
        }
        function stopWatchingForValueChange() {
          activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
        }
        function handlePropertyChange(nativeEvent) {
          if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(
              dispatchQueue,
              activeElementInst$1,
              nativeEvent,
              getEventTarget(nativeEvent)
            );
            batchedUpdates$1(runEventInBatch, dispatchQueue);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(domEventName) {
          if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
            return getInstIfValueChanged(activeElementInst$1);
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if ("click" === domEventName) return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if ("input" === domEventName || "change" === domEventName)
            return getInstIfValueChanged(targetInst);
        }
        function is(x, y) {
          return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
        }
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) return true;
          if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
            return false;
          var keysA = Object.keys(objA), keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (keysB = 0; keysB < keysA.length; keysB++) {
            var currentKey = keysA[keysB];
            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
              return false;
          }
          return true;
        }
        function getLeafNode(node) {
          for (; node && node.firstChild; ) node = node.firstChild;
          return node;
        }
        function getNodeForCharacterOffset(root2, offset) {
          var node = getLeafNode(root2);
          root2 = 0;
          for (var nodeEnd; node; ) {
            if (3 === node.nodeType) {
              nodeEnd = root2 + node.textContent.length;
              if (root2 <= offset && nodeEnd >= offset)
                return { node, offset: offset - root2 };
              root2 = nodeEnd;
            }
            a: {
              for (; node; ) {
                if (node.nextSibling) {
                  node = node.nextSibling;
                  break a;
                }
                node = node.parentNode;
              }
              node = void 0;
            }
            node = getLeafNode(node);
          }
        }
        function containsNode(outerNode, innerNode) {
          return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
        }
        function getActiveElementDeep(containerInfo) {
          containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
          for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
            try {
              var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
            } catch (err) {
              JSCompiler_inline_result = false;
            }
            if (JSCompiler_inline_result) containerInfo = element.contentWindow;
            else break;
            element = getActiveElement(containerInfo.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
          mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
            anchorNode: doc.anchorNode,
            anchorOffset: doc.anchorOffset,
            focusNode: doc.focusNode,
            focusOffset: doc.focusOffset
          }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
            "onSelect",
            "select",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes = {};
          prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes["Webkit" + styleProp] = "webkit" + eventName;
          prefixes["Moz" + styleProp] = "moz" + eventName;
          return prefixes;
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
          if (!vendorPrefixes[eventName]) return eventName;
          var prefixMap = vendorPrefixes[eventName], styleProp;
          for (styleProp in prefixMap)
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
              return prefixedEventNames[eventName] = prefixMap[styleProp];
          return eventName;
        }
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function createCapturedValueAtFiber(value, source) {
          if ("object" === typeof value && null !== value) {
            var existing = CapturedStacks.get(value);
            if (void 0 !== existing) return existing;
            source = {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
            CapturedStacks.set(value, source);
            return source;
          }
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
        }
        function finishQueueingConcurrentUpdates() {
          for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
            var fiber = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var queue = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var update = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var lane = concurrentQueues[i];
            concurrentQueues[i++] = null;
            if (null !== queue && null !== update) {
              var pending = queue.pending;
              null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
              queue.pending = update;
            }
            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
          }
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
          concurrentQueues[concurrentQueuesIndex++] = fiber;
          concurrentQueues[concurrentQueuesIndex++] = queue;
          concurrentQueues[concurrentQueuesIndex++] = update;
          concurrentQueues[concurrentQueuesIndex++] = lane;
          concurrentlyUpdatedLanes |= lane;
          fiber.lanes |= lane;
          fiber = fiber.alternate;
          null !== fiber && (fiber.lanes |= lane);
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          enqueueUpdate$1(fiber, queue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          enqueueUpdate$1(fiber, null, null, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
          sourceFiber.lanes |= lane;
          var alternate = sourceFiber.alternate;
          null !== alternate && (alternate.lanes |= lane);
          for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
            parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
          return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
        }
        function getRootForUpdatedFiber(sourceFiber) {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
            throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
              "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
            );
          nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
            "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
          ));
          null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          for (var node = sourceFiber, parent = node.return; null !== parent; )
            null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
          return 3 === node.tag ? node.stateNode : null;
        }
        function resolveFunctionForHotReloading(type2) {
          if (null === resolveFamily) return type2;
          var family = resolveFamily(type2);
          return void 0 === family ? type2 : family.current;
        }
        function resolveForwardRefForHotReloading(type2) {
          if (null === resolveFamily) return type2;
          var family = resolveFamily(type2);
          return void 0 === family ? null !== type2 && void 0 !== type2 && "function" === typeof type2.render && (family = resolveFunctionForHotReloading(type2.render), type2.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type2.displayName && (family.displayName = type2.displayName), family) : type2 : family.current;
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          if (null === resolveFamily) return false;
          var prevType = fiber.elementType;
          element = element.type;
          var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
          switch (fiber.tag) {
            case 1:
              "function" === typeof element && (needsCompareFamilies = true);
              break;
            case 0:
              "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 11:
              $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 14:
            case 15:
              $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            default:
              return false;
          }
          return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
        }
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type2 = fiber.type, candidateType = null;
          switch (tag) {
            case 0:
            case 15:
            case 1:
              candidateType = type2;
              break;
            case 11:
              candidateType = type2.render;
          }
          if (null === resolveFamily)
            throw Error("Expected resolveFamily to be set during hot reload.");
          var needsRender = false;
          type2 = false;
          null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type2 = true : updatedFamilies.has(candidateType) && (1 === tag ? type2 = true : needsRender = true)));
          null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type2 = true);
          type2 && (fiber._debugNeedsRemount = true);
          if (type2 || needsRender)
            alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
          null === child || type2 || scheduleFibersWithFamiliesRecursively(
            child,
            updatedFamilies,
            staleFamilies
          );
          null !== sibling && scheduleFibersWithFamiliesRecursively(
            sibling,
            updatedFamilies,
            staleFamilies
          );
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.refCleanup = this.ref = null;
          this.pendingProps = pendingProps;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = mode;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
          this.actualDuration = -0;
          this.actualStartTime = -1.1;
          this.treeBaseDuration = this.selfBaseDuration = -0;
          this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
        }
        function shouldConstruct(Component) {
          Component = Component.prototype;
          return !(!Component || !Component.isReactComponent);
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          null === workInProgress2 ? (workInProgress2 = createFiber(
            current2.tag,
            pendingProps,
            current2.key,
            current2.mode
          ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
          workInProgress2.flags = current2.flags & 65011712;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          pendingProps = current2.dependencies;
          workInProgress2.dependencies = null === pendingProps ? null : {
            lanes: pendingProps.lanes,
            firstContext: pendingProps.firstContext,
            _debugThenableState: pendingProps._debugThenableState
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          workInProgress2.refCleanup = current2.refCleanup;
          workInProgress2.selfBaseDuration = current2.selfBaseDuration;
          workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          workInProgress2._debugInfo = current2._debugInfo;
          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case 0:
            case 15:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 1:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case 11:
              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= 65011714;
          var current2 = workInProgress2.alternate;
          null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
            lanes: renderLanes2.lanes,
            firstContext: renderLanes2.firstContext,
            _debugThenableState: renderLanes2._debugThenableState
          }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
          return workInProgress2;
        }
        function createFiberFromTypeAndProps(type2, key, pendingProps, owner, mode, lanes) {
          var fiberTag = 0, resolvedType = type2;
          if ("function" === typeof type2)
            shouldConstruct(type2) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
          else if ("string" === typeof type2)
            fiberTag = getHostContext(), fiberTag = isHostHoistableType(type2, pendingProps, fiberTag) ? 26 : "html" === type2 || "head" === type2 || "body" === type2 ? 27 : 5;
          else
            a: switch (type2) {
              case REACT_ACTIVITY_TYPE:
                return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(
                  pendingProps.children,
                  mode,
                  lanes,
                  key
                );
              case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= StrictLegacyMode;
                mode |= StrictEffectsMode;
                break;
              case REACT_PROFILER_TYPE:
                return type2 = pendingProps, owner = mode, "string" !== typeof type2.id && console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type2.id
                ), key = createFiber(12, type2, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
              case REACT_SUSPENSE_TYPE:
                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
              case REACT_SUSPENSE_LIST_TYPE:
                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
              default:
                if ("object" === typeof type2 && null !== type2)
                  switch (type2.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 10;
                      break a;
                    case REACT_CONSUMER_TYPE:
                      fiberTag = 9;
                      break a;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = 11;
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      break a;
                    case REACT_MEMO_TYPE:
                      fiberTag = 14;
                      break a;
                    case REACT_LAZY_TYPE:
                      fiberTag = 16;
                      resolvedType = null;
                      break a;
                  }
                resolvedType = "";
                if (void 0 === type2 || "object" === typeof type2 && null !== type2 && 0 === Object.keys(type2).length)
                  resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                null === type2 ? pendingProps = "null" : isArrayImpl(type2) ? pendingProps = "array" : void 0 !== type2 && type2.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type2;
                (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
                fiberTag = 29;
                pendingProps = Error(
                  "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
                );
                resolvedType = null;
            }
          key = createFiber(fiberTag, pendingProps, key, mode);
          key.elementType = type2;
          key.type = resolvedType;
          key.lanes = lanes;
          key._debugOwner = owner;
          return key;
        }
        function createFiberFromElement(element, mode, lanes) {
          mode = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            element._owner,
            mode,
            lanes
          );
          mode._debugOwner = element._owner;
          mode._debugStack = element._debugStack;
          mode._debugTask = element._debugTask;
          return mode;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          elements = createFiber(7, elements, key, mode);
          elements.lanes = lanes;
          return elements;
        }
        function createFiberFromText(content, mode, lanes) {
          content = createFiber(6, content, null, mode);
          content.lanes = lanes;
          return content;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          mode = createFiber(
            4,
            null !== portal.children ? portal.children : [],
            portal.key,
            mode
          );
          mode.lanes = lanes;
          mode.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return mode;
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          workInProgress2 = treeContextOverflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index += 1;
          var length = 32 - clz32(totalChildren) + baseLength;
          if (30 < length) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
            treeContextOverflow = length + workInProgress2;
          } else
            treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
        }
        function popTreeContext(workInProgress2) {
          for (; workInProgress2 === treeForkProvider; )
            treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
          for (; workInProgress2 === treeContextProvider; )
            treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
        }
        function warnIfNotHydrating() {
          isHydrating || console.error(
            "Expected to be hydrating. This is a bug in React. Please file an issue."
          );
        }
        function buildHydrationDiffNode(fiber, distanceFromLeaf) {
          if (null === fiber.return) {
            if (null === hydrationDiffRootDEV)
              hydrationDiffRootDEV = {
                fiber,
                children: [],
                serverProps: void 0,
                serverTail: [],
                distanceFromLeaf
              };
            else {
              if (hydrationDiffRootDEV.fiber !== fiber)
                throw Error(
                  "Saw multiple hydration diff roots in a pass. This is a bug in React."
                );
              hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
            }
            return hydrationDiffRootDEV;
          }
          var siblings = buildHydrationDiffNode(
            fiber.return,
            distanceFromLeaf + 1
          ).children;
          if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
            return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
          distanceFromLeaf = {
            fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf
          };
          siblings.push(distanceFromLeaf);
          return distanceFromLeaf;
        }
        function warnNonHydratedInstance(fiber, rejectedCandidate) {
          didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
        }
        function throwOnHydrationMismatch(fiber) {
          var diff = "", diffRoot = hydrationDiffRootDEV;
          null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
          queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
              ),
              fiber
            )
          );
          throw HydrationMismatchException;
        }
        function prepareToHydrateHostInstance(fiber) {
          var didHydrate = fiber.stateNode;
          var type2 = fiber.type, props = fiber.memoizedProps;
          didHydrate[internalInstanceKey] = fiber;
          didHydrate[internalPropsKey] = props;
          validatePropertiesInDevelopment(type2, props);
          switch (type2) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", didHydrate);
              listenToNonDelegatedEvent("close", didHydrate);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "video":
            case "audio":
              for (type2 = 0; type2 < mediaEventTypes.length; type2++)
                listenToNonDelegatedEvent(mediaEventTypes[type2], didHydrate);
              break;
            case "source":
              listenToNonDelegatedEvent("error", didHydrate);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", didHydrate);
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", didHydrate);
              break;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateInputProps(didHydrate, props);
              initInput(
                didHydrate,
                props.value,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name,
                true
              );
              track(didHydrate);
              break;
            case "option":
              validateOptionProps(didHydrate, props);
              break;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateSelectProps(didHydrate, props);
              break;
            case "textarea":
              checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
                didHydrate,
                props.value,
                props.defaultValue,
                props.children
              ), track(didHydrate);
          }
          type2 = props.children;
          "string" !== typeof type2 && "number" !== typeof type2 && "bigint" !== typeof type2 || didHydrate.textContent === "" + type2 || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type2) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
          didHydrate || throwOnHydrationMismatch(fiber);
        }
        function popToNextHostParent(fiber) {
          for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
            switch (hydrationParentFiber.tag) {
              case 5:
              case 13:
                rootOrSingletonContext = false;
                return;
              case 27:
              case 3:
                rootOrSingletonContext = true;
                return;
              default:
                hydrationParentFiber = hydrationParentFiber.return;
            }
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) return false;
          if (!isHydrating)
            return popToNextHostParent(fiber), isHydrating = true, false;
          var tag = fiber.tag, JSCompiler_temp;
          if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
            if (JSCompiler_temp = 5 === tag)
              JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
            JSCompiler_temp = !JSCompiler_temp;
          }
          if (JSCompiler_temp && nextHydratableInstance) {
            for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
              var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
              diffNode.serverTail.push(description);
              JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
            }
            throwOnHydrationMismatch(fiber);
          }
          popToNextHostParent(fiber);
          if (13 === tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
          } else
            27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
          return true;
        }
        function resetHydrationState() {
          nextHydratableInstance = hydrationParentFiber = null;
          didSuspendOrErrorDEV = isHydrating = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          var queuedErrors = hydrationErrors;
          null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
            workInProgressRootRecoverableErrors,
            queuedErrors
          ), hydrationErrors = null);
          return queuedErrors;
        }
        function queueHydrationError(error) {
          null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
        }
        function emitPendingHydrationWarnings() {
          var diffRoot = hydrationDiffRootDEV;
          if (null !== diffRoot) {
            hydrationDiffRootDEV = null;
            for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
              diffRoot = diffRoot.children[0];
            runWithFiberInDEV(diffRoot.fiber, function() {
              console.error(
                "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
                "https://react.dev/link/hydration-mismatch",
                diff
              );
            });
          }
        }
        function resetContextDependencies() {
          lastContextDependency = currentlyRenderingFiber$1 = null;
          isDisallowedContextReadInDEV = false;
        }
        function pushProvider(providerFiber, context, nextValue) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          push(rendererCursorDEV, context._currentRenderer, providerFiber);
          void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
            "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
          );
          context._currentRenderer = rendererSigil;
        }
        function popProvider(context, providerFiber) {
          context._currentValue = valueCursor.current;
          var currentRenderer = rendererCursorDEV.current;
          pop(rendererCursorDEV, providerFiber);
          context._currentRenderer = currentRenderer;
          pop(valueCursor, providerFiber);
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          for (; null !== parent; ) {
            var alternate = parent.alternate;
            (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
            if (parent === propagationRoot) break;
            parent = parent.return;
          }
          parent !== propagationRoot && console.error(
            "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
          var fiber = workInProgress2.child;
          null !== fiber && (fiber.return = workInProgress2);
          for (; null !== fiber; ) {
            var list = fiber.dependencies;
            if (null !== list) {
              var nextFiber = fiber.child;
              list = list.firstContext;
              a: for (; null !== list; ) {
                var dependency = list;
                list = fiber;
                for (var i = 0; i < contexts.length; i++)
                  if (dependency.context === contexts[i]) {
                    list.lanes |= renderLanes2;
                    dependency = list.alternate;
                    null !== dependency && (dependency.lanes |= renderLanes2);
                    scheduleContextWorkOnParentPath(
                      list.return,
                      renderLanes2,
                      workInProgress2
                    );
                    forcePropagateEntireTree || (nextFiber = null);
                    break a;
                  }
                list = dependency.next;
              }
            } else if (18 === fiber.tag) {
              nextFiber = fiber.return;
              if (null === nextFiber)
                throw Error(
                  "We just came from a parent so we must have had a parent. This is a bug in React."
                );
              nextFiber.lanes |= renderLanes2;
              list = nextFiber.alternate;
              null !== list && (list.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                nextFiber,
                renderLanes2,
                workInProgress2
              );
              nextFiber = null;
            } else nextFiber = fiber.child;
            if (null !== nextFiber) nextFiber.return = fiber;
            else
              for (nextFiber = fiber; null !== nextFiber; ) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                fiber = nextFiber.sibling;
                if (null !== fiber) {
                  fiber.return = nextFiber.return;
                  nextFiber = fiber;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            fiber = nextFiber;
          }
        }
        function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
          current2 = null;
          for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
            if (!isInsidePropagationBailout) {
              if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
              else if (0 !== (parent.flags & 262144)) break;
            }
            if (10 === parent.tag) {
              var currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent = currentParent.memoizedProps;
              if (null !== currentParent) {
                var context = parent.type;
                objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context) : current2 = [context]);
              }
            } else if (parent === hostTransitionProviderCursor.current) {
              currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
            }
            parent = parent.return;
          }
          null !== current2 && propagateContextChanges(
            workInProgress2,
            current2,
            renderLanes2,
            forcePropagateEntireTree
          );
          workInProgress2.flags |= 262144;
        }
        function checkIfContextChanged(currentDependencies) {
          for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
            if (!objectIs(
              currentDependencies.context._currentValue,
              currentDependencies.memoizedValue
            ))
              return true;
            currentDependencies = currentDependencies.next;
          }
          return false;
        }
        function prepareToReadContext(workInProgress2) {
          currentlyRenderingFiber$1 = workInProgress2;
          lastContextDependency = null;
          workInProgress2 = workInProgress2.dependencies;
          null !== workInProgress2 && (workInProgress2.firstContext = null);
        }
        function readContext(context) {
          isDisallowedContextReadInDEV && console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
          return readContextForConsumer(currentlyRenderingFiber$1, context);
        }
        function readContextDuringReconciliation(consumer, context) {
          null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
          return readContextForConsumer(consumer, context);
        }
        function readContextForConsumer(consumer, context) {
          var value = context._currentValue;
          context = { context, memoizedValue: value, next: null };
          if (null === lastContextDependency) {
            if (null === consumer)
              throw Error(
                "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
              );
            lastContextDependency = context;
            consumer.dependencies = {
              lanes: 0,
              firstContext: context,
              _debugThenableState: null
            };
            consumer.flags |= 524288;
          } else lastContextDependency = lastContextDependency.next = context;
          return value;
        }
        function createCache() {
          return {
            controller: new AbortControllerLocal(),
            data: /* @__PURE__ */ new Map(),
            refCount: 0
          };
        }
        function retainCache(cache) {
          cache.controller.signal.aborted && console.warn(
            "A cache instance was retained after it was already freed. This likely indicates a bug in React."
          );
          cache.refCount++;
        }
        function releaseCache(cache) {
          cache.refCount--;
          0 > cache.refCount && console.warn(
            "A cache instance was released after it was already freed. This likely indicates a bug in React."
          );
          0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
            cache.controller.abort();
          });
        }
        function pushNestedEffectDurations() {
          var prevEffectDuration = profilerEffectDuration;
          profilerEffectDuration = 0;
          return prevEffectDuration;
        }
        function popNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration = prevEffectDuration;
          return elapsedTime;
        }
        function bubbleNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration += prevEffectDuration;
          return elapsedTime;
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now();
          0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
        }
        function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
          }
        }
        function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            profilerStartTime = -1;
          }
        }
        function recordEffectDuration() {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            profilerStartTime = -1;
            profilerEffectDuration += elapsedTime;
          }
        }
        function startEffectTimer() {
          profilerStartTime = now();
        }
        function transferActualDuration(fiber) {
          for (var child = fiber.child; child; )
            fiber.actualDuration += child.actualDuration, child = child.sibling;
        }
        function entangleAsyncAction(transition, thenable) {
          if (null === currentEntangledListeners) {
            var entangledListeners = currentEntangledListeners = [];
            currentEntangledPendingCount = 0;
            currentEntangledLane = requestTransitionLane();
            currentEntangledActionThenable = {
              status: "pending",
              value: void 0,
              then: function(resolve) {
                entangledListeners.push(resolve);
              }
            };
          }
          currentEntangledPendingCount++;
          thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
          return thenable;
        }
        function pingEngtangledActionScope() {
          if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
            var listeners = currentEntangledListeners;
            currentEntangledListeners = null;
            currentEntangledLane = 0;
            currentEntangledActionThenable = null;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
          }
        }
        function chainThenableValue(thenable, result) {
          var listeners = [], thenableWithOverride = {
            status: "pending",
            value: null,
            reason: null,
            then: function(resolve) {
              listeners.push(resolve);
            }
          };
          thenable.then(
            function() {
              thenableWithOverride.status = "fulfilled";
              thenableWithOverride.value = result;
              for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
            },
            function(error) {
              thenableWithOverride.status = "rejected";
              thenableWithOverride.reason = error;
              for (error = 0; error < listeners.length; error++)
                (0, listeners[error])(void 0);
            }
          );
          return thenableWithOverride;
        }
        function peekCacheFromPool() {
          var cacheResumedFromPreviousRender = resumedCache.current;
          return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
        }
        function pushTransition(offscreenWorkInProgress, prevCachePool) {
          null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
        }
        function getSuspendedCache() {
          var cacheFromPool = peekCacheFromPool();
          return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
        }
        function createThenableState() {
          return { didWarnAboutUncachedPromise: false, thenables: [] };
        }
        function isThenableResolved(thenable) {
          thenable = thenable.status;
          return "fulfilled" === thenable || "rejected" === thenable;
        }
        function noop$3() {
        }
        function trackUsedThenable(thenableState2, thenable, index) {
          null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
          var trackedThenables = thenableState2.thenables;
          index = trackedThenables[index];
          void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
            "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
          )), thenable.then(noop$3, noop$3), thenable = index);
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            default:
              if ("string" === typeof thenable.status)
                thenable.then(noop$3, noop$3);
              else {
                thenableState2 = workInProgressRoot;
                if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                  throw Error(
                    "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                  );
                thenableState2 = thenable;
                thenableState2.status = "pending";
                thenableState2.then(
                  function(fulfilledValue) {
                    if ("pending" === thenable.status) {
                      var fulfilledThenable = thenable;
                      fulfilledThenable.status = "fulfilled";
                      fulfilledThenable.value = fulfilledValue;
                    }
                  },
                  function(error) {
                    if ("pending" === thenable.status) {
                      var rejectedThenable = thenable;
                      rejectedThenable.status = "rejected";
                      rejectedThenable.reason = error;
                    }
                  }
                );
              }
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
              }
              suspendedThenable = thenable;
              needsToResetSuspendedThenableDEV = true;
              throw SuspenseException;
          }
        }
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(
              "Expected a suspended thenable. This is a bug in React. Please file an issue."
            );
          var thenable = suspendedThenable;
          suspendedThenable = null;
          needsToResetSuspendedThenableDEV = false;
          return thenable;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
          if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
            throw Error(
              "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
            );
        }
        function initializeUpdateQueue(fiber) {
          fiber.updateQueue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, lanes: 0, hiddenCallbacks: null },
            callbacks: null
          };
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          current2 = current2.updateQueue;
          workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
            baseState: current2.baseState,
            firstBaseUpdate: current2.firstBaseUpdate,
            lastBaseUpdate: current2.lastBaseUpdate,
            shared: current2.shared,
            callbacks: null
          });
        }
        function createUpdate(lane) {
          return {
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (null === updateQueue) return null;
          updateQueue = updateQueue.shared;
          if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
            var componentName2 = getComponentNameFromFiber(fiber);
            console.error(
              "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
              componentName2
            );
            didWarnUpdateInsideUpdate = true;
          }
          if ((executionContext & RenderContext) !== NoContext)
            return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
          enqueueUpdate$1(fiber, updateQueue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function entangleTransitions(root2, fiber, lane) {
          fiber = fiber.updateQueue;
          if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
            var queueLanes = fiber.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            fiber.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
          if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
            var newFirst = null, newLast = null;
            queue = queue.firstBaseUpdate;
            if (null !== queue) {
              do {
                var clone = {
                  lane: queue.lane,
                  tag: queue.tag,
                  payload: queue.payload,
                  callback: null,
                  next: null
                };
                null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
                queue = queue.next;
              } while (null !== queue);
              null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
            } else newFirst = newLast = capturedUpdate;
            queue = {
              baseState: current2.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: current2.shared,
              callbacks: current2.callbacks
            };
            workInProgress2.updateQueue = queue;
            return;
          }
          workInProgress2 = queue.lastBaseUpdate;
          null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
          queue.lastBaseUpdate = capturedUpdate;
        }
        function suspendIfUpdateReadFromEntangledAsyncAction() {
          if (didReadFromEntangledAsyncAction) {
            var entangledActionThenable = currentEntangledActionThenable;
            if (null !== entangledActionThenable) throw entangledActionThenable;
          }
        }
        function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
          didReadFromEntangledAsyncAction = false;
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          currentlyProcessingQueue = queue.shared;
          var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
          if (null !== pendingQueue) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
          }
          if (null !== firstBaseUpdate) {
            var newState = queue.baseState;
            lastBaseUpdate = 0;
            current2 = firstPendingUpdate = lastPendingUpdate = null;
            pendingQueue = firstBaseUpdate;
            do {
              var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
              if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
                0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                null !== current2 && (current2 = current2.next = {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
                a: {
                  updateLane = workInProgress2;
                  var partialState = pendingQueue;
                  var nextProps = props, instance = instance$jscomp$0;
                  switch (partialState.tag) {
                    case ReplaceState:
                      partialState = partialState.payload;
                      if ("function" === typeof partialState) {
                        isDisallowedContextReadInDEV = true;
                        var nextState = partialState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            partialState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                        newState = nextState;
                        break a;
                      }
                      newState = partialState;
                      break a;
                    case CaptureUpdate:
                      updateLane.flags = updateLane.flags & -65537 | 128;
                    case UpdateState:
                      nextState = partialState.payload;
                      if ("function" === typeof nextState) {
                        isDisallowedContextReadInDEV = true;
                        partialState = nextState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            nextState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                      } else partialState = nextState;
                      if (null === partialState || void 0 === partialState) break a;
                      newState = assign({}, newState, partialState);
                      break a;
                    case ForceUpdate:
                      hasForceUpdate = true;
                  }
                }
                updateLane = pendingQueue.callback;
                null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
              } else
                isHiddenUpdate = {
                  lane: updateLane,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: pendingQueue.callback,
                  next: null
                }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
              pendingQueue = pendingQueue.next;
              if (null === pendingQueue)
                if (pendingQueue = queue.shared.pending, null === pendingQueue)
                  break;
                else
                  isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
            } while (1);
            null === current2 && (lastPendingUpdate = newState);
            queue.baseState = lastPendingUpdate;
            queue.firstBaseUpdate = firstPendingUpdate;
            queue.lastBaseUpdate = current2;
            null === firstBaseUpdate && (queue.shared.lanes = 0);
            workInProgressRootSkippedLanes |= lastBaseUpdate;
            workInProgress2.lanes = lastBaseUpdate;
            workInProgress2.memoizedState = newState;
          }
          currentlyProcessingQueue = null;
        }
        function callCallback(callback, context) {
          if ("function" !== typeof callback)
            throw Error(
              "Invalid argument passed as callback. Expected a function. Instead received: " + callback
            );
          callback.call(context);
        }
        function commitHiddenCallbacks(updateQueue, context) {
          var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
          if (null !== hiddenCallbacks)
            for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
              callCallback(hiddenCallbacks[updateQueue], context);
        }
        function commitCallbacks(updateQueue, context) {
          var callbacks = updateQueue.callbacks;
          if (null !== callbacks)
            for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
              callCallback(callbacks[updateQueue], context);
        }
        function pushHiddenContext(fiber, context) {
          var prevEntangledRenderLanes = entangledRenderLanes;
          push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
          push(currentTreeHiddenStackCursor, context, fiber);
          entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
        }
        function reuseHiddenContextOnStack(fiber) {
          push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
          push(
            currentTreeHiddenStackCursor,
            currentTreeHiddenStackCursor.current,
            fiber
          );
        }
        function popHiddenContext(fiber) {
          entangledRenderLanes = prevEntangledRenderLanesCursor.current;
          pop(currentTreeHiddenStackCursor, fiber);
          pop(prevEntangledRenderLanesCursor, fiber);
        }
        function mountHookTypesDev() {
          var hookName = currentHookNameInDev;
          null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
        }
        function updateHookTypesDev() {
          var hookName = currentHookNameInDev;
          if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
            var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
              for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
                var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
                for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                  oldHookName += " ";
                oldHookName += newHookName + "\n";
                table += oldHookName;
              }
              console.error(
                "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
                componentName2,
                table
              );
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
            "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
            currentHookNameInDev,
            typeof deps
          );
        }
        function warnOnUseFormStateInDev() {
          var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
          didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
            "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
            componentName2
          ));
        }
        function throwInvalidHookError() {
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (ignorePreviousDependencies) return false;
          if (null === prevDeps)
            return console.error(
              "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
              currentHookNameInDev
            ), false;
          nextDeps.length !== prevDeps.length && console.error(
            "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
            currentHookNameInDev,
            "[" + prevDeps.join(", ") + "]",
            "[" + nextDeps.join(", ") + "]"
          );
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
            if (!objectIs(nextDeps[i], prevDeps[i])) return false;
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber = workInProgress2;
          hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component))
            nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
              "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
              null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
            ));
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = 0;
          ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
          shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
          var children = callComponentInDEV(Component, props, secondArg);
          shouldDoubleInvokeUserFnsInHooksDEV = false;
          didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
            workInProgress2,
            Component,
            props,
            secondArg
          ));
          if (nextRenderLanes) {
            setIsStrictModeForDevtools(true);
            try {
              children = renderWithHooksAgain(
                workInProgress2,
                Component,
                props,
                secondArg
              );
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          finishRenderingHooks(current2, workInProgress2);
          return children;
        }
        function finishRenderingHooks(current2, workInProgress2) {
          workInProgress2._debugHookTypes = hookTypesDev;
          null === workInProgress2.dependencies ? null !== thenableState$1 && (workInProgress2.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState$1
          }) : workInProgress2.dependencies._debugThenableState = thenableState$1;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
          renderLanes = 0;
          hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
            "Internal React error: Expected static flag was missing. Please notify the React team."
          );
          didScheduleRenderPhaseUpdate = false;
          thenableIndexCounter$1 = 0;
          thenableState$1 = null;
          if (didRenderTooFewHooks)
            throw Error(
              "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
            );
          null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
          needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
          current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
        }
        function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
          currentlyRenderingFiber = workInProgress2;
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
            thenableIndexCounter$1 = 0;
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            if (numberOfReRenders >= RE_RENDER_LIMIT)
              throw Error(
                "Too many re-renders. React limits the number of renders to prevent an infinite loop."
              );
            numberOfReRenders += 1;
            ignorePreviousDependencies = false;
            workInProgressHook = currentHook = null;
            if (null != workInProgress2.updateQueue) {
              var children = workInProgress2.updateQueue;
              children.lastEffect = null;
              children.events = null;
              children.stores = null;
              null != children.memoCache && (children.memoCache.index = 0);
            }
            hookTypesUpdateIndexDev = -1;
            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
            children = callComponentInDEV(Component, props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
          return children;
        }
        function TransitionAwareHostComponent() {
          var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
          maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
          dispatcher = dispatcher.useState()[0];
          (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
          return maybeThenable;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = 0 !== localIdCounter;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
          current2.lanes &= ~lanes;
        }
        function resetHooksOnUnwind(workInProgress2) {
          if (didScheduleRenderPhaseUpdate) {
            for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
              var queue = workInProgress2.queue;
              null !== queue && (queue.pending = null);
              workInProgress2 = workInProgress2.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = 0;
          hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          thenableIndexCounter$1 = localIdCounter = 0;
          thenableState$1 = null;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          if (null === currentHook) {
            var nextCurrentHook = currentlyRenderingFiber.alternate;
            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
          } else nextCurrentHook = currentHook.next;
          var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
          if (null !== nextWorkInProgressHook)
            workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
          else {
            if (null === nextCurrentHook) {
              if (null === currentlyRenderingFiber.alternate)
                throw Error(
                  "Update hook called on initial render. This is likely a bug in React. Please file an issue."
                );
              throw Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            nextCurrentHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return { lastEffect: null, events: null, stores: null, memoCache: null };
        }
        function useThenable(thenable) {
          var index = thenableIndexCounter$1;
          thenableIndexCounter$1 += 1;
          null === thenableState$1 && (thenableState$1 = createThenableState());
          thenable = trackUsedThenable(thenableState$1, thenable, index);
          index = currentlyRenderingFiber;
          null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
          return thenable;
        }
        function use(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then) return useThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
          }
          throw Error("An unsupported type was passed to use(): " + String(usable));
        }
        function useMemoCache(size) {
          var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
          null !== updateQueue && (memoCache = updateQueue.memoCache);
          if (null == memoCache) {
            var current2 = currentlyRenderingFiber.alternate;
            null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
              data: current2.data.map(function(array) {
                return array.slice();
              }),
              index: 0
            })));
          }
          null == memoCache && (memoCache = { data: [], index: 0 });
          null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
          updateQueue.memoCache = memoCache;
          updateQueue = memoCache.data[memoCache.index];
          if (void 0 === updateQueue || ignorePreviousDependencies)
            for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
              updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
          else
            updateQueue.length !== size && console.error(
              "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
              updateQueue.length,
              size
            );
          memoCache.index++;
          return updateQueue;
        }
        function basicStateReducer(state, action) {
          return "function" === typeof action ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        }
        function updateReducer(reducer) {
          var hook = updateWorkInProgressHook();
          return updateReducerImpl(hook, currentHook, reducer);
        }
        function updateReducerImpl(hook, current2, reducer) {
          var queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next;
              baseQueue.next = pendingQueue.next;
              pendingQueue.next = baseFirst;
            }
            current2.baseQueue !== baseQueue && console.error(
              "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
            );
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          pendingQueue = hook.baseState;
          if (null === baseQueue) hook.memoizedState = pendingQueue;
          else {
            current2 = baseQueue.next;
            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
            do {
              var updateLane = update.lane & -536870913;
              if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                var revertLane = update.revertLane;
                if (0 === revertLane)
                  null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                    lane: 0,
                    revertLane: 0,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                else if ((renderLanes & revertLane) === revertLane) {
                  update = update.next;
                  revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                  continue;
                } else
                  updateLane = {
                    lane: 0,
                    revertLane: update.revertLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                updateLane = update.action;
                shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
              } else
                revertLane = {
                  lane: updateLane,
                  revertLane: update.revertLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
              update = update.next;
            } while (null !== update && update !== current2);
            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
              throw reducer;
            hook.memoizedState = pendingQueue;
            hook.baseState = baseFirst;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = pendingQueue;
          }
          null === baseQueue && (queue.lanes = 0);
          return [hook.memoizedState, queue.dispatch];
        }
        function rerenderReducer(reducer) {
          var hook = updateWorkInProgressHook(), queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
          if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            do
              newState = reducer(newState, update.action), update = update.next;
            while (update !== lastRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
            hook.memoizedState = newState;
            null === hook.baseQueue && (hook.baseState = newState);
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            var nextSnapshot = getServerSnapshot();
            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
              "The result of getServerSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          } else {
            nextSnapshot = getSnapshot();
            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true));
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
          hook.memoizedState = nextSnapshot;
          getServerSnapshot = { value: nextSnapshot, getSnapshot };
          hook.queue = getServerSnapshot;
          mountEffect(
            subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
            [subscribe]
          );
          fiber.flags |= 2048;
          pushSimpleEffect(
            HasEffect | Passive,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              getServerSnapshot,
              nextSnapshot,
              getSnapshot
            ),
            null
          );
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
          if (isHydrating$jscomp$0) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            getServerSnapshot = getServerSnapshot();
          } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          if (cachedSnapshot = !objectIs(
            (currentHook || hook).memoizedState,
            getServerSnapshot
          ))
            hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
          hook = hook.queue;
          var create = subscribeToStore.bind(null, fiber, hook, subscribe);
          updateEffectImpl(2048, Passive, create, [subscribe]);
          if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= 2048;
            pushSimpleEffect(
              HasEffect | Passive,
              createEffectInstance(),
              updateStoreInstance.bind(
                null,
                fiber,
                hook,
                getServerSnapshot,
                getSnapshot
              ),
              null
            );
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          return getServerSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= 16384;
          fiber = { getSnapshot, value: renderedSnapshot };
          getSnapshot = currentlyRenderingFiber.updateQueue;
          null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        }
        function subscribeToStore(fiber, inst, subscribe) {
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
          });
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        }
        function mountStateImpl(initialState) {
          var hook = mountWorkInProgressHook();
          if ("function" === typeof initialState) {
            var initialStateInitializer = initialState;
            initialState = initialStateInitializer();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                initialStateInitializer();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          hook.memoizedState = hook.baseState = initialState;
          hook.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          return hook;
        }
        function mountState(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        }
        function mountOptimistic(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        }
        function updateOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        }
        function updateOptimisticImpl(hook, current2, passthrough, reducer) {
          hook.baseState = passthrough;
          return updateReducerImpl(
            hook,
            currentHook,
            "function" === typeof reducer ? reducer : basicStateReducer
          );
        }
        function rerenderOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        }
        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
          if (isRenderPhaseUpdate(fiber))
            throw Error("Cannot update form state while rendering.");
          fiber = actionQueue.action;
          if (null !== fiber) {
            var actionNode = {
              payload,
              action: fiber,
              next: null,
              isTransition: true,
              status: "pending",
              value: null,
              reason: null,
              listeners: [],
              then: function(listener) {
                actionNode.listeners.push(listener);
              }
            };
            null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
            setState(actionNode);
            setPendingState = actionQueue.pending;
            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
          }
        }
        function runActionStateAction(actionQueue, node) {
          var action = node.action, payload = node.payload, prevState = actionQueue.state;
          if (node.isTransition) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            ReactSharedInternals.T = currentTransition;
            ReactSharedInternals.T._updatedFibers = /* @__PURE__ */ new Set();
            try {
              var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
              handleActionReturnValue(actionQueue, node, returnValue);
            } catch (error) {
              onActionError(actionQueue, node, error);
            } finally {
              ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
            }
          } else
            try {
              currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
            } catch (error$4) {
              onActionError(actionQueue, node, error$4);
            }
        }
        function handleActionReturnValue(actionQueue, node, returnValue) {
          null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (returnValue.then(
            function(nextState) {
              onActionSuccess(actionQueue, node, nextState);
            },
            function(error) {
              return onActionError(actionQueue, node, error);
            }
          ), node.isTransition || console.error(
            "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
          )) : onActionSuccess(actionQueue, node, returnValue);
        }
        function onActionSuccess(actionQueue, actionNode, nextState) {
          actionNode.status = "fulfilled";
          actionNode.value = nextState;
          notifyActionListeners(actionNode);
          actionQueue.state = nextState;
          actionNode = actionQueue.pending;
          null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
        }
        function onActionError(actionQueue, actionNode, error) {
          var last = actionQueue.pending;
          actionQueue.pending = null;
          if (null !== last) {
            last = last.next;
            do
              actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
            while (actionNode !== last);
          }
          actionQueue.action = null;
        }
        function notifyActionListeners(actionNode) {
          actionNode = actionNode.listeners;
          for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
        }
        function actionStateReducer(oldState, newState) {
          return newState;
        }
        function mountActionState(action, initialStateProp) {
          if (isHydrating) {
            var ssrFormState = workInProgressRoot.formState;
            if (null !== ssrFormState) {
              a: {
                var isMatching = currentlyRenderingFiber;
                if (isHydrating) {
                  if (nextHydratableInstance) {
                    b: {
                      var markerInstance = nextHydratableInstance;
                      for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
                        if (!inRootOrSingleton) {
                          markerInstance = null;
                          break b;
                        }
                        markerInstance = getNextHydratable(
                          markerInstance.nextSibling
                        );
                        if (null === markerInstance) {
                          markerInstance = null;
                          break b;
                        }
                      }
                      inRootOrSingleton = markerInstance.data;
                      markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                    }
                    if (markerInstance) {
                      nextHydratableInstance = getNextHydratable(
                        markerInstance.nextSibling
                      );
                      isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                      break a;
                    }
                  }
                  throwOnHydrationMismatch(isMatching);
                }
                isMatching = false;
              }
              isMatching && (initialStateProp = ssrFormState[0]);
            }
          }
          ssrFormState = mountWorkInProgressHook();
          ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
          isMatching = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: actionStateReducer,
            lastRenderedState: initialStateProp
          };
          ssrFormState.queue = isMatching;
          ssrFormState = dispatchSetState.bind(
            null,
            currentlyRenderingFiber,
            isMatching
          );
          isMatching.dispatch = ssrFormState;
          isMatching = mountStateImpl(false);
          inRootOrSingleton = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            false,
            isMatching.queue
          );
          isMatching = mountWorkInProgressHook();
          markerInstance = {
            state: initialStateProp,
            dispatch: null,
            action,
            pending: null
          };
          isMatching.queue = markerInstance;
          ssrFormState = dispatchActionState.bind(
            null,
            currentlyRenderingFiber,
            markerInstance,
            inRootOrSingleton,
            ssrFormState
          );
          markerInstance.dispatch = ssrFormState;
          isMatching.memoizedState = action;
          return [initialStateProp, ssrFormState, false];
        }
        function updateActionState(action) {
          var stateHook = updateWorkInProgressHook();
          return updateActionStateImpl(stateHook, currentHook, action);
        }
        function updateActionStateImpl(stateHook, currentStateHook, action) {
          currentStateHook = updateReducerImpl(
            stateHook,
            currentStateHook,
            actionStateReducer
          )[0];
          stateHook = updateReducer(basicStateReducer)[0];
          if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
            try {
              var state = useThenable(currentStateHook);
            } catch (x) {
              if (x === SuspenseException) throw SuspenseActionException;
              throw x;
            }
          else state = currentStateHook;
          currentStateHook = updateWorkInProgressHook();
          var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
          action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
            HasEffect | Passive,
            createEffectInstance(),
            actionStateActionEffect.bind(null, actionQueue, action),
            null
          ));
          return [state, dispatch, stateHook];
        }
        function actionStateActionEffect(actionQueue, action) {
          actionQueue.action = action;
        }
        function rerenderActionState(action) {
          var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
          if (null !== currentStateHook)
            return updateActionStateImpl(stateHook, currentStateHook, action);
          updateWorkInProgressHook();
          stateHook = stateHook.memoizedState;
          currentStateHook = updateWorkInProgressHook();
          var dispatch = currentStateHook.queue.dispatch;
          currentStateHook.memoizedState = action;
          return [stateHook, dispatch, false];
        }
        function pushSimpleEffect(tag, inst, create, createDeps) {
          tag = {
            tag,
            create,
            deps: createDeps,
            inst,
            next: null
          };
          inst = currentlyRenderingFiber.updateQueue;
          null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
          create = inst.lastEffect;
          null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
          return tag;
        }
        function createEffectInstance() {
          return { destroy: void 0, resource: void 0 };
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
          var hook = mountWorkInProgressHook();
          createDeps = void 0 === createDeps ? null : createDeps;
          currentlyRenderingFiber.flags |= fiberFlags;
          hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            createEffectInstance(),
            create,
            createDeps
          );
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var inst = hook.memoizedState.inst;
          null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
            HasEffect | hookFlags,
            inst,
            create,
            deps
          ));
        }
        function mountEffect(create, createDeps) {
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(276826112, Passive, create, createDeps) : mountEffectImpl(8390656, Passive, create, createDeps);
        }
        function mountLayoutEffect(create, deps) {
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          return mountEffectImpl(fiberFlags, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if ("function" === typeof ref) {
            create = create();
            var refCleanup = ref(create);
            return function() {
              "function" === typeof refCleanup ? refCleanup() : ref(null);
            };
          }
          if (null !== ref && void 0 !== ref)
            return ref.hasOwnProperty("current") || console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ), create = create(), ref.current = create, function() {
              ref.current = null;
            };
        }
        function mountImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          var fiberFlags = 4194308;
          (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
          mountEffectImpl(
            fiberFlags,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function updateImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          updateEffectImpl(
            4,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function mountCallback(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          hook.memoizedState = [callback, deps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          prevState = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [prevState, deps];
          return prevState;
        }
        function mountDeferredValue(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        }
        function updateDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function rerenderDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
          if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
            return hook.memoizedState = value;
          hook.memoizedState = initialValue;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return initialValue;
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
          if (objectIs(value, prevValue)) return value;
          if (null !== currentTreeHiddenStackCursor.current)
            return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
          if (0 === (renderLanes & 42))
            return didReceiveUpdate = true, hook.memoizedState = value;
          hook = requestDeferredLane();
          currentlyRenderingFiber.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return prevValue;
        }
        function startTransition(fiber, queue, pendingState, finishedState, callback) {
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          dispatchOptimisticSetState(fiber, false, queue, pendingState);
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          try {
            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
              var thenableForFinishedState = chainThenableValue(
                returnValue,
                finishedState
              );
              dispatchSetStateInternal(
                fiber,
                queue,
                thenableForFinishedState,
                requestUpdateLane(fiber)
              );
            } else
              dispatchSetStateInternal(
                fiber,
                queue,
                finishedState,
                requestUpdateLane(fiber)
              );
          } catch (error) {
            dispatchSetStateInternal(
              fiber,
              queue,
              { then: function() {
              }, status: "rejected", reason: error },
              requestUpdateLane(fiber)
            );
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        }
        function startHostTransition(formFiber, pendingState, action, formData) {
          if (5 !== formFiber.tag)
            throw Error(
              "Expected the form instance to be a HostComponent. This is a bug in React."
            );
          var queue = ensureFormComponentIsStateful(formFiber).queue;
          startTransition(
            formFiber,
            queue,
            pendingState,
            NotPendingTransition,
            null === action ? noop$2 : function() {
              requestFormReset$1(formFiber);
              return action(formData);
            }
          );
        }
        function ensureFormComponentIsStateful(formFiber) {
          var existingStateHook = formFiber.memoizedState;
          if (null !== existingStateHook) return existingStateHook;
          existingStateHook = {
            memoizedState: NotPendingTransition,
            baseState: NotPendingTransition,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: NotPendingTransition
            },
            next: null
          };
          var initialResetState = {};
          existingStateHook.next = {
            memoizedState: initialResetState,
            baseState: initialResetState,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialResetState
            },
            next: null
          };
          formFiber.memoizedState = existingStateHook;
          formFiber = formFiber.alternate;
          null !== formFiber && (formFiber.memoizedState = existingStateHook);
          return existingStateHook;
        }
        function requestFormReset$1(formFiber) {
          null === ReactSharedInternals.T && console.error(
            "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
          );
          var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
          dispatchSetStateInternal(
            formFiber,
            resetStateQueue,
            {},
            requestUpdateLane(formFiber)
          );
        }
        function mountTransition() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        }
        function updateTransition() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function rerenderTransition() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function useHostTransitionStatus() {
          return readContext(HostTransitionContext);
        }
        function mountId() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var treeId = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
            identifierPrefix = "\xAB" + identifierPrefix + "R" + treeId;
            treeId = localIdCounter++;
            0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
            identifierPrefix += "\xBB";
          } else
            treeId = globalClientIdCounter++, identifierPrefix = "\xAB" + identifierPrefix + "r" + treeId.toString(32) + "\xBB";
          return hook.memoizedState = identifierPrefix;
        }
        function mountRefresh() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
        function refreshCache(fiber, seedKey) {
          for (var provider = fiber.return; null !== provider; ) {
            switch (provider.tag) {
              case 24:
              case 3:
                var lane = requestUpdateLane(provider);
                fiber = createUpdate(lane);
                var root2 = enqueueUpdate(provider, fiber, lane);
                null !== root2 && (scheduleUpdateOnFiber(root2, provider, lane), entangleTransitions(root2, provider, lane));
                provider = createCache();
                null !== seedKey && void 0 !== seedKey && null !== root2 && console.error(
                  "The seed argument is not enabled outside experimental channels."
                );
                fiber.payload = { cache: provider };
                return;
            }
            provider = provider.return;
          }
        }
        function dispatchReducerAction(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          var update = {
            lane: args,
            revertLane: 0,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
          markStateUpdateScheduled(fiber, args);
        }
        function dispatchSetState(fiber, queue, action) {
          var args = arguments;
          "function" === typeof args[3] && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          args = requestUpdateLane(fiber);
          dispatchSetStateInternal(fiber, queue, action, args);
          markStateUpdateScheduled(fiber, args);
        }
        function dispatchSetStateInternal(fiber, queue, action, lane) {
          var update = {
            lane,
            revertLane: 0,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
          else {
            var alternate = fiber.alternate;
            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState))
                  return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
              } catch (error) {
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            }
            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (null !== action)
              return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
          }
          return false;
        }
        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
          null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
            "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
          );
          action = {
            lane: 2,
            revertLane: requestTransitionLane(),
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            if (throwIfDuringRender)
              throw Error("Cannot update optimistic state while rendering.");
            console.error("Cannot call startTransition while rendering.");
          } else
            throwIfDuringRender = enqueueConcurrentHookUpdate(
              fiber,
              queue,
              action,
              2
            ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
          markStateUpdateScheduled(fiber, 2);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        function entangleTransitionUpdate(root2, queue, lane) {
          if (0 !== (lane & 4194048)) {
            var queueLanes = queue.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            queue.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function pushDebugInfo(debugInfo) {
          var previousDebugInfo = currentDebugInfo;
          null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
          return previousDebugInfo;
        }
        function validateFragmentProps(element, fiber, returnFiber) {
          for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
            var key = keys[i];
            if ("children" !== key && "key" !== key) {
              null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
              runWithFiberInDEV(
                fiber,
                function(erroredKey) {
                  console.error(
                    "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                    erroredKey
                  );
                },
                key
              );
              break;
            }
          }
        }
        function unwrapThenable(thenable) {
          var index = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = createThenableState());
          return trackUsedThenable(thenableState, thenable, index);
        }
        function coerceRef(workInProgress2, element) {
          element = element.props.ref;
          workInProgress2.ref = void 0 !== element ? element : null;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
            throw Error(
              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
            );
          returnFiber = Object.prototype.toString.call(newChild);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        function warnOnFunctionType(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
            invalidChild,
            invalidChild,
            invalidChild
          ) : console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
            invalidChild,
            invalidChild,
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnSymbolType(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
            "Symbols are not valid as a React child.\n  root.render(%s)",
            invalidChild
          ) : console.error(
            "Symbols are not valid as a React child.\n  <%s>%s</%s>",
            parentName,
            invalidChild,
            parentName
          ));
        }
        function createChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
              var deletions = returnFiber.deletions;
              null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for (; null !== currentFirstChild; )
              deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return null;
          }
          function mapRemainingChildren(currentFirstChild) {
            for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
              null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            fiber = createWorkInProgress(fiber, pendingProps);
            fiber.index = 0;
            fiber.sibling = null;
            return fiber;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects)
              return newFiber.flags |= 1048576, lastPlacedIndex;
            newIndex = newFiber.alternate;
            if (null !== newIndex)
              return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
            newFiber.flags |= 67108866;
            return lastPlacedIndex;
          }
          function placeSingleChild(newFiber) {
            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (null === current2 || 6 !== current2.tag)
              return current2 = createFiberFromText(
                textContent,
                returnFiber.mode,
                lanes
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, textContent);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateElement(returnFiber, current2, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE)
              return current2 = updateFragment(
                returnFiber,
                current2,
                element.props.children,
                lanes,
                element.key
              ), validateFragmentProps(element, current2, returnFiber), current2;
            if (null !== current2 && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current2.type))
              return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
            current2 = createFiberFromElement(element, returnFiber.mode, lanes);
            coerceRef(current2, element);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
              return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, portal.children || []);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function updateFragment(returnFiber, current2, fragment, lanes, key) {
            if (null === current2 || 7 !== current2.tag)
              return current2 = createFiberFromFragment(
                fragment,
                returnFiber.mode,
                lanes,
                key
              ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
            current2 = useFiber(current2, fragment);
            current2.return = returnFiber;
            current2._debugInfo = currentDebugInfo;
            return current2;
          }
          function createChild(returnFiber, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return newChild = createFiberFromText(
                "" + newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return lanes = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                case REACT_PORTAL_TYPE:
                  return newChild = createFiberFromPortal(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  newChild = callLazyInitInDEV(newChild);
                  returnFiber = createChild(returnFiber, newChild, lanes);
                  currentDebugInfo = _prevDebugInfo;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return lanes = createFiberFromFragment(
                  newChild,
                  returnFiber.mode,
                  lanes,
                  null
                ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                  returnFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return createChild(
                  returnFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber) : null;
                case REACT_PORTAL_TYPE:
                  return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                case REACT_LAZY_TYPE:
                  return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
                if (null !== key) return null;
                key = pushDebugInfo(newChild._debugInfo);
                returnFiber = updateFragment(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes,
                  null
                );
                currentDebugInfo = key;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = key, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateSlot(
                  returnFiber,
                  oldFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newIdx = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  ), currentDebugInfo = existingChildren, returnFiber;
                case REACT_PORTAL_TYPE:
                  return existingChildren = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                  newChild = callLazyInitInDEV(newChild);
                  returnFiber = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  );
                  currentDebugInfo = _prevDebugInfo7;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes,
                  null
                ), currentDebugInfo = existingChildren, returnFiber;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo7, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
            if ("object" !== typeof child || null === child) return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(returnFiber, workInProgress2, child);
                var key = child.key;
                if ("string" !== typeof key) break;
                if (null === knownKeys) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                runWithFiberInDEV(workInProgress2, function() {
                  console.error(
                    "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                    key
                  );
                });
                break;
              case REACT_LAZY_TYPE:
                child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                lanes
              );
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                newChildren[newIdx],
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; newIdx < newChildren.length; newIdx++)
                oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                newChildren[newIdx],
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
            if (null == newChildren)
              throw Error("An iterable object provided no iterator.");
            for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                step.value,
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; !step.done; newIdx++, step = newChildren.next())
                oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                step.value,
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
            "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  a: {
                    for (var key = newChild.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === key) {
                        key = newChild.type;
                        if (key === REACT_FRAGMENT_TYPE) {
                          if (7 === currentFirstChild.tag) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling
                            );
                            lanes = useFiber(
                              currentFirstChild,
                              newChild.props.children
                            );
                            lanes.return = returnFiber;
                            lanes._debugOwner = newChild._owner;
                            lanes._debugInfo = currentDebugInfo;
                            validateFragmentProps(newChild, lanes, returnFiber);
                            returnFiber = lanes;
                            break a;
                          }
                        } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                          currentFirstChild,
                          newChild
                        ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(currentFirstChild, newChild.props);
                          coerceRef(lanes, newChild);
                          lanes.return = returnFiber;
                          lanes._debugOwner = newChild._owner;
                          lanes._debugInfo = currentDebugInfo;
                          returnFiber = lanes;
                          break a;
                        }
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      } else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                  }
                  returnFiber = placeSingleChild(returnFiber);
                  currentDebugInfo = prevDebugInfo;
                  return returnFiber;
                case REACT_PORTAL_TYPE:
                  a: {
                    prevDebugInfo = newChild;
                    for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === newChild)
                        if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            prevDebugInfo.children || []
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        } else {
                          deleteRemainingChildren(returnFiber, currentFirstChild);
                          break;
                        }
                      else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    lanes = createFiberFromPortal(
                      prevDebugInfo,
                      returnFiber.mode,
                      lanes
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                  }
                  return placeSingleChild(returnFiber);
                case REACT_LAZY_TYPE:
                  return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    lanes
                  ), currentDebugInfo = prevDebugInfo, returnFiber;
              }
              if (isArrayImpl(newChild))
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (getIteratorFn(newChild)) {
                prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                key = getIteratorFn(newChild);
                if ("function" !== typeof key)
                  throw Error(
                    "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                  );
                var newChildren = key.call(newChild);
                if (newChildren === newChild) {
                  if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                    didWarnAboutGenerators || console.error(
                      "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                    ), didWarnAboutGenerators = true;
                } else
                  newChild.entries !== key || didWarnAboutMaps || (console.error(
                    "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                  ), didWarnAboutMaps = true);
                returnFiber = reconcileChildrenIterator(
                  returnFiber,
                  currentFirstChild,
                  newChildren,
                  lanes
                );
                currentDebugInfo = prevDebugInfo;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
                returnFiber,
                currentFirstChild.sibling
              ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
                prevDebugInfo,
                returnFiber.mode,
                lanes
              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return function(returnFiber, currentFirstChild, newChild, lanes) {
            var prevDebugInfo = currentDebugInfo;
            currentDebugInfo = null;
            try {
              thenableIndexCounter = 0;
              var firstChildFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
              thenableState = null;
              return firstChildFiber;
            } catch (x) {
              if (x === SuspenseException || x === SuspenseActionException) throw x;
              var fiber = createFiber(29, x, null, returnFiber.mode);
              fiber.lanes = lanes;
              fiber.return = returnFiber;
              var debugInfo = fiber._debugInfo = currentDebugInfo;
              fiber._debugOwner = returnFiber._debugOwner;
              fiber._debugTask = returnFiber._debugTask;
              if (null != debugInfo) {
                for (var i = debugInfo.length - 1; 0 <= i; i--)
                  if ("string" === typeof debugInfo[i].stack) {
                    fiber._debugOwner = debugInfo[i];
                    fiber._debugTask = debugInfo[i].debugTask;
                    break;
                  }
              }
              return fiber;
            } finally {
              currentDebugInfo = prevDebugInfo;
            }
          };
        }
        function pushPrimaryTreeSuspenseHandler(handler) {
          var current2 = handler.alternate;
          push(
            suspenseStackCursor,
            suspenseStackCursor.current & SubtreeSuspenseContextMask,
            handler
          );
          push(suspenseHandlerStackCursor, handler, handler);
          null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
        }
        function pushOffscreenSuspenseHandler(fiber) {
          if (22 === fiber.tag) {
            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {
              var current2 = fiber.alternate;
              null !== current2 && null !== current2.memoizedState && (shellBoundary = fiber);
            }
          } else reuseSuspenseHandlerOnStack(fiber);
        }
        function reuseSuspenseHandlerOnStack(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(
            suspenseHandlerStackCursor,
            suspenseHandlerStackCursor.current,
            fiber
          );
        }
        function popSuspenseHandler(fiber) {
          pop(suspenseHandlerStackCursor, fiber);
          shellBoundary === fiber && (shellBoundary = null);
          pop(suspenseStackCursor, fiber);
        }
        function findFirstSuspended(row) {
          for (var node = row; null !== node; ) {
            if (13 === node.tag) {
              var state = node.memoizedState;
              if (null !== state && (state = state.dehydrated, null === state || state.data === SUSPENSE_PENDING_START_DATA || isSuspenseInstanceFallback(state)))
                return node;
            } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
              if (0 !== (node.flags & 128)) return node;
            } else if (null !== node.child) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === row) return null;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        function warnOnInvalidCallback(callback) {
          if (null !== callback && "function" !== typeof callback) {
            var key = String(callback);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback
            ));
          }
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
          prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
          workInProgress2.memoizedState = prevState;
          0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
        }
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if ("function" === typeof instance.shouldComponentUpdate) {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                oldProps = instance.shouldComponentUpdate(
                  newProps,
                  newState,
                  nextContext
                );
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            void 0 === oldProps && console.error(
              "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
              getComponentNameFromType(ctor) || "Component"
            );
            return oldProps;
          }
          return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
          "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress2
          )), classComponentUpdater.enqueueReplaceState(
            instance,
            instance.state,
            null
          ));
        }
        function resolveClassComponentProps(Component, baseProps) {
          var newProps = baseProps;
          if ("ref" in baseProps) {
            newProps = {};
            for (var propName in baseProps)
              "ref" !== propName && (newProps[propName] = baseProps[propName]);
          }
          if (Component = Component.defaultProps) {
            newProps === baseProps && (newProps = assign({}, newProps));
            for (var _propName in Component)
              void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
          }
          return newProps;
        }
        function defaultOnUncaughtError(error) {
          reportGlobalError(error);
          console.warn(
            "%s\n\n%s\n",
            componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
            "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
          );
        }
        function defaultOnCaughtError(error) {
          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
          if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
            var JSCompiler_inline_result = error.environmentName;
            error = [
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            ].slice(0);
            "string" === typeof error[0] ? error.splice(
              0,
              1,
              badgeFormat + error[0],
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            ) : error.splice(
              0,
              0,
              badgeFormat,
              badgeStyle,
              pad + JSCompiler_inline_result + pad,
              resetStyle
            );
            error.unshift(console);
            JSCompiler_inline_result = bind.apply(console.error, error);
            JSCompiler_inline_result();
          } else
            console.error(
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            );
        }
        function defaultOnRecoverableError(error) {
          reportGlobalError(error);
        }
        function logUncaughtError(root2, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = null;
            var error = errorInfo.value;
            if (null !== ReactSharedInternals.actQueue)
              ReactSharedInternals.thrownErrors.push(error);
            else {
              var onUncaughtError = root2.onUncaughtError;
              onUncaughtError(error, { componentStack: errorInfo.stack });
            }
          } catch (e$5) {
            setTimeout(function() {
              throw e$5;
            });
          }
        }
        function logCaughtError(root2, boundary, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = getComponentNameFromFiber(boundary);
            var onCaughtError = root2.onCaughtError;
            onCaughtError(errorInfo.value, {
              componentStack: errorInfo.stack,
              errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
            });
          } catch (e$6) {
            setTimeout(function() {
              throw e$6;
            });
          }
        }
        function createRootErrorUpdate(root2, errorInfo, lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          lane.payload = { element: null };
          lane.callback = function() {
            runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
          };
          return lane;
        }
        function createClassErrorUpdate(lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          return lane;
        }
        function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if ("function" === typeof getDerivedStateFromError) {
            var error = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error);
            };
            update.callback = function() {
              markFailedErrorBoundaryForHotReloading(fiber);
              runWithFiberInDEV(
                errorInfo.source,
                logCaughtError,
                root2,
                fiber,
                errorInfo
              );
            };
          }
          var inst = fiber.stateNode;
          null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(
              errorInfo.source,
              logCaughtError,
              root2,
              fiber,
              errorInfo
            );
            "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
            callComponentDidCatchInDEV(this, errorInfo);
            "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
              "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
              getComponentNameFromFiber(fiber) || "Unknown"
            );
          });
        }
        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= 32768;
          isDevToolsPresent && restorePendingUpdaters(root2, rootRenderLanes);
          if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            returnFiber = sourceFiber.alternate;
            null !== returnFiber && propagateParentContextChanges(
              returnFiber,
              sourceFiber,
              rootRenderLanes,
              true
            );
            isHydrating && (didSuspendOrErrorDEV = true);
            sourceFiber = suspenseHandlerStackCursor.current;
            if (null !== sourceFiber) {
              switch (sourceFiber.tag) {
                case 13:
                  return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
                case 22:
                  return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: /* @__PURE__ */ new Set([value])
                  }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
              }
              throw Error(
                "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
              );
            }
            attachPingListener(root2, value, rootRenderLanes);
            renderDidSuspendDelayIfPossible();
            return false;
          }
          if (isHydrating)
            return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                  { cause: value }
                ),
                sourceFiber
              )
            )) : (value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                  { cause: value }
                ),
                sourceFiber
              )
            ), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
              root2.stateNode,
              value,
              rootRenderLanes
            ), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
          var error = createCapturedValueAtFiber(
            Error(
              "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
              { cause: value }
            ),
            sourceFiber
          );
          null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
          workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
          if (null === returnFiber) return true;
          value = createCapturedValueAtFiber(value, sourceFiber);
          sourceFiber = returnFiber;
          do {
            switch (sourceFiber.tag) {
              case 3:
                return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(
                  sourceFiber.stateNode,
                  value,
                  root2
                ), enqueueCapturedUpdate(sourceFiber, root2), false;
              case 1:
                if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
                  return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                    rootRenderLanes,
                    root2,
                    sourceFiber,
                    value
                  ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
            }
            sourceFiber = sourceFiber.return;
          } while (null !== sourceFiber);
          return false;
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
            workInProgress2,
            current2.child,
            nextChildren,
            renderLanes2
          );
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          Component = Component.render;
          var ref = workInProgress2.ref;
          if ("ref" in nextProps) {
            var propsWithoutRef = {};
            for (var key in nextProps)
              "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
          } else propsWithoutRef = nextProps;
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          nextProps = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            propsWithoutRef,
            ref,
            renderLanes2
          );
          key = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && key && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null === current2) {
            var type2 = Component.type;
            if ("function" === typeof type2 && !shouldConstruct(type2) && void 0 === type2.defaultProps && null === Component.compare)
              return Component = resolveFunctionForHotReloading(type2), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type2), updateSimpleMemoComponent(
                current2,
                workInProgress2,
                Component,
                nextProps,
                renderLanes2
              );
            current2 = createFiberFromTypeAndProps(
              Component.type,
              null,
              nextProps,
              workInProgress2,
              workInProgress2.mode,
              renderLanes2
            );
            current2.ref = workInProgress2.ref;
            current2.return = workInProgress2;
            return workInProgress2.child = current2;
          }
          type2 = current2.child;
          if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
            var prevProps = type2.memoizedProps;
            Component = Component.compare;
            Component = null !== Component ? Component : shallowEqual;
            if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
              return bailoutOnAlreadyFinishedWork(
                current2,
                workInProgress2,
                renderLanes2
              );
          }
          workInProgress2.flags |= 1;
          current2 = createWorkInProgress(type2, nextProps);
          current2.ref = workInProgress2.ref;
          current2.return = workInProgress2;
          return workInProgress2.child = current2;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (null !== current2) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
              if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
                0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
              else
                return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          return updateFunctionComponent(
            current2,
            workInProgress2,
            Component,
            nextProps,
            renderLanes2
          );
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
          if ("hidden" === nextProps.mode) {
            if (0 !== (workInProgress2.flags & 128)) {
              nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
              if (null !== current2) {
                nextChildren = workInProgress2.child = current2.child;
                for (prevState = 0; null !== nextChildren; )
                  prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
                workInProgress2.childLanes = prevState & ~nextProps;
              } else workInProgress2.childLanes = 0, workInProgress2.child = null;
              return deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                nextProps,
                renderLanes2
              );
            }
            if (0 !== (renderLanes2 & 536870912))
              workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
                workInProgress2,
                null !== prevState ? prevState.cachePool : null
              ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
            else
              return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
                current2,
                workInProgress2,
                null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
                renderLanes2
              );
          } else
            null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2) {
          var JSCompiler_inline_result = peekCacheFromPool();
          JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
            parent: CacheContext._currentValue,
            pool: JSCompiler_inline_result
          };
          workInProgress2.memoizedState = {
            baseLanes: nextBaseLanes,
            cachePool: JSCompiler_inline_result
          };
          null !== current2 && pushTransition(workInProgress2, null);
          reuseHiddenContextOnStack(workInProgress2);
          pushOffscreenSuspenseHandler(workInProgress2);
          null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
          return null;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (null === ref)
            null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
          else {
            if ("function" !== typeof ref && "object" !== typeof ref)
              throw Error(
                "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
              );
            if (null === current2 || current2.ref !== ref)
              workInProgress2.flags |= 4194816;
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (Component.prototype && "function" === typeof Component.prototype.render) {
            var componentName2 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutBadClass[componentName2] || (console.error(
              "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
              componentName2,
              componentName2
            ), didWarnAboutBadClass[componentName2] = true);
          }
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress2,
            null
          );
          null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
            componentName2
          ))));
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          Component = renderWithHooks(
            current2,
            workInProgress2,
            Component,
            nextProps,
            void 0,
            renderLanes2
          );
          nextProps = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, Component, renderLanes2);
          return workInProgress2.child;
        }
        function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
          workInProgress2.updateQueue = null;
          nextProps = renderWithHooksAgain(
            workInProgress2,
            Component,
            nextProps,
            secondArg
          );
          finishRenderingHooks(current2, workInProgress2);
          Component = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current2 && !didReceiveUpdate)
            return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          isHydrating && Component && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          switch (shouldErrorImpl(workInProgress2)) {
            case false:
              var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
                workInProgress2.memoizedProps,
                _instance.context
              ).state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            case true:
              workInProgress2.flags |= 128;
              workInProgress2.flags |= 65536;
              _instance = Error("Simulated error coming from DevTools");
              var lane = renderLanes2 & -renderLanes2;
              workInProgress2.lanes |= lane;
              state = workInProgressRoot;
              if (null === state)
                throw Error(
                  "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                );
              lane = createClassErrorUpdate(lane);
              initializeClassErrorUpdate(
                lane,
                state,
                workInProgress2,
                createCapturedValueAtFiber(_instance, workInProgress2)
              );
              enqueueCapturedUpdate(workInProgress2, lane);
          }
          prepareToReadContext(workInProgress2);
          if (null === workInProgress2.stateNode) {
            state = emptyContextObject;
            _instance = Component.contextType;
            "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
              "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
              getComponentNameFromType(Component) || "Component",
              lane
            ));
            "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
            _instance = new Component(nextProps, state);
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                _instance = new Component(nextProps, state);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
            _instance.updater = classComponentUpdater;
            workInProgress2.stateNode = _instance;
            _instance._reactInternals = workInProgress2;
            _instance._reactInternalInstance = fakeInternalInstance;
            "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
            if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
              var foundWillUpdateName = lane = state = null;
              "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
              "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
              "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== state || null !== lane || null !== foundWillUpdateName) {
                _instance = getComponentNameFromType(Component) || "Component";
                var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _instance,
                  newApiName,
                  null !== state ? "\n  " + state : "",
                  null !== lane ? "\n  " + lane : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            _instance = workInProgress2.stateNode;
            state = getComponentNameFromType(Component) || "Component";
            _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              state
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              state
            ));
            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              state
            );
            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              state
            );
            _instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              state
            );
            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              state
            ));
            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              state
            ));
            "function" === typeof _instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              state
            );
            Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(Component) || "A pure component"
            );
            "function" === typeof _instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              state
            );
            "function" === typeof _instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              state
            );
            "function" === typeof _instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              state
            );
            "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              state
            );
            lane = _instance.props !== nextProps;
            void 0 !== _instance.props && lane && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              state
            );
            _instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              state,
              state
            );
            "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(Component)
            ));
            "function" === typeof _instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof _instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof Component.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              state
            );
            (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
            "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              state
            );
            _instance = workInProgress2.stateNode;
            _instance.props = nextProps;
            _instance.state = workInProgress2.memoizedState;
            _instance.refs = {};
            initializeUpdateQueue(workInProgress2);
            state = Component.contextType;
            _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
            _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
            workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
              workInProgress2,
              _instance
            );
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
              workInProgress2,
              _instance
            );
            _instance.state = workInProgress2.memoizedState;
            state = Component.getDerivedStateFromProps;
            "function" === typeof state && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              state,
              nextProps
            ), _instance.state = workInProgress2.memoizedState);
            "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress2) || "Component"
            ), classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
            "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
            (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
            _instance = true;
          } else if (null === current2) {
            _instance = workInProgress2.stateNode;
            var unresolvedOldProps = workInProgress2.memoizedProps;
            lane = resolveClassComponentProps(Component, unresolvedOldProps);
            _instance.props = lane;
            var oldContext = _instance.context;
            foundWillUpdateName = Component.contextType;
            state = emptyContextObject;
            "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
            newApiName = Component.getDerivedStateFromProps;
            foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
            unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
            foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              state
            );
            hasForceUpdate = false;
            var oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            oldContext = workInProgress2.memoizedState;
            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              newApiName,
              nextProps
            ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              lane,
              nextProps,
              oldState,
              oldContext,
              state
            )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
          } else {
            _instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            state = workInProgress2.memoizedProps;
            foundWillUpdateName = resolveClassComponentProps(Component, state);
            _instance.props = foundWillUpdateName;
            newApiName = workInProgress2.pendingProps;
            oldState = _instance.context;
            oldContext = Component.contextType;
            lane = emptyContextObject;
            "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
            unresolvedOldProps = Component.getDerivedStateFromProps;
            (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              lane
            );
            hasForceUpdate = false;
            oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            var newState = workInProgress2.memoizedState;
            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
              workInProgress2,
              Component,
              unresolvedOldProps,
              nextProps
            ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component,
              foundWillUpdateName,
              nextProps,
              oldState,
              newState,
              lane
            ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
              nextProps,
              newState,
              lane
            )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
          }
          lane = _instance;
          markRef(current2, workInProgress2);
          state = 0 !== (workInProgress2.flags & 128);
          if (lane || state) {
            lane = workInProgress2.stateNode;
            setCurrentFiber(workInProgress2);
            if (state && "function" !== typeof Component.getDerivedStateFromError)
              Component = null, profilerStartTime = -1;
            else {
              markComponentRenderStarted(workInProgress2);
              Component = callRenderInDEV(lane);
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  callRenderInDEV(lane);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              markComponentRenderStopped();
            }
            workInProgress2.flags |= 1;
            null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              current2.child,
              null,
              renderLanes2
            ), workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              Component,
              renderLanes2
            )) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
            workInProgress2.memoizedState = lane.state;
            current2 = workInProgress2.child;
          } else
            current2 = bailoutOnAlreadyFinishedWork(
              current2,
              workInProgress2,
              renderLanes2
            );
          renderLanes2 = workInProgress2.stateNode;
          _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress2) || "a component"
          ), didWarnAboutReassigningProps = true);
          return current2;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
          resetHydrationState();
          workInProgress2.flags |= 256;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          Component && Component.childContextTypes && console.error(
            "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
            Component.displayName || Component.name || "Component"
          );
          "function" === typeof Component.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress2
          ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
          "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(
            "%s: Function components do not support contextType.",
            Component
          ), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
        }
        function mountSuspenseOffscreenState(renderLanes2) {
          return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
        }
        function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
          current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
          primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
          return current2;
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var JSCompiler_object_inline_digest_2451;
          var JSCompiler_object_inline_stack_2452 = workInProgress2.pendingProps;
          shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
          var JSCompiler_object_inline_componentStack_2453 = false;
          var didSuspend = 0 !== (workInProgress2.flags & 128);
          (JSCompiler_object_inline_digest_2451 = didSuspend) || (JSCompiler_object_inline_digest_2451 = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
          JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_componentStack_2453 = true, workInProgress2.flags &= -129);
          JSCompiler_object_inline_digest_2451 = 0 !== (workInProgress2.flags & 32);
          workInProgress2.flags &= -33;
          if (null === current2) {
            if (isHydrating) {
              JSCompiler_object_inline_componentStack_2453 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
              if (isHydrating) {
                var JSCompiler_object_inline_message_2450 = nextHydratableInstance;
                var JSCompiler_temp;
                if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2450)) {
                  c: {
                    var instance = JSCompiler_object_inline_message_2450;
                    for (JSCompiler_temp = rootOrSingletonContext; 8 !== instance.nodeType; ) {
                      if (!JSCompiler_temp) {
                        JSCompiler_temp = null;
                        break c;
                      }
                      instance = getNextHydratable(instance.nextSibling);
                      if (null === instance) {
                        JSCompiler_temp = null;
                        break c;
                      }
                    }
                    JSCompiler_temp = instance;
                  }
                  null !== JSCompiler_temp ? (warnIfNotHydrating(), workInProgress2.memoizedState = {
                    dehydrated: JSCompiler_temp,
                    treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                    retryLane: 536870912,
                    hydrationErrors: null
                  }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress2, workInProgress2.child = instance, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp = true) : JSCompiler_temp = false;
                  JSCompiler_temp = !JSCompiler_temp;
                }
                JSCompiler_temp && (warnNonHydratedInstance(
                  workInProgress2,
                  JSCompiler_object_inline_message_2450
                ), throwOnHydrationMismatch(workInProgress2));
              }
              JSCompiler_object_inline_message_2450 = workInProgress2.memoizedState;
              if (null !== JSCompiler_object_inline_message_2450 && (JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_message_2450.dehydrated, null !== JSCompiler_object_inline_message_2450))
                return isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
              popSuspenseHandler(workInProgress2);
            }
            JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_stack_2452.children;
            JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_stack_2452.fallback;
            if (JSCompiler_object_inline_componentStack_2453)
              return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = workInProgress2.mode, JSCompiler_object_inline_message_2450 = mountWorkInProgressOffscreenFiber(
                {
                  mode: "hidden",
                  children: JSCompiler_object_inline_message_2450
                },
                JSCompiler_object_inline_componentStack_2453
              ), JSCompiler_object_inline_stack_2452 = createFiberFromFragment(
                JSCompiler_object_inline_stack_2452,
                JSCompiler_object_inline_componentStack_2453,
                renderLanes2,
                null
              ), JSCompiler_object_inline_message_2450.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_message_2450.sibling = JSCompiler_object_inline_stack_2452, workInProgress2.child = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_componentStack_2453.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2451,
                renderLanes2
              ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            return mountSuspensePrimaryChildren(
              workInProgress2,
              JSCompiler_object_inline_message_2450
            );
          }
          var prevState = current2.memoizedState;
          if (null !== prevState && (JSCompiler_object_inline_message_2450 = prevState.dehydrated, null !== JSCompiler_object_inline_message_2450)) {
            if (didSuspend)
              workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_object_inline_stack_2452 = mountWorkInProgressOffscreenFiber(
                {
                  mode: "visible",
                  children: JSCompiler_object_inline_stack_2452.children
                },
                JSCompiler_object_inline_message_2450
              ), JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(
                JSCompiler_object_inline_componentStack_2453,
                JSCompiler_object_inline_message_2450,
                renderLanes2,
                null
              ), JSCompiler_object_inline_componentStack_2453.flags |= 2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, reconcileChildFibers(
                workInProgress2,
                current2.child,
                null,
                renderLanes2
              ), JSCompiler_object_inline_stack_2452 = workInProgress2.child, JSCompiler_object_inline_stack_2452.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2452.childLanes = getRemainingWorkInPrimaryTree(
                current2,
                JSCompiler_object_inline_digest_2451,
                renderLanes2
              ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = JSCompiler_object_inline_componentStack_2453);
            else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isHydrating && console.error(
              "We should not be hydrating here. This is a bug in React. Please file a bug."
            ), isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450)) {
              JSCompiler_object_inline_digest_2451 = JSCompiler_object_inline_message_2450.nextSibling && JSCompiler_object_inline_message_2450.nextSibling.dataset;
              if (JSCompiler_object_inline_digest_2451) {
                JSCompiler_temp = JSCompiler_object_inline_digest_2451.dgst;
                var message = JSCompiler_object_inline_digest_2451.msg;
                instance = JSCompiler_object_inline_digest_2451.stck;
                var componentStack = JSCompiler_object_inline_digest_2451.cstck;
              }
              JSCompiler_object_inline_message_2450 = message;
              JSCompiler_object_inline_digest_2451 = JSCompiler_temp;
              JSCompiler_object_inline_stack_2452 = instance;
              JSCompiler_temp = JSCompiler_object_inline_componentStack_2453 = componentStack;
              JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_message_2450 ? Error(JSCompiler_object_inline_message_2450) : Error(
                "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
              );
              JSCompiler_object_inline_componentStack_2453.stack = JSCompiler_object_inline_stack_2452 || "";
              JSCompiler_object_inline_componentStack_2453.digest = JSCompiler_object_inline_digest_2451;
              JSCompiler_object_inline_digest_2451 = void 0 === JSCompiler_temp ? null : JSCompiler_temp;
              JSCompiler_object_inline_stack_2452 = {
                value: JSCompiler_object_inline_componentStack_2453,
                source: null,
                stack: JSCompiler_object_inline_digest_2451
              };
              "string" === typeof JSCompiler_object_inline_digest_2451 && CapturedStacks.set(
                JSCompiler_object_inline_componentStack_2453,
                JSCompiler_object_inline_stack_2452
              );
              queueHydrationError(JSCompiler_object_inline_stack_2452);
              workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else if (didReceiveUpdate || propagateParentContextChanges(
              current2,
              workInProgress2,
              renderLanes2,
              false
            ), JSCompiler_object_inline_digest_2451 = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2451) {
              JSCompiler_object_inline_digest_2451 = workInProgressRoot;
              if (null !== JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_stack_2452 = renderLanes2 & -renderLanes2, JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & 42) ? 1 : getBumpedLaneForHydrationByLane(
                JSCompiler_object_inline_stack_2452
              ), JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & (JSCompiler_object_inline_digest_2451.suspendedLanes | renderLanes2)) ? 0 : JSCompiler_object_inline_stack_2452, 0 !== JSCompiler_object_inline_stack_2452 && JSCompiler_object_inline_stack_2452 !== prevState.retryLane))
                throw prevState.retryLane = JSCompiler_object_inline_stack_2452, enqueueConcurrentRenderForLane(
                  current2,
                  JSCompiler_object_inline_stack_2452
                ), scheduleUpdateOnFiber(
                  JSCompiler_object_inline_digest_2451,
                  current2,
                  JSCompiler_object_inline_stack_2452
                ), SelectiveHydrationException;
              JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
              workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current2,
                workInProgress2,
                renderLanes2
              );
            } else
              JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                JSCompiler_object_inline_message_2450.nextSibling
              ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current2.id, treeContextOverflow = current2.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
                workInProgress2,
                JSCompiler_object_inline_stack_2452.children
              ), workInProgress2.flags |= 4096);
            return workInProgress2;
          }
          if (JSCompiler_object_inline_componentStack_2453)
            return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_temp = current2.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2452 = createWorkInProgress(
              JSCompiler_temp,
              {
                mode: "hidden",
                children: JSCompiler_object_inline_stack_2452.children
              }
            ), JSCompiler_object_inline_stack_2452.subtreeFlags = JSCompiler_temp.subtreeFlags & 65011712, null !== instance ? JSCompiler_object_inline_componentStack_2453 = createWorkInProgress(
              instance,
              JSCompiler_object_inline_componentStack_2453
            ) : (JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(
              JSCompiler_object_inline_componentStack_2453,
              JSCompiler_object_inline_message_2450,
              renderLanes2,
              null
            ), JSCompiler_object_inline_componentStack_2453.flags |= 2), JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_message_2450 = current2.child.memoizedState, null === JSCompiler_object_inline_message_2450 ? JSCompiler_object_inline_message_2450 = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp = JSCompiler_object_inline_message_2450.cachePool, null !== JSCompiler_temp ? (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent !== instance ? { parent: instance, pool: instance } : JSCompiler_temp) : JSCompiler_temp = getSuspendedCache(), JSCompiler_object_inline_message_2450 = {
              baseLanes: JSCompiler_object_inline_message_2450.baseLanes | renderLanes2,
              cachePool: JSCompiler_temp
            }), JSCompiler_object_inline_componentStack_2453.memoizedState = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(
              current2,
              JSCompiler_object_inline_digest_2451,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          renderLanes2 = current2.child;
          current2 = renderLanes2.sibling;
          renderLanes2 = createWorkInProgress(renderLanes2, {
            mode: "visible",
            children: JSCompiler_object_inline_stack_2452.children
          });
          renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
          null !== current2 && (JSCompiler_object_inline_digest_2451 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2451 ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2451.push(current2));
          workInProgress2.child = renderLanes2;
          workInProgress2.memoizedState = null;
          return renderLanes2;
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
          primaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: primaryChildren },
            workInProgress2.mode
          );
          primaryChildren.return = workInProgress2;
          return workInProgress2.child = primaryChildren;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
          offscreenProps = createFiber(22, offscreenProps, null, mode);
          offscreenProps.lanes = 0;
          offscreenProps.stateNode = {
            _visibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
          };
          return offscreenProps;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          current2 = mountSuspensePrimaryChildren(
            workInProgress2,
            workInProgress2.pendingProps.children
          );
          current2.flags |= 2;
          workInProgress2.memoizedState = null;
          return current2;
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes |= renderLanes2;
          var alternate = fiber.alternate;
          null !== alternate && (alternate.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(
            fiber.return,
            renderLanes2,
            propagationRoot
          );
        }
        function validateSuspenseListNestedChild(childSlot, index) {
          var isAnArray = isArrayImpl(childSlot);
          childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
          return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index,
            isAnArray
          ), false) : true;
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
          var renderState = workInProgress2.memoizedState;
          null === renderState ? workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode
          } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
          nextProps = nextProps.children;
          if (void 0 !== revealOrder && "forwards" !== revealOrder && "backwards" !== revealOrder && "together" !== revealOrder && !didWarnAboutRevealOrder[revealOrder])
            if (didWarnAboutRevealOrder[revealOrder] = true, "string" === typeof revealOrder)
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                case "forward":
                case "backward":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                default:
                  console.error(
                    '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                    revealOrder
                  );
              }
            else
              console.error(
                '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                revealOrder
              );
          void 0 === tailMode || didWarnAboutTailOptions[tailMode] || ("collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[tailMode] = true, console.error(
            '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
            tailMode
          )) : "forwards" !== revealOrder && "backwards" !== revealOrder && (didWarnAboutTailOptions[tailMode] = true, console.error(
            '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
            tailMode
          )));
          a: if (("forwards" === revealOrder || "backwards" === revealOrder) && void 0 !== nextProps && null !== nextProps && false !== nextProps)
            if (isArrayImpl(nextProps))
              for (var i = 0; i < nextProps.length; i++) {
                if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
              }
            else if (i = getIteratorFn(nextProps), "function" === typeof i) {
              if (i = i.call(nextProps))
                for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
                  if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                  _i++;
                }
            } else
              console.error(
                'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
                revealOrder
              );
          reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
          nextProps = suspenseStackCursor.current;
          if (0 !== (nextProps & ForceSuspenseFallback))
            nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128;
          else {
            if (null !== current2 && 0 !== (current2.flags & 128))
              a: for (current2 = workInProgress2.child; null !== current2; ) {
                if (13 === current2.tag)
                  null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(
                    current2,
                    renderLanes2,
                    workInProgress2
                  );
                else if (19 === current2.tag)
                  scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
                else if (null !== current2.child) {
                  current2.child.return = current2;
                  current2 = current2.child;
                  continue;
                }
                if (current2 === workInProgress2) break a;
                for (; null === current2.sibling; ) {
                  if (null === current2.return || current2.return === workInProgress2)
                    break a;
                  current2 = current2.return;
                }
                current2.sibling.return = current2.return;
                current2 = current2.sibling;
              }
            nextProps &= SubtreeSuspenseContextMask;
          }
          push(suspenseStackCursor, nextProps, workInProgress2);
          switch (revealOrder) {
            case "forwards":
              renderLanes2 = workInProgress2.child;
              for (revealOrder = null; null !== renderLanes2; )
                current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
              renderLanes2 = revealOrder;
              null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
              initSuspenseListRenderState(
                workInProgress2,
                false,
                revealOrder,
                renderLanes2,
                tailMode
              );
              break;
            case "backwards":
              renderLanes2 = null;
              revealOrder = workInProgress2.child;
              for (workInProgress2.child = null; null !== revealOrder; ) {
                current2 = revealOrder.alternate;
                if (null !== current2 && null === findFirstSuspended(current2)) {
                  workInProgress2.child = revealOrder;
                  break;
                }
                current2 = revealOrder.sibling;
                revealOrder.sibling = renderLanes2;
                renderLanes2 = revealOrder;
                revealOrder = current2;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                renderLanes2,
                null,
                tailMode
              );
              break;
            case "together":
              initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
              break;
            default:
              workInProgress2.memoizedState = null;
          }
          return workInProgress2.child;
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          null !== current2 && (workInProgress2.dependencies = current2.dependencies);
          profilerStartTime = -1;
          workInProgressRootSkippedLanes |= workInProgress2.lanes;
          if (0 === (renderLanes2 & workInProgress2.childLanes))
            if (null !== current2) {
              if (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), 0 === (renderLanes2 & workInProgress2.childLanes))
                return null;
            } else return null;
          if (null !== current2 && workInProgress2.child !== current2.child)
            throw Error("Resuming work not yet implemented.");
          if (null !== workInProgress2.child) {
            current2 = workInProgress2.child;
            renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
            workInProgress2.child = renderLanes2;
            for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
              current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
            renderLanes2.sibling = null;
          }
          return workInProgress2.child;
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          if (0 !== (current2.lanes & renderLanes2)) return true;
          current2 = current2.dependencies;
          return null !== current2 && checkIfContextChanged(current2) ? true : false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case 3:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
              resetHydrationState();
              break;
            case 27:
            case 5:
              pushHostContext(workInProgress2);
              break;
            case 4:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              break;
            case 10:
              pushProvider(
                workInProgress2,
                workInProgress2.type,
                workInProgress2.memoizedProps.value
              );
              break;
            case 12:
              0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
              workInProgress2.flags |= 2048;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = -0;
              stateNode.passiveEffectDuration = -0;
              break;
            case 13:
              stateNode = workInProgress2.memoizedState;
              if (null !== stateNode) {
                if (null !== stateNode.dehydrated)
                  return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
                if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                  return updateSuspenseComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                pushPrimaryTreeSuspenseHandler(workInProgress2);
                current2 = bailoutOnAlreadyFinishedWork(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
                return null !== current2 ? current2.sibling : null;
              }
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              break;
            case 19:
              var didSuspendBefore = 0 !== (current2.flags & 128);
              stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
              stateNode || (propagateParentContextChanges(
                current2,
                workInProgress2,
                renderLanes2,
                false
              ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
              if (didSuspendBefore) {
                if (stateNode)
                  return updateSuspenseListComponent(
                    current2,
                    workInProgress2,
                    renderLanes2
                  );
                workInProgress2.flags |= 128;
              }
              didSuspendBefore = workInProgress2.memoizedState;
              null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
              push(
                suspenseStackCursor,
                suspenseStackCursor.current,
                workInProgress2
              );
              if (stateNode) break;
              else return null;
            case 22:
            case 23:
              return workInProgress2.lanes = 0, updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            case 24:
              pushProvider(
                workInProgress2,
                CacheContext,
                current2.memoizedState.cache
              );
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          if (workInProgress2._debugNeedsRemount && null !== current2) {
            renderLanes2 = createFiberFromTypeAndProps(
              workInProgress2.type,
              workInProgress2.key,
              workInProgress2.pendingProps,
              workInProgress2._debugOwner || null,
              workInProgress2.mode,
              workInProgress2.lanes
            );
            renderLanes2._debugStack = workInProgress2._debugStack;
            renderLanes2._debugTask = workInProgress2._debugTask;
            var returnFiber = workInProgress2.return;
            if (null === returnFiber) throw Error("Cannot swap the root fiber.");
            current2.alternate = null;
            workInProgress2.alternate = null;
            renderLanes2.index = workInProgress2.index;
            renderLanes2.sibling = workInProgress2.sibling;
            renderLanes2.return = workInProgress2.return;
            renderLanes2.ref = workInProgress2.ref;
            renderLanes2._debugInfo = workInProgress2._debugInfo;
            if (workInProgress2 === returnFiber.child)
              returnFiber.child = renderLanes2;
            else {
              var prevSibling = returnFiber.child;
              if (null === prevSibling)
                throw Error("Expected parent to have a child.");
              for (; prevSibling.sibling !== workInProgress2; )
                if (prevSibling = prevSibling.sibling, null === prevSibling)
                  throw Error("Expected to find the previous sibling.");
              prevSibling.sibling = renderLanes2;
            }
            workInProgress2 = returnFiber.deletions;
            null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
            renderLanes2.flags |= 2;
            return renderLanes2;
          }
          if (null !== current2)
            if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
              didReceiveUpdate = true;
            else {
              if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
                return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                  current2,
                  workInProgress2,
                  renderLanes2
                );
              didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
            }
          else {
            didReceiveUpdate = false;
            if (returnFiber = isHydrating)
              warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
            returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
          }
          workInProgress2.lanes = 0;
          switch (workInProgress2.tag) {
            case 16:
              a: if (returnFiber = workInProgress2.pendingProps, current2 = callLazyInitInDEV(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
                shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
                  current2,
                  returnFiber
                ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current2,
                  returnFiber,
                  renderLanes2
                ));
              else {
                if (void 0 !== current2 && null !== current2) {
                  if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (prevSibling === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = "";
                null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
                current2 = getComponentNameFromType(current2) || current2;
                throw Error(
                  "Element type is invalid. Received a promise that resolves to: " + current2 + ". Lazy element type must resolve to a class or function." + workInProgress2
                );
              }
              return workInProgress2;
            case 0:
              return updateFunctionComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 1:
              return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
                returnFiber,
                workInProgress2.pendingProps
              ), updateClassComponent(
                current2,
                workInProgress2,
                returnFiber,
                prevSibling,
                renderLanes2
              );
            case 3:
              a: {
                pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                );
                if (null === current2)
                  throw Error(
                    "Should have a current fiber. This is a bug in React."
                  );
                returnFiber = workInProgress2.pendingProps;
                var prevState = workInProgress2.memoizedState;
                prevSibling = prevState.element;
                cloneUpdateQueue(current2, workInProgress2);
                processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
                var nextState = workInProgress2.memoizedState;
                returnFiber = nextState.cache;
                pushProvider(workInProgress2, CacheContext, returnFiber);
                returnFiber !== prevState.cache && propagateContextChanges(
                  workInProgress2,
                  [CacheContext],
                  renderLanes2,
                  true
                );
                suspendIfUpdateReadFromEntangledAsyncAction();
                returnFiber = nextState.element;
                if (prevState.isDehydrated)
                  if (prevState = {
                    element: returnFiber,
                    isDehydrated: false,
                    cache: nextState.cache
                  }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (returnFiber !== prevSibling) {
                    prevSibling = createCapturedValueAtFiber(
                      Error(
                        "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                      ),
                      workInProgress2
                    );
                    queueHydrationError(prevSibling);
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current2,
                      workInProgress2,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else {
                    current2 = workInProgress2.stateNode.containerInfo;
                    switch (current2.nodeType) {
                      case 9:
                        current2 = current2.body;
                        break;
                      default:
                        current2 = "HTML" === current2.nodeName ? current2.ownerDocument.body : current2;
                    }
                    nextHydratableInstance = getNextHydratable(current2.firstChild);
                    hydrationParentFiber = workInProgress2;
                    isHydrating = true;
                    hydrationErrors = null;
                    didSuspendOrErrorDEV = false;
                    hydrationDiffRootDEV = null;
                    rootOrSingletonContext = true;
                    current2 = mountChildFibers(
                      workInProgress2,
                      null,
                      returnFiber,
                      renderLanes2
                    );
                    for (workInProgress2.child = current2; current2; )
                      current2.flags = current2.flags & -3 | 4096, current2 = current2.sibling;
                  }
                else {
                  resetHydrationState();
                  if (returnFiber === prevSibling) {
                    workInProgress2 = bailoutOnAlreadyFinishedWork(
                      current2,
                      workInProgress2,
                      renderLanes2
                    );
                    break a;
                  }
                  reconcileChildren(
                    current2,
                    workInProgress2,
                    returnFiber,
                    renderLanes2
                  );
                }
                workInProgress2 = workInProgress2.child;
              }
              return workInProgress2;
            case 26:
              return markRef(current2, workInProgress2), null === current2 ? (current2 = getResource(
                workInProgress2.type,
                null,
                workInProgress2.pendingProps,
                null
              )) ? workInProgress2.memoizedState = current2 : isHydrating || (current2 = workInProgress2.type, renderLanes2 = workInProgress2.pendingProps, returnFiber = requiredContext(
                rootInstanceStackCursor.current
              ), returnFiber = getOwnerDocumentFromRootContainer(
                returnFiber
              ).createElement(current2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = renderLanes2, setInitialProperties(returnFiber, current2, renderLanes2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
                workInProgress2.type,
                current2.memoizedProps,
                workInProgress2.pendingProps,
                current2.memoizedState
              ), null;
            case 27:
              return pushHostContext(workInProgress2), null === current2 && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                returnFiber,
                prevSibling,
                false
              ), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(
                returnFiber,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevSibling
              ), null !== prevSibling && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(
                returnFiber.firstChild
              )) : nextHydratableInstance = prevSibling), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
            case 5:
              return null === current2 && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(
                workInProgress2.type,
                prevState.ancestorInfo
              ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
                prevSibling,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(
                nextState,
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevState
              ), null !== prevState && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                nextState.firstChild
              ), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
                current2,
                workInProgress2,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes2
              ), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 6:
              return null === current2 && isHydrating && (current2 = workInProgress2.pendingProps, renderLanes2 = getHostContext(), returnFiber = renderLanes2.ancestorInfo.current, current2 = null != returnFiber ? validateTextNesting(
                current2,
                returnFiber.tag,
                renderLanes2.ancestorInfo.implicitRootScope
              ) : true, renderLanes2 = nextHydratableInstance, (returnFiber = !renderLanes2) || (returnFiber = canHydrateTextInstance(
                renderLanes2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (current2 && warnNonHydratedInstance(workInProgress2, renderLanes2), throwOnHydrationMismatch(workInProgress2))), null;
            case 13:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case 4:
              return pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                returnFiber,
                renderLanes2
              ) : reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 11:
              return updateForwardRef(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 7:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps,
                renderLanes2
              ), workInProgress2.child;
            case 8:
              return reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 12:
              return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 10:
              return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(
                current2,
                workInProgress2,
                prevSibling.children,
                renderLanes2
              ), workInProgress2.child;
            case 9:
              return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress2), returnFiber = callComponentInDEV(
                returnFiber,
                prevSibling,
                void 0
              ), markComponentRenderStopped(), workInProgress2.flags |= 1, reconcileChildren(
                current2,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 14:
              return updateMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 15:
              return updateSimpleMemoComponent(
                current2,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 19:
              return updateSuspenseListComponent(
                current2,
                workInProgress2,
                renderLanes2
              );
            case 31:
              return returnFiber = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, returnFiber = {
                mode: returnFiber.mode,
                children: returnFiber.children
              }, null === current2 ? (current2 = mountWorkInProgressOffscreenFiber(
                returnFiber,
                renderLanes2
              ), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2) : (current2 = createWorkInProgress(current2.child, returnFiber), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2), workInProgress2;
            case 22:
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            case 24:
              return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
                parent: returnFiber,
                cache: prevSibling
              }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
                parent: returnFiber,
                cache: returnFiber
              }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              ))), reconcileChildren(
                current2,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 29:
              throw workInProgress2.pendingProps;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= 4;
        }
        function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
          if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
            workInProgress2.flags &= -16777217;
          else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
            resource = suspenseHandlerStackCursor.current;
            if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
            workInProgress2.flags |= 8192;
          }
        }
        function scheduleRetryEffect(workInProgress2, retryQueue) {
          null !== retryQueue && (workInProgress2.flags |= 4);
          workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (!isHydrating)
            switch (renderState.tailMode) {
              case "hidden":
                hasRenderedATailFallback = renderState.tail;
                for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                  null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                break;
              case "collapsed":
                lastTailNode = renderState.tail;
                for (var _lastTailNode = null; null !== lastTailNode; )
                  null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
            }
        }
        function bubbleProperties(completedWork) {
          var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
          if (didBailout)
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
                newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else
              for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
                newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          else if ((completedWork.mode & ProfileMode) !== NoMode) {
            _treeBaseDuration = completedWork.actualDuration;
            _child2 = completedWork.selfBaseDuration;
            for (var child = completedWork.child; null !== child; )
              newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
            completedWork.actualDuration = _treeBaseDuration;
            completedWork.treeBaseDuration = _child2;
          } else
            for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
              newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          completedWork.subtreeFlags |= subtreeFlags;
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 31:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return bubbleProperties(workInProgress2), null;
            case 1:
              return bubbleProperties(workInProgress2), null;
            case 3:
              renderLanes2 = workInProgress2.stateNode;
              newProps = null;
              null !== current2 && (newProps = current2.memoizedState.cache);
              workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
              popProvider(CacheContext, workInProgress2);
              popHostContainer(workInProgress2);
              renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
              if (null === current2 || null === current2.child)
                popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
              bubbleProperties(workInProgress2);
              return null;
            case 26:
              return renderLanes2 = workInProgress2.memoizedState, null === current2 ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
            case 27:
              popHostContext(workInProgress2);
              renderLanes2 = requiredContext(rootInstanceStackCursor.current);
              var _type = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                current2 = getHostContext();
                popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(
                  _type,
                  newProps,
                  renderLanes2,
                  current2,
                  true
                ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
              }
              bubbleProperties(workInProgress2);
              return null;
            case 5:
              popHostContext(workInProgress2);
              renderLanes2 = workInProgress2.type;
              if (null !== current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                _type = getHostContext();
                if (popHydrationState(workInProgress2))
                  prepareToHydrateHostInstance(workInProgress2, _type);
                else {
                  current2 = requiredContext(rootInstanceStackCursor.current);
                  validateDOMNesting(renderLanes2, _type.ancestorInfo);
                  _type = _type.context;
                  current2 = getOwnerDocumentFromRootContainer(current2);
                  switch (_type) {
                    case HostContextNamespaceSvg:
                      current2 = current2.createElementNS(SVG_NAMESPACE, renderLanes2);
                      break;
                    case HostContextNamespaceMath:
                      current2 = current2.createElementNS(
                        MATH_NAMESPACE,
                        renderLanes2
                      );
                      break;
                    default:
                      switch (renderLanes2) {
                        case "svg":
                          current2 = current2.createElementNS(
                            SVG_NAMESPACE,
                            renderLanes2
                          );
                          break;
                        case "math":
                          current2 = current2.createElementNS(
                            MATH_NAMESPACE,
                            renderLanes2
                          );
                          break;
                        case "script":
                          current2 = current2.createElement("div");
                          current2.innerHTML = "<script><\/script>";
                          current2 = current2.removeChild(current2.firstChild);
                          break;
                        case "select":
                          current2 = "string" === typeof newProps.is ? current2.createElement("select", { is: newProps.is }) : current2.createElement("select");
                          newProps.multiple ? current2.multiple = true : newProps.size && (current2.size = newProps.size);
                          break;
                        default:
                          current2 = "string" === typeof newProps.is ? current2.createElement(renderLanes2, {
                            is: newProps.is
                          }) : current2.createElement(renderLanes2), -1 === renderLanes2.indexOf("-") && (renderLanes2 !== renderLanes2.toLowerCase() && console.error(
                            "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                            renderLanes2
                          ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(current2) || hasOwnProperty.call(
                            warnedUnknownTags,
                            renderLanes2
                          ) || (warnedUnknownTags[renderLanes2] = true, console.error(
                            "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                            renderLanes2
                          )));
                      }
                  }
                  current2[internalInstanceKey] = workInProgress2;
                  current2[internalPropsKey] = newProps;
                  a: for (_type = workInProgress2.child; null !== _type; ) {
                    if (5 === _type.tag || 6 === _type.tag)
                      current2.appendChild(_type.stateNode);
                    else if (4 !== _type.tag && 27 !== _type.tag && null !== _type.child) {
                      _type.child.return = _type;
                      _type = _type.child;
                      continue;
                    }
                    if (_type === workInProgress2) break a;
                    for (; null === _type.sibling; ) {
                      if (null === _type.return || _type.return === workInProgress2)
                        break a;
                      _type = _type.return;
                    }
                    _type.sibling.return = _type.return;
                    _type = _type.sibling;
                  }
                  workInProgress2.stateNode = current2;
                  a: switch (setInitialProperties(current2, renderLanes2, newProps), renderLanes2) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      current2 = !!newProps.autoFocus;
                      break a;
                    case "img":
                      current2 = true;
                      break a;
                    default:
                      current2 = false;
                  }
                  current2 && markUpdate(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              workInProgress2.flags &= -16777217;
              return null;
            case 6:
              if (current2 && null != workInProgress2.stateNode)
                current2.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                current2 = requiredContext(rootInstanceStackCursor.current);
                renderLanes2 = getHostContext();
                if (popHydrationState(workInProgress2)) {
                  current2 = workInProgress2.stateNode;
                  renderLanes2 = workInProgress2.memoizedProps;
                  _type = !didSuspendOrErrorDEV;
                  newProps = null;
                  var returnFiber = hydrationParentFiber;
                  if (null !== returnFiber)
                    switch (returnFiber.tag) {
                      case 3:
                        _type && (_type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== _type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = _type));
                        break;
                      case 27:
                      case 5:
                        newProps = returnFiber.memoizedProps, _type && (_type = diffHydratedTextForDevWarnings(
                          current2,
                          renderLanes2,
                          newProps
                        ), null !== _type && (buildHydrationDiffNode(
                          workInProgress2,
                          0
                        ).serverProps = _type));
                    }
                  current2[internalInstanceKey] = workInProgress2;
                  current2 = current2.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
                  current2 || throwOnHydrationMismatch(workInProgress2);
                } else
                  _type = renderLanes2.ancestorInfo.current, null != _type && validateTextNesting(
                    newProps,
                    _type.tag,
                    renderLanes2.ancestorInfo.implicitRootScope
                  ), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(
                    newProps
                  ), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
              }
              bubbleProperties(workInProgress2);
              return null;
            case 13:
              newProps = workInProgress2.memoizedState;
              if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
                _type = popHydrationState(workInProgress2);
                if (null !== newProps && null !== newProps.dehydrated) {
                  if (null === current2) {
                    if (!_type)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    _type = workInProgress2.memoizedState;
                    _type = null !== _type ? _type.dehydrated : null;
                    if (!_type)
                      throw Error(
                        "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    _type[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
                  _type = false;
                } else
                  _type = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = _type), _type = true;
                if (!_type) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
              }
              popSuspenseHandler(workInProgress2);
              if (0 !== (workInProgress2.flags & 128))
                return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
              renderLanes2 = null !== newProps;
              current2 = null !== current2 && null !== current2.memoizedState;
              renderLanes2 && (newProps = workInProgress2.child, _type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (_type = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== _type && (newProps.flags |= 2048));
              renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
              scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
              bubbleProperties(workInProgress2);
              (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              return null;
            case 4:
              return popHostContainer(workInProgress2), null === current2 && listenToAllSupportedEvents(
                workInProgress2.stateNode.containerInfo
              ), bubbleProperties(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
            case 19:
              pop(suspenseStackCursor, workInProgress2);
              _type = workInProgress2.memoizedState;
              if (null === _type) return bubbleProperties(workInProgress2), null;
              newProps = 0 !== (workInProgress2.flags & 128);
              returnFiber = _type.rendering;
              if (null === returnFiber)
                if (newProps) cutOffTailIfNeeded(_type, false);
                else {
                  if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
                    for (current2 = workInProgress2.child; null !== current2; ) {
                      returnFiber = findFirstSuspended(current2);
                      if (null !== returnFiber) {
                        workInProgress2.flags |= 128;
                        cutOffTailIfNeeded(_type, false);
                        current2 = returnFiber.updateQueue;
                        workInProgress2.updateQueue = current2;
                        scheduleRetryEffect(workInProgress2, current2);
                        workInProgress2.subtreeFlags = 0;
                        current2 = renderLanes2;
                        for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                          resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                        push(
                          suspenseStackCursor,
                          suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                          workInProgress2
                        );
                        return workInProgress2.child;
                      }
                      current2 = current2.sibling;
                    }
                  null !== _type.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
                }
              else {
                if (!newProps)
                  if (current2 = findFirstSuspended(returnFiber), null !== current2) {
                    if (workInProgress2.flags |= 128, newProps = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(_type, true), null === _type.tail && "hidden" === _type.tailMode && !returnFiber.alternate && !isHydrating)
                      return bubbleProperties(workInProgress2), null;
                  } else
                    2 * now$1() - _type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
                _type.isBackwards ? (returnFiber.sibling = workInProgress2.child, workInProgress2.child = returnFiber) : (current2 = _type.last, null !== current2 ? current2.sibling = returnFiber : workInProgress2.child = returnFiber, _type.last = returnFiber);
              }
              if (null !== _type.tail)
                return current2 = _type.tail, _type.rendering = current2, _type.tail = current2.sibling, _type.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = newProps ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), current2;
              bubbleProperties(workInProgress2);
              return null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
            case 24:
              return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
            case 25:
              return null;
            case 30:
              return null;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function unwindWork(current2, workInProgress2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 1:
              return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 3:
              return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
            case 26:
            case 27:
            case 5:
              return popHostContext(workInProgress2), null;
            case 13:
              popSuspenseHandler(workInProgress2);
              current2 = workInProgress2.memoizedState;
              if (null !== current2 && null !== current2.dehydrated) {
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current2 = workInProgress2.flags;
              return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 19:
              return pop(suspenseStackCursor, workInProgress2), null;
            case 4:
              return popHostContainer(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 24:
              return popProvider(CacheContext, workInProgress2), null;
            case 25:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case 3:
              popProvider(CacheContext, interruptedWork);
              popHostContainer(interruptedWork);
              break;
            case 26:
            case 27:
            case 5:
              popHostContext(interruptedWork);
              break;
            case 4:
              popHostContainer(interruptedWork);
              break;
            case 13:
              popSuspenseHandler(interruptedWork);
              break;
            case 19:
              pop(suspenseStackCursor, interruptedWork);
              break;
            case 10:
              popProvider(interruptedWork.type, interruptedWork);
              break;
            case 22:
            case 23:
              popSuspenseHandler(interruptedWork);
              popHiddenContext(interruptedWork);
              null !== current2 && pop(resumedCache, interruptedWork);
              break;
            case 24:
              popProvider(CacheContext, interruptedWork);
          }
        }
        function shouldProfile(current2) {
          return (current2.mode & ProfileMode) !== NoMode;
        }
        function commitHookLayoutEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitHookEffectListMount(flags, finishedWork) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(
                  finishedWork
                ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(
                  finishedWork
                ), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                  finishedWork,
                  callCreateInDEV,
                  updateQueue
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                  var hookName = void 0;
                  hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                  var addendum = void 0;
                  addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                  runWithFiberInDEV(
                    finishedWork,
                    function(n, a) {
                      console.error(
                        "%s must not return anything besides a function, which is used for clean-up.%s",
                        n,
                        a
                      );
                    },
                    hookName,
                    addendum
                  );
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags) {
                  var inst = updateQueue.inst, destroy = inst.destroy;
                  void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
                    finishedWork
                  ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
                    finishedWork
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
                    lastEffect,
                    callDestroyInDEV,
                    lastEffect,
                    nearestMountedAncestor,
                    destroy
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookPassiveMountEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitClassCallbacks(finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          if (null !== updateQueue) {
            var instance = finishedWork.stateNode;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ), instance.state !== finishedWork.memoizedState && console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                updateQueue,
                instance
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
          return instance.getSnapshotBeforeUpdate(prevProps, prevState);
        }
        function commitClassSnapshot(finishedWork, current2) {
          var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
          current2 = finishedWork.stateNode;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ), current2.state !== finishedWork.memoizedState && console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
          try {
            var resolvedPrevProps = resolveClassComponentProps(
              finishedWork.type,
              prevProps,
              finishedWork.elementType === finishedWork.type
            );
            var snapshot = runWithFiberInDEV(
              finishedWork,
              callGetSnapshotBeforeUpdates,
              current2,
              resolvedPrevProps,
              prevState
            );
            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
              console.error(
                "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
                getComponentNameFromFiber(finishedWork)
              );
            }));
            current2.__reactInternalSnapshotBeforeUpdate = snapshot;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
          instance.props = resolveClassComponentProps(
            current2.type,
            current2.memoizedProps
          );
          instance.state = current2.memoizedState;
          shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          ), recordEffectDuration()) : runWithFiberInDEV(
            current2,
            callComponentWillUnmountInDEV,
            current2,
            nearestMountedAncestor,
            instance
          );
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (null !== ref) {
            switch (finishedWork.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = finishedWork.stateNode;
                break;
              case 30:
                instanceToUse = finishedWork.stateNode;
                break;
              default:
                instanceToUse = finishedWork.stateNode;
            }
            if ("function" === typeof ref)
              if (shouldProfile(finishedWork))
                try {
                  startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
                } finally {
                  recordEffectDuration();
                }
              else finishedWork.refCleanup = ref(instanceToUse);
            else
              "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ), ref.current = instanceToUse;
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            runWithFiberInDEV(current2, commitAttachRef, current2);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref = current2.ref, refCleanup = current2.refCleanup;
          if (null !== ref)
            if ("function" === typeof refCleanup)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, refCleanup);
              } catch (error) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error);
              } finally {
                current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
              }
            else if ("function" === typeof ref)
              try {
                if (shouldProfile(current2))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current2, ref, null);
                  } finally {
                    recordEffectDuration(current2);
                  }
                else runWithFiberInDEV(current2, ref, null);
              } catch (error$7) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
              }
            else ref.current = null;
        }
        function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
          var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
          _finishedWork$memoize = _finishedWork$memoize.onRender;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
            id,
            current2,
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            commitStartTime2
          );
          "function" === typeof onCommit && onCommit(
            finishedWork.memoizedProps.id,
            current2,
            effectDuration,
            commitStartTime2
          );
        }
        function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
          var _finishedWork$memoize2 = finishedWork.memoizedProps;
          finishedWork = _finishedWork$memoize2.id;
          _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
          current2 = null === current2 ? "mount" : "update";
          currentUpdateIsNested && (current2 = "nested-update");
          "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
            finishedWork,
            current2,
            passiveEffectDuration,
            commitStartTime2
          );
        }
        function commitHostMount(finishedWork) {
          var type2 = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
          try {
            runWithFiberInDEV(
              finishedWork,
              commitMount,
              instance,
              type2,
              props,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHostUpdate(finishedWork, newProps, oldProps) {
          try {
            runWithFiberInDEV(
              finishedWork,
              commitUpdate,
              finishedWork.stateNode,
              finishedWork.type,
              oldProps,
              newProps,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHostParent(fiber) {
          return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
        }
        function getHostSibling(fiber) {
          a: for (; ; ) {
            for (; null === fiber.sibling; ) {
              if (null === fiber.return || isHostParent(fiber.return)) return null;
              fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
              if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
              if (fiber.flags & 2) continue a;
              if (null === fiber.child || 4 === fiber.tag) continue a;
              else fiber.child.return = fiber, fiber = fiber.child;
            }
            if (!(fiber.flags & 2)) return fiber.stateNode;
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
            for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          if (5 === tag || 6 === tag)
            node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
          else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
            for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
              insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
        }
        function commitPlacement(finishedWork) {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          switch (hostParentFiber.tag) {
            case 27:
              hostParentFiber = hostParentFiber.stateNode;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            case 5:
              parentFiber = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
              hostParentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(
                finishedWork,
                hostParentFiber,
                parentFiber
              );
              break;
            case 3:
            case 4:
              hostParentFiber = hostParentFiber.stateNode.containerInfo;
              parentFiber = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                parentFiber,
                hostParentFiber
              );
              break;
            default:
              throw Error(
                "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
              );
          }
        }
        function commitHostSingletonAcquisition(finishedWork) {
          var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
          try {
            runWithFiberInDEV(
              finishedWork,
              acquireSingletonInstance,
              finishedWork.type,
              props,
              singleton,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitBeforeMutationEffects(root2, firstChild) {
          root2 = root2.containerInfo;
          eventsEnabled = _enabled;
          root2 = getActiveElementDeep(root2);
          if (hasSelectionCapabilities(root2)) {
            if ("selectionStart" in root2)
              var JSCompiler_temp = {
                start: root2.selectionStart,
                end: root2.selectionEnd
              };
            else
              a: {
                JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
                var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                if (selection && 0 !== selection.rangeCount) {
                  JSCompiler_temp = selection.anchorNode;
                  var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                  selection = selection.focusOffset;
                  try {
                    JSCompiler_temp.nodeType, focusNode.nodeType;
                  } catch (e$2) {
                    JSCompiler_temp = null;
                    break a;
                  }
                  var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
                  b: for (; ; ) {
                    for (var next; ; ) {
                      node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                      node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                      3 === node.nodeType && (length += node.nodeValue.length);
                      if (null === (next = node.firstChild)) break;
                      parentNode = node;
                      node = next;
                    }
                    for (; ; ) {
                      if (node === root2) break b;
                      parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                      parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                      if (null !== (next = node.nextSibling)) break;
                      node = parentNode;
                      parentNode = node.parentNode;
                    }
                    node = next;
                  }
                  JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
                } else JSCompiler_temp = null;
              }
            JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
          } else JSCompiler_temp = null;
          selectionInformation = {
            focusedElem: root2,
            selectionRange: JSCompiler_temp
          };
          _enabled = false;
          for (nextEffect = firstChild; null !== nextEffect; )
            if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root2)
              root2.return = firstChild, nextEffect = root2;
            else
              for (; null !== nextEffect; ) {
                root2 = firstChild = nextEffect;
                JSCompiler_temp = root2.alternate;
                anchorOffset = root2.flags;
                switch (root2.tag) {
                  case 0:
                    break;
                  case 11:
                  case 15:
                    break;
                  case 1:
                    0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root2, JSCompiler_temp);
                    break;
                  case 3:
                    if (0 !== (anchorOffset & 1024)) {
                      if (root2 = root2.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                        clearContainerSparingly(root2);
                      else if (1 === JSCompiler_temp)
                        switch (root2.nodeName) {
                          case "HEAD":
                          case "HTML":
                          case "BODY":
                            clearContainerSparingly(root2);
                            break;
                          default:
                            root2.textContent = "";
                        }
                    }
                    break;
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    if (0 !== (anchorOffset & 1024))
                      throw Error(
                        "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                      );
                }
                root2 = firstChild.sibling;
                if (null !== root2) {
                  root2.return = firstChild.return;
                  nextEffect = root2;
                  break;
                }
                nextEffect = firstChild.return;
              }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
              break;
            case 1:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 4)
                if (finishedRoot = finishedWork.stateNode, null === current2)
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  );
                else {
                  var prevProps = resolveClassComponentProps(
                    finishedWork.type,
                    current2.memoizedProps
                  );
                  current2 = current2.memoizedState;
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
                  shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current2,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                }
              flags & 64 && commitClassCallbacks(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 3:
              current2 = pushNestedEffectDurations();
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                prevProps = null;
                if (null !== finishedWork.child)
                  switch (finishedWork.child.tag) {
                    case 27:
                    case 5:
                      prevProps = finishedWork.child.stateNode;
                      break;
                    case 1:
                      prevProps = finishedWork.child.stateNode;
                  }
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitCallbacks,
                    flags,
                    prevProps
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              finishedRoot.effectDuration += popNestedEffectDurations(current2);
              break;
            case 27:
              null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              null === current2 && flags & 4 && commitHostMount(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                finishedRoot = finishedWork.stateNode;
                finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    finishedRoot.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
                null,
                finishedWork
              ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
              break;
            case 22:
              flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
              if (!flags) {
                current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
                prevProps = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = flags;
                (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                offscreenSubtreeIsHidden = prevProps;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              }
              break;
            case 30:
              break;
            default:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          }
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
          fiber.stateNode = null;
          fiber._debugOwner = null;
          fiber.return = null;
          fiber.dependencies = null;
          fiber.memoizedProps = null;
          fiber.memoizedState = null;
          fiber.pendingProps = null;
          fiber.stateNode = null;
          fiber.updateQueue = null;
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          for (parent = parent.child; null !== parent; )
            commitDeletionEffectsOnFiber(
              finishedRoot,
              nearestMountedAncestor,
              parent
            ), parent = parent.sibling;
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
            try {
              injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
          switch (deletedFiber.tag) {
            case 26:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
              break;
            case 27:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              runWithFiberInDEV(
                deletedFiber,
                releaseSingletonInstance,
                deletedFiber.stateNode
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 5:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            case 6:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChildFromContainer,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
                else
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChild,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
              break;
            case 18:
              null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
                9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
                deletedFiber.stateNode
              ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
              break;
            case 4:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              offscreenSubtreeWasHidden || commitHookEffectListUnmount(
                Insertion,
                deletedFiber,
                nearestMountedAncestor
              );
              offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
                deletedFiber,
                nearestMountedAncestor,
                Layout
              );
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 1:
              offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 21:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 22:
              offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              offscreenSubtreeWasHidden = prevHostParent;
              break;
            default:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
          }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedSuspenseInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function getRetryCache(finishedWork) {
          switch (finishedWork.tag) {
            case 13:
            case 19:
              var retryCache = finishedWork.stateNode;
              null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
              return retryCache;
            case 22:
              return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
            default:
              throw Error(
                "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
              );
          }
        }
        function attachSuspenseRetryListeners(finishedWork, wakeables) {
          var retryCache = getRetryCache(finishedWork);
          wakeables.forEach(function(wakeable) {
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              if (isDevToolsPresent)
                if (null !== inProgressLanes && null !== inProgressRoot)
                  restorePendingUpdaters(inProgressRoot, inProgressLanes);
                else
                  throw Error(
                    "Expected finished root and lanes to be set. This is a bug in React."
                  );
              wakeable.then(retry, retry);
            }
          });
        }
        function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
          var deletions = parentFiber.deletions;
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var root2 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (isSingletonScope(parent.type)) {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break a;
                    }
                    break;
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent)
                throw Error(
                  "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                );
              commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
              root2 = deletedFiber;
              returnFiber = root2.alternate;
              null !== returnFiber && (returnFiber.return = null);
              root2.return = null;
            }
          if (parentFiber.subtreeFlags & 13878)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
        }
        function commitMutationEffectsOnFiber(finishedWork, root2) {
          var current2 = finishedWork.alternate, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (commitHookEffectListUnmount(
                Insertion | HasEffect,
                finishedWork,
                finishedWork.return
              ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout | HasEffect
              ));
              break;
            case 1:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current2 = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current2 ? flags : current2.concat(flags))));
              break;
            case 26:
              var hoistableRoot = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (flags & 4)
                if (root2 = null !== current2 ? current2.memoizedState : null, flags = finishedWork.memoizedState, null === current2)
                  if (null === flags)
                    if (null === finishedWork.stateNode) {
                      a: {
                        flags = finishedWork.type;
                        current2 = finishedWork.memoizedProps;
                        root2 = hoistableRoot.ownerDocument || hoistableRoot;
                        b: switch (flags) {
                          case "title":
                            hoistableRoot = root2.getElementsByTagName("title")[0];
                            if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute("itemprop"))
                              hoistableRoot = root2.createElement(flags), root2.head.insertBefore(
                                hoistableRoot,
                                root2.querySelector("head > title")
                              );
                            setInitialProperties(hoistableRoot, flags, current2);
                            hoistableRoot[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(hoistableRoot);
                            flags = hoistableRoot;
                            break a;
                          case "link":
                            var maybeNodes = getHydratableHoistableCache(
                              "link",
                              "href",
                              root2
                            ).get(flags + (current2.href || ""));
                            if (maybeNodes) {
                              for (var i = 0; i < maybeNodes.length; i++)
                                if (hoistableRoot = maybeNodes[i], hoistableRoot.getAttribute("href") === (null == current2.href || "" === current2.href ? null : current2.href) && hoistableRoot.getAttribute("rel") === (null == current2.rel ? null : current2.rel) && hoistableRoot.getAttribute("title") === (null == current2.title ? null : current2.title) && hoistableRoot.getAttribute("crossorigin") === (null == current2.crossOrigin ? null : current2.crossOrigin)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            hoistableRoot = root2.createElement(flags);
                            setInitialProperties(hoistableRoot, flags, current2);
                            root2.head.appendChild(hoistableRoot);
                            break;
                          case "meta":
                            if (maybeNodes = getHydratableHoistableCache(
                              "meta",
                              "content",
                              root2
                            ).get(flags + (current2.content || ""))) {
                              for (i = 0; i < maybeNodes.length; i++)
                                if (hoistableRoot = maybeNodes[i], checkAttributeStringCoercion(
                                  current2.content,
                                  "content"
                                ), hoistableRoot.getAttribute("content") === (null == current2.content ? null : "" + current2.content) && hoistableRoot.getAttribute("name") === (null == current2.name ? null : current2.name) && hoistableRoot.getAttribute("property") === (null == current2.property ? null : current2.property) && hoistableRoot.getAttribute("http-equiv") === (null == current2.httpEquiv ? null : current2.httpEquiv) && hoistableRoot.getAttribute("charset") === (null == current2.charSet ? null : current2.charSet)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            hoistableRoot = root2.createElement(flags);
                            setInitialProperties(hoistableRoot, flags, current2);
                            root2.head.appendChild(hoistableRoot);
                            break;
                          default:
                            throw Error(
                              'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
                            );
                        }
                        hoistableRoot[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(hoistableRoot);
                        flags = hoistableRoot;
                      }
                      finishedWork.stateNode = flags;
                    } else
                      mountHoistable(
                        hoistableRoot,
                        finishedWork.type,
                        finishedWork.stateNode
                      );
                  else
                    finishedWork.stateNode = acquireResource(
                      hoistableRoot,
                      flags,
                      finishedWork.memoizedProps
                    );
                else
                  root2 !== flags ? (null === root2 ? null !== current2.stateNode && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : root2.count--, null === flags ? mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  ) : acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current2.memoizedProps
                  );
              break;
            case 27:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              null !== current2 && flags & 4 && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current2.memoizedProps
              );
              break;
            case 5:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
              if (finishedWork.flags & 32) {
                root2 = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(finishedWork, resetTextContent, root2);
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              flags & 4 && null != finishedWork.stateNode && (root2 = finishedWork.memoizedProps, commitHostUpdate(
                finishedWork,
                root2,
                null !== current2 ? current2.memoizedProps : root2
              ));
              flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
              break;
            case 6:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & 4) {
                if (null === finishedWork.stateNode)
                  throw Error(
                    "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                  );
                flags = finishedWork.memoizedProps;
                current2 = null !== current2 ? current2.memoizedProps : flags;
                root2 = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitTextUpdate,
                    root2,
                    current2,
                    flags
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              break;
            case 3:
              hoistableRoot = pushNestedEffectDurations();
              tagCaches = null;
              maybeNodes = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(root2.containerInfo);
              recursivelyTraverseMutationEffects(root2, finishedWork);
              currentHoistableRoot = maybeNodes;
              commitReconciliationEffects(finishedWork);
              if (flags & 4 && null !== current2 && current2.memoizedState.isDehydrated)
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHydratedContainer,
                    root2.containerInfo
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
              root2.effectDuration += popNestedEffectDurations(hoistableRoot);
              break;
            case 4:
              flags = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                finishedWork.stateNode.containerInfo
              );
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              currentHoistableRoot = flags;
              break;
            case 12:
              flags = pushNestedEffectDurations();
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
              break;
            case 13:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 22:
              hoistableRoot = null !== finishedWork.memoizedState;
              var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              commitReconciliationEffects(finishedWork);
              if (flags & 8192)
                a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & ~OffscreenVisible : root2._visibility | OffscreenVisible, hoistableRoot && (null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current2 = null, root2 = finishedWork; ; ) {
                  if (5 === root2.tag || 26 === root2.tag) {
                    if (null === current2) {
                      wasHidden = current2 = root2;
                      try {
                        maybeNodes = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, maybeNodes) : runWithFiberInDEV(
                          wasHidden,
                          unhideInstance,
                          wasHidden.stateNode,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (6 === root2.tag) {
                    if (null === current2) {
                      wasHidden = root2;
                      try {
                        i = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, i) : runWithFiberInDEV(
                          wasHidden,
                          unhideTextInstance,
                          i,
                          wasHidden.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                    root2.child.return = root2;
                    root2 = root2.child;
                    continue;
                  }
                  if (root2 === finishedWork) break a;
                  for (; null === root2.sibling; ) {
                    if (null === root2.return || root2.return === finishedWork)
                      break a;
                    current2 === root2 && (current2 = null);
                    root2 = root2.return;
                  }
                  current2 === root2 && (current2 = null);
                  root2.sibling.return = root2.return;
                  root2 = root2.sibling;
                }
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
              break;
            case 19:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 30:
              break;
            case 21:
              break;
            default:
              recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & 2) {
            try {
              runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
            finishedWork.flags &= -3;
          }
          flags & 4096 && (finishedWork.flags &= -4097);
        }
        function recursivelyResetForms(parentFiber) {
          if (parentFiber.subtreeFlags & 1024)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var fiber = parentFiber;
              recursivelyResetForms(fiber);
              5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseLayoutEffects(root2, parentFiber) {
          if (parentFiber.subtreeFlags & 8772)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
        }
        function disappearLayoutEffects(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              runWithFiberInDEV(
                finishedWork,
                releaseSingletonInstance,
                finishedWork.stateNode
              );
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
        }
        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
        }
        function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookLayoutEffects(finishedWork, Layout);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current2 = finishedWork.stateNode;
              "function" === typeof current2.componentDidMount && runWithFiberInDEV(
                finishedWork,
                callComponentDidMountInDEV,
                finishedWork,
                current2
              );
              current2 = finishedWork.updateQueue;
              if (null !== current2) {
                finishedRoot = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHiddenCallbacks,
                    current2,
                    finishedRoot
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (includeWorkInProgressEffects && flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects = finishedWork.stateNode;
                includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current2,
                    commitStartTime,
                    includeWorkInProgressEffects.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
        }
        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reappearLayoutEffects(
              finishedRoot,
              parentFiber.alternate,
              parentFiber,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function commitOffscreenPassiveMountEffects(current2, finishedWork) {
          var previousCache = null;
          null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
          current2 = null;
          null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
          current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
        }
        function commitCachePassiveMountEffect(current2, finishedWork) {
          current2 = null;
          null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
          finishedWork = finishedWork.memoizedState.cache;
          finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
        }
        function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveMountOnFiber(
                root2,
                parentFiber,
                committedLanes,
                committedTransitions
              ), parentFiber = parentFiber.sibling;
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
              break;
            case 1:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              break;
            case 3:
              var prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));
              finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
              break;
            case 12:
              if (flags & 2048) {
                flags = pushNestedEffectDurations();
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
                finishedRoot = finishedWork.stateNode;
                finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfilerPostCommitImpl,
                    finishedWork,
                    finishedWork.alternate,
                    commitStartTime,
                    finishedRoot.passiveEffectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
              break;
            case 13:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              break;
            case 23:
              break;
            case 22:
              prevEffectDuration = finishedWork.stateNode;
              var _current = finishedWork.alternate;
              null !== finishedWork.memoizedState ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              ) : (prevEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                0 !== (finishedWork.subtreeFlags & 10256)
              ));
              flags & 2048 && commitOffscreenPassiveMountEffects(_current, finishedWork);
              break;
            case 24:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
          }
        }
        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reconnectPassiveEffects(
              finishedRoot,
              parentFiber,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookPassiveMountEffects(finishedWork, Passive);
              break;
            case 23:
              break;
            case 22:
              var _instance2 = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
        }
        function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
              switch (finishedWork.tag) {
                case 22:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
                  flags & 2048 && commitOffscreenPassiveMountEffects(
                    finishedWork.alternate,
                    finishedWork
                  );
                  break;
                case 24:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
                  flags & 2048 && commitCachePassiveMountEffect(
                    finishedWork.alternate,
                    finishedWork
                  );
                  break;
                default:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
              }
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyAccumulateSuspenseyCommit(parentFiber) {
          if (parentFiber.subtreeFlags & suspenseyCommitFlag)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function accumulateSuspenseyCommitOnFiber(fiber) {
          switch (fiber.tag) {
            case 26:
              recursivelyAccumulateSuspenseyCommit(fiber);
              fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
                currentHoistableRoot,
                fiber.memoizedState,
                fiber.memoizedProps
              );
              break;
            case 5:
              recursivelyAccumulateSuspenseyCommit(fiber);
              break;
            case 3:
            case 4:
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo
              );
              recursivelyAccumulateSuspenseyCommit(fiber);
              currentHoistableRoot = previousHoistableRoot;
              break;
            case 22:
              null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
              break;
            default:
              recursivelyAccumulateSuspenseyCommit(fiber);
          }
        }
        function detachAlternateSiblings(parentFiber) {
          var previousFiber = parentFiber.alternate;
          if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
            previousFiber.child = null;
            do
              previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
            while (null !== parentFiber);
          }
        }
        function recursivelyTraversePassiveUnmountEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
              }
            detachAlternateSiblings(parentFiber);
          }
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive | HasEffect
              );
              break;
            case 3:
              var prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
              break;
            case 12:
              prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
              break;
            case 22:
              prevEffectDuration = finishedWork.stateNode;
              null !== finishedWork.memoizedState && prevEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            default:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
          }
        }
        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
              }
            detachAlternateSiblings(parentFiber);
          }
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
        }
        function disconnectPassiveEffect(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive
              );
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
              break;
            case 22:
              var instance = finishedWork.stateNode;
              instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
          for (; null !== nextEffect; ) {
            var fiber = nextEffect, current2 = fiber;
            switch (current2.tag) {
              case 0:
              case 11:
              case 15:
                commitHookPassiveUnmountEffects(
                  current2,
                  nearestMountedAncestor,
                  Passive
                );
                break;
              case 23:
              case 22:
                null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (current2 = current2.memoizedState.cachePool.pool, null != current2 && retainCache(current2));
                break;
              case 24:
                releaseCache(current2.memoizedState.cache);
            }
            current2 = fiber.child;
            if (null !== current2) current2.return = fiber, nextEffect = current2;
            else
              a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                current2 = nextEffect;
                var sibling = current2.sibling, returnFiber = current2.return;
                detachFiberAfterEffects(current2);
                if (current2 === fiber) {
                  nextEffect = null;
                  break a;
                }
                if (null !== sibling) {
                  sibling.return = returnFiber;
                  nextEffect = sibling;
                  break a;
                }
                nextEffect = returnFiber;
              }
          }
        }
        function onCommitRoot() {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
        function isConcurrentActEnvironment() {
          var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
          isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
            "The current testing environment is not configured to support act(...)"
          );
          return isReactActEnvironmentGlobal;
        }
        function requestUpdateLane(fiber) {
          if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
            return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
          var transition = ReactSharedInternals.T;
          return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();
        }
        function requestDeferredLane() {
          0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
          var suspenseHandler = suspenseHandlerStackCursor.current;
          null !== suspenseHandler && (suspenseHandler.flags |= 32);
          return workInProgressDeferredLane;
        }
        function scheduleUpdateOnFiber(root2, fiber, lane) {
          isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
          isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
          if (root2 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
            prepareFreshStack(root2, 0), markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            );
          markRootUpdated$1(root2, lane);
          if (0 !== (executionContext & RenderContext) && root2 === workInProgressRoot) {
            if (isRendering)
              switch (fiber.tag) {
                case 0:
                case 11:
                case 15:
                  root2 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  didWarnAboutUpdateInRenderForAnotherComponent.has(root2) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root2), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                    "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                    fiber,
                    root2,
                    root2
                  ));
                  break;
                case 1:
                  didWarnAboutUpdateInRender || (console.error(
                    "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                  ), didWarnAboutUpdateInRender = true);
              }
          } else
            isDevToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            )), ensureRootIsScheduled(root2);
        }
        function performWorkOnRoot(root2, lanes, forceSync) {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root2.expiredLanes) || checkIfRootIsPrerendering(root2, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true), renderWasConcurrent = shouldTimeSlice;
          do {
            if (exitStatus === RootInProgress) {
              workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root2, lanes, 0, false);
              break;
            } else {
              forceSync = root2.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
                exitStatus = renderRootSync(root2, lanes, false);
                renderWasConcurrent = false;
                continue;
              }
              if (exitStatus === RootErrored) {
                renderWasConcurrent = lanes;
                if (root2.errorRecoveryDisabledLanes & renderWasConcurrent)
                  var errorRetryLanes = 0;
                else
                  errorRetryLanes = root2.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
                if (0 !== errorRetryLanes) {
                  lanes = errorRetryLanes;
                  a: {
                    exitStatus = root2;
                    var errorRetryLanes$jscomp$0 = errorRetryLanes;
                    errorRetryLanes = workInProgressRootConcurrentErrors;
                    var wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;
                    wasRootDehydrated && (prepareFreshStack(
                      exitStatus,
                      errorRetryLanes$jscomp$0
                    ).flags |= 256);
                    errorRetryLanes$jscomp$0 = renderRootSync(
                      exitStatus,
                      errorRetryLanes$jscomp$0,
                      false
                    );
                    if (errorRetryLanes$jscomp$0 !== RootErrored) {
                      if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                        exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
                        workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                        exitStatus = RootSuspendedWithDelay;
                        break a;
                      }
                      exitStatus = workInProgressRootRecoverableErrors;
                      workInProgressRootRecoverableErrors = errorRetryLanes;
                      null !== exitStatus && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = exitStatus : workInProgressRootRecoverableErrors.push.apply(
                        workInProgressRootRecoverableErrors,
                        exitStatus
                      ));
                    }
                    exitStatus = errorRetryLanes$jscomp$0;
                  }
                  renderWasConcurrent = false;
                  if (exitStatus !== RootErrored) continue;
                }
              }
              if (exitStatus === RootFatalErrored) {
                prepareFreshStack(root2, 0);
                markRootSuspended(root2, lanes, 0, true);
                break;
              }
              a: {
                shouldTimeSlice = root2;
                switch (exitStatus) {
                  case RootInProgress:
                  case RootFatalErrored:
                    throw Error("Root did not complete. This is a bug in React.");
                  case RootSuspendedWithDelay:
                    if ((lanes & 4194048) !== lanes) break;
                  case RootSuspendedAtTheShell:
                    markRootSuspended(
                      shouldTimeSlice,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    break a;
                  case RootErrored:
                    workInProgressRootRecoverableErrors = null;
                    break;
                  case RootSuspended:
                  case RootCompleted:
                    break;
                  default:
                    throw Error("Unknown root exit status.");
                }
                if (null !== ReactSharedInternals.actQueue)
                  commitRoot(
                    shouldTimeSlice,
                    forceSync,
                    lanes,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes
                  );
                else {
                  if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                    markRootSuspended(
                      shouldTimeSlice,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                    shouldTimeSlice.timeoutHandle = scheduleTimeout(
                      commitRootWhenReady.bind(
                        null,
                        shouldTimeSlice,
                        forceSync,
                        workInProgressRootRecoverableErrors,
                        workInProgressTransitions,
                        workInProgressRootDidIncludeRecursiveRenderUpdate,
                        lanes,
                        workInProgressDeferredLane,
                        workInProgressRootInterleavedUpdatedLanes,
                        workInProgressSuspendedRetryLanes,
                        workInProgressRootDidSkipSuspendedSiblings,
                        exitStatus,
                        THROTTLED_COMMIT,
                        renderStartTime,
                        0
                      ),
                      renderWasConcurrent
                    );
                    break a;
                  }
                  commitRootWhenReady(
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    exitStatus,
                    IMMEDIATE_COMMIT,
                    renderStartTime,
                    0
                  );
                }
              }
            }
            break;
          } while (1);
          ensureRootIsScheduled(root2);
        }
        function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          root2.timeoutHandle = noTimeout;
          suspendedCommitReason = finishedWork.subtreeFlags;
          if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
            if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
              root2.cancelPendingCommit = suspendedCommitReason(
                commitRoot.bind(
                  null,
                  root2,
                  finishedWork,
                  lanes,
                  recoverableErrors,
                  transitions,
                  didIncludeRenderPhaseUpdate,
                  spawnedLane,
                  updatedLanes,
                  suspendedRetryLanes,
                  exitStatus,
                  SUSPENDED_COMMIT,
                  completedRenderStartTime,
                  completedRenderEndTime
                )
              );
              markRootSuspended(
                root2,
                lanes,
                spawnedLane,
                !didSkipSuspendedSiblings
              );
              return;
            }
          }
          commitRoot(
            root2,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          for (var node = finishedWork; ; ) {
            var tag = node.tag;
            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
              for (var i = 0; i < tag.length; i++) {
                var check = tag[i], getSnapshot = check.getSnapshot;
                check = check.value;
                try {
                  if (!objectIs(getSnapshot(), check)) return false;
                } catch (error) {
                  return false;
                }
              }
            tag = node.child;
            if (node.subtreeFlags & 16384 && null !== tag)
              tag.return = node, node = tag;
            else {
              if (node === finishedWork) break;
              for (; null === node.sibling; ) {
                if (null === node.return || node.return === finishedWork) return true;
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return true;
        }
        function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
          suspendedLanes &= ~workInProgressRootPingedLanes;
          suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
          root2.suspendedLanes |= suspendedLanes;
          root2.pingedLanes &= ~suspendedLanes;
          didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
          didAttemptEntireTree = root2.expirationTimes;
          for (var lanes = suspendedLanes; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index;
            didAttemptEntireTree[index] = -1;
            lanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
        }
        function flushSyncWork$1() {
          return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
        }
        function resetWorkInProgressStack() {
          if (null !== workInProgress) {
            if (workInProgressSuspendedReason === NotSuspended)
              var interruptedWork = workInProgress.return;
            else
              interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
            for (; null !== interruptedWork; )
              unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
            workInProgress = null;
          }
        }
        function prepareFreshStack(root2, lanes) {
          var timeoutHandle = root2.timeoutHandle;
          timeoutHandle !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
          timeoutHandle = root2.cancelPendingCommit;
          null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
          resetWorkInProgressStack();
          workInProgressRoot = root2;
          workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
          workInProgressRootRenderLanes = lanes;
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          workInProgressRootDidSkipSuspendedSiblings = false;
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
          workInProgressRootDidAttachPingListener = false;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
          workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
          workInProgressRootDidIncludeRecursiveRenderUpdate = false;
          0 !== (lanes & 8) && (lanes |= lanes & 32);
          var allEntangledLanes = root2.entangledLanes;
          if (0 !== allEntangledLanes)
            for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
              var index = 31 - clz32(allEntangledLanes), lane = 1 << index;
              lanes |= root2[index];
              allEntangledLanes &= ~lane;
            }
          entangledRenderLanes = lanes;
          finishQueueingConcurrentUpdates();
          lanes = getCurrentTime();
          1e3 < lanes - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = lanes);
          ReactStrictModeWarnings.discardPendingWarnings();
          return timeoutHandle;
        }
        function handleThrow(root2, thrownValue) {
          currentlyRenderingFiber = null;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          ReactSharedInternals.getCurrentStack = null;
          isRendering = false;
          current = null;
          thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
          workInProgressThrownValue = thrownValue;
          var erroredWork = workInProgress;
          if (null === erroredWork)
            workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
          else
            switch (erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason) {
              case SuspendedOnError:
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(
                  erroredWork,
                  thrownValue,
                  workInProgressRootRenderLanes
                );
                break;
              case SuspendedOnData:
              case SuspendedOnAction:
              case SuspendedOnImmediate:
              case SuspendedOnDeprecatedThrowPromise:
              case SuspendedAndReadyToContinue:
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(
                  erroredWork,
                  thrownValue,
                  workInProgressRootRenderLanes
                );
            }
        }
        function pushDispatcher() {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
        }
        function pushAsyncDispatcher() {
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          return prevAsyncDispatcher;
        }
        function renderDidSuspendDelayIfPossible() {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
          workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
          0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
            workInProgressRoot,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        }
        function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            prepareFreshStack(root2, lanes);
          }
          markRenderStarted(lanes);
          lanes = false;
          memoizedUpdaters = workInProgressRootExitStatus;
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    memoizedUpdaters = RootSuspendedAtTheShell;
                    break a;
                  case SuspendedOnImmediate:
                  case SuspendedOnData:
                  case SuspendedOnAction:
                  case SuspendedOnDeprecatedThrowPromise:
                    null === suspenseHandlerStackCursor.current && (lanes = true);
                    var reason = workInProgressSuspendedReason;
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                    if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                      memoizedUpdaters = RootInProgress;
                      break a;
                    }
                    break;
                  default:
                    reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                }
              }
              workLoopSync();
              memoizedUpdaters = workInProgressRootExitStatus;
              break;
            } catch (thrownValue$8) {
              handleThrow(root2, thrownValue$8);
            }
          while (1);
          lanes && root2.shellSuspendCounter++;
          resetContextDependencies();
          executionContext = prevExecutionContext;
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          markRenderStopped();
          null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
          return memoizedUpdaters;
        }
        function workLoopSync() {
          for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
        }
        function renderRootConcurrent(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
            prepareFreshStack(root2, lanes);
          } else
            workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
              root2,
              lanes
            );
          markRenderStarted(lanes);
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
                b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnError
                    );
                    break;
                  case SuspendedOnData:
                  case SuspendedOnAction:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root2 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root2);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress;
                        if (resource ? preloadResource(resource) : 1) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (null !== sibling) workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error(
                          "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                        );
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnInstanceAndReadyToContinue
                    );
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnDeprecatedThrowPromise
                    );
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  default:
                    throw Error(
                      "Unexpected SuspendedReason. This is a bug in React."
                    );
                }
              null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
              break;
            } catch (thrownValue$9) {
              handleThrow(root2, thrownValue$9);
            }
          while (1);
          resetContextDependencies();
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          executionContext = prevExecutionContext;
          if (null !== workInProgress)
            return null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;
          markRenderStopped();
          workInProgressRoot = null;
          workInProgressRootRenderLanes = 0;
          finishQueueingConcurrentUpdates();
          return workInProgressRootExitStatus;
        }
        function workLoopConcurrentByScheduler() {
          for (; null !== workInProgress && !shouldYield(); )
            performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current2,
            unitOfWork,
            entangledRenderLanes
          );
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
        }
        function replaySuspendedUnitOfWork(unitOfWork) {
          var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
        }
        function replayBeginWork(unitOfWork) {
          var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
          isProfilingMode && startProfilerTimer(unitOfWork);
          switch (unitOfWork.tag) {
            case 15:
            case 0:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type,
                void 0,
                workInProgressRootRenderLanes
              );
              break;
            case 11:
              current2 = replayFunctionComponent(
                current2,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type.render,
                unitOfWork.ref,
                workInProgressRootRenderLanes
              );
              break;
            case 5:
              resetHooksOnUnwind(unitOfWork);
            default:
              unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
          }
          isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
          return current2;
        }
        function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
          resetContextDependencies();
          resetHooksOnUnwind(unitOfWork);
          thenableState = null;
          thenableIndexCounter = 0;
          var returnFiber = unitOfWork.return;
          try {
            if (throwException(
              root2,
              returnFiber,
              unitOfWork,
              thrownValue,
              workInProgressRootRenderLanes
            )) {
              workInProgressRootExitStatus = RootFatalErrored;
              logUncaughtError(
                root2,
                createCapturedValueAtFiber(thrownValue, root2.current)
              );
              workInProgress = null;
              return;
            }
          } catch (error) {
            if (null !== returnFiber) throw workInProgress = returnFiber, error;
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
          if (unitOfWork.flags & 32768) {
            if (isHydrating || suspendedReason === SuspendedOnError) root2 = true;
            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
              root2 = false;
            else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
              suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
            unwindUnitOfWork(unitOfWork, root2);
          } else completeUnitOfWork(unitOfWork);
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            if (0 !== (completedWork.flags & 32768)) {
              unwindUnitOfWork(
                completedWork,
                workInProgressRootDidSkipSuspendedSiblings
              );
              return;
            }
            var current2 = completedWork.alternate;
            unitOfWork = completedWork.return;
            startProfilerTimer(completedWork);
            current2 = runWithFiberInDEV(
              completedWork,
              completeWork,
              current2,
              completedWork,
              entangledRenderLanes
            );
            (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
            if (null !== current2) {
              workInProgress = current2;
              return;
            }
            completedWork = completedWork.sibling;
            if (null !== completedWork) {
              workInProgress = completedWork;
              return;
            }
            workInProgress = completedWork = unitOfWork;
          } while (null !== completedWork);
          workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
        }
        function unwindUnitOfWork(unitOfWork, skipSiblings) {
          do {
            var next = unwindWork(unitOfWork.alternate, unitOfWork);
            if (null !== next) {
              next.flags &= 32767;
              workInProgress = next;
              return;
            }
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
              next = unitOfWork.actualDuration;
              for (var child = unitOfWork.child; null !== child; )
                next += child.actualDuration, child = child.sibling;
              unitOfWork.actualDuration = next;
            }
            next = unitOfWork.return;
            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
              workInProgress = unitOfWork;
              return;
            }
            workInProgress = unitOfWork = next;
          } while (null !== unitOfWork);
          workInProgressRootExitStatus = RootSuspendedAtTheShell;
          workInProgress = null;
        }
        function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
          root2.cancelPendingCommit = null;
          do
            flushPendingEffects();
          while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
          ReactStrictModeWarnings.flushLegacyContextWarning();
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(lanes);
          if (null === finishedWork) markCommitStopped();
          else {
            0 === lanes && console.error(
              "finishedLanes should not be empty during a commit. This is a bug in React."
            );
            if (finishedWork === root2.current)
              throw Error(
                "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
              );
            didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
            didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
            markRootFinished(
              root2,
              lanes,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes
            );
            root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
            pendingFinishedWork = finishedWork;
            pendingEffectsRoot = root2;
            pendingEffectsLanes = lanes;
            pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
            pendingPassiveTransitions = transitions;
            pendingRecoverableErrors = recoverableErrors;
            0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
              flushPassiveEffects(true);
              return null;
            })) : (root2.callbackNode = null, root2.callbackPriority = 0);
            commitStartTime = now();
            recoverableErrors = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
              recoverableErrors = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              transitions = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              spawnedLane = executionContext;
              executionContext |= CommitContext;
              try {
                commitBeforeMutationEffects(root2, finishedWork, lanes);
              } finally {
                executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
              }
            }
            pendingEffectsStatus = PENDING_MUTATION_PHASE;
            flushMutationEffects();
            flushLayoutEffects();
            flushSpawnedWork();
          }
        }
        function flushMutationEffects() {
          if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
            if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
              rootMutationHasEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                inProgressLanes = lanes;
                inProgressRoot = root2;
                commitMutationEffectsOnFiber(finishedWork, root2);
                inProgressRoot = inProgressLanes = null;
                lanes = selectionInformation;
                var curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
                if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                  priorFocusedElem.ownerDocument.documentElement,
                  priorFocusedElem
                )) {
                  if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                    var start = priorSelectionRange.start, end = priorSelectionRange.end;
                    void 0 === end && (end = start);
                    if ("selectionStart" in priorFocusedElem)
                      priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                        end,
                        priorFocusedElem.value.length
                      );
                    else {
                      var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                      if (win.getSelection) {
                        var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(
                          priorSelectionRange.start,
                          length
                        ), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                        !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                        var startMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          start$jscomp$0
                        ), endMarker = getNodeForCharacterOffset(
                          priorFocusedElem,
                          end$jscomp$0
                        );
                        if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                          var range = doc.createRange();
                          range.setStart(startMarker.node, startMarker.offset);
                          selection.removeAllRanges();
                          start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                        }
                      }
                    }
                  }
                  doc = [];
                  for (selection = priorFocusedElem; selection = selection.parentNode; )
                    1 === selection.nodeType && doc.push({
                      element: selection,
                      left: selection.scrollLeft,
                      top: selection.scrollTop
                    });
                  "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                  for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                    var info = doc[priorFocusedElem];
                    info.element.scrollLeft = info.left;
                    info.element.scrollTop = info.top;
                  }
                }
                _enabled = !!eventsEnabled;
                selectionInformation = eventsEnabled = null;
              } finally {
                executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
              }
            }
            root2.current = finishedWork;
            pendingEffectsStatus = PENDING_LAYOUT_PHASE;
          }
        }
        function flushLayoutEffects() {
          if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
            if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
              rootHasLayoutEffect = ReactSharedInternals.T;
              ReactSharedInternals.T = null;
              var previousPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              try {
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(lanes), inProgressLanes = lanes, inProgressRoot = root2, commitLayoutEffectOnFiber(
                  root2,
                  finishedWork.alternate,
                  finishedWork
                ), inProgressRoot = inProgressLanes = null, null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped();
              } finally {
                executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
              }
            }
            pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
          }
        }
        function flushSpawnedWork() {
          if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            requestPaint();
            var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors, rootDidHavePassiveEffects = 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
            rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
            var remainingLanes = root2.pendingLanes;
            0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
            rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root2);
            rootDidHavePassiveEffects = lanesToEventPriority(lanes);
            finishedWork = finishedWork.stateNode;
            if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
              try {
                var didError = 128 === (finishedWork.current.flags & 128);
                switch (rootDidHavePassiveEffects) {
                  case DiscreteEventPriority:
                    var schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority$1;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority$1;
                }
                injectedHook.onCommitFiberRoot(
                  rendererID,
                  finishedWork,
                  schedulerPriority,
                  didError
                );
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %s",
                  err
                ));
              }
            isDevToolsPresent && root2.memoizedUpdaters.clear();
            onCommitRoot();
            if (null !== recoverableErrors) {
              didError = ReactSharedInternals.T;
              schedulerPriority = ReactDOMSharedInternals.p;
              ReactDOMSharedInternals.p = DiscreteEventPriority;
              ReactSharedInternals.T = null;
              try {
                var onRecoverableError = root2.onRecoverableError;
                for (finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++) {
                  var recoverableError = recoverableErrors[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
                  runWithFiberInDEV(
                    recoverableError.source,
                    onRecoverableError,
                    recoverableError.value,
                    errorInfo
                  );
                }
              } finally {
                ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
              }
            }
            0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
            ensureRootIsScheduled(root2);
            remainingLanes = root2.pendingLanes;
            0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2)) : nestedUpdateCount = 0;
            flushSyncWorkAcrossRoots_impl(0, false);
            markCommitStopped();
          }
        }
        function makeErrorInfo(componentStack) {
          componentStack = { componentStack };
          Object.defineProperty(componentStack, "digest", {
            get: function() {
              console.error(
                'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
              );
            }
          });
          return componentStack;
        }
        function releaseRootPooledCache(root2, remainingLanes) {
          0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
        }
        function flushPendingEffects(wasDelayedCommit) {
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
          return flushPassiveEffects(wasDelayedCommit);
        }
        function flushPassiveEffects() {
          if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
          var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
          pendingEffectsRemainingLanes = 0;
          var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
          renderPriority = ReactSharedInternals.T;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = priority;
            ReactSharedInternals.T = null;
            priority = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
            pendingEffectsStatus = NO_PENDING_EFFECTS;
            pendingFinishedWork = pendingEffectsRoot = null;
            pendingEffectsLanes = 0;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
              throw Error("Cannot flush passive effects while already rendering.");
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountOnFiber(root$jscomp$0.current);
            commitPassiveMountOnFiber(
              root$jscomp$0,
              root$jscomp$0.current,
              lanes,
              priority
            );
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();
            commitDoubleInvokeEffectsInDEV(root$jscomp$0);
            executionContext = prevExecutionContext;
            flushSyncWorkAcrossRoots_impl(0, false);
            didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;
            didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
            if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
              } catch (err) {
                hasLoggedError || (hasLoggedError = true, console.error(
                  "React instrumentation encountered an error: %s",
                  err
                ));
              }
            var stateNode = root$jscomp$0.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
            return true;
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root2, remainingLanes);
          }
        }
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
          rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
          null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
          isRunningInsertionEffect = false;
          if (3 === sourceFiber.tag)
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
          else {
            for (; null !== nearestMountedAncestor; ) {
              if (3 === nearestMountedAncestor.tag) {
                captureCommitPhaseErrorOnRoot(
                  nearestMountedAncestor,
                  sourceFiber,
                  error
                );
                return;
              }
              if (1 === nearestMountedAncestor.tag) {
                var instance = nearestMountedAncestor.stateNode;
                if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                  error = createClassErrorUpdate(2);
                  instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                  null !== instance && (initializeClassErrorUpdate(
                    error,
                    instance,
                    nearestMountedAncestor,
                    sourceFiber
                  ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                  return;
                }
              }
              nearestMountedAncestor = nearestMountedAncestor.return;
            }
            console.error(
              "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
              error
            );
          }
        }
        function attachPingListener(root2, wakeable, lanes) {
          var pingCache = root2.pingCache;
          if (null === pingCache) {
            pingCache = root2.pingCache = new PossiblyWeakMap();
            var threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else
            threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
          threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root2, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(pingCache, pingCache));
        }
        function pingSuspendedRoot(root2, wakeable, pingedLanes) {
          var pingCache = root2.pingCache;
          null !== pingCache && pingCache.delete(wakeable);
          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          root2.warmLanes &= ~pingedLanes;
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
            "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
          );
          workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
          ensureRootIsScheduled(root2);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          0 === retryLane && (retryLane = claimNextRetryLane());
          boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = 0;
          switch (boundaryFiber.tag) {
            case 13:
              var retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              null !== suspenseState && (retryLane = suspenseState.retryLane);
              break;
            case 19:
              retryCache = boundaryFiber.stateNode;
              break;
            case 22:
              retryCache = boundaryFiber.stateNode._retryCache;
              break;
            default:
              throw Error(
                "Pinged unknown suspense boundary type. This is probably a bug in React."
              );
          }
          null !== retryCache && retryCache.delete(wakeable);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
          if (0 !== (parentFiber.subtreeFlags & 67117056))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var root2 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
              isStrictModeFiber = isInStrictMode || isStrictModeFiber;
              22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber,
                (fiber.mode & NoStrictPassiveEffectsMode) === NoMode
              ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                root2,
                fiber,
                isStrictModeFiber
              ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber
              ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
                fiber,
                recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                root2,
                fiber,
                isStrictModeFiber
              ));
              parentFiber = parentFiber.sibling;
            }
        }
        function doubleInvokeEffectsOnFiber(root2, fiber) {
          var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : true;
          setIsStrictModeForDevtools(true);
          try {
            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root2, fiber.alternate, fiber, false), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root2, fiber, 0, null, false, 0);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        function commitDoubleInvokeEffectsInDEV(root2) {
          var doubleInvokeEffects = true;
          root2.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
          recursivelyTraverseAndDoubleInvokeEffectsInDEV(
            root2,
            root2.current,
            doubleInvokeEffects
          );
        }
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          if ((executionContext & RenderContext) === NoContext) {
            var tag = fiber.tag;
            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
              tag = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (null !== didWarnStateUpdateForNotYetMountedComponent) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
                didWarnStateUpdateForNotYetMountedComponent.add(tag);
              } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
              runWithFiberInDEV(fiber, function() {
                console.error(
                  "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
                );
              });
            }
          }
        }
        function restorePendingUpdaters(root2, lanes) {
          isDevToolsPresent && root2.memoizedUpdaters.forEach(function(schedulingFiber) {
            addFiberToLanesMap(root2, schedulingFiber, lanes);
          });
        }
        function scheduleCallback$1(priorityLevel, callback) {
          var actQueue = ReactSharedInternals.actQueue;
          return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
            console.error(
              "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
              getComponentNameFromFiber(fiber)
            );
          });
        }
        function ensureRootIsScheduled(root2) {
          root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
          mightHavePendingSyncWork = true;
          null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
        }
        function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
          if (!isFlushingWork && mightHavePendingSyncWork) {
            isFlushingWork = true;
            do {
              var didPerformSomeWork = false;
              for (var root2 = firstScheduledRoot; null !== root2; ) {
                if (!onlyLegacy)
                  if (0 !== syncTransitionLanes) {
                    var pendingLanes = root2.pendingLanes;
                    if (0 === pendingLanes) var nextLanes = 0;
                    else {
                      var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
                      nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                      nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                      nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                    }
                    0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                  } else
                    nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                      root2,
                      root2 === workInProgressRoot ? nextLanes : 0,
                      null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
                    ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root2, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                root2 = root2.next;
              }
            } while (didPerformSomeWork);
            isFlushingWork = false;
          }
        }
        function processRootScheduleInImmediateTask() {
          processRootScheduleInMicrotask();
        }
        function processRootScheduleInMicrotask() {
          mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
          var syncTransitionLanes = 0;
          0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
          for (var currentTime = now$1(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
            var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
            if (0 === nextLanes)
              root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
            else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
              mightHavePendingSyncWork = true;
            root2 = next;
          }
          flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
        }
        function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
          for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
            if (-1 === expirationTime) {
              if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                expirationTimes[index] = computeExpirationTime(lane, currentTime);
            } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
            lanes &= ~lane;
          }
          currentTime = workInProgressRoot;
          suspendedLanes = workInProgressRootRenderLanes;
          suspendedLanes = getNextLanes(
            root2,
            root2 === currentTime ? suspendedLanes : 0,
            null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
          );
          pingedLanes = root2.callbackNode;
          if (0 === suspendedLanes || root2 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
            return null !== pingedLanes && cancelCallback(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
          if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
            currentTime = suspendedLanes & -suspendedLanes;
            if (currentTime !== root2.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
              cancelCallback(pingedLanes);
            else return currentTime;
            switch (lanesToEventPriority(suspendedLanes)) {
              case DiscreteEventPriority:
              case ContinuousEventPriority:
                suspendedLanes = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                suspendedLanes = NormalPriority$1;
                break;
              case IdleEventPriority:
                suspendedLanes = IdlePriority;
                break;
              default:
                suspendedLanes = NormalPriority$1;
            }
            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
            root2.callbackPriority = currentTime;
            root2.callbackNode = suspendedLanes;
            return currentTime;
          }
          null !== pingedLanes && cancelCallback(pingedLanes);
          root2.callbackPriority = 2;
          root2.callbackNode = null;
          return 2;
        }
        function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
          nestedUpdateScheduled = currentUpdateIsNested = false;
          if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
            return root2.callbackNode = null, root2.callbackPriority = 0, null;
          var originalCallbackNode = root2.callbackNode;
          if (flushPendingEffects(true) && root2.callbackNode !== originalCallbackNode)
            return null;
          var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
          workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
            root2,
            root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
            null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
          );
          if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
          performWorkOnRoot(
            root2,
            workInProgressRootRenderLanes$jscomp$0,
            didTimeout
          );
          scheduleTaskForRootDuringMicrotask(root2, now$1());
          return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
        }
        function performSyncWorkOnRoot(root2, lanes) {
          if (flushPendingEffects()) return null;
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
          performWorkOnRoot(root2, lanes, true);
        }
        function cancelCallback(callbackNode) {
          callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
        }
        function scheduleImmediateRootScheduleTask() {
          null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
            processRootScheduleInMicrotask();
            return null;
          });
          scheduleMicrotask(function() {
            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
              ImmediatePriority,
              processRootScheduleInImmediateTask
            ) : processRootScheduleInMicrotask();
          });
        }
        function requestTransitionLane() {
          0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
          return currentEventTransitionLane;
        }
        function coerceFormActionProp(actionProp) {
          if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
            return null;
          if ("function" === typeof actionProp) return actionProp;
          checkAttributeStringCoercion(actionProp, "action");
          return sanitizeURL("" + actionProp);
        }
        function createFormDataWithSubmitter(form, submitter) {
          var temp2 = submitter.ownerDocument.createElement("input");
          temp2.name = submitter.name;
          temp2.value = submitter.value;
          form.id && temp2.setAttribute("form", form.id);
          submitter.parentNode.insertBefore(temp2, submitter);
          form = new FormData(form);
          temp2.parentNode.removeChild(temp2);
          return form;
        }
        function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
          if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
            var action = coerceFormActionProp(
              (nativeEventTarget[internalPropsKey] || null).action
            ), submitter = nativeEvent.submitter;
            submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
            var event = new SyntheticEvent(
              "action",
              "action",
              null,
              nativeEvent,
              nativeEventTarget
            );
            dispatchQueue.push({
              event,
              listeners: [
                {
                  instance: null,
                  listener: function() {
                    if (nativeEvent.defaultPrevented) {
                      if (0 !== currentEventTransitionLane) {
                        var formData = submitter ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        ) : new FormData(nativeEventTarget), pendingState = {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        };
                        Object.freeze(pendingState);
                        startHostTransition(
                          maybeTargetInst,
                          pendingState,
                          null,
                          formData
                        );
                      }
                    } else
                      "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(
                        nativeEventTarget,
                        submitter
                      ) : new FormData(nativeEventTarget), pendingState = {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      }, Object.freeze(pendingState), startHostTransition(
                        maybeTargetInst,
                        pendingState,
                        action,
                        formData
                      ));
                  },
                  currentTarget: nativeEventTarget
                }
              ]
            });
          }
        }
        function executeDispatch(event, listener, currentTarget) {
          event.currentTarget = currentTarget;
          try {
            listener(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          eventSystemFlags = 0 !== (eventSystemFlags & 4);
          for (var i = 0; i < dispatchQueue.length; i++) {
            var _dispatchQueue$i = dispatchQueue[i];
            a: {
              var previousInstance = void 0, event = _dispatchQueue$i.event;
              _dispatchQueue$i = _dispatchQueue$i.listeners;
              if (eventSystemFlags)
                for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                  var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
              else
                for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                  _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                  instance = _dispatchListeners$i.instance;
                  currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  null !== instance ? runWithFiberInDEV(
                    instance,
                    executeDispatch,
                    event,
                    _dispatchListeners$i,
                    currentTarget
                  ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
                  previousInstance = instance;
                }
            }
          }
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          nonDelegatedEvents.has(domEventName) || console.error(
            'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
            domEventName
          );
          var listenerSet = targetElement[internalEventHandlersKey];
          void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
          var listenerSetKey = domEventName + "__bubble";
          listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
            'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
            domEventName
          );
          var eventSystemFlags = 0;
          isCapturePhaseListener && (eventSystemFlags |= 4);
          addTrappedEventListener(
            target,
            domEventName,
            eventSystemFlags,
            isCapturePhaseListener
          );
        }
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
            });
            var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
            null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
          switch (getEventPriority(domEventName)) {
            case DiscreteEventPriority:
              var listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            default:
              listenerWrapper = dispatchEvent;
          }
          eventSystemFlags = listenerWrapper.bind(
            null,
            domEventName,
            eventSystemFlags,
            targetContainer
          );
          listenerWrapper = void 0;
          !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
          isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            capture: true,
            passive: listenerWrapper
          }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            passive: listenerWrapper
          }) : targetContainer.addEventListener(
            domEventName,
            eventSystemFlags,
            false
          );
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
          var ancestorInst = targetInst$jscomp$0;
          if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
            a: for (; ; ) {
              if (null === targetInst$jscomp$0) return;
              var nodeTag = targetInst$jscomp$0.tag;
              if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer) break;
                if (4 === nodeTag)
                  for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                    var grandTag = nodeTag.tag;
                    if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                      return;
                    nodeTag = nodeTag.return;
                  }
                for (; null !== container; ) {
                  nodeTag = getClosestInstanceFromNode(container);
                  if (null === nodeTag) return;
                  grandTag = nodeTag.tag;
                  if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                    targetInst$jscomp$0 = ancestorInst = nodeTag;
                    continue a;
                  }
                  container = container.parentNode;
                }
              }
              targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
          batchedUpdates$1(function() {
            var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
            a: {
              var reactName = topLevelEventsToReactNames.get(domEventName);
              if (void 0 !== reactName) {
                var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                switch (domEventName) {
                  case "keypress":
                    if (0 === getEventCharCode(nativeEvent)) break a;
                  case "keydown":
                  case "keyup":
                    SyntheticEventCtor = SyntheticKeyboardEvent;
                    break;
                  case "focusin":
                    reactEventType = "focus";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "focusout":
                    reactEventType = "blur";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "click":
                    if (2 === nativeEvent.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    SyntheticEventCtor = SyntheticMouseEvent;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    SyntheticEventCtor = SyntheticDragEvent;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    SyntheticEventCtor = SyntheticTouchEvent;
                    break;
                  case ANIMATION_END:
                  case ANIMATION_ITERATION:
                  case ANIMATION_START:
                    SyntheticEventCtor = SyntheticAnimationEvent;
                    break;
                  case TRANSITION_END:
                    SyntheticEventCtor = SyntheticTransitionEvent;
                    break;
                  case "scroll":
                  case "scrollend":
                    SyntheticEventCtor = SyntheticUIEvent;
                    break;
                  case "wheel":
                    SyntheticEventCtor = SyntheticWheelEvent;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    SyntheticEventCtor = SyntheticClipboardEvent;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    SyntheticEventCtor = SyntheticPointerEvent;
                    break;
                  case "toggle":
                  case "beforetoggle":
                    SyntheticEventCtor = SyntheticToggleEvent;
                }
                var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                inCapturePhase = [];
                for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                  var _instance2 = instance;
                  lastHostComponent = _instance2.stateNode;
                  _instance2 = _instance2.tag;
                  5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
                  if (accumulateTargetOnly) break;
                  instance = instance.return;
                }
                0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                  reactName,
                  reactEventType,
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: reactName,
                  listeners: inCapturePhase
                }));
              }
            }
            if (0 === (eventSystemFlags & 7)) {
              a: {
                reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                  break a;
                if (SyntheticEventCtor || reactName) {
                  reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                  if (SyntheticEventCtor) {
                    if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                      reactEventType = null;
                  } else SyntheticEventCtor = null, reactEventType = targetInst;
                  if (SyntheticEventCtor !== reactEventType) {
                    inCapturePhase = SyntheticMouseEvent;
                    _instance2 = "onMouseLeave";
                    reactEventName = "onMouseEnter";
                    instance = "mouse";
                    if ("pointerout" === domEventName || "pointerover" === domEventName)
                      inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                    accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                    lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                    reactName = new inCapturePhase(
                      _instance2,
                      instance + "leave",
                      SyntheticEventCtor,
                      nativeEvent,
                      nativeEventTarget
                    );
                    reactName.target = accumulateTargetOnly;
                    reactName.relatedTarget = lastHostComponent;
                    _instance2 = null;
                    getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                      reactEventName,
                      instance + "enter",
                      reactEventType,
                      nativeEvent,
                      nativeEventTarget
                    ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                    accumulateTargetOnly = _instance2;
                    if (SyntheticEventCtor && reactEventType)
                      b: {
                        inCapturePhase = SyntheticEventCtor;
                        reactEventName = reactEventType;
                        instance = 0;
                        for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                          instance++;
                        lastHostComponent = 0;
                        for (_instance2 = reactEventName; _instance2; _instance2 = getParent(_instance2))
                          lastHostComponent++;
                        for (; 0 < instance - lastHostComponent; )
                          inCapturePhase = getParent(inCapturePhase), instance--;
                        for (; 0 < lastHostComponent - instance; )
                          reactEventName = getParent(reactEventName), lastHostComponent--;
                        for (; instance--; ) {
                          if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                            break b;
                          inCapturePhase = getParent(inCapturePhase);
                          reactEventName = getParent(reactEventName);
                        }
                        inCapturePhase = null;
                      }
                    else inCapturePhase = null;
                    null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      reactName,
                      SyntheticEventCtor,
                      inCapturePhase,
                      false
                    );
                    null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      accumulateTargetOnly,
                      reactEventType,
                      inCapturePhase,
                      true
                    );
                  }
                }
              }
              a: {
                reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                  var getTargetInstFunc = getTargetInstForChangeEvent;
                else if (isTextInputElement(reactName))
                  if (isInputEventSupported)
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                  else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    var handleEventFunc = handleEventsForInputEventPolyfill;
                  }
                else
                  SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                  createAndAccumulateChangeEvent(
                    dispatchQueue,
                    getTargetInstFunc,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break a;
                }
                handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
              }
              handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
              switch (domEventName) {
                case "focusin":
                  if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                    activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                  break;
                case "focusout":
                  lastSelection = activeElementInst = activeElement = null;
                  break;
                case "mousedown":
                  mouseDown = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  mouseDown = false;
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break;
                case "selectionchange":
                  if (skipSelectionChangeEvent) break;
                case "keydown":
                case "keyup":
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
              }
              var fallbackData;
              if (canUseCompositionEvent)
                b: {
                  switch (domEventName) {
                    case "compositionstart":
                      var eventType = "onCompositionStart";
                      break b;
                    case "compositionend":
                      eventType = "onCompositionEnd";
                      break b;
                    case "compositionupdate":
                      eventType = "onCompositionUpdate";
                      break b;
                  }
                  eventType = void 0;
                }
              else
                isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
              eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
                targetInst,
                eventType
              ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
              if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
                eventType = accumulateTwoPhaseListeners(
                  targetInst,
                  "onBeforeInput"
                ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }), handleEventFunc.data = fallbackData);
              extractEvents$1(
                dispatchQueue,
                domEventName,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
            }
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
            var _instance3 = targetFiber, stateNode = _instance3.stateNode;
            _instance3 = _instance3.tag;
            5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
            if (3 === targetFiber.tag) return listeners;
            targetFiber = targetFiber.return;
          }
          return [];
        }
        function getParent(inst) {
          if (null === inst) return null;
          do
            inst = inst.return;
          while (inst && 5 !== inst.tag && 27 !== inst.tag);
          return inst ? inst : null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common2, inCapturePhase) {
          for (var registrationName = event._reactName, listeners = []; null !== target && target !== common2; ) {
            var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
            _instance4 = _instance4.tag;
            if (null !== alternate && alternate === common2) break;
            5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
            target = target.return;
          }
          0 !== listeners.length && dispatchQueue.push({ event, listeners });
        }
        function validatePropertiesInDevelopment(type2, props) {
          validateProperties$2(type2, props);
          "input" !== type2 && "textarea" !== type2 && "select" !== type2 || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type2 && props.multiple ? console.error(
            "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
            type2
          ) : console.error(
            "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
            type2
          ));
          var eventRegistry = {
            registrationNameDependencies,
            possibleRegistrationNames
          };
          isCustomElement(type2) || "string" === typeof props.is || warnUnknownProperties(type2, props, eventRegistry);
          props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
            "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
          );
        }
        function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
          serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
        }
        function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
          attributeNames.forEach(function(attributeName) {
            serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
          });
        }
        function warnForInvalidEventListener(registrationName, listener) {
          false === listener ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          ) : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener
          );
        }
        function normalizeHTML(parent, html) {
          parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
            parent.namespaceURI,
            parent.tagName
          ) : parent.ownerDocument.createElement(parent.tagName);
          parent.innerHTML = html;
          return parent.innerHTML;
        }
        function normalizeMarkupForTextOrAttribute(markup) {
          willCoercionThrow(markup) && (console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(markup)
          ), testStringCoercion(markup));
          return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText) {
          clientText = normalizeMarkupForTextOrAttribute(clientText);
          return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
        }
        function noop$1() {
        }
        function setProp(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "children":
              if ("string" === typeof value)
                validateTextNesting(value, tag, false), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
              else if ("number" === typeof value || "bigint" === typeof value)
                validateTextNesting("" + value, tag, false), "body" !== tag && setTextContent(domElement, "" + value);
              break;
            case "className":
              setValueForKnownAttribute(domElement, "class", value);
              break;
            case "tabIndex":
              setValueForKnownAttribute(domElement, "tabindex", value);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              setValueForKnownAttribute(domElement, key, value);
              break;
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "data":
              if ("object" !== tag) {
                setValueForKnownAttribute(domElement, "data", value);
                break;
              }
            case "src":
            case "href":
              if ("" === value && ("a" !== tag || "href" !== key)) {
                "src" === key ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                ) : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
                domElement.removeAttribute(key);
                break;
              }
              if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "action":
            case "formAction":
              null != value && ("form" === tag ? "formAction" === key ? console.error(
                "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
              ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
                "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
              ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
                'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
              )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
              )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
              ))) : (didWarnFormActionType = true, console.error(
                'A button can only specify a formAction along with type="submit" or no type.'
              )) : (didWarnFormActionType = true, console.error(
                'An input can only specify a formAction along with type="submit" or type="image".'
              )) : "action" === key ? console.error(
                "You can only pass the action prop to <form>."
              ) : console.error(
                "You can only pass the formAction prop to <input> or <button>."
              ));
              if ("function" === typeof value) {
                domElement.setAttribute(
                  key,
                  "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
                );
                break;
              } else
                "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                  domElement,
                  tag,
                  "formEncType",
                  props.formEncType,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formMethod",
                  props.formMethod,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formTarget",
                  props.formTarget,
                  props,
                  null
                )) : (setProp(
                  domElement,
                  tag,
                  "encType",
                  props.encType,
                  props,
                  null
                ), setProp(domElement, tag, "method", props.method, props, null), setProp(
                  domElement,
                  tag,
                  "target",
                  props.target,
                  props,
                  null
                )));
              if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "multiple":
              domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "muted":
              domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              break;
            case "autoFocus":
              break;
            case "xlinkHref":
              if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                domElement.removeAttribute("xlink:href");
                break;
              }
              checkAttributeStringCoercion(value, key);
              key = sanitizeURL("" + value);
              domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
              break;
            case "inert":
              "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
                "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                key
              ));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
              break;
            case "capture":
            case "download":
              true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "rowSpan":
            case "start":
              null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
              break;
            case "popover":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              setValueForAttribute(domElement, "popover", value);
              break;
            case "xlinkActuate":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:actuate",
                value
              );
              break;
            case "xlinkArcrole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:arcrole",
                value
              );
              break;
            case "xlinkRole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:role",
                value
              );
              break;
            case "xlinkShow":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:show",
                value
              );
              break;
            case "xlinkTitle":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:title",
                value
              );
              break;
            case "xlinkType":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:type",
                value
              );
              break;
            case "xmlBase":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:base",
                value
              );
              break;
            case "xmlLang":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:lang",
                value
              );
              break;
            case "xmlSpace":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:space",
                value
              );
              break;
            case "is":
              null != prevValue && console.error(
                'Cannot update the "is" prop after it has been initialized.'
              );
              setValueForAttribute(domElement, "is", value);
              break;
            case "innerText":
            case "textContent":
              break;
            case "popoverTarget":
              didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
                "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
                value
              ));
            default:
              !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
          }
        }
        function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "children":
              "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              if (registrationNameDependencies.hasOwnProperty(key))
                null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
              else
                a: {
                  if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                    "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                    domElement.addEventListener(tag, value, props);
                    break a;
                  }
                  key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                }
          }
        }
        function setInitialProperties(domElement, tag, props) {
          validatePropertiesInDevelopment(tag, props);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "img":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              var hasSrc = false, hasSrcSet = false, propKey;
              for (propKey in props)
                if (props.hasOwnProperty(propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case "src":
                        hasSrc = true;
                        break;
                      case "srcSet":
                        hasSrcSet = true;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        setProp(domElement, tag, propKey, propValue, props, null);
                    }
                }
              hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
              hasSrc && setProp(domElement, tag, "src", props.src, props, null);
              return;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", domElement);
              var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
              for (hasSrc in props)
                if (props.hasOwnProperty(hasSrc)) {
                  var _propValue = props[hasSrc];
                  if (null != _propValue)
                    switch (hasSrc) {
                      case "name":
                        hasSrcSet = _propValue;
                        break;
                      case "type":
                        propValue = _propValue;
                        break;
                      case "checked":
                        checked = _propValue;
                        break;
                      case "defaultChecked":
                        defaultChecked = _propValue;
                        break;
                      case "value":
                        propKey = _propValue;
                        break;
                      case "defaultValue":
                        defaultValue = _propValue;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != _propValue)
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        break;
                      default:
                        setProp(domElement, tag, hasSrc, _propValue, props, null);
                    }
                }
              validateInputProps(domElement, props);
              initInput(
                domElement,
                propKey,
                defaultValue,
                checked,
                defaultChecked,
                propValue,
                hasSrcSet,
                false
              );
              track(domElement);
              return;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", domElement);
              hasSrc = propValue = propKey = null;
              for (hasSrcSet in props)
                if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                  switch (hasSrcSet) {
                    case "value":
                      propKey = defaultValue;
                      break;
                    case "defaultValue":
                      propValue = defaultValue;
                      break;
                    case "multiple":
                      hasSrc = defaultValue;
                    default:
                      setProp(
                        domElement,
                        tag,
                        hasSrcSet,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateSelectProps(domElement, props);
              tag = propKey;
              props = propValue;
              domElement.multiple = !!hasSrc;
              null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
              return;
            case "textarea":
              checkControlledValueProps("textarea", props);
              listenToNonDelegatedEvent("invalid", domElement);
              propKey = hasSrcSet = hasSrc = null;
              for (propValue in props)
                if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                  switch (propValue) {
                    case "value":
                      hasSrc = defaultValue;
                      break;
                    case "defaultValue":
                      hasSrcSet = defaultValue;
                      break;
                    case "children":
                      propKey = defaultValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != defaultValue)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        propValue,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateTextareaProps(domElement, props);
              initTextarea(domElement, hasSrc, hasSrcSet, propKey);
              track(domElement);
              return;
            case "option":
              validateOptionProps(domElement, props);
              for (checked in props)
                if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                  switch (checked) {
                    case "selected":
                      domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                      break;
                    default:
                      setProp(domElement, tag, checked, hasSrc, props, null);
                  }
              return;
            case "dialog":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
              break;
            case "image":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "embed":
            case "source":
            case "link":
              listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
              for (defaultChecked in props)
                if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                  switch (defaultChecked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (_propValue in props)
                  props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
                return;
              }
          }
          for (defaultValue in props)
            props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
        }
        function updateProperties(domElement, tag, lastProps, nextProps) {
          validatePropertiesInDevelopment(tag, nextProps);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "input":
              var name = null, type2 = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
              for (propKey in lastProps) {
                var lastProp = lastProps[propKey];
                if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                  switch (propKey) {
                    case "checked":
                      break;
                    case "value":
                      break;
                    case "defaultValue":
                      lastDefaultValue = lastProp;
                    default:
                      nextProps.hasOwnProperty(propKey) || setProp(
                        domElement,
                        tag,
                        propKey,
                        null,
                        nextProps,
                        lastProp
                      );
                  }
              }
              for (var _propKey8 in nextProps) {
                var propKey = nextProps[_propKey8];
                lastProp = lastProps[_propKey8];
                if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
                  switch (_propKey8) {
                    case "type":
                      type2 = propKey;
                      break;
                    case "name":
                      name = propKey;
                      break;
                    case "checked":
                      checked = propKey;
                      break;
                    case "defaultChecked":
                      defaultChecked = propKey;
                      break;
                    case "value":
                      value = propKey;
                      break;
                    case "defaultValue":
                      defaultValue = propKey;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propKey)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      propKey !== lastProp && setProp(
                        domElement,
                        tag,
                        _propKey8,
                        propKey,
                        nextProps,
                        lastProp
                      );
                  }
              }
              tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
              nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
              tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
                "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnUncontrolledToControlled = true);
              !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
                "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnControlledToUncontrolled = true);
              updateInput(
                domElement,
                value,
                defaultValue,
                lastDefaultValue,
                checked,
                defaultChecked,
                type2,
                name
              );
              return;
            case "select":
              propKey = value = defaultValue = _propKey8 = null;
              for (type2 in lastProps)
                if (lastDefaultValue = lastProps[type2], lastProps.hasOwnProperty(type2) && null != lastDefaultValue)
                  switch (type2) {
                    case "value":
                      break;
                    case "multiple":
                      propKey = lastDefaultValue;
                    default:
                      nextProps.hasOwnProperty(type2) || setProp(
                        domElement,
                        tag,
                        type2,
                        null,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              for (name in nextProps)
                if (type2 = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type2 || null != lastDefaultValue))
                  switch (name) {
                    case "value":
                      _propKey8 = type2;
                      break;
                    case "defaultValue":
                      defaultValue = type2;
                      break;
                    case "multiple":
                      value = type2;
                    default:
                      type2 !== lastDefaultValue && setProp(
                        domElement,
                        tag,
                        name,
                        type2,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              nextProps = defaultValue;
              tag = value;
              lastProps = propKey;
              null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
              return;
            case "textarea":
              propKey = _propKey8 = null;
              for (defaultValue in lastProps)
                if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                  switch (defaultValue) {
                    case "value":
                      break;
                    case "children":
                      break;
                    default:
                      setProp(domElement, tag, defaultValue, null, nextProps, name);
                  }
              for (value in nextProps)
                if (name = nextProps[value], type2 = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type2))
                  switch (value) {
                    case "value":
                      _propKey8 = name;
                      break;
                    case "defaultValue":
                      propKey = name;
                      break;
                    case "children":
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != name)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      name !== type2 && setProp(domElement, tag, value, name, nextProps, type2);
                  }
              updateTextarea(domElement, _propKey8, propKey);
              return;
            case "option":
              for (var _propKey13 in lastProps)
                if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
                  switch (_propKey13) {
                    case "selected":
                      domElement.selected = false;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        _propKey13,
                        null,
                        nextProps,
                        _propKey8
                      );
                  }
              for (lastDefaultValue in nextProps)
                if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (lastDefaultValue) {
                    case "selected":
                      domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        lastDefaultValue,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            case "img":
            case "link":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
            case "menuitem":
              for (var _propKey15 in lastProps)
                _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
              for (checked in nextProps)
                if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (checked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != _propKey8)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        checked,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (var _propKey17 in lastProps)
                  _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
                for (defaultChecked in nextProps)
                  _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
                return;
              }
          }
          for (var _propKey19 in lastProps)
            _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
          for (lastProp in nextProps)
            _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
        }
        function getPropNameFromAttributeName(attrName) {
          switch (attrName) {
            case "class":
              return "className";
            case "for":
              return "htmlFor";
            default:
              return attrName;
          }
        }
        function getStylesObjectFromElement(domElement) {
          var serverValueInObjectForm = {};
          domElement = domElement.style;
          for (var i = 0; i < domElement.length; i++) {
            var styleName = domElement[i];
            serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
          }
          return serverValueInObjectForm;
        }
        function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
          if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
            console.error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          else {
            var clientValue;
            var delimiter = clientValue = "", styleName;
            for (styleName in value$jscomp$0)
              if (value$jscomp$0.hasOwnProperty(styleName)) {
                var value = value$jscomp$0[styleName];
                null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
              }
            clientValue = clientValue || null;
            value$jscomp$0 = domElement.getAttribute("style");
            value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
          }
        }
        function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
            }
            if (!value) return;
          } else
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (value) return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
              default:
                if (isNaN(value)) return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function diffHydratedProperties(domElement, tag, props, hostContext) {
          for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++)
            switch (attributes[i].name.toLowerCase()) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributes.add(attributes[i].name);
            }
          if (isCustomElement(tag))
            for (var propKey in props) {
              if (props.hasOwnProperty(propKey)) {
                var value = props[propKey];
                if (null != value) {
                  if (registrationNameDependencies.hasOwnProperty(propKey))
                    "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                  else if (true !== props.suppressHydrationWarning)
                    switch (propKey) {
                      case "children":
                        "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
                          "children",
                          domElement.textContent,
                          value,
                          serverDifferences
                        );
                        continue;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "defaultValue":
                      case "defaultChecked":
                      case "innerHTML":
                      case "ref":
                        continue;
                      case "dangerouslySetInnerHTML":
                        attributes = domElement.innerHTML;
                        value = value ? value.__html : void 0;
                        null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        ));
                        continue;
                      case "style":
                        extraAttributes.delete(propKey);
                        diffHydratedStyles(domElement, value, serverDifferences);
                        continue;
                      case "offsetParent":
                      case "offsetTop":
                      case "offsetLeft":
                      case "offsetWidth":
                      case "offsetHeight":
                      case "isContentEditable":
                      case "outerText":
                      case "outerHTML":
                        extraAttributes.delete(propKey.toLowerCase());
                        console.error(
                          "Assignment to read-only property will result in a no-op: `%s`",
                          propKey
                        );
                        continue;
                      case "className":
                        extraAttributes.delete("class");
                        attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          "class",
                          value
                        );
                        warnForPropDifference(
                          "className",
                          attributes,
                          value,
                          serverDifferences
                        );
                        continue;
                      default:
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          propKey,
                          value
                        ), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        );
                    }
                }
              }
            }
          else
            for (value in props)
              if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
                if (registrationNameDependencies.hasOwnProperty(value))
                  "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
                else if (true !== props.suppressHydrationWarning)
                  switch (value) {
                    case "children":
                      "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
                        "children",
                        domElement.textContent,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "value":
                    case "checked":
                    case "selected":
                    case "defaultValue":
                    case "defaultChecked":
                    case "innerHTML":
                    case "ref":
                      continue;
                    case "dangerouslySetInnerHTML":
                      attributes = domElement.innerHTML;
                      propKey = propKey ? propKey.__html : void 0;
                      null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
                      continue;
                    case "className":
                      hydrateAttribute(
                        domElement,
                        value,
                        "class",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "tabIndex":
                      hydrateAttribute(
                        domElement,
                        value,
                        "tabindex",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "style":
                      extraAttributes.delete(value);
                      diffHydratedStyles(domElement, propKey, serverDifferences);
                      continue;
                    case "multiple":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.multiple,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "muted":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.muted,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "autoFocus":
                      extraAttributes.delete("autofocus");
                      warnForPropDifference(
                        value,
                        domElement.autofocus,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "data":
                      if ("object" !== tag) {
                        extraAttributes.delete(value);
                        attributes = domElement.getAttribute("data");
                        warnForPropDifference(
                          value,
                          attributes,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                    case "src":
                    case "href":
                      if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                        "src" === value ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        ) : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "action":
                    case "formAction":
                      attributes = domElement.getAttribute(value);
                      if ("function" === typeof propKey) {
                        extraAttributes.delete(value.toLowerCase());
                        "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                        continue;
                      } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                        extraAttributes.delete(value.toLowerCase());
                        warnForPropDifference(
                          value,
                          "function",
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkHref":
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        "xlink:href",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "contentEditable":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "contenteditable",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "spellCheck":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "spellcheck",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "draggable":
                    case "autoReverse":
                    case "externalResourcesRequired":
                    case "focusable":
                    case "preserveAlpha":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "allowFullScreen":
                    case "async":
                    case "autoPlay":
                    case "controls":
                    case "default":
                    case "defer":
                    case "disabled":
                    case "disablePictureInPicture":
                    case "disableRemotePlayback":
                    case "formNoValidate":
                    case "hidden":
                    case "loop":
                    case "noModule":
                    case "noValidate":
                    case "open":
                    case "playsInline":
                    case "readOnly":
                    case "required":
                    case "reversed":
                    case "scoped":
                    case "seamless":
                    case "itemScope":
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "capture":
                    case "download":
                      a: {
                        i = domElement;
                        var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                              break a;
                            default:
                              if (false === propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                              break;
                            case "boolean":
                              if (true === propKey && "" === i) break a;
                              break;
                            default:
                              if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "cols":
                    case "rows":
                    case "size":
                    case "span":
                      a: {
                        i = domElement;
                        attributeName = attributes = value;
                        serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                              break a;
                            default:
                              if (isNaN(propKey) || 1 > propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                            case "boolean":
                              break;
                            default:
                              if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey))
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "rowSpan":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        "rowspan",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "start":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xHeight":
                      hydrateAttribute(
                        domElement,
                        value,
                        "x-height",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkActuate":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:actuate",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkArcrole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:arcrole",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkRole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:role",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkShow":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:show",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkTitle":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:title",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkType":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:type",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlBase":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:base",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlLang":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:lang",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlSpace":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:space",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "inert":
                      "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
                        "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                        value
                      ));
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    default:
                      if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                        i = getAttributeAlias(value);
                        attributes = false;
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
                        a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                          if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                            attributeName = attributeName.getAttribute(
                              serverDifferences$jscomp$0
                            ), checkAttributeStringCoercion(
                              i,
                              serverDifferences$jscomp$0
                            ), i = attributeName === "" + i ? i : attributeName;
                          else {
                            switch (typeof i) {
                              case "function":
                              case "symbol":
                                break a;
                              case "boolean":
                                if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
                                  break a;
                            }
                            i = void 0 === i ? void 0 : null;
                          }
                        else i = void 0;
                        attributes || warnForPropDifference(
                          value,
                          i,
                          propKey,
                          serverDifferences
                        );
                      }
                  }
              }
          0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
          return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
        }
        function propNamesListJoin(list, combinator) {
          switch (list.length) {
            case 0:
              return "";
            case 1:
              return list[0];
            case 2:
              return list[0] + " " + combinator + " " + list[1];
            default:
              return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
          }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function getOwnHostContext(namespaceURI) {
          switch (namespaceURI) {
            case SVG_NAMESPACE:
              return HostContextNamespaceSvg;
            case MATH_NAMESPACE:
              return HostContextNamespaceMath;
            default:
              return HostContextNamespaceNone;
          }
        }
        function getChildHostContextProd(parentNamespace, type2) {
          if (parentNamespace === HostContextNamespaceNone)
            switch (type2) {
              case "svg":
                return HostContextNamespaceSvg;
              case "math":
                return HostContextNamespaceMath;
              default:
                return HostContextNamespaceNone;
            }
          return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type2 ? HostContextNamespaceNone : parentNamespace;
        }
        function shouldSetTextContent(type2, props) {
          return "textarea" === type2 || "noscript" === type2 || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
        }
        function shouldAttemptEagerTransition() {
          var event = window.event;
          if (event && "popstate" === event.type) {
            if (event === currentPopstateTransitionEvent) return false;
            currentPopstateTransitionEvent = event;
            return true;
          }
          currentPopstateTransitionEvent = null;
          return false;
        }
        function handleErrorInNextTick(error) {
          setTimeout(function() {
            throw error;
          });
        }
        function commitMount(domElement, type2, newProps) {
          switch (type2) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps.autoFocus && domElement.focus();
              break;
            case "img":
              newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
          }
        }
        function commitUpdate(domElement, type2, oldProps, newProps) {
          updateProperties(domElement, type2, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function isSingletonScope(type2) {
          return "head" === type2;
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          (9 === container.nodeType ? container.body : "HTML" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
          var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && 8 === nextNode.nodeType)
              if (node = nextNode.data, node === SUSPENSE_END_DATA) {
                if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
                  node = possiblePreambleContribution;
                  var ownerDocument = parentInstance.ownerDocument;
                  node & PREAMBLE_CONTRIBUTION_HTML && releaseSingletonInstance(ownerDocument.documentElement);
                  node & PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(ownerDocument.body);
                  if (node & PREAMBLE_CONTRIBUTION_HEAD)
                    for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
                      var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
                      ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
                      ownerDocument = nextNode$jscomp$0;
                    }
                }
                if (0 === depth) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(suspenseInstance);
                  return;
                }
                depth--;
              } else
                node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_FALLBACK_START_DATA ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
            else possiblePreambleContribution = 0;
            node = nextNode;
          } while (node);
          retryIfBlockedOn(suspenseInstance);
        }
        function hideInstance(instance) {
          instance = instance.style;
          "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance, props) {
          props = props[STYLE];
          props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
          instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainerSparingly(container) {
          var nextNode = container.firstChild;
          nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
          for (; nextNode; ) {
            var node = nextNode;
            nextNode = nextNode.nextSibling;
            switch (node.nodeName) {
              case "HTML":
              case "HEAD":
              case "BODY":
                clearContainerSparingly(node);
                detachDeletedInstance(node);
                continue;
              case "SCRIPT":
              case "STYLE":
                continue;
              case "LINK":
                if ("stylesheet" === node.rel.toLowerCase()) continue;
            }
            container.removeChild(node);
          }
        }
        function canHydrateInstance(instance, type2, props, inRootOrSingleton) {
          for (; 1 === instance.nodeType; ) {
            var anyProps = props;
            if (instance.nodeName.toLowerCase() !== type2.toLowerCase()) {
              if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
                break;
            } else if (!inRootOrSingleton)
              if ("input" === type2 && "hidden" === instance.type) {
                checkAttributeStringCoercion(anyProps.name, "name");
                var name = null == anyProps.name ? null : "" + anyProps.name;
                if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                  return instance;
              } else return instance;
            else if (!instance[internalHoistableMarker])
              switch (type2) {
                case "meta":
                  if (!instance.hasAttribute("itemprop")) break;
                  return instance;
                case "link":
                  name = instance.getAttribute("rel");
                  if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                    break;
                  else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                    break;
                  return instance;
                case "style":
                  if (instance.hasAttribute("data-precedence")) break;
                  return instance;
                case "script":
                  name = instance.getAttribute("src");
                  if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                    break;
                  return instance;
                default:
                  return instance;
              }
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) break;
          }
          return null;
        }
        function canHydrateTextInstance(instance, text, inRootOrSingleton) {
          if ("" === text) return null;
          for (; 3 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE;
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          var ownerDocument = instance.ownerDocument;
          if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE)
            callback();
          else {
            var listener = function() {
              callback();
              ownerDocument.removeEventListener("DOMContentLoaded", listener);
            };
            ownerDocument.addEventListener("DOMContentLoaded", listener);
            instance._reactRetry = listener;
          }
        }
        function getNextHydratable(node) {
          for (; null != node; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
            if (8 === nodeType) {
              nodeType = node.data;
              if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
                break;
              if (nodeType === SUSPENSE_END_DATA) return null;
            }
          }
          return node;
        }
        function describeHydratableInstanceForDevWarnings(instance) {
          if (1 === instance.nodeType) {
            for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++) {
              var attr = attributes[i];
              serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
            }
            return { type: JSCompiler_temp_const, props: serverDifferences };
          }
          return 8 === instance.nodeType ? { type: "Suspense", props: {} } : instance.nodeValue;
        }
        function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
          return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          suspenseInstance = suspenseInstance.nextSibling;
          for (var depth = 0; suspenseInstance; ) {
            if (8 === suspenseInstance.nodeType) {
              var data = suspenseInstance.data;
              if (data === SUSPENSE_END_DATA) {
                if (0 === depth)
                  return getNextHydratable(suspenseInstance.nextSibling);
                depth--;
              } else
                data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA || depth++;
            }
            suspenseInstance = suspenseInstance.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          targetInstance = targetInstance.previousSibling;
          for (var depth = 0; targetInstance; ) {
            if (8 === targetInstance.nodeType) {
              var data = targetInstance.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                if (0 === depth) return targetInstance;
                depth--;
              } else data === SUSPENSE_END_DATA && depth++;
            }
            targetInstance = targetInstance.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function resolveSingletonInstance(type2, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
          validateDOMNestingDev && validateDOMNesting(type2, hostContext.ancestorInfo);
          props = getOwnerDocumentFromRootContainer(rootContainerInstance);
          switch (type2) {
            case "html":
              type2 = props.documentElement;
              if (!type2)
                throw Error(
                  "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type2;
            case "head":
              type2 = props.head;
              if (!type2)
                throw Error(
                  "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type2;
            case "body":
              type2 = props.body;
              if (!type2)
                throw Error(
                  "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type2;
            default:
              throw Error(
                "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
        }
        function acquireSingletonInstance(type2, props, instance, internalInstanceHandle) {
          if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
            var tagName = instance.tagName.toLowerCase();
            console.error(
              "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
              tagName,
              tagName,
              tagName
            );
          }
          switch (type2) {
            case "html":
            case "head":
            case "body":
              break;
            default:
              console.error(
                "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
          for (tagName = instance.attributes; tagName.length; )
            instance.removeAttributeNode(tagName[0]);
          setInitialProperties(instance, type2, props);
          instance[internalInstanceKey] = internalInstanceHandle;
          instance[internalPropsKey] = props;
        }
        function releaseSingletonInstance(instance) {
          for (var attributes = instance.attributes; attributes.length; )
            instance.removeAttributeNode(attributes[0]);
          detachDeletedInstance(instance);
        }
        function getHoistableRoot(container) {
          return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
        }
        function preconnectAs(rel, href, crossOrigin) {
          var ownerDocument = globalDocument;
          if (ownerDocument && "string" === typeof href && href) {
            var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
            limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
            "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
            preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
          }
        }
        function getResource(type2, currentProps, pendingProps, currentResource) {
          var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
          if (!resourceRoot)
            throw Error(
              '"resourceRoot" was expected to exist. This is a bug in React.'
            );
          switch (type2) {
            case "meta":
            case "title":
              return null;
            case "style":
              return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "style",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            case "link":
              if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                type2 = getStyleKey(pendingProps.href);
                var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type2);
                if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                  type: "stylesheet",
                  instance: null,
                  count: 0,
                  state: { loading: NotLoaded, preload: null }
                }, _styles.set(type2, _resource), (_styles = resourceRoot.querySelector(
                  getStylesheetSelectorFromKey(type2)
                )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type2))) {
                  var preloadProps = {
                    rel: "preload",
                    as: "style",
                    href: pendingProps.href,
                    crossOrigin: pendingProps.crossOrigin,
                    integrity: pendingProps.integrity,
                    media: pendingProps.media,
                    hrefLang: pendingProps.hrefLang,
                    referrerPolicy: pendingProps.referrerPolicy
                  };
                  preloadPropsMap.set(type2, preloadProps);
                  _styles || preloadStylesheet(
                    resourceRoot,
                    type2,
                    preloadProps,
                    _resource.state
                  );
                }
                if (currentProps && null === currentResource)
                  throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                    "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                  );
                return _resource;
              }
              if (currentProps && null !== currentResource)
                throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                  "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                );
              return null;
            case "script":
              return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            default:
              throw Error(
                'getResource encountered a type it did not expect: "' + type2 + '". this is a bug in React.'
              );
          }
        }
        function describeLinkForResourceErrorDEV(props) {
          var describedProps = 0, description = "<link";
          "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
          "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
          "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
          Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
          return description + " />";
        }
        function getStyleKey(href) {
          return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
        }
        function getStylesheetSelectorFromKey(key) {
          return 'link[rel="stylesheet"][' + key + "]";
        }
        function stylesheetPropsFromRawProps(rawProps) {
          return assign({}, rawProps, {
            "data-precedence": rawProps.precedence,
            precedence: null
          });
        }
        function preloadStylesheet(ownerDocument, key, preloadProps, state) {
          ownerDocument.querySelector(
            'link[rel="preload"][as="style"][' + key + "]"
          ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
            return state.loading |= Loaded;
          }), key.addEventListener("error", function() {
            return state.loading |= Errored;
          }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
        }
        function getScriptKey(src) {
          return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
        }
        function getScriptSelectorFromKey(key) {
          return "script[async]" + key;
        }
        function acquireResource(hoistableRoot, resource, props) {
          resource.count++;
          if (null === resource.instance)
            switch (resource.type) {
              case "style":
                var instance = hoistableRoot.querySelector(
                  'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
                );
                if (instance)
                  return resource.instance = instance, markNodeAsHoistable(instance), instance;
                var styleProps = assign({}, props, {
                  "data-href": props.href,
                  "data-precedence": props.precedence,
                  href: null,
                  precedence: null
                });
                instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                markNodeAsHoistable(instance);
                setInitialProperties(instance, "style", styleProps);
                insertStylesheet(instance, props.precedence, hoistableRoot);
                return resource.instance = instance;
              case "stylesheet":
                styleProps = getStyleKey(props.href);
                var _instance = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(styleProps)
                );
                if (_instance)
                  return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
                instance = stylesheetPropsFromRawProps(props);
                (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                markNodeAsHoistable(_instance);
                var linkInstance = _instance;
                linkInstance._p = new Promise(function(resolve, reject) {
                  linkInstance.onload = resolve;
                  linkInstance.onerror = reject;
                });
                setInitialProperties(_instance, "link", instance);
                resource.state.loading |= Inserted;
                insertStylesheet(_instance, props.precedence, hoistableRoot);
                return resource.instance = _instance;
              case "script":
                _instance = getScriptKey(props.src);
                if (styleProps = hoistableRoot.querySelector(
                  getScriptSelectorFromKey(_instance)
                ))
                  return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                instance = props;
                if (styleProps = preloadPropsMap.get(_instance))
                  instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                styleProps = hoistableRoot.createElement("script");
                markNodeAsHoistable(styleProps);
                setInitialProperties(styleProps, "link", instance);
                hoistableRoot.head.appendChild(styleProps);
                return resource.instance = styleProps;
              case "void":
                return null;
              default:
                throw Error(
                  'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
                );
            }
          else
            "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
          return resource.instance;
        }
        function insertStylesheet(instance, precedence, root2) {
          for (var nodes = root2.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (node.dataset.precedence === precedence) prior = node;
            else if (prior !== last) break;
          }
          prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
        }
        function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
          null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
          null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
          null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
        }
        function adoptPreloadPropsForScript(scriptProps, preloadProps) {
          null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
          null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
          null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
        }
        function getHydratableHoistableCache(type2, keyAttribute, ownerDocument) {
          if (null === tagCaches) {
            var cache = /* @__PURE__ */ new Map();
            var caches = tagCaches = /* @__PURE__ */ new Map();
            caches.set(ownerDocument, cache);
          } else
            caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
          if (cache.has(type2)) return cache;
          cache.set(type2, null);
          ownerDocument = ownerDocument.getElementsByTagName(type2);
          for (caches = 0; caches < ownerDocument.length; caches++) {
            var node = ownerDocument[caches];
            if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type2 && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
              var nodeKey = node.getAttribute(keyAttribute) || "";
              nodeKey = type2 + nodeKey;
              var existing = cache.get(nodeKey);
              existing ? existing.push(node) : cache.set(nodeKey, [node]);
            }
          }
          return cache;
        }
        function mountHoistable(hoistableRoot, type2, instance) {
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          hoistableRoot.head.insertBefore(
            instance,
            "title" === type2 ? hoistableRoot.querySelector("head > title") : null
          );
        }
        function isHostHoistableType(type2, props, hostContext) {
          var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
          if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
            return !outsideHostContainerContext || null == props.itemProp || "meta" !== type2 && "title" !== type2 && "style" !== type2 && "link" !== type2 && "script" !== type2 || console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type2,
              type2
            ), false;
          switch (type2) {
            case "meta":
            case "title":
              return true;
            case "style":
              if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
                outsideHostContainerContext && console.error(
                  'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
                );
                break;
              }
              return true;
            case "link":
              if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
                if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                  type2 = props.href;
                  var onError = props.onError, disabled = props.disabled;
                  hostContext = [];
                  props.onLoad && hostContext.push("`onLoad`");
                  onError && hostContext.push("`onError`");
                  null != disabled && hostContext.push("`disabled`");
                  onError = propNamesListJoin(hostContext, "and");
                  onError += 1 === hostContext.length ? " prop" : " props";
                  disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
                  hostContext.length && console.error(
                    'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                    type2,
                    disabled,
                    onError
                  );
                }
                outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
                  "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                ) : (props.onError || props.onLoad) && console.error(
                  "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ));
                break;
              }
              switch (props.rel) {
                case "stylesheet":
                  return type2 = props.precedence, props = props.disabled, "string" !== typeof type2 && outsideHostContainerContext && console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ), "string" === typeof type2 && null == props;
                default:
                  return true;
              }
            case "script":
              type2 = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
              if (!type2 || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
                outsideHostContainerContext && (type2 ? props.onLoad || props.onError ? console.error(
                  "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                ));
                break;
              }
              return true;
            case "noscript":
            case "template":
              outsideHostContainerContext && console.error(
                "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
                type2
              );
          }
          return false;
        }
        function preloadResource(resource) {
          return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
        }
        function noop() {
        }
        function suspendResource(hoistableRoot, resource, props) {
          if (null === suspendedState)
            throw Error(
              "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
            );
          var state = suspendedState;
          if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
            if (null === resource.instance) {
              var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(key)
              );
              if (instance) {
                hoistableRoot = instance._p;
                null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                resource.state.loading |= Inserted;
                resource.instance = instance;
                markNodeAsHoistable(instance);
                return;
              }
              instance = hoistableRoot.ownerDocument || hoistableRoot;
              props = stylesheetPropsFromRawProps(props);
              (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
              instance = instance.createElement("link");
              markNodeAsHoistable(instance);
              var linkInstance = instance;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance, "link", props);
              resource.instance = instance;
            }
            null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
            state.stylesheets.set(resource, hoistableRoot);
            (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
          }
        }
        function waitForCommitToBeReady() {
          if (null === suspendedState)
            throw Error(
              "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
            );
          var state = suspendedState;
          state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
          return 0 < state.count ? function(commit) {
            var stylesheetTimer = setTimeout(function() {
              state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, 6e4);
            state.unsuspend = commit;
            return function() {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
            };
          } : null;
        }
        function onUnsuspend() {
          this.count--;
          if (0 === this.count) {
            if (this.stylesheets)
              insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
              var unsuspend = this.unsuspend;
              this.unsuspend = null;
              unsuspend();
            }
          }
        }
        function insertSuspendedStylesheets(state, resources) {
          state.stylesheets = null;
          null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
        }
        function insertStylesheetIntoRoot(root2, resource) {
          if (!(resource.state.loading & Inserted)) {
            var precedences = precedencesByRoot.get(root2);
            if (precedences) var last = precedences.get(LAST_PRECEDENCE);
            else {
              precedences = /* @__PURE__ */ new Map();
              precedencesByRoot.set(root2, precedences);
              for (var nodes = root2.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ), i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                  precedences.set(node.dataset.precedence, node), last = node;
              }
              last && precedences.set(LAST_PRECEDENCE, last);
            }
            nodes = resource.instance;
            node = nodes.getAttribute("data-precedence");
            i = precedences.get(node) || last;
            i === last && precedences.set(LAST_PRECEDENCE, nodes);
            precedences.set(node, nodes);
            this.count++;
            last = onUnsuspend.bind(this);
            nodes.addEventListener("load", last);
            nodes.addEventListener("error", last);
            i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
            resource.state.loading |= Inserted;
          }
        }
        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
          this.tag = 1;
          this.containerInfo = containerInfo;
          this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = noTimeout;
          this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
          this.callbackPriority = 0;
          this.expirationTimes = createLaneMap(-1);
          this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = createLaneMap(0);
          this.hiddenUpdates = createLaneMap(null);
          this.identifierPrefix = identifierPrefix;
          this.onUncaughtError = onUncaughtError;
          this.onCaughtError = onCaughtError;
          this.onRecoverableError = onRecoverableError;
          this.pooledCache = null;
          this.pooledCacheLanes = 0;
          this.formState = formState;
          this.incompleteTransitions = /* @__PURE__ */ new Map();
          this.passiveEffectDuration = this.effectDuration = -0;
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          containerInfo = this.pendingUpdatersLaneMap = [];
          for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
          this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
        }
        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
          containerInfo = new FiberRootNode(
            containerInfo,
            tag,
            hydrate,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            formState
          );
          tag = ConcurrentMode;
          true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
          isDevToolsPresent && (tag |= ProfileMode);
          isStrictMode = createFiber(3, null, null, tag);
          containerInfo.current = isStrictMode;
          isStrictMode.stateNode = containerInfo;
          tag = createCache();
          retainCache(tag);
          containerInfo.pooledCache = tag;
          retainCache(tag);
          isStrictMode.memoizedState = {
            element: initialChildren,
            isDehydrated: hydrate,
            cache: tag
          };
          initializeUpdateQueue(isStrictMode);
          return containerInfo;
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) return emptyContextObject;
          parentComponent = emptyContextObject;
          return parentComponent;
        }
        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
          if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
            try {
              injectedHook.onScheduleFiberRoot(rendererID, container, element);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);
          parentComponent = getContextForSubtree(parentComponent);
          null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
          isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
            "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
            getComponentNameFromFiber(current) || "Unknown"
          ));
          container = createUpdate(lane);
          container.payload = { element };
          callback = void 0 === callback ? null : callback;
          null !== callback && ("function" !== typeof callback && console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback
          ), container.callback = callback);
          element = enqueueUpdate(rootFiber, container, lane);
          null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
        }
        function markRetryLaneImpl(fiber, retryLane) {
          fiber = fiber.memoizedState;
          if (null !== fiber && null !== fiber.dehydrated) {
            var a = fiber.retryLane;
            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
        }
        function attemptContinuousHydration(fiber) {
          if (13 === fiber.tag) {
            var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
            null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
            markRetryLaneIfNotHydrated(fiber, 67108864);
          }
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function getLaneLabelMap() {
          for (var map2 = /* @__PURE__ */ new Map(), lane = 1, index = 0; 31 > index; index++) {
            var label = getLabelForLane(lane);
            map2.set(lane, label);
            lane *= 2;
          }
          return map2;
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (_enabled) {
            var blockedOn = findInstanceBlockingEvent(nativeEvent);
            if (null === blockedOn)
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              ), clearIfContinuousEvent(domEventName, nativeEvent);
            else if (queueIfContinuousEvent(
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ))
              nativeEvent.stopPropagation();
            else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
              for (; null !== blockedOn; ) {
                var fiber = getInstanceFromNode(blockedOn);
                if (null !== fiber)
                  switch (fiber.tag) {
                    case 3:
                      fiber = fiber.stateNode;
                      if (fiber.current.memoizedState.isDehydrated) {
                        var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                        if (0 !== lanes) {
                          var root2 = fiber;
                          root2.pendingLanes |= 2;
                          for (root2.entangledLanes |= 2; lanes; ) {
                            var lane = 1 << 31 - clz32(lanes);
                            root2.entanglements[1] |= lane;
                            lanes &= ~lane;
                          }
                          ensureRootIsScheduled(fiber);
                          (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                        }
                      }
                      break;
                    case 13:
                      root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                  }
                fiber = findInstanceBlockingEvent(nativeEvent);
                null === fiber && dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer
                );
                if (fiber === blockedOn) break;
                blockedOn = fiber;
              }
              null !== blockedOn && nativeEvent.stopPropagation();
            } else
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                null,
                targetContainer
              );
          }
        }
        function findInstanceBlockingEvent(nativeEvent) {
          nativeEvent = getEventTarget(nativeEvent);
          return findInstanceBlockingTarget(nativeEvent);
        }
        function findInstanceBlockingTarget(targetNode) {
          return_targetInst = null;
          targetNode = getClosestInstanceFromNode(targetNode);
          if (null !== targetNode) {
            var nearestMounted = getNearestMountedFiber(targetNode);
            if (null === nearestMounted) targetNode = null;
            else {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (3 === tag) {
                if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                  return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                targetNode = null;
              } else nearestMounted !== targetNode && (targetNode = null);
            }
          }
          return_targetInst = targetNode;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message":
              switch (getCurrentPriorityLevel()) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority$1:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            default:
              return DefaultEventPriority;
          }
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout":
              queuedPointers.delete(nativeEvent.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              queuedPointerCaptures.delete(nativeEvent.pointerId);
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
            return existingQueuedEvent = {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          blockedOn = existingQueuedEvent.targetContainers;
          null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin":
              return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedFocus,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "dragenter":
              return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedDrag,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "mouseover":
              return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedMouse,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "pointerover":
              var pointerId = nativeEvent.pointerId;
              queuedPointers.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointers.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              );
              return true;
            case "gotpointercapture":
              return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointerCaptures.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              ), true;
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted) {
              if (targetInst = nearestMounted.tag, 13 === targetInst) {
                if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    if (13 === nearestMounted.tag) {
                      var lane = requestUpdateLane(nearestMounted);
                      lane = getBumpedLaneForHydrationByLane(lane);
                      var root2 = enqueueConcurrentRenderForLane(
                        nearestMounted,
                        lane
                      );
                      null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                      markRetryLaneIfNotHydrated(nearestMounted, lane);
                    }
                  });
                  return;
                }
              } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                return;
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (null !== queuedEvent.blockedOn) return false;
          for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
            if (null === nextBlockedOn) {
              nextBlockedOn = queuedEvent.nativeEvent;
              var nativeEventClone = new nextBlockedOn.constructor(
                nextBlockedOn.type,
                nextBlockedOn
              ), event = nativeEventClone;
              null !== currentReplayingEvent && console.error(
                "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = event;
              nextBlockedOn.target.dispatchEvent(nativeEventClone);
              null === currentReplayingEvent && console.error(
                "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = null;
            } else
              return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
          attemptReplayContinuousQueuedEvent(queuedEvent) && map2.delete(key);
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
          null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
          null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
        }
        function scheduleReplayQueueIfNeeded(formReplayingQueue) {
          lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            function() {
              lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
              for (var i = 0; i < formReplayingQueue.length; i += 3) {
                var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
                if ("function" !== typeof submitterOrAction)
                  if (null === findInstanceBlockingTarget(submitterOrAction || form))
                    continue;
                  else break;
                var formInst = getInstanceFromNode(form);
                null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }, Object.freeze(form), startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
              }
            }
          ));
        }
        function retryIfBlockedOn(unblocked) {
          function unblock(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
          }
          null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
            var queuedTarget = queuedExplicitHydrationTargets[i];
            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
          }
          for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
            attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
          i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
          if (null != i)
            for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
              var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
              if ("function" === typeof submitterOrAction)
                formProps || scheduleReplayQueueIfNeeded(i);
              else if (formProps) {
                var action = null;
                if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                  if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                    action = formProps.formAction;
                  else {
                    if (null !== findInstanceBlockingTarget(form)) continue;
                  }
                else action = formProps.action;
                "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
                scheduleReplayQueueIfNeeded(i);
              }
            }
        }
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function warnIfReactDOMContainerInDEV(container) {
          container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(
            "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
          ) : console.error(
            "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
          ));
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var Scheduler = require_scheduler(), React13 = require_react(), ReactDOM = require_react_dom(), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
        Symbol.for("react.scope");
        var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
        Symbol.for("react.legacy_hidden");
        Symbol.for("react.tracing_marker");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        Symbol.for("react.view_transition");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React13.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
          pending: false,
          data: null,
          method: null,
          action: null
        }), valueStack = [];
        var fiberStack = [];
        var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log3 = Math.log, LN2 = Math.LN2, nextTransitionLane = 256, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var current = null, isRendering = false, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
        var didWarnValueDefaultValue = false;
        var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null,
          containerTagInScope: null,
          implicitRootScope: false
        }, didWarn = {}, shorthandToLonghand = {
          animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
          background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
          borderBlockEnd: [
            "borderBlockEndColor",
            "borderBlockEndStyle",
            "borderBlockEndWidth"
          ],
          borderBlockStart: [
            "borderBlockStartColor",
            "borderBlockStartStyle",
            "borderBlockStartWidth"
          ],
          borderBottom: [
            "borderBottomColor",
            "borderBottomStyle",
            "borderBottomWidth"
          ],
          borderColor: [
            "borderBottomColor",
            "borderLeftColor",
            "borderRightColor",
            "borderTopColor"
          ],
          borderImage: [
            "borderImageOutset",
            "borderImageRepeat",
            "borderImageSlice",
            "borderImageSource",
            "borderImageWidth"
          ],
          borderInlineEnd: [
            "borderInlineEndColor",
            "borderInlineEndStyle",
            "borderInlineEndWidth"
          ],
          borderInlineStart: [
            "borderInlineStartColor",
            "borderInlineStartStyle",
            "borderInlineStartWidth"
          ],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: [
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
            "borderTopLeftRadius",
            "borderTopRightRadius"
          ],
          borderRight: [
            "borderRightColor",
            "borderRightStyle",
            "borderRightWidth"
          ],
          borderStyle: [
            "borderBottomStyle",
            "borderLeftStyle",
            "borderRightStyle",
            "borderTopStyle"
          ],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: [
            "borderBottomWidth",
            "borderLeftWidth",
            "borderRightWidth",
            "borderTopWidth"
          ],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
            " "
          ),
          fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
          gap: ["columnGap", "rowGap"],
          grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
            " "
          ),
          gridArea: [
            "gridColumnEnd",
            "gridColumnStart",
            "gridRowEnd",
            "gridRowStart"
          ],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: [
            "gridTemplateAreas",
            "gridTemplateColumns",
            "gridTemplateRows"
          ],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
            " "
          ),
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: [
            "textDecorationColor",
            "textDecorationLine",
            "textDecorationStyle"
          ],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: [
            "transitionDelay",
            "transitionDuration",
            "transitionProperty",
            "transitionTimingFunction"
          ],
          wordWrap: ["overflowWrap"]
        }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
          "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
            " "
          )
        ), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = /* @__PURE__ */ new Map([
          ["acceptCharset", "accept-charset"],
          ["htmlFor", "for"],
          ["httpEquiv", "http-equiv"],
          ["crossOrigin", "crossorigin"],
          ["accentHeight", "accent-height"],
          ["alignmentBaseline", "alignment-baseline"],
          ["arabicForm", "arabic-form"],
          ["baselineShift", "baseline-shift"],
          ["capHeight", "cap-height"],
          ["clipPath", "clip-path"],
          ["clipRule", "clip-rule"],
          ["colorInterpolation", "color-interpolation"],
          ["colorInterpolationFilters", "color-interpolation-filters"],
          ["colorProfile", "color-profile"],
          ["colorRendering", "color-rendering"],
          ["dominantBaseline", "dominant-baseline"],
          ["enableBackground", "enable-background"],
          ["fillOpacity", "fill-opacity"],
          ["fillRule", "fill-rule"],
          ["floodColor", "flood-color"],
          ["floodOpacity", "flood-opacity"],
          ["fontFamily", "font-family"],
          ["fontSize", "font-size"],
          ["fontSizeAdjust", "font-size-adjust"],
          ["fontStretch", "font-stretch"],
          ["fontStyle", "font-style"],
          ["fontVariant", "font-variant"],
          ["fontWeight", "font-weight"],
          ["glyphName", "glyph-name"],
          ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
          ["glyphOrientationVertical", "glyph-orientation-vertical"],
          ["horizAdvX", "horiz-adv-x"],
          ["horizOriginX", "horiz-origin-x"],
          ["imageRendering", "image-rendering"],
          ["letterSpacing", "letter-spacing"],
          ["lightingColor", "lighting-color"],
          ["markerEnd", "marker-end"],
          ["markerMid", "marker-mid"],
          ["markerStart", "marker-start"],
          ["overlinePosition", "overline-position"],
          ["overlineThickness", "overline-thickness"],
          ["paintOrder", "paint-order"],
          ["panose-1", "panose-1"],
          ["pointerEvents", "pointer-events"],
          ["renderingIntent", "rendering-intent"],
          ["shapeRendering", "shape-rendering"],
          ["stopColor", "stop-color"],
          ["stopOpacity", "stop-opacity"],
          ["strikethroughPosition", "strikethrough-position"],
          ["strikethroughThickness", "strikethrough-thickness"],
          ["strokeDasharray", "stroke-dasharray"],
          ["strokeDashoffset", "stroke-dashoffset"],
          ["strokeLinecap", "stroke-linecap"],
          ["strokeLinejoin", "stroke-linejoin"],
          ["strokeMiterlimit", "stroke-miterlimit"],
          ["strokeOpacity", "stroke-opacity"],
          ["strokeWidth", "stroke-width"],
          ["textAnchor", "text-anchor"],
          ["textDecoration", "text-decoration"],
          ["textRendering", "text-rendering"],
          ["transformOrigin", "transform-origin"],
          ["underlinePosition", "underline-position"],
          ["underlineThickness", "underline-thickness"],
          ["unicodeBidi", "unicode-bidi"],
          ["unicodeRange", "unicode-range"],
          ["unitsPerEm", "units-per-em"],
          ["vAlphabetic", "v-alphabetic"],
          ["vHanging", "v-hanging"],
          ["vIdeographic", "v-ideographic"],
          ["vMathematical", "v-mathematical"],
          ["vectorEffect", "vector-effect"],
          ["vertAdvY", "vert-adv-y"],
          ["vertOriginX", "vert-origin-x"],
          ["vertOriginY", "vert-origin-y"],
          ["wordSpacing", "word-spacing"],
          ["writingMode", "writing-mode"],
          ["xmlnsXlink", "xmlns:xlink"],
          ["xHeight", "x-height"]
        ]), possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          fetchpriority: "fetchPriority",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          inert: "inert",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          popover: "popover",
          popovertarget: "popoverTarget",
          popovertargetaction: "popoverTargetAction",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          transformorigin: "transformOrigin",
          "transform-origin": "transformOrigin",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        }, ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        }, warnedProperties$1 = {}, rARIA$1 = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel$1 = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
        if (canUseDOM)
          try {
            var options$jscomp$0 = {};
            Object.defineProperty(options$jscomp$0, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options$jscomp$0, options$jscomp$0);
            window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
          } catch (e) {
            passiveBrowserEventsSupported = false;
          }
        var root = null, startText = null, fallbackText = null, EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) return event.movementX;
            event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
            return lastMovementX;
          },
          movementY: function(event) {
            return "movementY" in event ? event.movementY : lastMovementY;
          }
        }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
          CompositionEventInterface
        ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        }, translateToKey = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta"
        }, modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        }, KeyboardEventInterface = assign({}, UIEventInterface, {
          key: function(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if ("Unidentified" !== key) return key;
            }
            return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : 0;
          },
          keyCode: function(event) {
            return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          },
          which: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          }
        }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
          newState: 0,
          oldState: 0
        }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
        canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
        canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
        var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionrun: makePrefixMap("Transition", "TransitionRun"),
          transitionstart: makePrefixMap("Transition", "TransitionStart"),
          transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        }, prefixedEventNames = {}, style = {};
        canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
        var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " "
        );
        simpleEventPluginEvents.push("scrollEnd");
        var CapturedStacks = /* @__PURE__ */ new WeakMap(), OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, NoStrictPassiveEffectsMode = 64;
        var hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e$3) {
          hasBadMapPolyfill = true;
        }
        var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
          "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), lastResetTime = 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          var getCurrentTime = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          getCurrentTime = function() {
            return localDate.now();
          };
        }
        var valueCursor = createCursor(null);
        var rendererCursorDEV = createCursor(null);
        var rendererSigil = {};
        var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
          var listeners = [], signal = this.signal = {
            aborted: false,
            addEventListener: function(type2, listener) {
              listeners.push(listener);
            }
          };
          this.abort = function() {
            signal.aborted = true;
            listeners.forEach(function(listener) {
              return listener();
            });
          };
        }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Consumer: null,
          Provider: null,
          _currentValue: null,
          _currentValue2: null,
          _threadCount: 0,
          _currentRenderer: null,
          _currentRenderer2: null
        }, now = Scheduler.unstable_now, renderStartTime = -0, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
        ReactSharedInternals.S = function(transition, returnValue) {
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
          null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
        };
        var resumedCache = createCursor(null), ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function() {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function() {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillMountWarnings = []);
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillMountWarnings = []);
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillReceivePropsWarnings = []);
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
            function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }
          ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillUpdateWarnings = []);
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
          if (0 < UNSAFE_componentWillMountUniqueNames.size) {
            var sortedNames = setToSortedString(
              UNSAFE_componentWillMountUniqueNames
            );
            console.error(
              "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
              sortedNames
            );
          }
          0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillReceivePropsUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillUpdateUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
            "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            componentWillReceivePropsUniqueNames
          ), console.warn(
            "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
            "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = null;
          for (var node = fiber; null !== node; )
            node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
          null === strictRoot ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          ) : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray) {
            if (0 !== fiberArray.length) {
              var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              runWithFiberInDEV(firstFiber, function() {
                console.error(
                  "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                  sortedNames
                );
              });
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
        var SuspenseException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
        ), SuspenseyCommitException = Error(
          "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), SuspenseActionException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
        ), noopSuspenseyCommitThenable = {
          then: function() {
            console.error(
              'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
            );
          }
        }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
        var didWarnUpdateInsideUpdate = false;
        var currentlyProcessingQueue = null;
        var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), didWarnUncachedGetSnapshot;
        var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
        var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
        var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
          readContext,
          use,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          useHostTransitionStatus: throwInvalidHookError,
          useFormState: throwInvalidHookError,
          useActionState: throwInvalidHookError,
          useOptimistic: throwInvalidHookError,
          useMemoCache: throwInvalidHookError,
          useCacheRefresh: throwInvalidHookError
        }, HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(createDeps);
            return mountEffect(create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            mountHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          }
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return mountActionState(action, initialState);
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return mountRefresh();
          }
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            updateHookTypesDev();
            warnOnUseFormStateInDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useHostTransitionStatus,
          useMemoCache,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          useFormState: function(action, initialState) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useActionState: function(action, initialState) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountActionState(action, initialState);
          },
          useOptimistic: function(passthrough) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountOptimistic(passthrough);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          }
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, createDeps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, createDeps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useFormState: function(action) {
            currentHookNameInDev = "useFormState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useActionState: function(action) {
            currentHookNameInDev = "useActionState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderActionState(action);
          },
          useOptimistic: function(passthrough, reducer) {
            currentHookNameInDev = "useOptimistic";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderOptimistic(passthrough, reducer);
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          },
          useHostTransitionStatus,
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        var callComponent = {
          "react-stack-bottom-frame": function(Component, props, secondArg) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return Component(props, secondArg);
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent), callRender = {
          "react-stack-bottom-frame": function(instance) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return instance.render();
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender), callComponentDidMount = {
          "react-stack-bottom-frame": function(finishedWork, instance) {
            try {
              instance.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidMountInDEV = callComponentDidMount["react-stack-bottom-frame"].bind(callComponentDidMount), callComponentDidUpdate = {
          "react-stack-bottom-frame": function(finishedWork, instance, prevProps, prevState, snapshot) {
            try {
              instance.componentDidUpdate(prevProps, prevState, snapshot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidUpdateInDEV = callComponentDidUpdate["react-stack-bottom-frame"].bind(callComponentDidUpdate), callComponentDidCatch = {
          "react-stack-bottom-frame": function(instance, errorInfo) {
            var stack = errorInfo.stack;
            instance.componentDidCatch(errorInfo.value, {
              componentStack: null !== stack ? stack : ""
            });
          }
        }, callComponentDidCatchInDEV = callComponentDidCatch["react-stack-bottom-frame"].bind(callComponentDidCatch), callComponentWillUnmount = {
          "react-stack-bottom-frame": function(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentWillUnmount();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callComponentWillUnmountInDEV = callComponentWillUnmount["react-stack-bottom-frame"].bind(callComponentWillUnmount), callCreate = {
          "react-stack-bottom-frame": function(effect) {
            null != effect.resourceKind && console.error(
              "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
              effect.resourceKind
            );
            var create = effect.create;
            effect = effect.inst;
            create = create();
            return effect.destroy = create;
          }
        }, callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate), callDestroy = {
          "react-stack-bottom-frame": function(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error);
            }
          }
        }, callDestroyInDEV = callDestroy["react-stack-bottom-frame"].bind(callDestroy), callLazyInit = {
          "react-stack-bottom-frame": function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
          }
        }, callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit), thenableState = null, thenableIndexCounter = 0, currentDebugInfo = null, didWarnAboutMaps;
        var didWarnAboutGenerators = didWarnAboutMaps = false;
        var ownerHasKeyUseWarning = {};
        var ownerHasFunctionTypeWarning = {};
        var ownerHasSymbolTypeWarning = {};
        warnForMissingKey = function(returnFiber, workInProgress2, child) {
          if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            child._store.validated = 1;
            var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
            if (!ownerHasKeyUseWarning[componentKey]) {
              ownerHasKeyUseWarning[componentKey] = true;
              child = child._owner;
              returnFiber = returnFiber._debugOwner;
              var currentComponentErrorInfo = "";
              returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
              currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
              var childOwnerAppendix = "";
              null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
              runWithFiberInDEV(workInProgress2, function() {
                console.error(
                  'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                  currentComponentErrorInfo,
                  childOwnerAppendix
                );
              });
            }
          }
        };
        var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
        var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
        var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        Object.freeze(fakeInternalInstance);
        var classComponentUpdater = {
          enqueueSetState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            markStateUpdateScheduled(inst, lane);
          },
          enqueueReplaceState: function(inst, payload, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ReplaceState;
            update.payload = payload;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            markStateUpdateScheduled(inst, lane);
          },
          enqueueForceUpdate: function(inst, callback) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ForceUpdate;
            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
            callback = enqueueUpdate(inst, update, lane);
            null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
          }
        }, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
          "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
        ), didReceiveUpdate = false;
        var didWarnAboutBadClass = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutContextTypes = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutRevealOrder = {};
        var didWarnAboutTailOptions = {};
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0,
          hydrationErrors: null
        }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
          getCacheForType: function(resourceType) {
            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
            return cacheForType;
          },
          getOwner: function() {
            return current;
          }
        };
        if ("function" === typeof Symbol && Symbol.for) {
          var symbolFor = Symbol.for;
          symbolFor("selector.component");
          symbolFor("selector.has_pseudo_class");
          symbolFor("selector.role");
          symbolFor("selector.test_id");
          symbolFor("selector.text");
        }
        var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
        (function() {
          for (var i = 0; i < simpleEventPluginEvents.length; i++) {
            var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();
            eventName = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + eventName);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
          registerSimpleEvent(TRANSITION_START, "onTransitionStart");
          registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        })();
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        registerTwoPhaseEvent(
          "onChange",
          "change click focusin focusout input keydown keyup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent(
          "onSelect",
          "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent("onBeforeInput", [
          "compositionend",
          "keypress",
          "textInput",
          "paste"
        ]);
        registerTwoPhaseEvent(
          "onCompositionEnd",
          "compositionend focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionStart",
          "compositionstart focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionUpdate",
          "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
        );
        var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ), nonDelegatedEvents = new Set(
          "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
        ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
        var didWarnForNewBooleanPropsWithEmptyValue = {};
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = 1, PREAMBLE_CONTRIBUTION_BODY = 2, PREAMBLE_CONTRIBUTION_HEAD = 4, FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_COMPLETE = "complete", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: function() {
            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
            return previousWasRendering || wasRendering;
          },
          r: function(form) {
            var formInst = getInstanceFromNode(form);
            null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
          },
          D: function(href) {
            previousDispatcher.D(href);
            preconnectAs("dns-prefetch", href, null);
          },
          C: function(href, crossOrigin) {
            previousDispatcher.C(href, crossOrigin);
            preconnectAs("preconnect", href, crossOrigin);
          },
          L: function(href, as, options) {
            previousDispatcher.L(href, as, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href && as) {
              var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
              "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSrcSet
              ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
              var key = preloadSelector;
              switch (as) {
                case "style":
                  key = getStyleKey(href);
                  break;
                case "script":
                  key = getScriptKey(href);
              }
              preloadPropsMap.has(key) || (href = assign(
                {
                  rel: "preload",
                  href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                  as
                },
                options
              ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
            }
          },
          m: function(href, options) {
            previousDispatcher.m(href, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
              switch (as) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  key = getScriptKey(href);
              }
              if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                switch (as) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                      return;
                }
                as = ownerDocument.createElement("link");
                setInitialProperties(as, "link", href);
                markNodeAsHoistable(as);
                ownerDocument.head.appendChild(as);
              }
            }
          },
          X: function(src, options) {
            previousDispatcher.X(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          },
          S: function(href, precedence, options) {
            previousDispatcher.S(href, precedence, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
              var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
              precedence = precedence || "default";
              var resource = styles.get(key);
              if (!resource) {
                var state = { loading: NotLoaded, preload: null };
                if (resource = ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                ))
                  state.loading = Loaded | Inserted;
                else {
                  href = assign(
                    {
                      rel: "stylesheet",
                      href,
                      "data-precedence": precedence
                    },
                    options
                  );
                  (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                  var link = resource = ownerDocument.createElement("link");
                  markNodeAsHoistable(link);
                  setInitialProperties(link, "link", href);
                  link._p = new Promise(function(resolve, reject) {
                    link.onload = resolve;
                    link.onerror = reject;
                  });
                  link.addEventListener("load", function() {
                    state.loading |= Loaded;
                  });
                  link.addEventListener("error", function() {
                    state.loading |= Errored;
                  });
                  state.loading |= Inserted;
                  insertStylesheet(resource, precedence, ownerDocument);
                }
                resource = {
                  type: "stylesheet",
                  instance: resource,
                  count: 1,
                  state
                };
                styles.set(key, resource);
              }
            }
          },
          M: function(src, options) {
            previousDispatcher.M(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          }
        };
        var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, suspendedState = null, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Provider: null,
          Consumer: null,
          _currentValue: NotPendingTransition,
          _currentValue2: NotPendingTransition,
          _threadCount: 0
        }, badgeFormat = "%c%s%c ", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind = Function.prototype.bind;
        var didWarnAboutNestedUpdates = false;
        var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;
        overrideHookState = function(fiber, id, path, value) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateDeletePath = function(fiber, id, path) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          id = findHook(fiber, id);
          null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
        };
        overrideProps = function(fiber, path, value) {
          fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(
            fiber.memoizedProps,
            oldPath,
            newPath
          );
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          oldPath = enqueueConcurrentRenderForLane(fiber, 2);
          null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
        };
        scheduleUpdate = function(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
        var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ), lastScheduledReplayQueue = null;
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root2 = this._internalRoot;
          if (null === root2) throw Error("Cannot update an unmounted root.");
          var args = arguments;
          "function" === typeof args[1] ? console.error(
            "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          ) : isValidContainer(args[1]) ? console.error(
            "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
          ) : "undefined" !== typeof args[1] && console.error(
            "You passed a second argument to root.render(...) but it only accepts one argument."
          );
          args = children;
          var current2 = root2.current, lane = requestUpdateLane(current2);
          updateContainerImpl(current2, lane, args, root2, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          var args = arguments;
          "function" === typeof args[0] && console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
          args = this._internalRoot;
          if (null !== args) {
            this._internalRoot = null;
            var container = args.containerInfo;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
            updateContainerImpl(args.current, 2, null, args, null, null);
            flushSyncWork$1();
            container[internalContainerInstanceKey] = null;
          }
        };
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
          if (target) {
            var updatePriority = resolveUpdatePriority();
            target = { blockedOn: null, target, priority: updatePriority };
            for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
            queuedExplicitHydrationTargets.splice(i, 0, target);
            0 === i && attemptExplicitHydrationTarget(target);
          }
        };
        (function() {
          var isomorphicReactPackageVersion = React13.version;
          if ("19.1.0" !== isomorphicReactPackageVersion)
            throw Error(
              'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.1.0\nLearn more: https://react.dev/warnings/version-mismatch")
            );
        })();
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
        );
        ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
          var fiber = componentOrElement._reactInternals;
          if (void 0 === fiber) {
            if ("function" === typeof componentOrElement.render)
              throw Error("Unable to find node on an unmounted component.");
            componentOrElement = Object.keys(componentOrElement).join(",");
            throw Error(
              "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
            );
          }
          componentOrElement = findCurrentFiberUsingSlowPath(fiber);
          componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
          componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
          return componentOrElement;
        };
        if (!function() {
          var internals = {
            bundleType: 1,
            version: "19.1.0",
            rendererPackageName: "react-dom",
            currentDispatcherRef: ReactSharedInternals,
            reconcilerVersion: "19.1.0"
          };
          internals.overrideHookState = overrideHookState;
          internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
          internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
          internals.overrideProps = overrideProps;
          internals.overridePropsDeletePath = overridePropsDeletePath;
          internals.overridePropsRenamePath = overridePropsRenamePath;
          internals.scheduleUpdate = scheduleUpdate;
          internals.setErrorHandler = setErrorHandler;
          internals.setSuspenseHandler = setSuspenseHandler;
          internals.scheduleRefresh = scheduleRefresh;
          internals.scheduleRoot = scheduleRoot;
          internals.setRefreshHandler = setRefreshHandler;
          internals.getCurrentFiber = getCurrentFiberForDevTools;
          internals.getLaneLabelMap = getLaneLabelMap;
          internals.injectProfilingHooks = injectProfilingHooks;
          return injectInternals(internals);
        }() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
          var protocol = window.location.protocol;
          /^(https?|file):$/.test(protocol) && console.info(
            "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
            "font-weight:bold"
          );
        }
        exports.createRoot = function(container, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
          null !== options && void 0 !== options && (options.hydrate ? console.warn(
            "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
          ) : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(
            "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
          ), true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
          options = createFiberRoot(
            container,
            1,
            false,
            null,
            null,
            isStrictMode,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            transitionCallbacks,
            null
          );
          container[internalContainerInstanceKey] = options.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMRoot(options);
        };
        exports.hydrateRoot = function(container, initialChildren, options) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          void 0 === initialChildren && console.error(
            "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
          );
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
          null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
          initialChildren = createFiberRoot(
            container,
            1,
            true,
            initialChildren,
            null != options ? options : null,
            isStrictMode,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            transitionCallbacks,
            formState
          );
          initialChildren.context = getContextForSubtree(null);
          options = initialChildren.current;
          isStrictMode = requestUpdateLane(options);
          isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
          identifierPrefix = createUpdate(isStrictMode);
          identifierPrefix.callback = null;
          enqueueUpdate(options, identifierPrefix, isStrictMode);
          options = isStrictMode;
          initialChildren.current.lanes = options;
          markRootUpdated$1(initialChildren, options);
          ensureRootIsScheduled(initialChildren);
          container[internalContainerInstanceKey] = initialChildren.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMHydrationRoot(initialChildren);
        };
        exports.version = "19.1.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_client_development();
      }
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      (function() {
        function getComponentNameFromType(type2) {
          if (null == type2) return null;
          if ("function" === typeof type2)
            return type2.$$typeof === REACT_CLIENT_REFERENCE ? null : type2.displayName || type2.name || null;
          if ("string" === typeof type2) return type2;
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
          }
          if ("object" === typeof type2)
            switch ("number" === typeof type2.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type2.$$typeof) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return (type2.displayName || "Context") + ".Provider";
              case REACT_CONSUMER_TYPE:
                return (type2._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type2.render;
                type2 = type2.displayName;
                type2 || (type2 = innerType.displayName || innerType.name || "", type2 = "" !== type2 ? "ForwardRef(" + type2 + ")" : "ForwardRef");
                return type2;
              case REACT_MEMO_TYPE:
                return innerType = type2.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type2._payload;
                type2 = type2._init;
                try {
                  return getComponentNameFromType(type2(innerType));
                } catch (x) {
                }
            }
          return null;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getTaskName(type2) {
          if (type2 === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type2 && null !== type2 && type2.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type2);
            return name ? "<" + name + ">" : "<...>";
          } catch (x) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type2, key, self2, source, owner, props, debugStack, debugTask) {
          self2 = props.ref;
          type2 = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type2,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type2, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type2, "ref", { enumerable: false, value: null });
          type2._store = {};
          Object.defineProperty(type2._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type2, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.defineProperty(type2, "_debugStack", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugStack
          });
          Object.defineProperty(type2, "_debugTask", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: debugTask
          });
          Object.freeze && (Object.freeze(type2.props), Object.freeze(type2));
          return type2;
        }
        function jsxDEVImpl(type2, config, maybeKey, isStaticChildren, source, self2, debugStack, debugTask) {
          var children = config.children;
          if (void 0 !== children)
            if (isStaticChildren)
              if (isArrayImpl(children)) {
                for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                  validateChildKeys(children[isStaticChildren]);
                Object.freeze && Object.freeze(children);
              } else
                console.error(
                  "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
                );
            else validateChildKeys(children);
          if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type2);
            var keys = Object.keys(config).filter(function(k) {
              return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
              'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
              isStaticChildren,
              children,
              keys,
              children
            ), didWarnAboutKeySpread[children + isStaticChildren] = true);
          }
          children = null;
          void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
          hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
          if ("key" in config) {
            maybeKey = {};
            for (var propName in config)
              "key" !== propName && (maybeKey[propName] = config[propName]);
          } else maybeKey = config;
          children && defineKeyPropWarningGetter(
            maybeKey,
            "function" === typeof type2 ? type2.displayName || type2.name || "Unknown" : type2
          );
          return ReactElement(
            type2,
            children,
            self2,
            source,
            getOwner(),
            maybeKey,
            debugStack,
            debugTask
          );
        }
        function validateChildKeys(node) {
          "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
        }
        var React13 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        Symbol.for("react.provider");
        var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React13.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
          return null;
        };
        React13 = {
          "react-stack-bottom-frame": function(callStackForError) {
            return callStackForError();
          }
        };
        var specialPropKeyWarningShown;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = React13["react-stack-bottom-frame"].bind(
          React13,
          UnknownOwner
        )();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutKeySpread = {};
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = function(type2, config, maybeKey, source, self2) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type2,
            config,
            maybeKey,
            false,
            source,
            self2,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type2)) : unknownOwnerDebugTask
          );
        };
        exports.jsxs = function(type2, config, maybeKey, source, self2) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          return jsxDEVImpl(
            type2,
            config,
            maybeKey,
            true,
            source,
            self2,
            trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
            trackActualOwner ? createTask(getTaskName(type2)) : unknownOwnerDebugTask
          );
        };
      })();
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "node_modules/lodash/_listCacheClear.js"(exports, module) {
      "use strict";
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module.exports = listCacheClear;
    }
  });

  // node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "node_modules/lodash/eq.js"(exports, module) {
      "use strict";
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      module.exports = eq;
    }
  });

  // node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "node_modules/lodash/_assocIndexOf.js"(exports, module) {
      "use strict";
      var eq = require_eq();
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module.exports = assocIndexOf;
    }
  });

  // node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "node_modules/lodash/_listCacheDelete.js"(exports, module) {
      "use strict";
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      module.exports = listCacheDelete;
    }
  });

  // node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "node_modules/lodash/_listCacheGet.js"(exports, module) {
      "use strict";
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      module.exports = listCacheGet;
    }
  });

  // node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "node_modules/lodash/_listCacheHas.js"(exports, module) {
      "use strict";
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module.exports = listCacheHas;
    }
  });

  // node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "node_modules/lodash/_listCacheSet.js"(exports, module) {
      "use strict";
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      module.exports = listCacheSet;
    }
  });

  // node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "node_modules/lodash/_ListCache.js"(exports, module) {
      "use strict";
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module.exports = ListCache;
    }
  });

  // node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "node_modules/lodash/_stackClear.js"(exports, module) {
      "use strict";
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module.exports = stackClear;
    }
  });

  // node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "node_modules/lodash/_stackDelete.js"(exports, module) {
      "use strict";
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module.exports = stackDelete;
    }
  });

  // node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "node_modules/lodash/_stackGet.js"(exports, module) {
      "use strict";
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module.exports = stackGet;
    }
  });

  // node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "node_modules/lodash/_stackHas.js"(exports, module) {
      "use strict";
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module.exports = stackHas;
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports, module) {
      "use strict";
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports, module) {
      "use strict";
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module.exports = root;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports, module) {
      "use strict";
      var root = require_root();
      var Symbol3 = root.Symbol;
      module.exports = Symbol3;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports, module) {
      "use strict";
      var Symbol3 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol3 ? Symbol3.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports, module) {
      "use strict";
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module.exports = objectToString;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports, module) {
      "use strict";
      var Symbol3 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol3 ? Symbol3.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports, module) {
      "use strict";
      function isObject2(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      module.exports = isObject2;
    }
  });

  // node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/lodash/isFunction.js"(exports, module) {
      "use strict";
      var baseGetTag = require_baseGetTag();
      var isObject2 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module.exports = isFunction;
    }
  });

  // node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "node_modules/lodash/_coreJsData.js"(exports, module) {
      "use strict";
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module.exports = coreJsData;
    }
  });

  // node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "node_modules/lodash/_isMasked.js"(exports, module) {
      "use strict";
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module.exports = isMasked;
    }
  });

  // node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "node_modules/lodash/_toSource.js"(exports, module) {
      "use strict";
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      module.exports = toSource;
    }
  });

  // node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "node_modules/lodash/_baseIsNative.js"(exports, module) {
      "use strict";
      var isFunction = require_isFunction();
      var isMasked = require_isMasked();
      var isObject2 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module.exports = baseIsNative;
    }
  });

  // node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "node_modules/lodash/_getValue.js"(exports, module) {
      "use strict";
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      module.exports = getValue;
    }
  });

  // node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "node_modules/lodash/_getNative.js"(exports, module) {
      "use strict";
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      module.exports = getNative;
    }
  });

  // node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "node_modules/lodash/_Map.js"(exports, module) {
      "use strict";
      var getNative = require_getNative();
      var root = require_root();
      var Map2 = getNative(root, "Map");
      module.exports = Map2;
    }
  });

  // node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "node_modules/lodash/_nativeCreate.js"(exports, module) {
      "use strict";
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module.exports = nativeCreate;
    }
  });

  // node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "node_modules/lodash/_hashClear.js"(exports, module) {
      "use strict";
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module.exports = hashClear;
    }
  });

  // node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "node_modules/lodash/_hashDelete.js"(exports, module) {
      "use strict";
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = hashDelete;
    }
  });

  // node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "node_modules/lodash/_hashGet.js"(exports, module) {
      "use strict";
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      module.exports = hashGet;
    }
  });

  // node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "node_modules/lodash/_hashHas.js"(exports, module) {
      "use strict";
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      module.exports = hashHas;
    }
  });

  // node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "node_modules/lodash/_hashSet.js"(exports, module) {
      "use strict";
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module.exports = hashSet;
    }
  });

  // node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "node_modules/lodash/_Hash.js"(exports, module) {
      "use strict";
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module.exports = Hash;
    }
  });

  // node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "node_modules/lodash/_mapCacheClear.js"(exports, module) {
      "use strict";
      var Hash = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      module.exports = mapCacheClear;
    }
  });

  // node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "node_modules/lodash/_isKeyable.js"(exports, module) {
      "use strict";
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      module.exports = isKeyable;
    }
  });

  // node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "node_modules/lodash/_getMapData.js"(exports, module) {
      "use strict";
      var isKeyable = require_isKeyable();
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module.exports = getMapData;
    }
  });

  // node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
      "use strict";
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = mapCacheDelete;
    }
  });

  // node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "node_modules/lodash/_mapCacheGet.js"(exports, module) {
      "use strict";
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module.exports = mapCacheGet;
    }
  });

  // node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "node_modules/lodash/_mapCacheHas.js"(exports, module) {
      "use strict";
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module.exports = mapCacheHas;
    }
  });

  // node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "node_modules/lodash/_mapCacheSet.js"(exports, module) {
      "use strict";
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      module.exports = mapCacheSet;
    }
  });

  // node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "node_modules/lodash/_MapCache.js"(exports, module) {
      "use strict";
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module.exports = MapCache;
    }
  });

  // node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "node_modules/lodash/_stackSet.js"(exports, module) {
      "use strict";
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs2 = data.__data__;
          if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
            pairs2.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs2);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module.exports = stackSet;
    }
  });

  // node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "node_modules/lodash/_Stack.js"(exports, module) {
      "use strict";
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      module.exports = Stack;
    }
  });

  // node_modules/lodash/_arrayEach.js
  var require_arrayEach = __commonJS({
    "node_modules/lodash/_arrayEach.js"(exports, module) {
      "use strict";
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      module.exports = arrayEach;
    }
  });

  // node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/lodash/_defineProperty.js"(exports, module) {
      "use strict";
      var getNative = require_getNative();
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      module.exports = defineProperty;
    }
  });

  // node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS({
    "node_modules/lodash/_baseAssignValue.js"(exports, module) {
      "use strict";
      var defineProperty = require_defineProperty();
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      module.exports = baseAssignValue;
    }
  });

  // node_modules/lodash/_assignValue.js
  var require_assignValue = __commonJS({
    "node_modules/lodash/_assignValue.js"(exports, module) {
      "use strict";
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module.exports = assignValue;
    }
  });

  // node_modules/lodash/_copyObject.js
  var require_copyObject = __commonJS({
    "node_modules/lodash/_copyObject.js"(exports, module) {
      "use strict";
      var assignValue = require_assignValue();
      var baseAssignValue = require_baseAssignValue();
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      module.exports = copyObject;
    }
  });

  // node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "node_modules/lodash/_baseTimes.js"(exports, module) {
      "use strict";
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      module.exports = baseTimes;
    }
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js"(exports, module) {
      "use strict";
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module.exports = isObjectLike;
    }
  });

  // node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "node_modules/lodash/_baseIsArguments.js"(exports, module) {
      "use strict";
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      module.exports = baseIsArguments;
    }
  });

  // node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/lodash/isArguments.js"(exports, module) {
      "use strict";
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike = require_isObjectLike();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module.exports = isArguments;
    }
  });

  // node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "node_modules/lodash/isArray.js"(exports, module) {
      "use strict";
      var isArray = Array.isArray;
      module.exports = isArray;
    }
  });

  // node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "node_modules/lodash/stubFalse.js"(exports, module) {
      "use strict";
      function stubFalse() {
        return false;
      }
      module.exports = stubFalse;
    }
  });

  // node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "node_modules/lodash/isBuffer.js"(exports, module) {
      "use strict";
      var root = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module.exports = isBuffer;
    }
  });

  // node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "node_modules/lodash/_isIndex.js"(exports, module) {
      "use strict";
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type2 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module.exports = isIndex;
    }
  });

  // node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "node_modules/lodash/isLength.js"(exports, module) {
      "use strict";
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module.exports = isLength;
    }
  });

  // node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
      "use strict";
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module.exports = baseIsTypedArray;
    }
  });

  // node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "node_modules/lodash/_baseUnary.js"(exports, module) {
      "use strict";
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module.exports = baseUnary;
    }
  });

  // node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "node_modules/lodash/_nodeUtil.js"(exports, module) {
      "use strict";
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      module.exports = nodeUtil;
    }
  });

  // node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "node_modules/lodash/isTypedArray.js"(exports, module) {
      "use strict";
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module.exports = isTypedArray;
    }
  });

  // node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
      "use strict";
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = arrayLikeKeys;
    }
  });

  // node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "node_modules/lodash/_isPrototype.js"(exports, module) {
      "use strict";
      var objectProto = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      module.exports = isPrototype;
    }
  });

  // node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "node_modules/lodash/_overArg.js"(exports, module) {
      "use strict";
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module.exports = overArg;
    }
  });

  // node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "node_modules/lodash/_nativeKeys.js"(exports, module) {
      "use strict";
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module.exports = nativeKeys;
    }
  });

  // node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "node_modules/lodash/_baseKeys.js"(exports, module) {
      "use strict";
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeys;
    }
  });

  // node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "node_modules/lodash/isArrayLike.js"(exports, module) {
      "use strict";
      var isFunction = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      module.exports = isArrayLike;
    }
  });

  // node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "node_modules/lodash/keys.js"(exports, module) {
      "use strict";
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      module.exports = keys;
    }
  });

  // node_modules/lodash/_baseAssign.js
  var require_baseAssign = __commonJS({
    "node_modules/lodash/_baseAssign.js"(exports, module) {
      "use strict";
      var copyObject = require_copyObject();
      var keys = require_keys();
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      module.exports = baseAssign;
    }
  });

  // node_modules/lodash/_nativeKeysIn.js
  var require_nativeKeysIn = __commonJS({
    "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
      "use strict";
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = nativeKeysIn;
    }
  });

  // node_modules/lodash/_baseKeysIn.js
  var require_baseKeysIn = __commonJS({
    "node_modules/lodash/_baseKeysIn.js"(exports, module) {
      "use strict";
      var isObject2 = require_isObject();
      var isPrototype = require_isPrototype();
      var nativeKeysIn = require_nativeKeysIn();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeysIn;
    }
  });

  // node_modules/lodash/keysIn.js
  var require_keysIn = __commonJS({
    "node_modules/lodash/keysIn.js"(exports, module) {
      "use strict";
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeysIn = require_baseKeysIn();
      var isArrayLike = require_isArrayLike();
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      module.exports = keysIn;
    }
  });

  // node_modules/lodash/_baseAssignIn.js
  var require_baseAssignIn = __commonJS({
    "node_modules/lodash/_baseAssignIn.js"(exports, module) {
      "use strict";
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      module.exports = baseAssignIn;
    }
  });

  // node_modules/lodash/_cloneBuffer.js
  var require_cloneBuffer = __commonJS({
    "node_modules/lodash/_cloneBuffer.js"(exports, module) {
      "use strict";
      var root = require_root();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      module.exports = cloneBuffer;
    }
  });

  // node_modules/lodash/_copyArray.js
  var require_copyArray = __commonJS({
    "node_modules/lodash/_copyArray.js"(exports, module) {
      "use strict";
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      module.exports = copyArray;
    }
  });

  // node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "node_modules/lodash/_arrayFilter.js"(exports, module) {
      "use strict";
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module.exports = arrayFilter;
    }
  });

  // node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "node_modules/lodash/stubArray.js"(exports, module) {
      "use strict";
      function stubArray() {
        return [];
      }
      module.exports = stubArray;
    }
  });

  // node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "node_modules/lodash/_getSymbols.js"(exports, module) {
      "use strict";
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto = Object.prototype;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      module.exports = getSymbols;
    }
  });

  // node_modules/lodash/_copySymbols.js
  var require_copySymbols = __commonJS({
    "node_modules/lodash/_copySymbols.js"(exports, module) {
      "use strict";
      var copyObject = require_copyObject();
      var getSymbols = require_getSymbols();
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      module.exports = copySymbols;
    }
  });

  // node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "node_modules/lodash/_arrayPush.js"(exports, module) {
      "use strict";
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      module.exports = arrayPush;
    }
  });

  // node_modules/lodash/_getPrototype.js
  var require_getPrototype = __commonJS({
    "node_modules/lodash/_getPrototype.js"(exports, module) {
      "use strict";
      var overArg = require_overArg();
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      module.exports = getPrototype;
    }
  });

  // node_modules/lodash/_getSymbolsIn.js
  var require_getSymbolsIn = __commonJS({
    "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
      "use strict";
      var arrayPush = require_arrayPush();
      var getPrototype = require_getPrototype();
      var getSymbols = require_getSymbols();
      var stubArray = require_stubArray();
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };
      module.exports = getSymbolsIn;
    }
  });

  // node_modules/lodash/_copySymbolsIn.js
  var require_copySymbolsIn = __commonJS({
    "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
      "use strict";
      var copyObject = require_copyObject();
      var getSymbolsIn = require_getSymbolsIn();
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      module.exports = copySymbolsIn;
    }
  });

  // node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
      "use strict";
      var arrayPush = require_arrayPush();
      var isArray = require_isArray();
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      module.exports = baseGetAllKeys;
    }
  });

  // node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "node_modules/lodash/_getAllKeys.js"(exports, module) {
      "use strict";
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys = require_keys();
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      module.exports = getAllKeys;
    }
  });

  // node_modules/lodash/_getAllKeysIn.js
  var require_getAllKeysIn = __commonJS({
    "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
      "use strict";
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbolsIn = require_getSymbolsIn();
      var keysIn = require_keysIn();
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      module.exports = getAllKeysIn;
    }
  });

  // node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "node_modules/lodash/_DataView.js"(exports, module) {
      "use strict";
      var getNative = require_getNative();
      var root = require_root();
      var DataView2 = getNative(root, "DataView");
      module.exports = DataView2;
    }
  });

  // node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "node_modules/lodash/_Promise.js"(exports, module) {
      "use strict";
      var getNative = require_getNative();
      var root = require_root();
      var Promise2 = getNative(root, "Promise");
      module.exports = Promise2;
    }
  });

  // node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "node_modules/lodash/_Set.js"(exports, module) {
      "use strict";
      var getNative = require_getNative();
      var root = require_root();
      var Set2 = getNative(root, "Set");
      module.exports = Set2;
    }
  });

  // node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "node_modules/lodash/_WeakMap.js"(exports, module) {
      "use strict";
      var getNative = require_getNative();
      var root = require_root();
      var WeakMap2 = getNative(root, "WeakMap");
      module.exports = WeakMap2;
    }
  });

  // node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "node_modules/lodash/_getTag.js"(exports, module) {
      "use strict";
      var DataView2 = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap2 = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView2);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module.exports = getTag;
    }
  });

  // node_modules/lodash/_initCloneArray.js
  var require_initCloneArray = __commonJS({
    "node_modules/lodash/_initCloneArray.js"(exports, module) {
      "use strict";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      module.exports = initCloneArray;
    }
  });

  // node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "node_modules/lodash/_Uint8Array.js"(exports, module) {
      "use strict";
      var root = require_root();
      var Uint8Array2 = root.Uint8Array;
      module.exports = Uint8Array2;
    }
  });

  // node_modules/lodash/_cloneArrayBuffer.js
  var require_cloneArrayBuffer = __commonJS({
    "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
      "use strict";
      var Uint8Array2 = require_Uint8Array();
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      module.exports = cloneArrayBuffer;
    }
  });

  // node_modules/lodash/_cloneDataView.js
  var require_cloneDataView = __commonJS({
    "node_modules/lodash/_cloneDataView.js"(exports, module) {
      "use strict";
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      module.exports = cloneDataView;
    }
  });

  // node_modules/lodash/_cloneRegExp.js
  var require_cloneRegExp = __commonJS({
    "node_modules/lodash/_cloneRegExp.js"(exports, module) {
      "use strict";
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      module.exports = cloneRegExp;
    }
  });

  // node_modules/lodash/_cloneSymbol.js
  var require_cloneSymbol = __commonJS({
    "node_modules/lodash/_cloneSymbol.js"(exports, module) {
      "use strict";
      var Symbol3 = require_Symbol();
      var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      module.exports = cloneSymbol;
    }
  });

  // node_modules/lodash/_cloneTypedArray.js
  var require_cloneTypedArray = __commonJS({
    "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
      "use strict";
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      module.exports = cloneTypedArray;
    }
  });

  // node_modules/lodash/_initCloneByTag.js
  var require_initCloneByTag = __commonJS({
    "node_modules/lodash/_initCloneByTag.js"(exports, module) {
      "use strict";
      var cloneArrayBuffer = require_cloneArrayBuffer();
      var cloneDataView = require_cloneDataView();
      var cloneRegExp = require_cloneRegExp();
      var cloneSymbol = require_cloneSymbol();
      var cloneTypedArray = require_cloneTypedArray();
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      module.exports = initCloneByTag;
    }
  });

  // node_modules/lodash/_baseCreate.js
  var require_baseCreate = __commonJS({
    "node_modules/lodash/_baseCreate.js"(exports, module) {
      "use strict";
      var isObject2 = require_isObject();
      var objectCreate = Object.create;
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      module.exports = baseCreate;
    }
  });

  // node_modules/lodash/_initCloneObject.js
  var require_initCloneObject = __commonJS({
    "node_modules/lodash/_initCloneObject.js"(exports, module) {
      "use strict";
      var baseCreate = require_baseCreate();
      var getPrototype = require_getPrototype();
      var isPrototype = require_isPrototype();
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      module.exports = initCloneObject;
    }
  });

  // node_modules/lodash/_baseIsMap.js
  var require_baseIsMap = __commonJS({
    "node_modules/lodash/_baseIsMap.js"(exports, module) {
      "use strict";
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var mapTag = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      module.exports = baseIsMap;
    }
  });

  // node_modules/lodash/isMap.js
  var require_isMap = __commonJS({
    "node_modules/lodash/isMap.js"(exports, module) {
      "use strict";
      var baseIsMap = require_baseIsMap();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      module.exports = isMap;
    }
  });

  // node_modules/lodash/_baseIsSet.js
  var require_baseIsSet = __commonJS({
    "node_modules/lodash/_baseIsSet.js"(exports, module) {
      "use strict";
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var setTag = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      module.exports = baseIsSet;
    }
  });

  // node_modules/lodash/isSet.js
  var require_isSet = __commonJS({
    "node_modules/lodash/isSet.js"(exports, module) {
      "use strict";
      var baseIsSet = require_baseIsSet();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      module.exports = isSet;
    }
  });

  // node_modules/lodash/_baseClone.js
  var require_baseClone = __commonJS({
    "node_modules/lodash/_baseClone.js"(exports, module) {
      "use strict";
      var Stack = require_Stack();
      var arrayEach = require_arrayEach();
      var assignValue = require_assignValue();
      var baseAssign = require_baseAssign();
      var baseAssignIn = require_baseAssignIn();
      var cloneBuffer = require_cloneBuffer();
      var copyArray = require_copyArray();
      var copySymbols = require_copySymbols();
      var copySymbolsIn = require_copySymbolsIn();
      var getAllKeys = require_getAllKeys();
      var getAllKeysIn = require_getAllKeysIn();
      var getTag = require_getTag();
      var initCloneArray = require_initCloneArray();
      var initCloneByTag = require_initCloneByTag();
      var initCloneObject = require_initCloneObject();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isMap = require_isMap();
      var isObject2 = require_isObject();
      var isSet = require_isSet();
      var keys = require_keys();
      var keysIn = require_keysIn();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_FLAT_FLAG = 2;
      var CLONE_SYMBOLS_FLAG = 4;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      module.exports = baseClone;
    }
  });

  // node_modules/lodash/clone.js
  var require_clone = __commonJS({
    "node_modules/lodash/clone.js"(exports, module) {
      "use strict";
      var baseClone = require_baseClone();
      var CLONE_SYMBOLS_FLAG = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      module.exports = clone;
    }
  });

  // node_modules/lodash/constant.js
  var require_constant = __commonJS({
    "node_modules/lodash/constant.js"(exports, module) {
      "use strict";
      function constant(value) {
        return function() {
          return value;
        };
      }
      module.exports = constant;
    }
  });

  // node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS({
    "node_modules/lodash/_createBaseFor.js"(exports, module) {
      "use strict";
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      module.exports = createBaseFor;
    }
  });

  // node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS({
    "node_modules/lodash/_baseFor.js"(exports, module) {
      "use strict";
      var createBaseFor = require_createBaseFor();
      var baseFor = createBaseFor();
      module.exports = baseFor;
    }
  });

  // node_modules/lodash/_baseForOwn.js
  var require_baseForOwn = __commonJS({
    "node_modules/lodash/_baseForOwn.js"(exports, module) {
      "use strict";
      var baseFor = require_baseFor();
      var keys = require_keys();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      module.exports = baseForOwn;
    }
  });

  // node_modules/lodash/_createBaseEach.js
  var require_createBaseEach = __commonJS({
    "node_modules/lodash/_createBaseEach.js"(exports, module) {
      "use strict";
      var isArrayLike = require_isArrayLike();
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      module.exports = createBaseEach;
    }
  });

  // node_modules/lodash/_baseEach.js
  var require_baseEach = __commonJS({
    "node_modules/lodash/_baseEach.js"(exports, module) {
      "use strict";
      var baseForOwn = require_baseForOwn();
      var createBaseEach = require_createBaseEach();
      var baseEach = createBaseEach(baseForOwn);
      module.exports = baseEach;
    }
  });

  // node_modules/lodash/identity.js
  var require_identity = __commonJS({
    "node_modules/lodash/identity.js"(exports, module) {
      "use strict";
      function identity(value) {
        return value;
      }
      module.exports = identity;
    }
  });

  // node_modules/lodash/_castFunction.js
  var require_castFunction = __commonJS({
    "node_modules/lodash/_castFunction.js"(exports, module) {
      "use strict";
      var identity = require_identity();
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      module.exports = castFunction;
    }
  });

  // node_modules/lodash/forEach.js
  var require_forEach = __commonJS({
    "node_modules/lodash/forEach.js"(exports, module) {
      "use strict";
      var arrayEach = require_arrayEach();
      var baseEach = require_baseEach();
      var castFunction = require_castFunction();
      var isArray = require_isArray();
      function forEach(collection, iteratee) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, castFunction(iteratee));
      }
      module.exports = forEach;
    }
  });

  // node_modules/lodash/each.js
  var require_each = __commonJS({
    "node_modules/lodash/each.js"(exports, module) {
      "use strict";
      module.exports = require_forEach();
    }
  });

  // node_modules/lodash/_baseFilter.js
  var require_baseFilter = __commonJS({
    "node_modules/lodash/_baseFilter.js"(exports, module) {
      "use strict";
      var baseEach = require_baseEach();
      function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result.push(value);
          }
        });
        return result;
      }
      module.exports = baseFilter;
    }
  });

  // node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "node_modules/lodash/_setCacheAdd.js"(exports, module) {
      "use strict";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module.exports = setCacheAdd;
    }
  });

  // node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "node_modules/lodash/_setCacheHas.js"(exports, module) {
      "use strict";
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module.exports = setCacheHas;
    }
  });

  // node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "node_modules/lodash/_SetCache.js"(exports, module) {
      "use strict";
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module.exports = SetCache;
    }
  });

  // node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "node_modules/lodash/_arraySome.js"(exports, module) {
      "use strict";
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      module.exports = arraySome;
    }
  });

  // node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "node_modules/lodash/_cacheHas.js"(exports, module) {
      "use strict";
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      module.exports = cacheHas;
    }
  });

  // node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "node_modules/lodash/_equalArrays.js"(exports, module) {
      "use strict";
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      module.exports = equalArrays;
    }
  });

  // node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "node_modules/lodash/_mapToArray.js"(exports, module) {
      "use strict";
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      module.exports = mapToArray;
    }
  });

  // node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "node_modules/lodash/_setToArray.js"(exports, module) {
      "use strict";
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      module.exports = setToArray;
    }
  });

  // node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "node_modules/lodash/_equalByTag.js"(exports, module) {
      "use strict";
      var Symbol3 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq = require_eq();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      module.exports = equalByTag;
    }
  });

  // node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "node_modules/lodash/_equalObjects.js"(exports, module) {
      "use strict";
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      module.exports = equalObjects;
    }
  });

  // node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
      "use strict";
      var Stack = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      module.exports = baseIsEqualDeep;
    }
  });

  // node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "node_modules/lodash/_baseIsEqual.js"(exports, module) {
      "use strict";
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike = require_isObjectLike();
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      module.exports = baseIsEqual;
    }
  });

  // node_modules/lodash/_baseIsMatch.js
  var require_baseIsMatch = __commonJS({
    "node_modules/lodash/_baseIsMatch.js"(exports, module) {
      "use strict";
      var Stack = require_Stack();
      var baseIsEqual = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      module.exports = baseIsMatch;
    }
  });

  // node_modules/lodash/_isStrictComparable.js
  var require_isStrictComparable = __commonJS({
    "node_modules/lodash/_isStrictComparable.js"(exports, module) {
      "use strict";
      var isObject2 = require_isObject();
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      module.exports = isStrictComparable;
    }
  });

  // node_modules/lodash/_getMatchData.js
  var require_getMatchData = __commonJS({
    "node_modules/lodash/_getMatchData.js"(exports, module) {
      "use strict";
      var isStrictComparable = require_isStrictComparable();
      var keys = require_keys();
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      module.exports = getMatchData;
    }
  });

  // node_modules/lodash/_matchesStrictComparable.js
  var require_matchesStrictComparable = __commonJS({
    "node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
      "use strict";
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      module.exports = matchesStrictComparable;
    }
  });

  // node_modules/lodash/_baseMatches.js
  var require_baseMatches = __commonJS({
    "node_modules/lodash/_baseMatches.js"(exports, module) {
      "use strict";
      var baseIsMatch = require_baseIsMatch();
      var getMatchData = require_getMatchData();
      var matchesStrictComparable = require_matchesStrictComparable();
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      module.exports = baseMatches;
    }
  });

  // node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "node_modules/lodash/isSymbol.js"(exports, module) {
      "use strict";
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module.exports = isSymbol;
    }
  });

  // node_modules/lodash/_isKey.js
  var require_isKey = __commonJS({
    "node_modules/lodash/_isKey.js"(exports, module) {
      "use strict";
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      module.exports = isKey;
    }
  });

  // node_modules/lodash/memoize.js
  var require_memoize = __commonJS({
    "node_modules/lodash/memoize.js"(exports, module) {
      "use strict";
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      module.exports = memoize;
    }
  });

  // node_modules/lodash/_memoizeCapped.js
  var require_memoizeCapped = __commonJS({
    "node_modules/lodash/_memoizeCapped.js"(exports, module) {
      "use strict";
      var memoize = require_memoize();
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      module.exports = memoizeCapped;
    }
  });

  // node_modules/lodash/_stringToPath.js
  var require_stringToPath = __commonJS({
    "node_modules/lodash/_stringToPath.js"(exports, module) {
      "use strict";
      var memoizeCapped = require_memoizeCapped();
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      module.exports = stringToPath;
    }
  });

  // node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "node_modules/lodash/_arrayMap.js"(exports, module) {
      "use strict";
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      module.exports = arrayMap;
    }
  });

  // node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS({
    "node_modules/lodash/_baseToString.js"(exports, module) {
      "use strict";
      var Symbol3 = require_Symbol();
      var arrayMap = require_arrayMap();
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      var symbolProto = Symbol3 ? Symbol3.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = baseToString;
    }
  });

  // node_modules/lodash/toString.js
  var require_toString = __commonJS({
    "node_modules/lodash/toString.js"(exports, module) {
      "use strict";
      var baseToString = require_baseToString();
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      module.exports = toString2;
    }
  });

  // node_modules/lodash/_castPath.js
  var require_castPath = __commonJS({
    "node_modules/lodash/_castPath.js"(exports, module) {
      "use strict";
      var isArray = require_isArray();
      var isKey = require_isKey();
      var stringToPath = require_stringToPath();
      var toString2 = require_toString();
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString2(value));
      }
      module.exports = castPath;
    }
  });

  // node_modules/lodash/_toKey.js
  var require_toKey = __commonJS({
    "node_modules/lodash/_toKey.js"(exports, module) {
      "use strict";
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = toKey;
    }
  });

  // node_modules/lodash/_baseGet.js
  var require_baseGet = __commonJS({
    "node_modules/lodash/_baseGet.js"(exports, module) {
      "use strict";
      var castPath = require_castPath();
      var toKey = require_toKey();
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      module.exports = baseGet;
    }
  });

  // node_modules/lodash/get.js
  var require_get = __commonJS({
    "node_modules/lodash/get.js"(exports, module) {
      "use strict";
      var baseGet = require_baseGet();
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      module.exports = get;
    }
  });

  // node_modules/lodash/_baseHasIn.js
  var require_baseHasIn = __commonJS({
    "node_modules/lodash/_baseHasIn.js"(exports, module) {
      "use strict";
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      module.exports = baseHasIn;
    }
  });

  // node_modules/lodash/_hasPath.js
  var require_hasPath = __commonJS({
    "node_modules/lodash/_hasPath.js"(exports, module) {
      "use strict";
      var castPath = require_castPath();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isIndex = require_isIndex();
      var isLength = require_isLength();
      var toKey = require_toKey();
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      module.exports = hasPath;
    }
  });

  // node_modules/lodash/hasIn.js
  var require_hasIn = __commonJS({
    "node_modules/lodash/hasIn.js"(exports, module) {
      "use strict";
      var baseHasIn = require_baseHasIn();
      var hasPath = require_hasPath();
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      module.exports = hasIn;
    }
  });

  // node_modules/lodash/_baseMatchesProperty.js
  var require_baseMatchesProperty = __commonJS({
    "node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
      "use strict";
      var baseIsEqual = require_baseIsEqual();
      var get = require_get();
      var hasIn = require_hasIn();
      var isKey = require_isKey();
      var isStrictComparable = require_isStrictComparable();
      var matchesStrictComparable = require_matchesStrictComparable();
      var toKey = require_toKey();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      module.exports = baseMatchesProperty;
    }
  });

  // node_modules/lodash/_baseProperty.js
  var require_baseProperty = __commonJS({
    "node_modules/lodash/_baseProperty.js"(exports, module) {
      "use strict";
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      module.exports = baseProperty;
    }
  });

  // node_modules/lodash/_basePropertyDeep.js
  var require_basePropertyDeep = __commonJS({
    "node_modules/lodash/_basePropertyDeep.js"(exports, module) {
      "use strict";
      var baseGet = require_baseGet();
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      module.exports = basePropertyDeep;
    }
  });

  // node_modules/lodash/property.js
  var require_property = __commonJS({
    "node_modules/lodash/property.js"(exports, module) {
      "use strict";
      var baseProperty = require_baseProperty();
      var basePropertyDeep = require_basePropertyDeep();
      var isKey = require_isKey();
      var toKey = require_toKey();
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      module.exports = property;
    }
  });

  // node_modules/lodash/_baseIteratee.js
  var require_baseIteratee = __commonJS({
    "node_modules/lodash/_baseIteratee.js"(exports, module) {
      "use strict";
      var baseMatches = require_baseMatches();
      var baseMatchesProperty = require_baseMatchesProperty();
      var identity = require_identity();
      var isArray = require_isArray();
      var property = require_property();
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      module.exports = baseIteratee;
    }
  });

  // node_modules/lodash/filter.js
  var require_filter = __commonJS({
    "node_modules/lodash/filter.js"(exports, module) {
      "use strict";
      var arrayFilter = require_arrayFilter();
      var baseFilter = require_baseFilter();
      var baseIteratee = require_baseIteratee();
      var isArray = require_isArray();
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, baseIteratee(predicate, 3));
      }
      module.exports = filter;
    }
  });

  // node_modules/lodash/_baseHas.js
  var require_baseHas = __commonJS({
    "node_modules/lodash/_baseHas.js"(exports, module) {
      "use strict";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      module.exports = baseHas;
    }
  });

  // node_modules/lodash/has.js
  var require_has = __commonJS({
    "node_modules/lodash/has.js"(exports, module) {
      "use strict";
      var baseHas = require_baseHas();
      var hasPath = require_hasPath();
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      module.exports = has;
    }
  });

  // node_modules/lodash/isEmpty.js
  var require_isEmpty = __commonJS({
    "node_modules/lodash/isEmpty.js"(exports, module) {
      "use strict";
      var baseKeys = require_baseKeys();
      var getTag = require_getTag();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isArrayLike = require_isArrayLike();
      var isBuffer = require_isBuffer();
      var isPrototype = require_isPrototype();
      var isTypedArray = require_isTypedArray();
      var mapTag = "[object Map]";
      var setTag = "[object Set]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      module.exports = isEmpty;
    }
  });

  // node_modules/lodash/isUndefined.js
  var require_isUndefined = __commonJS({
    "node_modules/lodash/isUndefined.js"(exports, module) {
      "use strict";
      function isUndefined(value) {
        return value === void 0;
      }
      module.exports = isUndefined;
    }
  });

  // node_modules/lodash/_baseMap.js
  var require_baseMap = __commonJS({
    "node_modules/lodash/_baseMap.js"(exports, module) {
      "use strict";
      var baseEach = require_baseEach();
      var isArrayLike = require_isArrayLike();
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      module.exports = baseMap;
    }
  });

  // node_modules/lodash/map.js
  var require_map = __commonJS({
    "node_modules/lodash/map.js"(exports, module) {
      "use strict";
      var arrayMap = require_arrayMap();
      var baseIteratee = require_baseIteratee();
      var baseMap = require_baseMap();
      var isArray = require_isArray();
      function map2(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee, 3));
      }
      module.exports = map2;
    }
  });

  // node_modules/lodash/_arrayReduce.js
  var require_arrayReduce = __commonJS({
    "node_modules/lodash/_arrayReduce.js"(exports, module) {
      "use strict";
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      module.exports = arrayReduce;
    }
  });

  // node_modules/lodash/_baseReduce.js
  var require_baseReduce = __commonJS({
    "node_modules/lodash/_baseReduce.js"(exports, module) {
      "use strict";
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      module.exports = baseReduce;
    }
  });

  // node_modules/lodash/reduce.js
  var require_reduce = __commonJS({
    "node_modules/lodash/reduce.js"(exports, module) {
      "use strict";
      var arrayReduce = require_arrayReduce();
      var baseEach = require_baseEach();
      var baseIteratee = require_baseIteratee();
      var baseReduce = require_baseReduce();
      var isArray = require_isArray();
      function reduce(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
      }
      module.exports = reduce;
    }
  });

  // node_modules/lodash/isString.js
  var require_isString = __commonJS({
    "node_modules/lodash/isString.js"(exports, module) {
      "use strict";
      var baseGetTag = require_baseGetTag();
      var isArray = require_isArray();
      var isObjectLike = require_isObjectLike();
      var stringTag = "[object String]";
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      module.exports = isString;
    }
  });

  // node_modules/lodash/_asciiSize.js
  var require_asciiSize = __commonJS({
    "node_modules/lodash/_asciiSize.js"(exports, module) {
      "use strict";
      var baseProperty = require_baseProperty();
      var asciiSize = baseProperty("length");
      module.exports = asciiSize;
    }
  });

  // node_modules/lodash/_hasUnicode.js
  var require_hasUnicode = __commonJS({
    "node_modules/lodash/_hasUnicode.js"(exports, module) {
      "use strict";
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsZWJ = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      module.exports = hasUnicode;
    }
  });

  // node_modules/lodash/_unicodeSize.js
  var require_unicodeSize = __commonJS({
    "node_modules/lodash/_unicodeSize.js"(exports, module) {
      "use strict";
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      module.exports = unicodeSize;
    }
  });

  // node_modules/lodash/_stringSize.js
  var require_stringSize = __commonJS({
    "node_modules/lodash/_stringSize.js"(exports, module) {
      "use strict";
      var asciiSize = require_asciiSize();
      var hasUnicode = require_hasUnicode();
      var unicodeSize = require_unicodeSize();
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      module.exports = stringSize;
    }
  });

  // node_modules/lodash/size.js
  var require_size = __commonJS({
    "node_modules/lodash/size.js"(exports, module) {
      "use strict";
      var baseKeys = require_baseKeys();
      var getTag = require_getTag();
      var isArrayLike = require_isArrayLike();
      var isString = require_isString();
      var stringSize = require_stringSize();
      var mapTag = "[object Map]";
      var setTag = "[object Set]";
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      module.exports = size;
    }
  });

  // node_modules/lodash/transform.js
  var require_transform = __commonJS({
    "node_modules/lodash/transform.js"(exports, module) {
      "use strict";
      var arrayEach = require_arrayEach();
      var baseCreate = require_baseCreate();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      var getPrototype = require_getPrototype();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isFunction = require_isFunction();
      var isObject2 = require_isObject();
      var isTypedArray = require_isTypedArray();
      function transform(object, iteratee, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee = baseIteratee(iteratee, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee(accumulator, value, index, object2);
        });
        return accumulator;
      }
      module.exports = transform;
    }
  });

  // node_modules/lodash/_isFlattenable.js
  var require_isFlattenable = __commonJS({
    "node_modules/lodash/_isFlattenable.js"(exports, module) {
      "use strict";
      var Symbol3 = require_Symbol();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      module.exports = isFlattenable;
    }
  });

  // node_modules/lodash/_baseFlatten.js
  var require_baseFlatten = __commonJS({
    "node_modules/lodash/_baseFlatten.js"(exports, module) {
      "use strict";
      var arrayPush = require_arrayPush();
      var isFlattenable = require_isFlattenable();
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      module.exports = baseFlatten;
    }
  });

  // node_modules/lodash/_apply.js
  var require_apply = __commonJS({
    "node_modules/lodash/_apply.js"(exports, module) {
      "use strict";
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      module.exports = apply;
    }
  });

  // node_modules/lodash/_overRest.js
  var require_overRest = __commonJS({
    "node_modules/lodash/_overRest.js"(exports, module) {
      "use strict";
      var apply = require_apply();
      var nativeMax = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      module.exports = overRest;
    }
  });

  // node_modules/lodash/_baseSetToString.js
  var require_baseSetToString = __commonJS({
    "node_modules/lodash/_baseSetToString.js"(exports, module) {
      "use strict";
      var constant = require_constant();
      var defineProperty = require_defineProperty();
      var identity = require_identity();
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      module.exports = baseSetToString;
    }
  });

  // node_modules/lodash/_shortOut.js
  var require_shortOut = __commonJS({
    "node_modules/lodash/_shortOut.js"(exports, module) {
      "use strict";
      var HOT_COUNT = 800;
      var HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      module.exports = shortOut;
    }
  });

  // node_modules/lodash/_setToString.js
  var require_setToString = __commonJS({
    "node_modules/lodash/_setToString.js"(exports, module) {
      "use strict";
      var baseSetToString = require_baseSetToString();
      var shortOut = require_shortOut();
      var setToString = shortOut(baseSetToString);
      module.exports = setToString;
    }
  });

  // node_modules/lodash/_baseRest.js
  var require_baseRest = __commonJS({
    "node_modules/lodash/_baseRest.js"(exports, module) {
      "use strict";
      var identity = require_identity();
      var overRest = require_overRest();
      var setToString = require_setToString();
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      module.exports = baseRest;
    }
  });

  // node_modules/lodash/_baseFindIndex.js
  var require_baseFindIndex = __commonJS({
    "node_modules/lodash/_baseFindIndex.js"(exports, module) {
      "use strict";
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      module.exports = baseFindIndex;
    }
  });

  // node_modules/lodash/_baseIsNaN.js
  var require_baseIsNaN = __commonJS({
    "node_modules/lodash/_baseIsNaN.js"(exports, module) {
      "use strict";
      function baseIsNaN(value) {
        return value !== value;
      }
      module.exports = baseIsNaN;
    }
  });

  // node_modules/lodash/_strictIndexOf.js
  var require_strictIndexOf = __commonJS({
    "node_modules/lodash/_strictIndexOf.js"(exports, module) {
      "use strict";
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      module.exports = strictIndexOf;
    }
  });

  // node_modules/lodash/_baseIndexOf.js
  var require_baseIndexOf = __commonJS({
    "node_modules/lodash/_baseIndexOf.js"(exports, module) {
      "use strict";
      var baseFindIndex = require_baseFindIndex();
      var baseIsNaN = require_baseIsNaN();
      var strictIndexOf = require_strictIndexOf();
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      module.exports = baseIndexOf;
    }
  });

  // node_modules/lodash/_arrayIncludes.js
  var require_arrayIncludes = __commonJS({
    "node_modules/lodash/_arrayIncludes.js"(exports, module) {
      "use strict";
      var baseIndexOf = require_baseIndexOf();
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      module.exports = arrayIncludes;
    }
  });

  // node_modules/lodash/_arrayIncludesWith.js
  var require_arrayIncludesWith = __commonJS({
    "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
      "use strict";
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      module.exports = arrayIncludesWith;
    }
  });

  // node_modules/lodash/noop.js
  var require_noop = __commonJS({
    "node_modules/lodash/noop.js"(exports, module) {
      "use strict";
      function noop() {
      }
      module.exports = noop;
    }
  });

  // node_modules/lodash/_createSet.js
  var require_createSet = __commonJS({
    "node_modules/lodash/_createSet.js"(exports, module) {
      "use strict";
      var Set2 = require_Set();
      var noop = require_noop();
      var setToArray = require_setToArray();
      var INFINITY = 1 / 0;
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
        return new Set2(values);
      };
      module.exports = createSet;
    }
  });

  // node_modules/lodash/_baseUniq.js
  var require_baseUniq = __commonJS({
    "node_modules/lodash/_baseUniq.js"(exports, module) {
      "use strict";
      var SetCache = require_SetCache();
      var arrayIncludes = require_arrayIncludes();
      var arrayIncludesWith = require_arrayIncludesWith();
      var cacheHas = require_cacheHas();
      var createSet = require_createSet();
      var setToArray = require_setToArray();
      var LARGE_ARRAY_SIZE = 200;
      function baseUniq(array, iteratee, comparator) {
        var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee ? iteratee(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
        return result;
      }
      module.exports = baseUniq;
    }
  });

  // node_modules/lodash/isArrayLikeObject.js
  var require_isArrayLikeObject = __commonJS({
    "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
      "use strict";
      var isArrayLike = require_isArrayLike();
      var isObjectLike = require_isObjectLike();
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      module.exports = isArrayLikeObject;
    }
  });

  // node_modules/lodash/union.js
  var require_union = __commonJS({
    "node_modules/lodash/union.js"(exports, module) {
      "use strict";
      var baseFlatten = require_baseFlatten();
      var baseRest = require_baseRest();
      var baseUniq = require_baseUniq();
      var isArrayLikeObject = require_isArrayLikeObject();
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      module.exports = union;
    }
  });

  // node_modules/lodash/_baseValues.js
  var require_baseValues = __commonJS({
    "node_modules/lodash/_baseValues.js"(exports, module) {
      "use strict";
      var arrayMap = require_arrayMap();
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      module.exports = baseValues;
    }
  });

  // node_modules/lodash/values.js
  var require_values = __commonJS({
    "node_modules/lodash/values.js"(exports, module) {
      "use strict";
      var baseValues = require_baseValues();
      var keys = require_keys();
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      module.exports = values;
    }
  });

  // node_modules/graphlib/lib/lodash.js
  var require_lodash = __commonJS({
    "node_modules/graphlib/lib/lodash.js"(exports, module) {
      "use strict";
      var lodash;
      if (typeof __require === "function") {
        try {
          lodash = {
            clone: require_clone(),
            constant: require_constant(),
            each: require_each(),
            filter: require_filter(),
            has: require_has(),
            isArray: require_isArray(),
            isEmpty: require_isEmpty(),
            isFunction: require_isFunction(),
            isUndefined: require_isUndefined(),
            keys: require_keys(),
            map: require_map(),
            reduce: require_reduce(),
            size: require_size(),
            transform: require_transform(),
            union: require_union(),
            values: require_values()
          };
        } catch (e) {
        }
      }
      if (!lodash) {
        lodash = window._;
      }
      module.exports = lodash;
    }
  });

  // node_modules/graphlib/lib/graph.js
  var require_graph = __commonJS({
    "node_modules/graphlib/lib/graph.js"(exports, module) {
      "use strict";
      var _ = require_lodash();
      module.exports = Graph3;
      var DEFAULT_EDGE_NAME = "\0";
      var GRAPH_NODE = "\0";
      var EDGE_KEY_DELIM = "";
      function Graph3(opts) {
        this._isDirected = _.has(opts, "directed") ? opts.directed : true;
        this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
        this._isCompound = _.has(opts, "compound") ? opts.compound : false;
        this._label = void 0;
        this._defaultNodeLabelFn = _.constant(void 0);
        this._defaultEdgeLabelFn = _.constant(void 0);
        this._nodes = {};
        if (this._isCompound) {
          this._parent = {};
          this._children = {};
          this._children[GRAPH_NODE] = {};
        }
        this._in = {};
        this._preds = {};
        this._out = {};
        this._sucs = {};
        this._edgeObjs = {};
        this._edgeLabels = {};
      }
      Graph3.prototype._nodeCount = 0;
      Graph3.prototype._edgeCount = 0;
      Graph3.prototype.isDirected = function() {
        return this._isDirected;
      };
      Graph3.prototype.isMultigraph = function() {
        return this._isMultigraph;
      };
      Graph3.prototype.isCompound = function() {
        return this._isCompound;
      };
      Graph3.prototype.setGraph = function(label) {
        this._label = label;
        return this;
      };
      Graph3.prototype.graph = function() {
        return this._label;
      };
      Graph3.prototype.setDefaultNodeLabel = function(newDefault) {
        if (!_.isFunction(newDefault)) {
          newDefault = _.constant(newDefault);
        }
        this._defaultNodeLabelFn = newDefault;
        return this;
      };
      Graph3.prototype.nodeCount = function() {
        return this._nodeCount;
      };
      Graph3.prototype.nodes = function() {
        return _.keys(this._nodes);
      };
      Graph3.prototype.sources = function() {
        var self2 = this;
        return _.filter(this.nodes(), function(v) {
          return _.isEmpty(self2._in[v]);
        });
      };
      Graph3.prototype.sinks = function() {
        var self2 = this;
        return _.filter(this.nodes(), function(v) {
          return _.isEmpty(self2._out[v]);
        });
      };
      Graph3.prototype.setNodes = function(vs, value) {
        var args = arguments;
        var self2 = this;
        _.each(vs, function(v) {
          if (args.length > 1) {
            self2.setNode(v, value);
          } else {
            self2.setNode(v);
          }
        });
        return this;
      };
      Graph3.prototype.setNode = function(v, value) {
        if (_.has(this._nodes, v)) {
          if (arguments.length > 1) {
            this._nodes[v] = value;
          }
          return this;
        }
        this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
        if (this._isCompound) {
          this._parent[v] = GRAPH_NODE;
          this._children[v] = {};
          this._children[GRAPH_NODE][v] = true;
        }
        this._in[v] = {};
        this._preds[v] = {};
        this._out[v] = {};
        this._sucs[v] = {};
        ++this._nodeCount;
        return this;
      };
      Graph3.prototype.node = function(v) {
        return this._nodes[v];
      };
      Graph3.prototype.hasNode = function(v) {
        return _.has(this._nodes, v);
      };
      Graph3.prototype.removeNode = function(v) {
        var self2 = this;
        if (_.has(this._nodes, v)) {
          var removeEdge = function(e) {
            self2.removeEdge(self2._edgeObjs[e]);
          };
          delete this._nodes[v];
          if (this._isCompound) {
            this._removeFromParentsChildList(v);
            delete this._parent[v];
            _.each(this.children(v), function(child) {
              self2.setParent(child);
            });
            delete this._children[v];
          }
          _.each(_.keys(this._in[v]), removeEdge);
          delete this._in[v];
          delete this._preds[v];
          _.each(_.keys(this._out[v]), removeEdge);
          delete this._out[v];
          delete this._sucs[v];
          --this._nodeCount;
        }
        return this;
      };
      Graph3.prototype.setParent = function(v, parent) {
        if (!this._isCompound) {
          throw new Error("Cannot set parent in a non-compound graph");
        }
        if (_.isUndefined(parent)) {
          parent = GRAPH_NODE;
        } else {
          parent += "";
          for (var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
            if (ancestor === v) {
              throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
            }
          }
          this.setNode(parent);
        }
        this.setNode(v);
        this._removeFromParentsChildList(v);
        this._parent[v] = parent;
        this._children[parent][v] = true;
        return this;
      };
      Graph3.prototype._removeFromParentsChildList = function(v) {
        delete this._children[this._parent[v]][v];
      };
      Graph3.prototype.parent = function(v) {
        if (this._isCompound) {
          var parent = this._parent[v];
          if (parent !== GRAPH_NODE) {
            return parent;
          }
        }
      };
      Graph3.prototype.children = function(v) {
        if (_.isUndefined(v)) {
          v = GRAPH_NODE;
        }
        if (this._isCompound) {
          var children = this._children[v];
          if (children) {
            return _.keys(children);
          }
        } else if (v === GRAPH_NODE) {
          return this.nodes();
        } else if (this.hasNode(v)) {
          return [];
        }
      };
      Graph3.prototype.predecessors = function(v) {
        var predsV = this._preds[v];
        if (predsV) {
          return _.keys(predsV);
        }
      };
      Graph3.prototype.successors = function(v) {
        var sucsV = this._sucs[v];
        if (sucsV) {
          return _.keys(sucsV);
        }
      };
      Graph3.prototype.neighbors = function(v) {
        var preds = this.predecessors(v);
        if (preds) {
          return _.union(preds, this.successors(v));
        }
      };
      Graph3.prototype.isLeaf = function(v) {
        var neighbors;
        if (this.isDirected()) {
          neighbors = this.successors(v);
        } else {
          neighbors = this.neighbors(v);
        }
        return neighbors.length === 0;
      };
      Graph3.prototype.filterNodes = function(filter) {
        var copy = new this.constructor({
          directed: this._isDirected,
          multigraph: this._isMultigraph,
          compound: this._isCompound
        });
        copy.setGraph(this.graph());
        var self2 = this;
        _.each(this._nodes, function(value, v) {
          if (filter(v)) {
            copy.setNode(v, value);
          }
        });
        _.each(this._edgeObjs, function(e) {
          if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
            copy.setEdge(e, self2.edge(e));
          }
        });
        var parents = {};
        function findParent(v) {
          var parent = self2.parent(v);
          if (parent === void 0 || copy.hasNode(parent)) {
            parents[v] = parent;
            return parent;
          } else if (parent in parents) {
            return parents[parent];
          } else {
            return findParent(parent);
          }
        }
        if (this._isCompound) {
          _.each(copy.nodes(), function(v) {
            copy.setParent(v, findParent(v));
          });
        }
        return copy;
      };
      Graph3.prototype.setDefaultEdgeLabel = function(newDefault) {
        if (!_.isFunction(newDefault)) {
          newDefault = _.constant(newDefault);
        }
        this._defaultEdgeLabelFn = newDefault;
        return this;
      };
      Graph3.prototype.edgeCount = function() {
        return this._edgeCount;
      };
      Graph3.prototype.edges = function() {
        return _.values(this._edgeObjs);
      };
      Graph3.prototype.setPath = function(vs, value) {
        var self2 = this;
        var args = arguments;
        _.reduce(vs, function(v, w) {
          if (args.length > 1) {
            self2.setEdge(v, w, value);
          } else {
            self2.setEdge(v, w);
          }
          return w;
        });
        return this;
      };
      Graph3.prototype.setEdge = function() {
        var v, w, name, value;
        var valueSpecified = false;
        var arg0 = arguments[0];
        if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
          v = arg0.v;
          w = arg0.w;
          name = arg0.name;
          if (arguments.length === 2) {
            value = arguments[1];
            valueSpecified = true;
          }
        } else {
          v = arg0;
          w = arguments[1];
          name = arguments[3];
          if (arguments.length > 2) {
            value = arguments[2];
            valueSpecified = true;
          }
        }
        v = "" + v;
        w = "" + w;
        if (!_.isUndefined(name)) {
          name = "" + name;
        }
        var e = edgeArgsToId(this._isDirected, v, w, name);
        if (_.has(this._edgeLabels, e)) {
          if (valueSpecified) {
            this._edgeLabels[e] = value;
          }
          return this;
        }
        if (!_.isUndefined(name) && !this._isMultigraph) {
          throw new Error("Cannot set a named edge when isMultigraph = false");
        }
        this.setNode(v);
        this.setNode(w);
        this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
        var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
        v = edgeObj.v;
        w = edgeObj.w;
        Object.freeze(edgeObj);
        this._edgeObjs[e] = edgeObj;
        incrementOrInitEntry(this._preds[w], v);
        incrementOrInitEntry(this._sucs[v], w);
        this._in[w][e] = edgeObj;
        this._out[v][e] = edgeObj;
        this._edgeCount++;
        return this;
      };
      Graph3.prototype.edge = function(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
        return this._edgeLabels[e];
      };
      Graph3.prototype.hasEdge = function(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
        return _.has(this._edgeLabels, e);
      };
      Graph3.prototype.removeEdge = function(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
        var edge = this._edgeObjs[e];
        if (edge) {
          v = edge.v;
          w = edge.w;
          delete this._edgeLabels[e];
          delete this._edgeObjs[e];
          decrementOrRemoveEntry(this._preds[w], v);
          decrementOrRemoveEntry(this._sucs[v], w);
          delete this._in[w][e];
          delete this._out[v][e];
          this._edgeCount--;
        }
        return this;
      };
      Graph3.prototype.inEdges = function(v, u) {
        var inV = this._in[v];
        if (inV) {
          var edges = _.values(inV);
          if (!u) {
            return edges;
          }
          return _.filter(edges, function(edge) {
            return edge.v === u;
          });
        }
      };
      Graph3.prototype.outEdges = function(v, w) {
        var outV = this._out[v];
        if (outV) {
          var edges = _.values(outV);
          if (!w) {
            return edges;
          }
          return _.filter(edges, function(edge) {
            return edge.w === w;
          });
        }
      };
      Graph3.prototype.nodeEdges = function(v, w) {
        var inEdges = this.inEdges(v, w);
        if (inEdges) {
          return inEdges.concat(this.outEdges(v, w));
        }
      };
      function incrementOrInitEntry(map2, k) {
        if (map2[k]) {
          map2[k]++;
        } else {
          map2[k] = 1;
        }
      }
      function decrementOrRemoveEntry(map2, k) {
        if (!--map2[k]) {
          delete map2[k];
        }
      }
      function edgeArgsToId(isDirected, v_, w_, name) {
        var v = "" + v_;
        var w = "" + w_;
        if (!isDirected && v > w) {
          var tmp = v;
          v = w;
          w = tmp;
        }
        return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
      }
      function edgeArgsToObj(isDirected, v_, w_, name) {
        var v = "" + v_;
        var w = "" + w_;
        if (!isDirected && v > w) {
          var tmp = v;
          v = w;
          w = tmp;
        }
        var edgeObj = { v, w };
        if (name) {
          edgeObj.name = name;
        }
        return edgeObj;
      }
      function edgeObjToId(isDirected, edgeObj) {
        return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
      }
    }
  });

  // node_modules/graphlib/lib/version.js
  var require_version = __commonJS({
    "node_modules/graphlib/lib/version.js"(exports, module) {
      "use strict";
      module.exports = "2.1.8";
    }
  });

  // node_modules/graphlib/lib/index.js
  var require_lib = __commonJS({
    "node_modules/graphlib/lib/index.js"(exports, module) {
      "use strict";
      module.exports = {
        Graph: require_graph(),
        version: require_version()
      };
    }
  });

  // node_modules/graphlib/lib/json.js
  var require_json = __commonJS({
    "node_modules/graphlib/lib/json.js"(exports, module) {
      "use strict";
      var _ = require_lodash();
      var Graph3 = require_graph();
      module.exports = {
        write,
        read
      };
      function write(g) {
        var json2 = {
          options: {
            directed: g.isDirected(),
            multigraph: g.isMultigraph(),
            compound: g.isCompound()
          },
          nodes: writeNodes(g),
          edges: writeEdges(g)
        };
        if (!_.isUndefined(g.graph())) {
          json2.value = _.clone(g.graph());
        }
        return json2;
      }
      function writeNodes(g) {
        return _.map(g.nodes(), function(v) {
          var nodeValue = g.node(v);
          var parent = g.parent(v);
          var node = { v };
          if (!_.isUndefined(nodeValue)) {
            node.value = nodeValue;
          }
          if (!_.isUndefined(parent)) {
            node.parent = parent;
          }
          return node;
        });
      }
      function writeEdges(g) {
        return _.map(g.edges(), function(e) {
          var edgeValue = g.edge(e);
          var edge = { v: e.v, w: e.w };
          if (!_.isUndefined(e.name)) {
            edge.name = e.name;
          }
          if (!_.isUndefined(edgeValue)) {
            edge.value = edgeValue;
          }
          return edge;
        });
      }
      function read(json2) {
        var g = new Graph3(json2.options).setGraph(json2.value);
        _.each(json2.nodes, function(entry) {
          g.setNode(entry.v, entry.value);
          if (entry.parent) {
            g.setParent(entry.v, entry.parent);
          }
        });
        _.each(json2.edges, function(entry) {
          g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
        });
        return g;
      }
    }
  });

  // node_modules/graphlib/lib/alg/components.js
  var require_components = __commonJS({
    "node_modules/graphlib/lib/alg/components.js"(exports, module) {
      "use strict";
      var _ = require_lodash();
      module.exports = components;
      function components(g) {
        var visited = {};
        var cmpts = [];
        var cmpt;
        function dfs(v) {
          if (_.has(visited, v)) return;
          visited[v] = true;
          cmpt.push(v);
          _.each(g.successors(v), dfs);
          _.each(g.predecessors(v), dfs);
        }
        _.each(g.nodes(), function(v) {
          cmpt = [];
          dfs(v);
          if (cmpt.length) {
            cmpts.push(cmpt);
          }
        });
        return cmpts;
      }
    }
  });

  // node_modules/graphlib/lib/data/priority-queue.js
  var require_priority_queue = __commonJS({
    "node_modules/graphlib/lib/data/priority-queue.js"(exports, module) {
      "use strict";
      var _ = require_lodash();
      module.exports = PriorityQueue;
      function PriorityQueue() {
        this._arr = [];
        this._keyIndices = {};
      }
      PriorityQueue.prototype.size = function() {
        return this._arr.length;
      };
      PriorityQueue.prototype.keys = function() {
        return this._arr.map(function(x) {
          return x.key;
        });
      };
      PriorityQueue.prototype.has = function(key) {
        return _.has(this._keyIndices, key);
      };
      PriorityQueue.prototype.priority = function(key) {
        var index = this._keyIndices[key];
        if (index !== void 0) {
          return this._arr[index].priority;
        }
      };
      PriorityQueue.prototype.min = function() {
        if (this.size() === 0) {
          throw new Error("Queue underflow");
        }
        return this._arr[0].key;
      };
      PriorityQueue.prototype.add = function(key, priority) {
        var keyIndices = this._keyIndices;
        key = String(key);
        if (!_.has(keyIndices, key)) {
          var arr = this._arr;
          var index = arr.length;
          keyIndices[key] = index;
          arr.push({ key, priority });
          this._decrease(index);
          return true;
        }
        return false;
      };
      PriorityQueue.prototype.removeMin = function() {
        this._swap(0, this._arr.length - 1);
        var min6 = this._arr.pop();
        delete this._keyIndices[min6.key];
        this._heapify(0);
        return min6.key;
      };
      PriorityQueue.prototype.decrease = function(key, priority) {
        var index = this._keyIndices[key];
        if (priority > this._arr[index].priority) {
          throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
        }
        this._arr[index].priority = priority;
        this._decrease(index);
      };
      PriorityQueue.prototype._heapify = function(i) {
        var arr = this._arr;
        var l = 2 * i;
        var r = l + 1;
        var largest = i;
        if (l < arr.length) {
          largest = arr[l].priority < arr[largest].priority ? l : largest;
          if (r < arr.length) {
            largest = arr[r].priority < arr[largest].priority ? r : largest;
          }
          if (largest !== i) {
            this._swap(i, largest);
            this._heapify(largest);
          }
        }
      };
      PriorityQueue.prototype._decrease = function(index) {
        var arr = this._arr;
        var priority = arr[index].priority;
        var parent;
        while (index !== 0) {
          parent = index >> 1;
          if (arr[parent].priority < priority) {
            break;
          }
          this._swap(index, parent);
          index = parent;
        }
      };
      PriorityQueue.prototype._swap = function(i, j) {
        var arr = this._arr;
        var keyIndices = this._keyIndices;
        var origArrI = arr[i];
        var origArrJ = arr[j];
        arr[i] = origArrJ;
        arr[j] = origArrI;
        keyIndices[origArrJ.key] = i;
        keyIndices[origArrI.key] = j;
      };
    }
  });

  // node_modules/graphlib/lib/alg/dijkstra.js
  var require_dijkstra = __commonJS({
    "node_modules/graphlib/lib/alg/dijkstra.js"(exports, module) {
      "use strict";
      var _ = require_lodash();
      var PriorityQueue = require_priority_queue();
      module.exports = dijkstra;
      var DEFAULT_WEIGHT_FUNC = _.constant(1);
      function dijkstra(g, source, weightFn, edgeFn) {
        return runDijkstra(
          g,
          String(source),
          weightFn || DEFAULT_WEIGHT_FUNC,
          edgeFn || function(v) {
            return g.outEdges(v);
          }
        );
      }
      function runDijkstra(g, source, weightFn, edgeFn) {
        var results = {};
        var pq = new PriorityQueue();
        var v, vEntry;
        var updateNeighbors = function(edge) {
          var w = edge.v !== v ? edge.v : edge.w;
          var wEntry = results[w];
          var weight = weightFn(edge);
          var distance = vEntry.distance + weight;
          if (weight < 0) {
            throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
          }
          if (distance < wEntry.distance) {
            wEntry.distance = distance;
            wEntry.predecessor = v;
            pq.decrease(w, distance);
          }
        };
        g.nodes().forEach(function(v2) {
          var distance = v2 === source ? 0 : Number.POSITIVE_INFINITY;
          results[v2] = { distance };
          pq.add(v2, distance);
        });
        while (pq.size() > 0) {
          v = pq.removeMin();
          vEntry = results[v];
          if (vEntry.distance === Number.POSITIVE_INFINITY) {
            break;
          }
          edgeFn(v).forEach(updateNeighbors);
        }
        return results;
      }
    }
  });

  // node_modules/graphlib/lib/alg/dijkstra-all.js
  var require_dijkstra_all = __commonJS({
    "node_modules/graphlib/lib/alg/dijkstra-all.js"(exports, module) {
      "use strict";
      var dijkstra = require_dijkstra();
      var _ = require_lodash();
      module.exports = dijkstraAll;
      function dijkstraAll(g, weightFunc, edgeFunc) {
        return _.transform(g.nodes(), function(acc, v) {
          acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
        }, {});
      }
    }
  });

  // node_modules/graphlib/lib/alg/tarjan.js
  var require_tarjan = __commonJS({
    "node_modules/graphlib/lib/alg/tarjan.js"(exports, module) {
      "use strict";
      var _ = require_lodash();
      module.exports = tarjan;
      function tarjan(g) {
        var index = 0;
        var stack = [];
        var visited = {};
        var results = [];
        function dfs(v) {
          var entry = visited[v] = {
            onStack: true,
            lowlink: index,
            index: index++
          };
          stack.push(v);
          g.successors(v).forEach(function(w2) {
            if (!_.has(visited, w2)) {
              dfs(w2);
              entry.lowlink = Math.min(entry.lowlink, visited[w2].lowlink);
            } else if (visited[w2].onStack) {
              entry.lowlink = Math.min(entry.lowlink, visited[w2].index);
            }
          });
          if (entry.lowlink === entry.index) {
            var cmpt = [];
            var w;
            do {
              w = stack.pop();
              visited[w].onStack = false;
              cmpt.push(w);
            } while (v !== w);
            results.push(cmpt);
          }
        }
        g.nodes().forEach(function(v) {
          if (!_.has(visited, v)) {
            dfs(v);
          }
        });
        return results;
      }
    }
  });

  // node_modules/graphlib/lib/alg/find-cycles.js
  var require_find_cycles = __commonJS({
    "node_modules/graphlib/lib/alg/find-cycles.js"(exports, module) {
      "use strict";
      var _ = require_lodash();
      var tarjan = require_tarjan();
      module.exports = findCycles;
      function findCycles(g) {
        return _.filter(tarjan(g), function(cmpt) {
          return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
        });
      }
    }
  });

  // node_modules/graphlib/lib/alg/floyd-warshall.js
  var require_floyd_warshall = __commonJS({
    "node_modules/graphlib/lib/alg/floyd-warshall.js"(exports, module) {
      "use strict";
      var _ = require_lodash();
      module.exports = floydWarshall;
      var DEFAULT_WEIGHT_FUNC = _.constant(1);
      function floydWarshall(g, weightFn, edgeFn) {
        return runFloydWarshall(
          g,
          weightFn || DEFAULT_WEIGHT_FUNC,
          edgeFn || function(v) {
            return g.outEdges(v);
          }
        );
      }
      function runFloydWarshall(g, weightFn, edgeFn) {
        var results = {};
        var nodes = g.nodes();
        nodes.forEach(function(v) {
          results[v] = {};
          results[v][v] = { distance: 0 };
          nodes.forEach(function(w) {
            if (v !== w) {
              results[v][w] = { distance: Number.POSITIVE_INFINITY };
            }
          });
          edgeFn(v).forEach(function(edge) {
            var w = edge.v === v ? edge.w : edge.v;
            var d = weightFn(edge);
            results[v][w] = { distance: d, predecessor: v };
          });
        });
        nodes.forEach(function(k) {
          var rowK = results[k];
          nodes.forEach(function(i) {
            var rowI = results[i];
            nodes.forEach(function(j) {
              var ik = rowI[k];
              var kj = rowK[j];
              var ij = rowI[j];
              var altDistance = ik.distance + kj.distance;
              if (altDistance < ij.distance) {
                ij.distance = altDistance;
                ij.predecessor = kj.predecessor;
              }
            });
          });
        });
        return results;
      }
    }
  });

  // node_modules/graphlib/lib/alg/topsort.js
  var require_topsort = __commonJS({
    "node_modules/graphlib/lib/alg/topsort.js"(exports, module) {
      "use strict";
      var _ = require_lodash();
      module.exports = topsort;
      topsort.CycleException = CycleException;
      function topsort(g) {
        var visited = {};
        var stack = {};
        var results = [];
        function visit(node) {
          if (_.has(stack, node)) {
            throw new CycleException();
          }
          if (!_.has(visited, node)) {
            stack[node] = true;
            visited[node] = true;
            _.each(g.predecessors(node), visit);
            delete stack[node];
            results.push(node);
          }
        }
        _.each(g.sinks(), visit);
        if (_.size(visited) !== g.nodeCount()) {
          throw new CycleException();
        }
        return results;
      }
      function CycleException() {
      }
      CycleException.prototype = new Error();
    }
  });

  // node_modules/graphlib/lib/alg/is-acyclic.js
  var require_is_acyclic = __commonJS({
    "node_modules/graphlib/lib/alg/is-acyclic.js"(exports, module) {
      "use strict";
      var topsort = require_topsort();
      module.exports = isAcyclic;
      function isAcyclic(g) {
        try {
          topsort(g);
        } catch (e) {
          if (e instanceof topsort.CycleException) {
            return false;
          }
          throw e;
        }
        return true;
      }
    }
  });

  // node_modules/graphlib/lib/alg/dfs.js
  var require_dfs = __commonJS({
    "node_modules/graphlib/lib/alg/dfs.js"(exports, module) {
      "use strict";
      var _ = require_lodash();
      module.exports = dfs;
      function dfs(g, vs, order) {
        if (!_.isArray(vs)) {
          vs = [vs];
        }
        var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);
        var acc = [];
        var visited = {};
        _.each(vs, function(v) {
          if (!g.hasNode(v)) {
            throw new Error("Graph does not have node: " + v);
          }
          doDfs(g, v, order === "post", visited, navigation, acc);
        });
        return acc;
      }
      function doDfs(g, v, postorder, visited, navigation, acc) {
        if (!_.has(visited, v)) {
          visited[v] = true;
          if (!postorder) {
            acc.push(v);
          }
          _.each(navigation(v), function(w) {
            doDfs(g, w, postorder, visited, navigation, acc);
          });
          if (postorder) {
            acc.push(v);
          }
        }
      }
    }
  });

  // node_modules/graphlib/lib/alg/postorder.js
  var require_postorder = __commonJS({
    "node_modules/graphlib/lib/alg/postorder.js"(exports, module) {
      "use strict";
      var dfs = require_dfs();
      module.exports = postorder;
      function postorder(g, vs) {
        return dfs(g, vs, "post");
      }
    }
  });

  // node_modules/graphlib/lib/alg/preorder.js
  var require_preorder = __commonJS({
    "node_modules/graphlib/lib/alg/preorder.js"(exports, module) {
      "use strict";
      var dfs = require_dfs();
      module.exports = preorder;
      function preorder(g, vs) {
        return dfs(g, vs, "pre");
      }
    }
  });

  // node_modules/graphlib/lib/alg/prim.js
  var require_prim = __commonJS({
    "node_modules/graphlib/lib/alg/prim.js"(exports, module) {
      "use strict";
      var _ = require_lodash();
      var Graph3 = require_graph();
      var PriorityQueue = require_priority_queue();
      module.exports = prim;
      function prim(g, weightFunc) {
        var result = new Graph3();
        var parents = {};
        var pq = new PriorityQueue();
        var v;
        function updateNeighbors(edge) {
          var w = edge.v === v ? edge.w : edge.v;
          var pri = pq.priority(w);
          if (pri !== void 0) {
            var edgeWeight = weightFunc(edge);
            if (edgeWeight < pri) {
              parents[w] = v;
              pq.decrease(w, edgeWeight);
            }
          }
        }
        if (g.nodeCount() === 0) {
          return result;
        }
        _.each(g.nodes(), function(v2) {
          pq.add(v2, Number.POSITIVE_INFINITY);
          result.setNode(v2);
        });
        pq.decrease(g.nodes()[0], 0);
        var init = false;
        while (pq.size() > 0) {
          v = pq.removeMin();
          if (_.has(parents, v)) {
            result.setEdge(v, parents[v]);
          } else if (init) {
            throw new Error("Input graph is not connected: " + g);
          } else {
            init = true;
          }
          g.nodeEdges(v).forEach(updateNeighbors);
        }
        return result;
      }
    }
  });

  // node_modules/graphlib/lib/alg/index.js
  var require_alg = __commonJS({
    "node_modules/graphlib/lib/alg/index.js"(exports, module) {
      "use strict";
      module.exports = {
        components: require_components(),
        dijkstra: require_dijkstra(),
        dijkstraAll: require_dijkstra_all(),
        findCycles: require_find_cycles(),
        floydWarshall: require_floyd_warshall(),
        isAcyclic: require_is_acyclic(),
        postorder: require_postorder(),
        preorder: require_preorder(),
        prim: require_prim(),
        tarjan: require_tarjan(),
        topsort: require_topsort()
      };
    }
  });

  // node_modules/graphlib/index.js
  var require_graphlib = __commonJS({
    "node_modules/graphlib/index.js"(exports, module) {
      "use strict";
      var lib = require_lib();
      module.exports = {
        Graph: lib.Graph,
        json: require_json(),
        alg: require_alg(),
        version: lib.version
      };
    }
  });

  // node_modules/simple-graph-query/dist/simple-graph-query.bundle.js
  var require_simple_graph_query_bundle = __commonJS({
    "node_modules/simple-graph-query/dist/simple-graph-query.bundle.js"(exports, module) {
      "use strict";
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else if (typeof exports === "object")
          exports["SimpleGraphQuery"] = factory();
        else
          root["SimpleGraphQuery"] = factory();
      })(exports, () => {
        return (
          /******/
          (() => {
            var __webpack_modules__ = {
              /***/
              "./node_modules/antlr4ts/ANTLRErrorListener.js": (
                /*!*****************************************************!*\
                  !*** ./node_modules/antlr4ts/ANTLRErrorListener.js ***!
                  \*****************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                }
              ),
              /***/
              "./node_modules/antlr4ts/ANTLRErrorStrategy.js": (
                /*!*****************************************************!*\
                  !*** ./node_modules/antlr4ts/ANTLRErrorStrategy.js ***!
                  \*****************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                }
              ),
              /***/
              "./node_modules/antlr4ts/ANTLRInputStream.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/ANTLRInputStream.js ***!
                  \***************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ANTLRInputStream = void 0;
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const IntStream_1 = __webpack_require__2(
                    /*! ./IntStream */
                    "./node_modules/antlr4ts/IntStream.js"
                  );
                  const READ_BUFFER_SIZE = 1024;
                  const INITIAL_BUFFER_SIZE = 1024;
                  class ANTLRInputStream {
                    /** Copy data in string to a local char array */
                    constructor(input) {
                      this.p = 0;
                      this.data = input;
                      this.n = input.length;
                    }
                    /** Reset the stream so that it's in the same state it was
                     *  when the object was created *except* the data array is not
                     *  touched.
                     */
                    reset() {
                      this.p = 0;
                    }
                    consume() {
                      if (this.p >= this.n) {
                        assert(this.LA(1) === IntStream_1.IntStream.EOF);
                        throw new Error("cannot consume EOF");
                      }
                      if (this.p < this.n) {
                        this.p++;
                      }
                    }
                    LA(i) {
                      if (i === 0) {
                        return 0;
                      }
                      if (i < 0) {
                        i++;
                        if (this.p + i - 1 < 0) {
                          return IntStream_1.IntStream.EOF;
                        }
                      }
                      if (this.p + i - 1 >= this.n) {
                        return IntStream_1.IntStream.EOF;
                      }
                      return this.data.charCodeAt(this.p + i - 1);
                    }
                    LT(i) {
                      return this.LA(i);
                    }
                    /** Return the current input symbol index 0..n where n indicates the
                     *  last symbol has been read.  The index is the index of char to
                     *  be returned from LA(1).
                     */
                    get index() {
                      return this.p;
                    }
                    get size() {
                      return this.n;
                    }
                    /** mark/release do nothing; we have entire buffer */
                    mark() {
                      return -1;
                    }
                    release(marker) {
                    }
                    /** consume() ahead until p==index; can't just set p=index as we must
                     *  update line and charPositionInLine. If we seek backwards, just set p
                     */
                    seek(index) {
                      if (index <= this.p) {
                        this.p = index;
                        return;
                      }
                      index = Math.min(index, this.n);
                      while (this.p < index) {
                        this.consume();
                      }
                    }
                    getText(interval) {
                      let start = interval.a;
                      let stop = interval.b;
                      if (stop >= this.n) {
                        stop = this.n - 1;
                      }
                      let count = stop - start + 1;
                      if (start >= this.n) {
                        return "";
                      }
                      return this.data.substr(start, count);
                    }
                    get sourceName() {
                      if (!this.name) {
                        return IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
                      }
                      return this.name;
                    }
                    toString() {
                      return this.data;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], ANTLRInputStream.prototype, "consume", null);
                  __decorate([
                    Decorators_1.Override
                  ], ANTLRInputStream.prototype, "LA", null);
                  __decorate([
                    Decorators_1.Override
                  ], ANTLRInputStream.prototype, "index", null);
                  __decorate([
                    Decorators_1.Override
                  ], ANTLRInputStream.prototype, "size", null);
                  __decorate([
                    Decorators_1.Override
                  ], ANTLRInputStream.prototype, "mark", null);
                  __decorate([
                    Decorators_1.Override
                  ], ANTLRInputStream.prototype, "release", null);
                  __decorate([
                    Decorators_1.Override
                  ], ANTLRInputStream.prototype, "seek", null);
                  __decorate([
                    Decorators_1.Override
                  ], ANTLRInputStream.prototype, "getText", null);
                  __decorate([
                    Decorators_1.Override
                  ], ANTLRInputStream.prototype, "sourceName", null);
                  __decorate([
                    Decorators_1.Override
                  ], ANTLRInputStream.prototype, "toString", null);
                  exports2.ANTLRInputStream = ANTLRInputStream;
                }
              ),
              /***/
              "./node_modules/antlr4ts/BailErrorStrategy.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/BailErrorStrategy.js ***!
                  \****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.BailErrorStrategy = void 0;
                  const DefaultErrorStrategy_1 = __webpack_require__2(
                    /*! ./DefaultErrorStrategy */
                    "./node_modules/antlr4ts/DefaultErrorStrategy.js"
                  );
                  const InputMismatchException_1 = __webpack_require__2(
                    /*! ./InputMismatchException */
                    "./node_modules/antlr4ts/InputMismatchException.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ParseCancellationException_1 = __webpack_require__2(
                    /*! ./misc/ParseCancellationException */
                    "./node_modules/antlr4ts/misc/ParseCancellationException.js"
                  );
                  class BailErrorStrategy extends DefaultErrorStrategy_1.DefaultErrorStrategy {
                    /** Instead of recovering from exception `e`, re-throw it wrapped
                     *  in a {@link ParseCancellationException} so it is not caught by the
                     *  rule function catches.  Use {@link Exception#getCause()} to get the
                     *  original {@link RecognitionException}.
                     */
                    recover(recognizer, e) {
                      for (let context = recognizer.context; context; context = context.parent) {
                        context.exception = e;
                      }
                      throw new ParseCancellationException_1.ParseCancellationException(e);
                    }
                    /** Make sure we don't attempt to recover inline; if the parser
                     *  successfully recovers, it won't throw an exception.
                     */
                    recoverInline(recognizer) {
                      let e = new InputMismatchException_1.InputMismatchException(recognizer);
                      for (let context = recognizer.context; context; context = context.parent) {
                        context.exception = e;
                      }
                      throw new ParseCancellationException_1.ParseCancellationException(e);
                    }
                    /** Make sure we don't attempt to recover from problems in subrules. */
                    sync(recognizer) {
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], BailErrorStrategy.prototype, "recover", null);
                  __decorate([
                    Decorators_1.Override
                  ], BailErrorStrategy.prototype, "recoverInline", null);
                  __decorate([
                    Decorators_1.Override
                  ], BailErrorStrategy.prototype, "sync", null);
                  exports2.BailErrorStrategy = BailErrorStrategy;
                }
              ),
              /***/
              "./node_modules/antlr4ts/BufferedTokenStream.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/BufferedTokenStream.js ***!
                  \******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.BufferedTokenStream = void 0;
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  const CommonToken_1 = __webpack_require__2(
                    /*! ./CommonToken */
                    "./node_modules/antlr4ts/CommonToken.js"
                  );
                  const Interval_1 = __webpack_require__2(
                    /*! ./misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const Lexer_1 = __webpack_require__2(
                    /*! ./Lexer */
                    "./node_modules/antlr4ts/Lexer.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  let BufferedTokenStream = class BufferedTokenStream {
                    constructor(tokenSource) {
                      this.tokens = [];
                      this.p = -1;
                      this.fetchedEOF = false;
                      if (tokenSource == null) {
                        throw new Error("tokenSource cannot be null");
                      }
                      this._tokenSource = tokenSource;
                    }
                    get tokenSource() {
                      return this._tokenSource;
                    }
                    /** Reset this token stream by setting its token source. */
                    set tokenSource(tokenSource) {
                      this._tokenSource = tokenSource;
                      this.tokens.length = 0;
                      this.p = -1;
                      this.fetchedEOF = false;
                    }
                    get index() {
                      return this.p;
                    }
                    mark() {
                      return 0;
                    }
                    release(marker) {
                    }
                    seek(index) {
                      this.lazyInit();
                      this.p = this.adjustSeekIndex(index);
                    }
                    get size() {
                      return this.tokens.length;
                    }
                    consume() {
                      let skipEofCheck;
                      if (this.p >= 0) {
                        if (this.fetchedEOF) {
                          skipEofCheck = this.p < this.tokens.length - 1;
                        } else {
                          skipEofCheck = this.p < this.tokens.length;
                        }
                      } else {
                        skipEofCheck = false;
                      }
                      if (!skipEofCheck && this.LA(1) === Token_1.Token.EOF) {
                        throw new Error("cannot consume EOF");
                      }
                      if (this.sync(this.p + 1)) {
                        this.p = this.adjustSeekIndex(this.p + 1);
                      }
                    }
                    /** Make sure index `i` in tokens has a token.
                     *
                     * @returns `true` if a token is located at index `i`, otherwise
                     *    `false`.
                     * @see #get(int i)
                     */
                    sync(i) {
                      assert(i >= 0);
                      let n = i - this.tokens.length + 1;
                      if (n > 0) {
                        let fetched = this.fetch(n);
                        return fetched >= n;
                      }
                      return true;
                    }
                    /** Add `n` elements to buffer.
                     *
                     * @returns The actual number of elements added to the buffer.
                     */
                    fetch(n) {
                      if (this.fetchedEOF) {
                        return 0;
                      }
                      for (let i = 0; i < n; i++) {
                        let t = this.tokenSource.nextToken();
                        if (this.isWritableToken(t)) {
                          t.tokenIndex = this.tokens.length;
                        }
                        this.tokens.push(t);
                        if (t.type === Token_1.Token.EOF) {
                          this.fetchedEOF = true;
                          return i + 1;
                        }
                      }
                      return n;
                    }
                    get(i) {
                      if (i < 0 || i >= this.tokens.length) {
                        throw new RangeError("token index " + i + " out of range 0.." + (this.tokens.length - 1));
                      }
                      return this.tokens[i];
                    }
                    /** Get all tokens from start..stop inclusively. */
                    getRange(start, stop) {
                      if (start < 0 || stop < 0) {
                        return [];
                      }
                      this.lazyInit();
                      let subset = new Array();
                      if (stop >= this.tokens.length) {
                        stop = this.tokens.length - 1;
                      }
                      for (let i = start; i <= stop; i++) {
                        let t = this.tokens[i];
                        if (t.type === Token_1.Token.EOF) {
                          break;
                        }
                        subset.push(t);
                      }
                      return subset;
                    }
                    LA(i) {
                      let token = this.LT(i);
                      if (!token) {
                        return Token_1.Token.INVALID_TYPE;
                      }
                      return token.type;
                    }
                    tryLB(k) {
                      if (this.p - k < 0) {
                        return void 0;
                      }
                      return this.tokens[this.p - k];
                    }
                    LT(k) {
                      let result = this.tryLT(k);
                      if (result === void 0) {
                        throw new RangeError("requested lookback index out of range");
                      }
                      return result;
                    }
                    tryLT(k) {
                      this.lazyInit();
                      if (k === 0) {
                        throw new RangeError("0 is not a valid lookahead index");
                      }
                      if (k < 0) {
                        return this.tryLB(-k);
                      }
                      let i = this.p + k - 1;
                      this.sync(i);
                      if (i >= this.tokens.length) {
                        return this.tokens[this.tokens.length - 1];
                      }
                      return this.tokens[i];
                    }
                    /**
                     * Allowed derived classes to modify the behavior of operations which change
                     * the current stream position by adjusting the target token index of a seek
                     * operation. The default implementation simply returns `i`. If an
                     * exception is thrown in this method, the current stream index should not be
                     * changed.
                     *
                     * For example, {@link CommonTokenStream} overrides this method to ensure that
                     * the seek target is always an on-channel token.
                     *
                     * @param i The target token index.
                     * @returns The adjusted target token index.
                     */
                    adjustSeekIndex(i) {
                      return i;
                    }
                    lazyInit() {
                      if (this.p === -1) {
                        this.setup();
                      }
                    }
                    setup() {
                      this.sync(0);
                      this.p = this.adjustSeekIndex(0);
                    }
                    /** Given a start and stop index, return a `List` of all tokens in
                     *  the token type `BitSet`.  Return an empty array if no tokens were found.  This
                     *  method looks at both on and off channel tokens.
                     */
                    getTokens(start, stop, types2) {
                      this.lazyInit();
                      if (start === void 0) {
                        assert(stop === void 0 && types2 === void 0);
                        return this.tokens;
                      } else if (stop === void 0) {
                        stop = this.tokens.length - 1;
                      }
                      if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
                        throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
                      }
                      if (start > stop) {
                        return [];
                      }
                      if (types2 === void 0) {
                        return this.tokens.slice(start, stop + 1);
                      } else if (typeof types2 === "number") {
                        types2 = (/* @__PURE__ */ new Set()).add(types2);
                      }
                      let typesSet = types2;
                      let filteredTokens = this.tokens.slice(start, stop + 1);
                      filteredTokens = filteredTokens.filter((value) => typesSet.has(value.type));
                      return filteredTokens;
                    }
                    /**
                     * Given a starting index, return the index of the next token on channel.
                     * Return `i` if `tokens[i]` is on channel. Return the index of
                     * the EOF token if there are no tokens on channel between `i` and
                     * EOF.
                     */
                    nextTokenOnChannel(i, channel) {
                      this.sync(i);
                      if (i >= this.size) {
                        return this.size - 1;
                      }
                      let token = this.tokens[i];
                      while (token.channel !== channel) {
                        if (token.type === Token_1.Token.EOF) {
                          return i;
                        }
                        i++;
                        this.sync(i);
                        token = this.tokens[i];
                      }
                      return i;
                    }
                    /**
                     * Given a starting index, return the index of the previous token on
                     * channel. Return `i` if `tokens[i]` is on channel. Return -1
                     * if there are no tokens on channel between `i` and 0.
                     *
                     * If `i` specifies an index at or after the EOF token, the EOF token
                     * index is returned. This is due to the fact that the EOF token is treated
                     * as though it were on every channel.
                     */
                    previousTokenOnChannel(i, channel) {
                      this.sync(i);
                      if (i >= this.size) {
                        return this.size - 1;
                      }
                      while (i >= 0) {
                        let token = this.tokens[i];
                        if (token.type === Token_1.Token.EOF || token.channel === channel) {
                          return i;
                        }
                        i--;
                      }
                      return i;
                    }
                    /** Collect all tokens on specified channel to the right of
                     *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL} or
                     *  EOF. If `channel` is `-1`, find any non default channel token.
                     */
                    getHiddenTokensToRight(tokenIndex, channel = -1) {
                      this.lazyInit();
                      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
                        throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
                      }
                      let nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
                      let to;
                      let from = tokenIndex + 1;
                      if (nextOnChannel === -1) {
                        to = this.size - 1;
                      } else {
                        to = nextOnChannel;
                      }
                      return this.filterForChannel(from, to, channel);
                    }
                    /** Collect all tokens on specified channel to the left of
                     *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL}.
                     *  If `channel` is `-1`, find any non default channel token.
                     */
                    getHiddenTokensToLeft(tokenIndex, channel = -1) {
                      this.lazyInit();
                      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
                        throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
                      }
                      if (tokenIndex === 0) {
                        return [];
                      }
                      let prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
                      if (prevOnChannel === tokenIndex - 1) {
                        return [];
                      }
                      let from = prevOnChannel + 1;
                      let to = tokenIndex - 1;
                      return this.filterForChannel(from, to, channel);
                    }
                    filterForChannel(from, to, channel) {
                      let hidden = new Array();
                      for (let i = from; i <= to; i++) {
                        let t = this.tokens[i];
                        if (channel === -1) {
                          if (t.channel !== Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL) {
                            hidden.push(t);
                          }
                        } else {
                          if (t.channel === channel) {
                            hidden.push(t);
                          }
                        }
                      }
                      return hidden;
                    }
                    get sourceName() {
                      return this.tokenSource.sourceName;
                    }
                    getText(interval) {
                      if (interval === void 0) {
                        interval = Interval_1.Interval.of(0, this.size - 1);
                      } else if (!(interval instanceof Interval_1.Interval)) {
                        interval = interval.sourceInterval;
                      }
                      let start = interval.a;
                      let stop = interval.b;
                      if (start < 0 || stop < 0) {
                        return "";
                      }
                      this.fill();
                      if (stop >= this.tokens.length) {
                        stop = this.tokens.length - 1;
                      }
                      let buf = "";
                      for (let i = start; i <= stop; i++) {
                        let t = this.tokens[i];
                        if (t.type === Token_1.Token.EOF) {
                          break;
                        }
                        buf += t.text;
                      }
                      return buf.toString();
                    }
                    getTextFromRange(start, stop) {
                      if (this.isToken(start) && this.isToken(stop)) {
                        return this.getText(Interval_1.Interval.of(start.tokenIndex, stop.tokenIndex));
                      }
                      return "";
                    }
                    /** Get all tokens from lexer until EOF. */
                    fill() {
                      this.lazyInit();
                      const blockSize = 1e3;
                      while (true) {
                        let fetched = this.fetch(blockSize);
                        if (fetched < blockSize) {
                          return;
                        }
                      }
                    }
                    // TODO: Figure out a way to make this more flexible?
                    isWritableToken(t) {
                      return t instanceof CommonToken_1.CommonToken;
                    }
                    // TODO: Figure out a way to make this more flexible?
                    isToken(t) {
                      return t instanceof CommonToken_1.CommonToken;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], BufferedTokenStream.prototype, "_tokenSource", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "tokenSource", null);
                  __decorate([
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "index", null);
                  __decorate([
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "mark", null);
                  __decorate([
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "release", null);
                  __decorate([
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "seek", null);
                  __decorate([
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "size", null);
                  __decorate([
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "consume", null);
                  __decorate([
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "get", null);
                  __decorate([
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "LA", null);
                  __decorate([
                    Decorators_1.NotNull,
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "LT", null);
                  __decorate([
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "sourceName", null);
                  __decorate([
                    Decorators_1.NotNull,
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "getText", null);
                  __decorate([
                    Decorators_1.NotNull,
                    Decorators_1.Override
                  ], BufferedTokenStream.prototype, "getTextFromRange", null);
                  BufferedTokenStream = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], BufferedTokenStream);
                  exports2.BufferedTokenStream = BufferedTokenStream;
                }
              ),
              /***/
              "./node_modules/antlr4ts/CharStream.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/antlr4ts/CharStream.js ***!
                  \*********************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                }
              ),
              /***/
              "./node_modules/antlr4ts/CharStreams.js": (
                /*!**********************************************!*\
                  !*** ./node_modules/antlr4ts/CharStreams.js ***!
                  \**********************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.CharStreams = void 0;
                  const CodePointBuffer_1 = __webpack_require__2(
                    /*! ./CodePointBuffer */
                    "./node_modules/antlr4ts/CodePointBuffer.js"
                  );
                  const CodePointCharStream_1 = __webpack_require__2(
                    /*! ./CodePointCharStream */
                    "./node_modules/antlr4ts/CodePointCharStream.js"
                  );
                  const IntStream_1 = __webpack_require__2(
                    /*! ./IntStream */
                    "./node_modules/antlr4ts/IntStream.js"
                  );
                  var CharStreams;
                  (function(CharStreams2) {
                    function fromString(s, sourceName) {
                      if (sourceName === void 0 || sourceName.length === 0) {
                        sourceName = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
                      }
                      let codePointBufferBuilder = CodePointBuffer_1.CodePointBuffer.builder(s.length);
                      let cb = new Uint16Array(s.length);
                      for (let i = 0; i < s.length; i++) {
                        cb[i] = s.charCodeAt(i);
                      }
                      codePointBufferBuilder.append(cb);
                      return CodePointCharStream_1.CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);
                    }
                    CharStreams2.fromString = fromString;
                  })(CharStreams = exports2.CharStreams || (exports2.CharStreams = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/CodePointBuffer.js": (
                /*!**************************************************!*\
                  !*** ./node_modules/antlr4ts/CodePointBuffer.js ***!
                  \**************************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.CodePointBuffer = void 0;
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  const Character = __webpack_require__2(
                    /*! ./misc/Character */
                    "./node_modules/antlr4ts/misc/Character.js"
                  );
                  class CodePointBuffer {
                    constructor(buffer, size) {
                      this.buffer = buffer;
                      this._position = 0;
                      this._size = size;
                    }
                    static withArray(buffer) {
                      return new CodePointBuffer(buffer, buffer.length);
                    }
                    get position() {
                      return this._position;
                    }
                    set position(newPosition) {
                      if (newPosition < 0 || newPosition > this._size) {
                        throw new RangeError();
                      }
                      this._position = newPosition;
                    }
                    get remaining() {
                      return this._size - this.position;
                    }
                    get(offset) {
                      return this.buffer[offset];
                    }
                    array() {
                      return this.buffer.slice(0, this._size);
                    }
                    static builder(initialBufferSize) {
                      return new CodePointBuffer.Builder(initialBufferSize);
                    }
                  }
                  exports2.CodePointBuffer = CodePointBuffer;
                  (function(CodePointBuffer2) {
                    let Type2;
                    (function(Type3) {
                      Type3[Type3["BYTE"] = 0] = "BYTE";
                      Type3[Type3["CHAR"] = 1] = "CHAR";
                      Type3[Type3["INT"] = 2] = "INT";
                    })(Type2 || (Type2 = {}));
                    class Builder {
                      constructor(initialBufferSize) {
                        this.type = 0;
                        this.buffer = new Uint8Array(initialBufferSize);
                        this.prevHighSurrogate = -1;
                        this.position = 0;
                      }
                      build() {
                        return new CodePointBuffer2(this.buffer, this.position);
                      }
                      static roundUpToNextPowerOfTwo(i) {
                        let nextPowerOfTwo = 32 - Math.clz32(i - 1);
                        return Math.pow(2, nextPowerOfTwo);
                      }
                      ensureRemaining(remainingNeeded) {
                        switch (this.type) {
                          case 0:
                            if (this.buffer.length - this.position < remainingNeeded) {
                              let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                              let newBuffer = new Uint8Array(newCapacity);
                              newBuffer.set(this.buffer.subarray(0, this.position), 0);
                              this.buffer = newBuffer;
                            }
                            break;
                          case 1:
                            if (this.buffer.length - this.position < remainingNeeded) {
                              let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                              let newBuffer = new Uint16Array(newCapacity);
                              newBuffer.set(this.buffer.subarray(0, this.position), 0);
                              this.buffer = newBuffer;
                            }
                            break;
                          case 2:
                            if (this.buffer.length - this.position < remainingNeeded) {
                              let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                              let newBuffer = new Int32Array(newCapacity);
                              newBuffer.set(this.buffer.subarray(0, this.position), 0);
                              this.buffer = newBuffer;
                            }
                            break;
                        }
                      }
                      append(utf16In) {
                        this.ensureRemaining(utf16In.length);
                        this.appendArray(utf16In);
                      }
                      appendArray(utf16In) {
                        switch (this.type) {
                          case 0:
                            this.appendArrayByte(utf16In);
                            break;
                          case 1:
                            this.appendArrayChar(utf16In);
                            break;
                          case 2:
                            this.appendArrayInt(utf16In);
                            break;
                        }
                      }
                      appendArrayByte(utf16In) {
                        assert(this.prevHighSurrogate === -1);
                        let input = utf16In;
                        let inOffset = 0;
                        let inLimit = utf16In.length;
                        let outByte = this.buffer;
                        let outOffset = this.position;
                        while (inOffset < inLimit) {
                          let c = input[inOffset];
                          if (c <= 255) {
                            outByte[outOffset] = c;
                          } else {
                            utf16In = utf16In.subarray(inOffset, inLimit);
                            this.position = outOffset;
                            if (!Character.isHighSurrogate(c)) {
                              this.byteToCharBuffer(utf16In.length);
                              this.appendArrayChar(utf16In);
                              return;
                            } else {
                              this.byteToIntBuffer(utf16In.length);
                              this.appendArrayInt(utf16In);
                              return;
                            }
                          }
                          inOffset++;
                          outOffset++;
                        }
                        this.position = outOffset;
                      }
                      appendArrayChar(utf16In) {
                        assert(this.prevHighSurrogate === -1);
                        let input = utf16In;
                        let inOffset = 0;
                        let inLimit = utf16In.length;
                        let outChar = this.buffer;
                        let outOffset = this.position;
                        while (inOffset < inLimit) {
                          let c = input[inOffset];
                          if (!Character.isHighSurrogate(c)) {
                            outChar[outOffset] = c;
                          } else {
                            utf16In = utf16In.subarray(inOffset, inLimit);
                            this.position = outOffset;
                            this.charToIntBuffer(utf16In.length);
                            this.appendArrayInt(utf16In);
                            return;
                          }
                          inOffset++;
                          outOffset++;
                        }
                        this.position = outOffset;
                      }
                      appendArrayInt(utf16In) {
                        let input = utf16In;
                        let inOffset = 0;
                        let inLimit = utf16In.length;
                        let outInt = this.buffer;
                        let outOffset = this.position;
                        while (inOffset < inLimit) {
                          let c = input[inOffset];
                          inOffset++;
                          if (this.prevHighSurrogate !== -1) {
                            if (Character.isLowSurrogate(c)) {
                              outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0);
                              outOffset++;
                              this.prevHighSurrogate = -1;
                            } else {
                              outInt[outOffset] = this.prevHighSurrogate;
                              outOffset++;
                              if (Character.isHighSurrogate(c)) {
                                this.prevHighSurrogate = c;
                              } else {
                                outInt[outOffset] = c;
                                outOffset++;
                                this.prevHighSurrogate = -1;
                              }
                            }
                          } else if (Character.isHighSurrogate(c)) {
                            this.prevHighSurrogate = c;
                          } else {
                            outInt[outOffset] = c;
                            outOffset++;
                          }
                        }
                        if (this.prevHighSurrogate !== -1) {
                          outInt[outOffset] = this.prevHighSurrogate;
                          outOffset++;
                        }
                        this.position = outOffset;
                      }
                      byteToCharBuffer(toAppend) {
                        let newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
                        newBuffer.set(this.buffer.subarray(0, this.position), 0);
                        this.type = 1;
                        this.buffer = newBuffer;
                      }
                      byteToIntBuffer(toAppend) {
                        let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));
                        newBuffer.set(this.buffer.subarray(0, this.position), 0);
                        this.type = 2;
                        this.buffer = newBuffer;
                      }
                      charToIntBuffer(toAppend) {
                        let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
                        newBuffer.set(this.buffer.subarray(0, this.position), 0);
                        this.type = 2;
                        this.buffer = newBuffer;
                      }
                    }
                    CodePointBuffer2.Builder = Builder;
                  })(CodePointBuffer = exports2.CodePointBuffer || (exports2.CodePointBuffer = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/CodePointCharStream.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/CodePointCharStream.js ***!
                  \******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.CodePointCharStream = void 0;
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  const IntStream_1 = __webpack_require__2(
                    /*! ./IntStream */
                    "./node_modules/antlr4ts/IntStream.js"
                  );
                  const Interval_1 = __webpack_require__2(
                    /*! ./misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class CodePointCharStream {
                    // Use the factory method {@link #fromBuffer(CodePointBuffer)} to
                    // construct instances of this type.
                    constructor(array, position, remaining, name) {
                      assert(position === 0);
                      this._array = array;
                      this._size = remaining;
                      this._name = name;
                      this._position = 0;
                    }
                    get internalStorage() {
                      return this._array;
                    }
                    static fromBuffer(codePointBuffer, name) {
                      if (name === void 0 || name.length === 0) {
                        name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
                      }
                      return new CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);
                    }
                    consume() {
                      if (this._size - this._position === 0) {
                        assert(this.LA(1) === IntStream_1.IntStream.EOF);
                        throw new RangeError("cannot consume EOF");
                      }
                      this._position++;
                    }
                    get index() {
                      return this._position;
                    }
                    get size() {
                      return this._size;
                    }
                    /** mark/release do nothing; we have entire buffer */
                    mark() {
                      return -1;
                    }
                    release(marker) {
                    }
                    seek(index) {
                      this._position = index;
                    }
                    get sourceName() {
                      return this._name;
                    }
                    toString() {
                      return this.getText(Interval_1.Interval.of(0, this.size - 1));
                    }
                    LA(i) {
                      let offset;
                      switch (Math.sign(i)) {
                        case -1:
                          offset = this.index + i;
                          if (offset < 0) {
                            return IntStream_1.IntStream.EOF;
                          }
                          return this._array[offset];
                        case 0:
                          return 0;
                        case 1:
                          offset = this.index + i - 1;
                          if (offset >= this.size) {
                            return IntStream_1.IntStream.EOF;
                          }
                          return this._array[offset];
                      }
                      throw new RangeError("Not reached");
                    }
                    /** Return the UTF-16 encoded string for the given interval */
                    getText(interval) {
                      const startIdx = Math.min(interval.a, this.size);
                      const len = Math.min(interval.b - interval.a + 1, this.size - startIdx);
                      if (this._array instanceof Int32Array) {
                        return String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));
                      } else {
                        return String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));
                      }
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], CodePointCharStream.prototype, "consume", null);
                  __decorate([
                    Decorators_1.Override
                  ], CodePointCharStream.prototype, "index", null);
                  __decorate([
                    Decorators_1.Override
                  ], CodePointCharStream.prototype, "size", null);
                  __decorate([
                    Decorators_1.Override
                  ], CodePointCharStream.prototype, "mark", null);
                  __decorate([
                    Decorators_1.Override
                  ], CodePointCharStream.prototype, "release", null);
                  __decorate([
                    Decorators_1.Override
                  ], CodePointCharStream.prototype, "seek", null);
                  __decorate([
                    Decorators_1.Override
                  ], CodePointCharStream.prototype, "sourceName", null);
                  __decorate([
                    Decorators_1.Override
                  ], CodePointCharStream.prototype, "toString", null);
                  __decorate([
                    Decorators_1.Override
                  ], CodePointCharStream.prototype, "LA", null);
                  __decorate([
                    Decorators_1.Override
                  ], CodePointCharStream.prototype, "getText", null);
                  exports2.CodePointCharStream = CodePointCharStream;
                }
              ),
              /***/
              "./node_modules/antlr4ts/CommonToken.js": (
                /*!**********************************************!*\
                  !*** ./node_modules/antlr4ts/CommonToken.js ***!
                  \**********************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.CommonToken = void 0;
                  const Interval_1 = __webpack_require__2(
                    /*! ./misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  let CommonToken = class CommonToken2 {
                    constructor(type2, text, source = CommonToken2.EMPTY_SOURCE, channel = Token_1.Token.DEFAULT_CHANNEL, start = 0, stop = 0) {
                      this._line = 0;
                      this._charPositionInLine = -1;
                      this._channel = Token_1.Token.DEFAULT_CHANNEL;
                      this.index = -1;
                      this._text = text;
                      this._type = type2;
                      this.source = source;
                      this._channel = channel;
                      this.start = start;
                      this.stop = stop;
                      if (source.source != null) {
                        this._line = source.source.line;
                        this._charPositionInLine = source.source.charPositionInLine;
                      }
                    }
                    /**
                     * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
                     *
                     * If `oldToken` is also a {@link CommonToken} instance, the newly
                     * constructed token will share a reference to the {@link #text} field and
                     * the {@link Tuple2} stored in {@link #source}. Otherwise, {@link #text} will
                     * be assigned the result of calling {@link #getText}, and {@link #source}
                     * will be constructed from the result of {@link Token#getTokenSource} and
                     * {@link Token#getInputStream}.
                     *
                     * @param oldToken The token to copy.
                     */
                    static fromToken(oldToken) {
                      let result = new CommonToken2(oldToken.type, void 0, CommonToken2.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);
                      result._line = oldToken.line;
                      result.index = oldToken.tokenIndex;
                      result._charPositionInLine = oldToken.charPositionInLine;
                      if (oldToken instanceof CommonToken2) {
                        result._text = oldToken._text;
                        result.source = oldToken.source;
                      } else {
                        result._text = oldToken.text;
                        result.source = { source: oldToken.tokenSource, stream: oldToken.inputStream };
                      }
                      return result;
                    }
                    get type() {
                      return this._type;
                    }
                    // @Override
                    set type(type2) {
                      this._type = type2;
                    }
                    get line() {
                      return this._line;
                    }
                    // @Override
                    set line(line) {
                      this._line = line;
                    }
                    get text() {
                      if (this._text != null) {
                        return this._text;
                      }
                      let input = this.inputStream;
                      if (input == null) {
                        return void 0;
                      }
                      let n = input.size;
                      if (this.start < n && this.stop < n) {
                        return input.getText(Interval_1.Interval.of(this.start, this.stop));
                      } else {
                        return "<EOF>";
                      }
                    }
                    /**
                     * Explicitly set the text for this token. If {code text} is not
                     * `undefined`, then {@link #getText} will return this value rather than
                     * extracting the text from the input.
                     *
                     * @param text The explicit text of the token, or `undefined` if the text
                     * should be obtained from the input along with the start and stop indexes
                     * of the token.
                     */
                    // @Override
                    set text(text) {
                      this._text = text;
                    }
                    get charPositionInLine() {
                      return this._charPositionInLine;
                    }
                    // @Override
                    set charPositionInLine(charPositionInLine) {
                      this._charPositionInLine = charPositionInLine;
                    }
                    get channel() {
                      return this._channel;
                    }
                    // @Override
                    set channel(channel) {
                      this._channel = channel;
                    }
                    get startIndex() {
                      return this.start;
                    }
                    set startIndex(start) {
                      this.start = start;
                    }
                    get stopIndex() {
                      return this.stop;
                    }
                    set stopIndex(stop) {
                      this.stop = stop;
                    }
                    get tokenIndex() {
                      return this.index;
                    }
                    // @Override
                    set tokenIndex(index) {
                      this.index = index;
                    }
                    get tokenSource() {
                      return this.source.source;
                    }
                    get inputStream() {
                      return this.source.stream;
                    }
                    toString(recognizer) {
                      let channelStr = "";
                      if (this._channel > 0) {
                        channelStr = ",channel=" + this._channel;
                      }
                      let txt = this.text;
                      if (txt != null) {
                        txt = txt.replace(/\n/g, "\\n");
                        txt = txt.replace(/\r/g, "\\r");
                        txt = txt.replace(/\t/g, "\\t");
                      } else {
                        txt = "<no text>";
                      }
                      let typeString = String(this._type);
                      if (recognizer) {
                        typeString = recognizer.vocabulary.getDisplayName(this._type);
                      }
                      return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + typeString + ">" + channelStr + "," + this._line + ":" + this.charPositionInLine + "]";
                    }
                  };
                  CommonToken.EMPTY_SOURCE = { source: void 0, stream: void 0 };
                  __decorate([
                    Decorators_1.NotNull
                  ], CommonToken.prototype, "source", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], CommonToken.prototype, "type", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonToken.prototype, "line", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonToken.prototype, "text", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonToken.prototype, "charPositionInLine", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonToken.prototype, "channel", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonToken.prototype, "startIndex", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonToken.prototype, "stopIndex", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonToken.prototype, "tokenIndex", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonToken.prototype, "tokenSource", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonToken.prototype, "inputStream", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonToken.prototype, "toString", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], CommonToken, "fromToken", null);
                  CommonToken = __decorate([
                    __param(2, Decorators_1.NotNull)
                  ], CommonToken);
                  exports2.CommonToken = CommonToken;
                }
              ),
              /***/
              "./node_modules/antlr4ts/CommonTokenFactory.js": (
                /*!*****************************************************!*\
                  !*** ./node_modules/antlr4ts/CommonTokenFactory.js ***!
                  \*****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.CommonTokenFactory = void 0;
                  const CommonToken_1 = __webpack_require__2(
                    /*! ./CommonToken */
                    "./node_modules/antlr4ts/CommonToken.js"
                  );
                  const Interval_1 = __webpack_require__2(
                    /*! ./misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class CommonTokenFactory {
                    /**
                     * Constructs a {@link CommonTokenFactory} with the specified value for
                     * {@link #copyText}.
                     *
                     * When `copyText` is `false`, the {@link #DEFAULT} instance
                     * should be used instead of constructing a new instance.
                     *
                     * @param copyText The value for {@link #copyText}.
                     */
                    constructor(copyText = false) {
                      this.copyText = copyText;
                    }
                    create(source, type2, text, channel, start, stop, line, charPositionInLine) {
                      let t = new CommonToken_1.CommonToken(type2, text, source, channel, start, stop);
                      t.line = line;
                      t.charPositionInLine = charPositionInLine;
                      if (text == null && this.copyText && source.stream != null) {
                        t.text = source.stream.getText(Interval_1.Interval.of(start, stop));
                      }
                      return t;
                    }
                    createSimple(type2, text) {
                      return new CommonToken_1.CommonToken(type2, text);
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], CommonTokenFactory.prototype, "create", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonTokenFactory.prototype, "createSimple", null);
                  exports2.CommonTokenFactory = CommonTokenFactory;
                  (function(CommonTokenFactory2) {
                    CommonTokenFactory2.DEFAULT = new CommonTokenFactory2();
                  })(CommonTokenFactory = exports2.CommonTokenFactory || (exports2.CommonTokenFactory = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/CommonTokenStream.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/CommonTokenStream.js ***!
                  \****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.CommonTokenStream = void 0;
                  const BufferedTokenStream_1 = __webpack_require__2(
                    /*! ./BufferedTokenStream */
                    "./node_modules/antlr4ts/BufferedTokenStream.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  let CommonTokenStream = class CommonTokenStream extends BufferedTokenStream_1.BufferedTokenStream {
                    /**
                     * Constructs a new {@link CommonTokenStream} using the specified token
                     * source and filtering tokens to the specified channel. Only tokens whose
                     * {@link Token#getChannel} matches `channel` or have the
                     * `Token.type` equal to {@link Token#EOF} will be returned by the
                     * token stream lookahead methods.
                     *
                     * @param tokenSource The token source.
                     * @param channel The channel to use for filtering tokens.
                     */
                    constructor(tokenSource, channel = Token_1.Token.DEFAULT_CHANNEL) {
                      super(tokenSource);
                      this.channel = channel;
                    }
                    adjustSeekIndex(i) {
                      return this.nextTokenOnChannel(i, this.channel);
                    }
                    tryLB(k) {
                      if (this.p - k < 0) {
                        return void 0;
                      }
                      let i = this.p;
                      let n = 1;
                      while (n <= k && i > 0) {
                        i = this.previousTokenOnChannel(i - 1, this.channel);
                        n++;
                      }
                      if (i < 0) {
                        return void 0;
                      }
                      return this.tokens[i];
                    }
                    tryLT(k) {
                      this.lazyInit();
                      if (k === 0) {
                        throw new RangeError("0 is not a valid lookahead index");
                      }
                      if (k < 0) {
                        return this.tryLB(-k);
                      }
                      let i = this.p;
                      let n = 1;
                      while (n < k) {
                        if (this.sync(i + 1)) {
                          i = this.nextTokenOnChannel(i + 1, this.channel);
                        }
                        n++;
                      }
                      return this.tokens[i];
                    }
                    /** Count EOF just once. */
                    getNumberOfOnChannelTokens() {
                      let n = 0;
                      this.fill();
                      for (let t of this.tokens) {
                        if (t.channel === this.channel) {
                          n++;
                        }
                        if (t.type === Token_1.Token.EOF) {
                          break;
                        }
                      }
                      return n;
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], CommonTokenStream.prototype, "adjustSeekIndex", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonTokenStream.prototype, "tryLB", null);
                  __decorate([
                    Decorators_1.Override
                  ], CommonTokenStream.prototype, "tryLT", null);
                  CommonTokenStream = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], CommonTokenStream);
                  exports2.CommonTokenStream = CommonTokenStream;
                }
              ),
              /***/
              "./node_modules/antlr4ts/ConsoleErrorListener.js": (
                /*!*******************************************************!*\
                  !*** ./node_modules/antlr4ts/ConsoleErrorListener.js ***!
                  \*******************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ConsoleErrorListener = void 0;
                  class ConsoleErrorListener {
                    /**
                     * {@inheritDoc}
                     *
                     * This implementation prints messages to {@link System#err} containing the
                     * values of `line`, `charPositionInLine`, and `msg` using
                     * the following format.
                     *
                     * <pre>
                     * line *line*:*charPositionInLine* *msg*
                     * </pre>
                     */
                    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
                      console.error(`line ${line}:${charPositionInLine} ${msg}`);
                    }
                  }
                  exports2.ConsoleErrorListener = ConsoleErrorListener;
                  ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
                }
              ),
              /***/
              "./node_modules/antlr4ts/Decorators.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/antlr4ts/Decorators.js ***!
                  \*********************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.SuppressWarnings = exports2.Override = exports2.Nullable = exports2.NotNull = void 0;
                  function NotNull(target, propertyKey, propertyDescriptor) {
                  }
                  exports2.NotNull = NotNull;
                  function Nullable(target, propertyKey, propertyDescriptor) {
                  }
                  exports2.Nullable = Nullable;
                  function Override(target, propertyKey, propertyDescriptor) {
                  }
                  exports2.Override = Override;
                  function SuppressWarnings(options) {
                    return (target, propertyKey, descriptor) => {
                    };
                  }
                  exports2.SuppressWarnings = SuppressWarnings;
                }
              ),
              /***/
              "./node_modules/antlr4ts/DefaultErrorStrategy.js": (
                /*!*******************************************************!*\
                  !*** ./node_modules/antlr4ts/DefaultErrorStrategy.js ***!
                  \*******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.DefaultErrorStrategy = void 0;
                  const ATNState_1 = __webpack_require__2(
                    /*! ./atn/ATNState */
                    "./node_modules/antlr4ts/atn/ATNState.js"
                  );
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./atn/ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const FailedPredicateException_1 = __webpack_require__2(
                    /*! ./FailedPredicateException */
                    "./node_modules/antlr4ts/FailedPredicateException.js"
                  );
                  const InputMismatchException_1 = __webpack_require__2(
                    /*! ./InputMismatchException */
                    "./node_modules/antlr4ts/InputMismatchException.js"
                  );
                  const IntervalSet_1 = __webpack_require__2(
                    /*! ./misc/IntervalSet */
                    "./node_modules/antlr4ts/misc/IntervalSet.js"
                  );
                  const NoViableAltException_1 = __webpack_require__2(
                    /*! ./NoViableAltException */
                    "./node_modules/antlr4ts/NoViableAltException.js"
                  );
                  const PredictionContext_1 = __webpack_require__2(
                    /*! ./atn/PredictionContext */
                    "./node_modules/antlr4ts/atn/PredictionContext.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class DefaultErrorStrategy {
                    constructor() {
                      this.errorRecoveryMode = false;
                      this.lastErrorIndex = -1;
                      this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The default implementation simply calls {@link #endErrorCondition} to
                     * ensure that the handler is not in error recovery mode.
                     */
                    reset(recognizer) {
                      this.endErrorCondition(recognizer);
                    }
                    /**
                     * This method is called to enter error recovery mode when a recognition
                     * exception is reported.
                     *
                     * @param recognizer the parser instance
                     */
                    beginErrorCondition(recognizer) {
                      this.errorRecoveryMode = true;
                    }
                    /**
                     * {@inheritDoc}
                     */
                    inErrorRecoveryMode(recognizer) {
                      return this.errorRecoveryMode;
                    }
                    /**
                     * This method is called to leave error recovery mode after recovering from
                     * a recognition exception.
                     *
                     * @param recognizer
                     */
                    endErrorCondition(recognizer) {
                      this.errorRecoveryMode = false;
                      this.lastErrorStates = void 0;
                      this.lastErrorIndex = -1;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The default implementation simply calls {@link #endErrorCondition}.
                     */
                    reportMatch(recognizer) {
                      this.endErrorCondition(recognizer);
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The default implementation returns immediately if the handler is already
                     * in error recovery mode. Otherwise, it calls {@link #beginErrorCondition}
                     * and dispatches the reporting task based on the runtime type of `e`
                     * according to the following table.
                     *
                     * * {@link NoViableAltException}: Dispatches the call to
                     *   {@link #reportNoViableAlternative}
                     * * {@link InputMismatchException}: Dispatches the call to
                     *   {@link #reportInputMismatch}
                     * * {@link FailedPredicateException}: Dispatches the call to
                     *   {@link #reportFailedPredicate}
                     * * All other types: calls {@link Parser#notifyErrorListeners} to report
                     *   the exception
                     */
                    reportError(recognizer, e) {
                      if (this.inErrorRecoveryMode(recognizer)) {
                        return;
                      }
                      this.beginErrorCondition(recognizer);
                      if (e instanceof NoViableAltException_1.NoViableAltException) {
                        this.reportNoViableAlternative(recognizer, e);
                      } else if (e instanceof InputMismatchException_1.InputMismatchException) {
                        this.reportInputMismatch(recognizer, e);
                      } else if (e instanceof FailedPredicateException_1.FailedPredicateException) {
                        this.reportFailedPredicate(recognizer, e);
                      } else {
                        console.error(`unknown recognition error type: ${e}`);
                        this.notifyErrorListeners(recognizer, e.toString(), e);
                      }
                    }
                    notifyErrorListeners(recognizer, message, e) {
                      let offendingToken = e.getOffendingToken(recognizer);
                      if (offendingToken === void 0) {
                        offendingToken = null;
                      }
                      recognizer.notifyErrorListeners(message, offendingToken, e);
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The default implementation resynchronizes the parser by consuming tokens
                     * until we find one in the resynchronization set--loosely the set of tokens
                     * that can follow the current rule.
                     */
                    recover(recognizer, e) {
                      if (this.lastErrorIndex === recognizer.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(recognizer.state)) {
                        recognizer.consume();
                      }
                      this.lastErrorIndex = recognizer.inputStream.index;
                      if (!this.lastErrorStates) {
                        this.lastErrorStates = new IntervalSet_1.IntervalSet();
                      }
                      this.lastErrorStates.add(recognizer.state);
                      let followSet = this.getErrorRecoverySet(recognizer);
                      this.consumeUntil(recognizer, followSet);
                    }
                    /**
                     * The default implementation of {@link ANTLRErrorStrategy#sync} makes sure
                     * that the current lookahead symbol is consistent with what were expecting
                     * at this point in the ATN. You can call this anytime but ANTLR only
                     * generates code to check before subrules/loops and each iteration.
                     *
                     * Implements Jim Idle's magic sync mechanism in closures and optional
                     * subrules. E.g.,
                     *
                     * ```antlr
                     * a : sync ( stuff sync )* ;
                     * sync : {consume to what can follow sync} ;
                     * ```
                     *
                     * At the start of a sub rule upon error, {@link #sync} performs single
                     * token deletion, if possible. If it can't do that, it bails on the current
                     * rule and uses the default error recovery, which consumes until the
                     * resynchronization set of the current rule.
                     *
                     * If the sub rule is optional (`(...)?`, `(...)*`, or block
                     * with an empty alternative), then the expected set includes what follows
                     * the subrule.
                     *
                     * During loop iteration, it consumes until it sees a token that can start a
                     * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
                     * stay in the loop as long as possible.
                     *
                     * **ORIGINS**
                     *
                     * Previous versions of ANTLR did a poor job of their recovery within loops.
                     * A single mismatch token or missing token would force the parser to bail
                     * out of the entire rules surrounding the loop. So, for rule
                     *
                     * ```antlr
                     * classDef : 'class' ID '{' member* '}'
                     * ```
                     *
                     * input with an extra token between members would force the parser to
                     * consume until it found the next class definition rather than the next
                     * member definition of the current class.
                     *
                     * This functionality cost a little bit of effort because the parser has to
                     * compare token set at the start of the loop and at each iteration. If for
                     * some reason speed is suffering for you, you can turn off this
                     * functionality by simply overriding this method as a blank { }.
                     */
                    sync(recognizer) {
                      let s = recognizer.interpreter.atn.states[recognizer.state];
                      if (this.inErrorRecoveryMode(recognizer)) {
                        return;
                      }
                      let tokens = recognizer.inputStream;
                      let la = tokens.LA(1);
                      let nextTokens = recognizer.atn.nextTokens(s);
                      if (nextTokens.contains(la)) {
                        this.nextTokensContext = void 0;
                        this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
                        return;
                      }
                      if (nextTokens.contains(Token_1.Token.EPSILON)) {
                        if (this.nextTokensContext === void 0) {
                          this.nextTokensContext = recognizer.context;
                          this.nextTokensState = recognizer.state;
                        }
                        return;
                      }
                      switch (s.stateType) {
                        case ATNStateType_1.ATNStateType.BLOCK_START:
                        case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
                        case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
                        case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
                          if (this.singleTokenDeletion(recognizer)) {
                            return;
                          }
                          throw new InputMismatchException_1.InputMismatchException(recognizer);
                        case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
                        case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
                          this.reportUnwantedToken(recognizer);
                          let expecting = recognizer.getExpectedTokens();
                          let whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));
                          this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
                          break;
                        default:
                          break;
                      }
                    }
                    /**
                     * This is called by {@link #reportError} when the exception is a
                     * {@link NoViableAltException}.
                     *
                     * @see #reportError
                     *
                     * @param recognizer the parser instance
                     * @param e the recognition exception
                     */
                    reportNoViableAlternative(recognizer, e) {
                      let tokens = recognizer.inputStream;
                      let input;
                      if (tokens) {
                        if (e.startToken.type === Token_1.Token.EOF) {
                          input = "<EOF>";
                        } else {
                          input = tokens.getTextFromRange(e.startToken, e.getOffendingToken());
                        }
                      } else {
                        input = "<unknown input>";
                      }
                      let msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
                      this.notifyErrorListeners(recognizer, msg, e);
                    }
                    /**
                     * This is called by {@link #reportError} when the exception is an
                     * {@link InputMismatchException}.
                     *
                     * @see #reportError
                     *
                     * @param recognizer the parser instance
                     * @param e the recognition exception
                     */
                    reportInputMismatch(recognizer, e) {
                      let expected = e.expectedTokens;
                      let expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : "";
                      let msg = "mismatched input " + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) + " expecting " + expectedString;
                      this.notifyErrorListeners(recognizer, msg, e);
                    }
                    /**
                     * This is called by {@link #reportError} when the exception is a
                     * {@link FailedPredicateException}.
                     *
                     * @see #reportError
                     *
                     * @param recognizer the parser instance
                     * @param e the recognition exception
                     */
                    reportFailedPredicate(recognizer, e) {
                      let ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
                      let msg = "rule " + ruleName + " " + e.message;
                      this.notifyErrorListeners(recognizer, msg, e);
                    }
                    /**
                     * This method is called to report a syntax error which requires the removal
                     * of a token from the input stream. At the time this method is called, the
                     * erroneous symbol is current `LT(1)` symbol and has not yet been
                     * removed from the input stream. When this method returns,
                     * `recognizer` is in error recovery mode.
                     *
                     * This method is called when {@link #singleTokenDeletion} identifies
                     * single-token deletion as a viable recovery strategy for a mismatched
                     * input error.
                     *
                     * The default implementation simply returns if the handler is already in
                     * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
                     * enter error recovery mode, followed by calling
                     * {@link Parser#notifyErrorListeners}.
                     *
                     * @param recognizer the parser instance
                     */
                    reportUnwantedToken(recognizer) {
                      if (this.inErrorRecoveryMode(recognizer)) {
                        return;
                      }
                      this.beginErrorCondition(recognizer);
                      let t = recognizer.currentToken;
                      let tokenName = this.getTokenErrorDisplay(t);
                      let expecting = this.getExpectedTokens(recognizer);
                      let msg = "extraneous input " + tokenName + " expecting " + expecting.toStringVocabulary(recognizer.vocabulary);
                      recognizer.notifyErrorListeners(msg, t, void 0);
                    }
                    /**
                     * This method is called to report a syntax error which requires the
                     * insertion of a missing token into the input stream. At the time this
                     * method is called, the missing token has not yet been inserted. When this
                     * method returns, `recognizer` is in error recovery mode.
                     *
                     * This method is called when {@link #singleTokenInsertion} identifies
                     * single-token insertion as a viable recovery strategy for a mismatched
                     * input error.
                     *
                     * The default implementation simply returns if the handler is already in
                     * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
                     * enter error recovery mode, followed by calling
                     * {@link Parser#notifyErrorListeners}.
                     *
                     * @param recognizer the parser instance
                     */
                    reportMissingToken(recognizer) {
                      if (this.inErrorRecoveryMode(recognizer)) {
                        return;
                      }
                      this.beginErrorCondition(recognizer);
                      let t = recognizer.currentToken;
                      let expecting = this.getExpectedTokens(recognizer);
                      let msg = "missing " + expecting.toStringVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
                      recognizer.notifyErrorListeners(msg, t, void 0);
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The default implementation attempts to recover from the mismatched input
                     * by using single token insertion and deletion as described below. If the
                     * recovery attempt fails, this method
                     * {@link InputMismatchException}.
                     *
                     * **EXTRA TOKEN** (single token deletion)
                     *
                     * `LA(1)` is not what we are looking for. If `LA(2)` has the
                     * right token, however, then assume `LA(1)` is some extra spurious
                     * token and delete it. Then consume and return the next token (which was
                     * the `LA(2)` token) as the successful result of the match operation.
                     *
                     * This recovery strategy is implemented by {@link #singleTokenDeletion}.
                     *
                     * **MISSING TOKEN** (single token insertion)
                     *
                     * If current token (at `LA(1)`) is consistent with what could come
                     * after the expected `LA(1)` token, then assume the token is missing
                     * and use the parser's {@link TokenFactory} to create it on the fly. The
                     * "insertion" is performed by returning the created token as the successful
                     * result of the match operation.
                     *
                     * This recovery strategy is implemented by {@link #singleTokenInsertion}.
                     *
                     * **EXAMPLE**
                     *
                     * For example, Input `i=(3;` is clearly missing the `')'`. When
                     * the parser returns from the nested call to `expr`, it will have
                     * call chain:
                     *
                     * ```
                     * stat  expr  atom
                     * ```
                     *
                     * and it will be trying to match the `')'` at this point in the
                     * derivation:
                     *
                     * ```
                     * => ID '=' '(' INT ')' ('+' atom)* ';'
                     *                    ^
                     * ```
                     *
                     * The attempt to match `')'` will fail when it sees `';'` and
                     * call {@link #recoverInline}. To recover, it sees that `LA(1)==';'`
                     * is in the set of tokens that can follow the `')'` token reference
                     * in rule `atom`. It can assume that you forgot the `')'`.
                     */
                    recoverInline(recognizer) {
                      let matchedSymbol = this.singleTokenDeletion(recognizer);
                      if (matchedSymbol) {
                        recognizer.consume();
                        return matchedSymbol;
                      }
                      if (this.singleTokenInsertion(recognizer)) {
                        return this.getMissingSymbol(recognizer);
                      }
                      if (this.nextTokensContext === void 0) {
                        throw new InputMismatchException_1.InputMismatchException(recognizer);
                      } else {
                        throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);
                      }
                    }
                    /**
                     * This method implements the single-token insertion inline error recovery
                     * strategy. It is called by {@link #recoverInline} if the single-token
                     * deletion strategy fails to recover from the mismatched input. If this
                     * method returns `true`, `recognizer` will be in error recovery
                     * mode.
                     *
                     * This method determines whether or not single-token insertion is viable by
                     * checking if the `LA(1)` input symbol could be successfully matched
                     * if it were instead the `LA(2)` symbol. If this method returns
                     * `true`, the caller is responsible for creating and inserting a
                     * token with the correct type to produce this behavior.
                     *
                     * @param recognizer the parser instance
                     * @returns `true` if single-token insertion is a viable recovery
                     * strategy for the current mismatched input, otherwise `false`
                     */
                    singleTokenInsertion(recognizer) {
                      let currentSymbolType = recognizer.inputStream.LA(1);
                      let currentState = recognizer.interpreter.atn.states[recognizer.state];
                      let next = currentState.transition(0).target;
                      let atn = recognizer.interpreter.atn;
                      let expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));
                      if (expectingAtLL2.contains(currentSymbolType)) {
                        this.reportMissingToken(recognizer);
                        return true;
                      }
                      return false;
                    }
                    /**
                     * This method implements the single-token deletion inline error recovery
                     * strategy. It is called by {@link #recoverInline} to attempt to recover
                     * from mismatched input. If this method returns `undefined`, the parser and error
                     * handler state will not have changed. If this method returns non-`undefined`,
                     * `recognizer` will *not* be in error recovery mode since the
                     * returned token was a successful match.
                     *
                     * If the single-token deletion is successful, this method calls
                     * {@link #reportUnwantedToken} to report the error, followed by
                     * {@link Parser#consume} to actually "delete" the extraneous token. Then,
                     * before returning {@link #reportMatch} is called to signal a successful
                     * match.
                     *
                     * @param recognizer the parser instance
                     * @returns the successfully matched {@link Token} instance if single-token
                     * deletion successfully recovers from the mismatched input, otherwise
                     * `undefined`
                     */
                    singleTokenDeletion(recognizer) {
                      let nextTokenType = recognizer.inputStream.LA(2);
                      let expecting = this.getExpectedTokens(recognizer);
                      if (expecting.contains(nextTokenType)) {
                        this.reportUnwantedToken(recognizer);
                        recognizer.consume();
                        let matchedSymbol = recognizer.currentToken;
                        this.reportMatch(recognizer);
                        return matchedSymbol;
                      }
                      return void 0;
                    }
                    /** Conjure up a missing token during error recovery.
                     *
                     *  The recognizer attempts to recover from single missing
                     *  symbols. But, actions might refer to that missing symbol.
                     *  For example, x=ID {f($x);}. The action clearly assumes
                     *  that there has been an identifier matched previously and that
                     *  $x points at that token. If that token is missing, but
                     *  the next token in the stream is what we want we assume that
                     *  this token is missing and we keep going. Because we
                     *  have to return some token to replace the missing token,
                     *  we have to conjure one up. This method gives the user control
                     *  over the tokens returned for missing tokens. Mostly,
                     *  you will want to create something special for identifier
                     *  tokens. For literals such as '{' and ',', the default
                     *  action in the parser or tree parser works. It simply creates
                     *  a CommonToken of the appropriate type. The text will be the token.
                     *  If you change what tokens must be created by the lexer,
                     *  override this method to create the appropriate tokens.
                     */
                    getMissingSymbol(recognizer) {
                      let currentSymbol = recognizer.currentToken;
                      let expecting = this.getExpectedTokens(recognizer);
                      let expectedTokenType = Token_1.Token.INVALID_TYPE;
                      if (!expecting.isNil) {
                        expectedTokenType = expecting.minElement;
                      }
                      let tokenText;
                      if (expectedTokenType === Token_1.Token.EOF) {
                        tokenText = "<missing EOF>";
                      } else {
                        tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
                      }
                      let current = currentSymbol;
                      let lookback = recognizer.inputStream.tryLT(-1);
                      if (current.type === Token_1.Token.EOF && lookback != null) {
                        current = lookback;
                      }
                      return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);
                    }
                    constructToken(tokenSource, expectedTokenType, tokenText, current) {
                      let factory = tokenSource.tokenFactory;
                      let x = current.tokenSource;
                      let stream = x ? x.inputStream : void 0;
                      return factory.create({ source: tokenSource, stream }, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);
                    }
                    getExpectedTokens(recognizer) {
                      return recognizer.getExpectedTokens();
                    }
                    /** How should a token be displayed in an error message? The default
                     *  is to display just the text, but during development you might
                     *  want to have a lot of information spit out.  Override in that case
                     *  to use t.toString() (which, for CommonToken, dumps everything about
                     *  the token). This is better than forcing you to override a method in
                     *  your token objects because you don't have to go modify your lexer
                     *  so that it creates a new Java type.
                     */
                    getTokenErrorDisplay(t) {
                      if (!t) {
                        return "<no token>";
                      }
                      let s = this.getSymbolText(t);
                      if (!s) {
                        if (this.getSymbolType(t) === Token_1.Token.EOF) {
                          s = "<EOF>";
                        } else {
                          s = `<${this.getSymbolType(t)}>`;
                        }
                      }
                      return this.escapeWSAndQuote(s);
                    }
                    getSymbolText(symbol) {
                      return symbol.text;
                    }
                    getSymbolType(symbol) {
                      return symbol.type;
                    }
                    escapeWSAndQuote(s) {
                      s = s.replace("\n", "\\n");
                      s = s.replace("\r", "\\r");
                      s = s.replace("	", "\\t");
                      return "'" + s + "'";
                    }
                    /*  Compute the error recovery set for the current rule.  During
                     *  rule invocation, the parser pushes the set of tokens that can
                     *  follow that rule reference on the stack; this amounts to
                     *  computing FIRST of what follows the rule reference in the
                     *  enclosing rule. See LinearApproximator.FIRST().
                     *  This local follow set only includes tokens
                     *  from within the rule; i.e., the FIRST computation done by
                     *  ANTLR stops at the end of a rule.
                     *
                     *  EXAMPLE
                     *
                     *  When you find a "no viable alt exception", the input is not
                     *  consistent with any of the alternatives for rule r.  The best
                     *  thing to do is to consume tokens until you see something that
                     *  can legally follow a call to r *or* any rule that called r.
                     *  You don't want the exact set of viable next tokens because the
                     *  input might just be missing a token--you might consume the
                     *  rest of the input looking for one of the missing tokens.
                     *
                     *  Consider grammar:
                     *
                     *  a : '[' b ']'
                     *    | '(' b ')'
                     *    ;
                     *  b : c '^' INT ;
                     *  c : ID
                     *    | INT
                     *    ;
                     *
                     *  At each rule invocation, the set of tokens that could follow
                     *  that rule is pushed on a stack.  Here are the various
                     *  context-sensitive follow sets:
                     *
                     *  FOLLOW(b1_in_a) = FIRST(']') = ']'
                     *  FOLLOW(b2_in_a) = FIRST(')') = ')'
                     *  FOLLOW(c_in_b) = FIRST('^') = '^'
                     *
                     *  Upon erroneous input "[]", the call chain is
                     *
                     *  a -> b -> c
                     *
                     *  and, hence, the follow context stack is:
                     *
                     *  depth     follow set       start of rule execution
                     *    0         <EOF>                    a (from main())
                     *    1          ']'                     b
                     *    2          '^'                     c
                     *
                     *  Notice that ')' is not included, because b would have to have
                     *  been called from a different context in rule a for ')' to be
                     *  included.
                     *
                     *  For error recovery, we cannot consider FOLLOW(c)
                     *  (context-sensitive or otherwise).  We need the combined set of
                     *  all context-sensitive FOLLOW sets--the set of all tokens that
                     *  could follow any reference in the call chain.  We need to
                     *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
                     *  we resync'd to that token, we'd consume until EOF.  We need to
                     *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
                     *  In this case, for input "[]", LA(1) is ']' and in the set, so we would
                     *  not consume anything. After printing an error, rule c would
                     *  return normally.  Rule b would not find the required '^' though.
                     *  At this point, it gets a mismatched token error and
                     *  exception (since LA(1) is not in the viable following token
                     *  set).  The rule exception handler tries to recover, but finds
                     *  the same recovery set and doesn't consume anything.  Rule b
                     *  exits normally returning to rule a.  Now it finds the ']' (and
                     *  with the successful match exits errorRecovery mode).
                     *
                     *  So, you can see that the parser walks up the call chain looking
                     *  for the token that was a member of the recovery set.
                     *
                     *  Errors are not generated in errorRecovery mode.
                     *
                     *  ANTLR's error recovery mechanism is based upon original ideas:
                     *
                     *  "Algorithms + Data Structures = Programs" by Niklaus Wirth
                     *
                     *  and
                     *
                     *  "A note on error recovery in recursive descent parsers":
                     *  http://portal.acm.org/citation.cfm?id=947902.947905
                     *
                     *  Later, Josef Grosch had some good ideas:
                     *
                     *  "Efficient and Comfortable Error Recovery in Recursive Descent
                     *  Parsers":
                     *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
                     *
                     *  Like Grosch I implement context-sensitive FOLLOW sets that are combined
                     *  at run-time upon error to avoid overhead during parsing.
                     */
                    getErrorRecoverySet(recognizer) {
                      let atn = recognizer.interpreter.atn;
                      let ctx = recognizer.context;
                      let recoverSet = new IntervalSet_1.IntervalSet();
                      while (ctx && ctx.invokingState >= 0) {
                        let invokingState = atn.states[ctx.invokingState];
                        let rt = invokingState.transition(0);
                        let follow = atn.nextTokens(rt.followState);
                        recoverSet.addAll(follow);
                        ctx = ctx._parent;
                      }
                      recoverSet.remove(Token_1.Token.EPSILON);
                      return recoverSet;
                    }
                    /** Consume tokens until one matches the given token set. */
                    consumeUntil(recognizer, set2) {
                      let ttype = recognizer.inputStream.LA(1);
                      while (ttype !== Token_1.Token.EOF && !set2.contains(ttype)) {
                        recognizer.consume();
                        ttype = recognizer.inputStream.LA(1);
                      }
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], DefaultErrorStrategy.prototype, "reset", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "beginErrorCondition", null);
                  __decorate([
                    Decorators_1.Override
                  ], DefaultErrorStrategy.prototype, "inErrorRecoveryMode", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "endErrorCondition", null);
                  __decorate([
                    Decorators_1.Override
                  ], DefaultErrorStrategy.prototype, "reportMatch", null);
                  __decorate([
                    Decorators_1.Override
                  ], DefaultErrorStrategy.prototype, "reportError", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "notifyErrorListeners", null);
                  __decorate([
                    Decorators_1.Override
                  ], DefaultErrorStrategy.prototype, "recover", null);
                  __decorate([
                    Decorators_1.Override
                  ], DefaultErrorStrategy.prototype, "sync", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "reportNoViableAlternative", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "reportInputMismatch", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "reportFailedPredicate", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "reportUnwantedToken", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "reportMissingToken", null);
                  __decorate([
                    Decorators_1.Override
                  ], DefaultErrorStrategy.prototype, "recoverInline", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "singleTokenInsertion", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "singleTokenDeletion", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "getMissingSymbol", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "getExpectedTokens", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "getSymbolText", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "getSymbolType", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "escapeWSAndQuote", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "getErrorRecoverySet", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], DefaultErrorStrategy.prototype, "consumeUntil", null);
                  exports2.DefaultErrorStrategy = DefaultErrorStrategy;
                }
              ),
              /***/
              "./node_modules/antlr4ts/Dependents.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/antlr4ts/Dependents.js ***!
                  \*********************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Dependents = void 0;
                  var Dependents;
                  (function(Dependents2) {
                    Dependents2[Dependents2["SELF"] = 0] = "SELF";
                    Dependents2[Dependents2["PARENTS"] = 1] = "PARENTS";
                    Dependents2[Dependents2["CHILDREN"] = 2] = "CHILDREN";
                    Dependents2[Dependents2["ANCESTORS"] = 3] = "ANCESTORS";
                    Dependents2[Dependents2["DESCENDANTS"] = 4] = "DESCENDANTS";
                    Dependents2[Dependents2["SIBLINGS"] = 5] = "SIBLINGS";
                    Dependents2[Dependents2["PRECEEDING_SIBLINGS"] = 6] = "PRECEEDING_SIBLINGS";
                    Dependents2[Dependents2["FOLLOWING_SIBLINGS"] = 7] = "FOLLOWING_SIBLINGS";
                    Dependents2[Dependents2["PRECEEDING"] = 8] = "PRECEEDING";
                    Dependents2[Dependents2["FOLLOWING"] = 9] = "FOLLOWING";
                  })(Dependents = exports2.Dependents || (exports2.Dependents = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/DiagnosticErrorListener.js": (
                /*!**********************************************************!*\
                  !*** ./node_modules/antlr4ts/DiagnosticErrorListener.js ***!
                  \**********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.DiagnosticErrorListener = void 0;
                  const BitSet_1 = __webpack_require__2(
                    /*! ./misc/BitSet */
                    "./node_modules/antlr4ts/misc/BitSet.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Interval_1 = __webpack_require__2(
                    /*! ./misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  class DiagnosticErrorListener {
                    /**
                     * Initializes a new instance of {@link DiagnosticErrorListener}, specifying
                     * whether all ambiguities or only exact ambiguities are reported.
                     *
                     * @param exactOnly `true` to report only exact ambiguities, otherwise
                     * `false` to report all ambiguities.  Defaults to true.
                     */
                    constructor(exactOnly = true) {
                      this.exactOnly = exactOnly;
                      this.exactOnly = exactOnly;
                    }
                    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
                    }
                    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
                      if (this.exactOnly && !exact) {
                        return;
                      }
                      let decision = this.getDecisionDescription(recognizer, dfa);
                      let conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
                      let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
                      let message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;
                      recognizer.notifyErrorListeners(message);
                    }
                    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
                      let format = "reportAttemptingFullContext d=%s, input='%s'";
                      let decision = this.getDecisionDescription(recognizer, dfa);
                      let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
                      let message = `reportAttemptingFullContext d=${decision}, input='${text}'`;
                      recognizer.notifyErrorListeners(message);
                    }
                    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
                      let format = "reportContextSensitivity d=%s, input='%s'";
                      let decision = this.getDecisionDescription(recognizer, dfa);
                      let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
                      let message = `reportContextSensitivity d=${decision}, input='${text}'`;
                      recognizer.notifyErrorListeners(message);
                    }
                    getDecisionDescription(recognizer, dfa) {
                      let decision = dfa.decision;
                      let ruleIndex = dfa.atnStartState.ruleIndex;
                      let ruleNames = recognizer.ruleNames;
                      if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
                        return decision.toString();
                      }
                      let ruleName = ruleNames[ruleIndex];
                      if (!ruleName) {
                        return decision.toString();
                      }
                      return `${decision} (${ruleName})`;
                    }
                    /**
                     * Computes the set of conflicting or ambiguous alternatives from a
                     * configuration set, if that information was not already provided by the
                     * parser.
                     *
                     * @param reportedAlts The set of conflicting or ambiguous alternatives, as
                     * reported by the parser.
                     * @param configs The conflicting or ambiguous configuration set.
                     * @returns Returns `reportedAlts` if it is not `undefined`, otherwise
                     * returns the set of alternatives represented in `configs`.
                     */
                    getConflictingAlts(reportedAlts, configs) {
                      if (reportedAlts != null) {
                        return reportedAlts;
                      }
                      let result = new BitSet_1.BitSet();
                      for (let config of configs) {
                        result.set(config.alt);
                      }
                      return result;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], DiagnosticErrorListener.prototype, "syntaxError", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(6, Decorators_1.NotNull)
                  ], DiagnosticErrorListener.prototype, "reportAmbiguity", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(5, Decorators_1.NotNull)
                  ], DiagnosticErrorListener.prototype, "reportAttemptingFullContext", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(5, Decorators_1.NotNull)
                  ], DiagnosticErrorListener.prototype, "reportContextSensitivity", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], DiagnosticErrorListener.prototype, "getDecisionDescription", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(1, Decorators_1.NotNull)
                  ], DiagnosticErrorListener.prototype, "getConflictingAlts", null);
                  exports2.DiagnosticErrorListener = DiagnosticErrorListener;
                }
              ),
              /***/
              "./node_modules/antlr4ts/FailedPredicateException.js": (
                /*!***********************************************************!*\
                  !*** ./node_modules/antlr4ts/FailedPredicateException.js ***!
                  \***********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.FailedPredicateException = void 0;
                  const RecognitionException_1 = __webpack_require__2(
                    /*! ./RecognitionException */
                    "./node_modules/antlr4ts/RecognitionException.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const PredicateTransition_1 = __webpack_require__2(
                    /*! ./atn/PredicateTransition */
                    "./node_modules/antlr4ts/atn/PredicateTransition.js"
                  );
                  let FailedPredicateException = class FailedPredicateException2 extends RecognitionException_1.RecognitionException {
                    constructor(recognizer, predicate, message) {
                      super(recognizer, recognizer.inputStream, recognizer.context, FailedPredicateException2.formatMessage(predicate, message));
                      let s = recognizer.interpreter.atn.states[recognizer.state];
                      let trans = s.transition(0);
                      if (trans instanceof PredicateTransition_1.PredicateTransition) {
                        this._ruleIndex = trans.ruleIndex;
                        this._predicateIndex = trans.predIndex;
                      } else {
                        this._ruleIndex = 0;
                        this._predicateIndex = 0;
                      }
                      this._predicate = predicate;
                      super.setOffendingToken(recognizer, recognizer.currentToken);
                    }
                    get ruleIndex() {
                      return this._ruleIndex;
                    }
                    get predicateIndex() {
                      return this._predicateIndex;
                    }
                    get predicate() {
                      return this._predicate;
                    }
                    static formatMessage(predicate, message) {
                      if (message) {
                        return message;
                      }
                      return `failed predicate: {${predicate}}?`;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], FailedPredicateException, "formatMessage", null);
                  FailedPredicateException = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], FailedPredicateException);
                  exports2.FailedPredicateException = FailedPredicateException;
                }
              ),
              /***/
              "./node_modules/antlr4ts/InputMismatchException.js": (
                /*!*********************************************************!*\
                  !*** ./node_modules/antlr4ts/InputMismatchException.js ***!
                  \*********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.InputMismatchException = void 0;
                  const RecognitionException_1 = __webpack_require__2(
                    /*! ./RecognitionException */
                    "./node_modules/antlr4ts/RecognitionException.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let InputMismatchException = class InputMismatchException extends RecognitionException_1.RecognitionException {
                    constructor(recognizer, state, context) {
                      if (context === void 0) {
                        context = recognizer.context;
                      }
                      super(recognizer, recognizer.inputStream, context);
                      if (state !== void 0) {
                        this.setOffendingState(state);
                      }
                      this.setOffendingToken(recognizer, recognizer.currentToken);
                    }
                  };
                  InputMismatchException = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], InputMismatchException);
                  exports2.InputMismatchException = InputMismatchException;
                }
              ),
              /***/
              "./node_modules/antlr4ts/IntStream.js": (
                /*!********************************************!*\
                  !*** ./node_modules/antlr4ts/IntStream.js ***!
                  \********************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.IntStream = void 0;
                  var IntStream;
                  (function(IntStream2) {
                    IntStream2.EOF = -1;
                    IntStream2.UNKNOWN_SOURCE_NAME = "<unknown>";
                  })(IntStream = exports2.IntStream || (exports2.IntStream = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/InterpreterRuleContext.js": (
                /*!*********************************************************!*\
                  !*** ./node_modules/antlr4ts/InterpreterRuleContext.js ***!
                  \*********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.InterpreterRuleContext = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ParserRuleContext_1 = __webpack_require__2(
                    /*! ./ParserRuleContext */
                    "./node_modules/antlr4ts/ParserRuleContext.js"
                  );
                  class InterpreterRuleContext extends ParserRuleContext_1.ParserRuleContext {
                    constructor(ruleIndex, parent, invokingStateNumber) {
                      if (invokingStateNumber !== void 0) {
                        super(parent, invokingStateNumber);
                      } else {
                        super();
                      }
                      this._ruleIndex = ruleIndex;
                    }
                    get ruleIndex() {
                      return this._ruleIndex;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], InterpreterRuleContext.prototype, "ruleIndex", null);
                  exports2.InterpreterRuleContext = InterpreterRuleContext;
                }
              ),
              /***/
              "./node_modules/antlr4ts/Lexer.js": (
                /*!****************************************!*\
                  !*** ./node_modules/antlr4ts/Lexer.js ***!
                  \****************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Lexer = void 0;
                  const CommonTokenFactory_1 = __webpack_require__2(
                    /*! ./CommonTokenFactory */
                    "./node_modules/antlr4ts/CommonTokenFactory.js"
                  );
                  const IntegerStack_1 = __webpack_require__2(
                    /*! ./misc/IntegerStack */
                    "./node_modules/antlr4ts/misc/IntegerStack.js"
                  );
                  const Interval_1 = __webpack_require__2(
                    /*! ./misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const IntStream_1 = __webpack_require__2(
                    /*! ./IntStream */
                    "./node_modules/antlr4ts/IntStream.js"
                  );
                  const LexerATNSimulator_1 = __webpack_require__2(
                    /*! ./atn/LexerATNSimulator */
                    "./node_modules/antlr4ts/atn/LexerATNSimulator.js"
                  );
                  const LexerNoViableAltException_1 = __webpack_require__2(
                    /*! ./LexerNoViableAltException */
                    "./node_modules/antlr4ts/LexerNoViableAltException.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Recognizer_1 = __webpack_require__2(
                    /*! ./Recognizer */
                    "./node_modules/antlr4ts/Recognizer.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  class Lexer extends Recognizer_1.Recognizer {
                    constructor(input) {
                      super();
                      this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
                      this._tokenStartCharIndex = -1;
                      this._tokenStartLine = 0;
                      this._tokenStartCharPositionInLine = 0;
                      this._hitEOF = false;
                      this._channel = 0;
                      this._type = 0;
                      this._modeStack = new IntegerStack_1.IntegerStack();
                      this._mode = Lexer.DEFAULT_MODE;
                      this._input = input;
                      this._tokenFactorySourcePair = { source: this, stream: input };
                    }
                    static get DEFAULT_TOKEN_CHANNEL() {
                      return Token_1.Token.DEFAULT_CHANNEL;
                    }
                    static get HIDDEN() {
                      return Token_1.Token.HIDDEN_CHANNEL;
                    }
                    reset(resetInput) {
                      if (resetInput === void 0 || resetInput) {
                        this._input.seek(0);
                      }
                      this._token = void 0;
                      this._type = Token_1.Token.INVALID_TYPE;
                      this._channel = Token_1.Token.DEFAULT_CHANNEL;
                      this._tokenStartCharIndex = -1;
                      this._tokenStartCharPositionInLine = -1;
                      this._tokenStartLine = -1;
                      this._text = void 0;
                      this._hitEOF = false;
                      this._mode = Lexer.DEFAULT_MODE;
                      this._modeStack.clear();
                      this.interpreter.reset();
                    }
                    /** Return a token from this source; i.e., match a token on the char
                     *  stream.
                     */
                    nextToken() {
                      if (this._input == null) {
                        throw new Error("nextToken requires a non-null input stream.");
                      }
                      let tokenStartMarker = this._input.mark();
                      try {
                        outer: while (true) {
                          if (this._hitEOF) {
                            return this.emitEOF();
                          }
                          this._token = void 0;
                          this._channel = Token_1.Token.DEFAULT_CHANNEL;
                          this._tokenStartCharIndex = this._input.index;
                          this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;
                          this._tokenStartLine = this.interpreter.line;
                          this._text = void 0;
                          do {
                            this._type = Token_1.Token.INVALID_TYPE;
                            let ttype;
                            try {
                              ttype = this.interpreter.match(this._input, this._mode);
                            } catch (e) {
                              if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
                                this.notifyListeners(e);
                                this.recover(e);
                                ttype = Lexer.SKIP;
                              } else {
                                throw e;
                              }
                            }
                            if (this._input.LA(1) === IntStream_1.IntStream.EOF) {
                              this._hitEOF = true;
                            }
                            if (this._type === Token_1.Token.INVALID_TYPE) {
                              this._type = ttype;
                            }
                            if (this._type === Lexer.SKIP) {
                              continue outer;
                            }
                          } while (this._type === Lexer.MORE);
                          if (this._token == null) {
                            return this.emit();
                          }
                          return this._token;
                        }
                      } finally {
                        this._input.release(tokenStartMarker);
                      }
                    }
                    /** Instruct the lexer to skip creating a token for current lexer rule
                     *  and look for another token.  nextToken() knows to keep looking when
                     *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
                     *  if token==undefined at end of any token rule, it creates one for you
                     *  and emits it.
                     */
                    skip() {
                      this._type = Lexer.SKIP;
                    }
                    more() {
                      this._type = Lexer.MORE;
                    }
                    mode(m) {
                      this._mode = m;
                    }
                    pushMode(m) {
                      if (LexerATNSimulator_1.LexerATNSimulator.debug) {
                        console.log("pushMode " + m);
                      }
                      this._modeStack.push(this._mode);
                      this.mode(m);
                    }
                    popMode() {
                      if (this._modeStack.isEmpty) {
                        throw new Error("EmptyStackException");
                      }
                      if (LexerATNSimulator_1.LexerATNSimulator.debug) {
                        console.log("popMode back to " + this._modeStack.peek());
                      }
                      this.mode(this._modeStack.pop());
                      return this._mode;
                    }
                    get tokenFactory() {
                      return this._factory;
                    }
                    // @Override
                    set tokenFactory(factory) {
                      this._factory = factory;
                    }
                    get inputStream() {
                      return this._input;
                    }
                    /** Set the char stream and reset the lexer */
                    set inputStream(input) {
                      this.reset(false);
                      this._input = input;
                      this._tokenFactorySourcePair = { source: this, stream: this._input };
                    }
                    get sourceName() {
                      return this._input.sourceName;
                    }
                    emit(token) {
                      if (!token) {
                        token = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine);
                      }
                      this._token = token;
                      return token;
                    }
                    emitEOF() {
                      let cpos = this.charPositionInLine;
                      let line = this.line;
                      let eof = this._factory.create(this._tokenFactorySourcePair, Token_1.Token.EOF, void 0, Token_1.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, line, cpos);
                      this.emit(eof);
                      return eof;
                    }
                    get line() {
                      return this.interpreter.line;
                    }
                    set line(line) {
                      this.interpreter.line = line;
                    }
                    get charPositionInLine() {
                      return this.interpreter.charPositionInLine;
                    }
                    set charPositionInLine(charPositionInLine) {
                      this.interpreter.charPositionInLine = charPositionInLine;
                    }
                    /** What is the index of the current character of lookahead? */
                    get charIndex() {
                      return this._input.index;
                    }
                    /** Return the text matched so far for the current token or any
                     *  text override.
                     */
                    get text() {
                      if (this._text != null) {
                        return this._text;
                      }
                      return this.interpreter.getText(this._input);
                    }
                    /** Set the complete text of this token; it wipes any previous
                     *  changes to the text.
                     */
                    set text(text) {
                      this._text = text;
                    }
                    /** Override if emitting multiple tokens. */
                    get token() {
                      return this._token;
                    }
                    set token(_token) {
                      this._token = _token;
                    }
                    set type(ttype) {
                      this._type = ttype;
                    }
                    get type() {
                      return this._type;
                    }
                    set channel(channel) {
                      this._channel = channel;
                    }
                    get channel() {
                      return this._channel;
                    }
                    /** Return a list of all Token objects in input char stream.
                     *  Forces load of all tokens. Does not include EOF token.
                     */
                    getAllTokens() {
                      let tokens = [];
                      let t = this.nextToken();
                      while (t.type !== Token_1.Token.EOF) {
                        tokens.push(t);
                        t = this.nextToken();
                      }
                      return tokens;
                    }
                    notifyListeners(e) {
                      let text = this._input.getText(Interval_1.Interval.of(this._tokenStartCharIndex, this._input.index));
                      let msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
                      let listener = this.getErrorListenerDispatch();
                      if (listener.syntaxError) {
                        listener.syntaxError(this, void 0, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);
                      }
                    }
                    getErrorDisplay(s) {
                      if (typeof s === "number") {
                        switch (s) {
                          case Token_1.Token.EOF:
                            return "<EOF>";
                          case 10:
                            return "\\n";
                          case 9:
                            return "\\t";
                          case 13:
                            return "\\r";
                        }
                        return String.fromCharCode(s);
                      }
                      return s.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
                    }
                    getCharErrorDisplay(c) {
                      let s = this.getErrorDisplay(c);
                      return "'" + s + "'";
                    }
                    recover(re) {
                      if (re instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
                        if (this._input.LA(1) !== IntStream_1.IntStream.EOF) {
                          this.interpreter.consume(this._input);
                        }
                      } else {
                        this._input.consume();
                      }
                    }
                  }
                  Lexer.DEFAULT_MODE = 0;
                  Lexer.MORE = -2;
                  Lexer.SKIP = -3;
                  Lexer.MIN_CHAR_VALUE = 0;
                  Lexer.MAX_CHAR_VALUE = 1114111;
                  __decorate([
                    Decorators_1.Override
                  ], Lexer.prototype, "nextToken", null);
                  __decorate([
                    Decorators_1.Override
                  ], Lexer.prototype, "tokenFactory", null);
                  __decorate([
                    Decorators_1.Override
                  ], Lexer.prototype, "inputStream", null);
                  __decorate([
                    Decorators_1.Override
                  ], Lexer.prototype, "sourceName", null);
                  __decorate([
                    Decorators_1.Override
                  ], Lexer.prototype, "line", null);
                  __decorate([
                    Decorators_1.Override
                  ], Lexer.prototype, "charPositionInLine", null);
                  exports2.Lexer = Lexer;
                }
              ),
              /***/
              "./node_modules/antlr4ts/LexerInterpreter.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/LexerInterpreter.js ***!
                  \***************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerInterpreter = void 0;
                  const Lexer_1 = __webpack_require__2(
                    /*! ./Lexer */
                    "./node_modules/antlr4ts/Lexer.js"
                  );
                  const LexerATNSimulator_1 = __webpack_require__2(
                    /*! ./atn/LexerATNSimulator */
                    "./node_modules/antlr4ts/atn/LexerATNSimulator.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Decorators_2 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let LexerInterpreter = class LexerInterpreter extends Lexer_1.Lexer {
                    constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
                      super(input);
                      if (atn.grammarType !== 0) {
                        throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
                      }
                      this._grammarFileName = grammarFileName;
                      this._atn = atn;
                      this._ruleNames = ruleNames.slice(0);
                      this._channelNames = channelNames.slice(0);
                      this._modeNames = modeNames.slice(0);
                      this._vocabulary = vocabulary;
                      this._interp = new LexerATNSimulator_1.LexerATNSimulator(atn, this);
                    }
                    get atn() {
                      return this._atn;
                    }
                    get grammarFileName() {
                      return this._grammarFileName;
                    }
                    get ruleNames() {
                      return this._ruleNames;
                    }
                    get channelNames() {
                      return this._channelNames;
                    }
                    get modeNames() {
                      return this._modeNames;
                    }
                    get vocabulary() {
                      return this._vocabulary;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], LexerInterpreter.prototype, "_vocabulary", void 0);
                  __decorate([
                    Decorators_2.Override
                  ], LexerInterpreter.prototype, "atn", null);
                  __decorate([
                    Decorators_2.Override
                  ], LexerInterpreter.prototype, "grammarFileName", null);
                  __decorate([
                    Decorators_2.Override
                  ], LexerInterpreter.prototype, "ruleNames", null);
                  __decorate([
                    Decorators_2.Override
                  ], LexerInterpreter.prototype, "channelNames", null);
                  __decorate([
                    Decorators_2.Override
                  ], LexerInterpreter.prototype, "modeNames", null);
                  __decorate([
                    Decorators_2.Override
                  ], LexerInterpreter.prototype, "vocabulary", null);
                  LexerInterpreter = __decorate([
                    __param(1, Decorators_1.NotNull)
                  ], LexerInterpreter);
                  exports2.LexerInterpreter = LexerInterpreter;
                }
              ),
              /***/
              "./node_modules/antlr4ts/LexerNoViableAltException.js": (
                /*!************************************************************!*\
                  !*** ./node_modules/antlr4ts/LexerNoViableAltException.js ***!
                  \************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerNoViableAltException = void 0;
                  const RecognitionException_1 = __webpack_require__2(
                    /*! ./RecognitionException */
                    "./node_modules/antlr4ts/RecognitionException.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Interval_1 = __webpack_require__2(
                    /*! ./misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const Utils = __webpack_require__2(
                    /*! ./misc/Utils */
                    "./node_modules/antlr4ts/misc/Utils.js"
                  );
                  let LexerNoViableAltException = class LexerNoViableAltException extends RecognitionException_1.RecognitionException {
                    constructor(lexer, input, startIndex, deadEndConfigs) {
                      super(lexer, input);
                      this._startIndex = startIndex;
                      this._deadEndConfigs = deadEndConfigs;
                    }
                    get startIndex() {
                      return this._startIndex;
                    }
                    get deadEndConfigs() {
                      return this._deadEndConfigs;
                    }
                    get inputStream() {
                      return super.inputStream;
                    }
                    toString() {
                      let symbol = "";
                      if (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {
                        symbol = this.inputStream.getText(Interval_1.Interval.of(this._startIndex, this._startIndex));
                        symbol = Utils.escapeWhitespace(symbol, false);
                      }
                      return `LexerNoViableAltException('${symbol}')`;
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], LexerNoViableAltException.prototype, "inputStream", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerNoViableAltException.prototype, "toString", null);
                  LexerNoViableAltException = __decorate([
                    __param(1, Decorators_1.NotNull)
                  ], LexerNoViableAltException);
                  exports2.LexerNoViableAltException = LexerNoViableAltException;
                }
              ),
              /***/
              "./node_modules/antlr4ts/ListTokenSource.js": (
                /*!**************************************************!*\
                  !*** ./node_modules/antlr4ts/ListTokenSource.js ***!
                  \**************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ListTokenSource = void 0;
                  const CommonTokenFactory_1 = __webpack_require__2(
                    /*! ./CommonTokenFactory */
                    "./node_modules/antlr4ts/CommonTokenFactory.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  let ListTokenSource = class ListTokenSource {
                    /**
                     * Constructs a new {@link ListTokenSource} instance from the specified
                     * collection of {@link Token} objects and source name.
                     *
                     * @param tokens The collection of {@link Token} objects to provide as a
                     * {@link TokenSource}.
                     * @param sourceName The name of the {@link TokenSource}. If this value is
                     * `undefined`, {@link #getSourceName} will attempt to infer the name from
                     * the next {@link Token} (or the previous token if the end of the input has
                     * been reached).
                     *
                     * @exception NullPointerException if `tokens` is `undefined`
                     */
                    constructor(tokens, sourceName) {
                      this.i = 0;
                      this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
                      if (tokens == null) {
                        throw new Error("tokens cannot be null");
                      }
                      this.tokens = tokens;
                      this._sourceName = sourceName;
                    }
                    /**
                     * {@inheritDoc}
                     */
                    get charPositionInLine() {
                      if (this.i < this.tokens.length) {
                        return this.tokens[this.i].charPositionInLine;
                      } else if (this.eofToken != null) {
                        return this.eofToken.charPositionInLine;
                      } else if (this.tokens.length > 0) {
                        let lastToken = this.tokens[this.tokens.length - 1];
                        let tokenText = lastToken.text;
                        if (tokenText != null) {
                          let lastNewLine = tokenText.lastIndexOf("\n");
                          if (lastNewLine >= 0) {
                            return tokenText.length - lastNewLine - 1;
                          }
                        }
                        return lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;
                      }
                      return 0;
                    }
                    /**
                     * {@inheritDoc}
                     */
                    nextToken() {
                      if (this.i >= this.tokens.length) {
                        if (this.eofToken == null) {
                          let start = -1;
                          if (this.tokens.length > 0) {
                            let previousStop = this.tokens[this.tokens.length - 1].stopIndex;
                            if (previousStop !== -1) {
                              start = previousStop + 1;
                            }
                          }
                          let stop = Math.max(-1, start - 1);
                          this.eofToken = this._factory.create({ source: this, stream: this.inputStream }, Token_1.Token.EOF, "EOF", Token_1.Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);
                        }
                        return this.eofToken;
                      }
                      let t = this.tokens[this.i];
                      if (this.i === this.tokens.length - 1 && t.type === Token_1.Token.EOF) {
                        this.eofToken = t;
                      }
                      this.i++;
                      return t;
                    }
                    /**
                     * {@inheritDoc}
                     */
                    get line() {
                      if (this.i < this.tokens.length) {
                        return this.tokens[this.i].line;
                      } else if (this.eofToken != null) {
                        return this.eofToken.line;
                      } else if (this.tokens.length > 0) {
                        let lastToken = this.tokens[this.tokens.length - 1];
                        let line = lastToken.line;
                        let tokenText = lastToken.text;
                        if (tokenText != null) {
                          for (let i = 0; i < tokenText.length; i++) {
                            if (tokenText.charAt(i) === "\n") {
                              line++;
                            }
                          }
                        }
                        return line;
                      }
                      return 1;
                    }
                    /**
                     * {@inheritDoc}
                     */
                    get inputStream() {
                      if (this.i < this.tokens.length) {
                        return this.tokens[this.i].inputStream;
                      } else if (this.eofToken != null) {
                        return this.eofToken.inputStream;
                      } else if (this.tokens.length > 0) {
                        return this.tokens[this.tokens.length - 1].inputStream;
                      }
                      return void 0;
                    }
                    /**
                     * {@inheritDoc}
                     */
                    get sourceName() {
                      if (this._sourceName) {
                        return this._sourceName;
                      }
                      let inputStream = this.inputStream;
                      if (inputStream != null) {
                        return inputStream.sourceName;
                      }
                      return "List";
                    }
                    /**
                     * {@inheritDoc}
                     */
                    // @Override
                    set tokenFactory(factory) {
                      this._factory = factory;
                    }
                    /**
                     * {@inheritDoc}
                     */
                    get tokenFactory() {
                      return this._factory;
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], ListTokenSource.prototype, "charPositionInLine", null);
                  __decorate([
                    Decorators_1.Override
                  ], ListTokenSource.prototype, "nextToken", null);
                  __decorate([
                    Decorators_1.Override
                  ], ListTokenSource.prototype, "line", null);
                  __decorate([
                    Decorators_1.Override
                  ], ListTokenSource.prototype, "inputStream", null);
                  __decorate([
                    Decorators_1.Override
                  ], ListTokenSource.prototype, "sourceName", null);
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], ListTokenSource.prototype, "tokenFactory", null);
                  ListTokenSource = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ListTokenSource);
                  exports2.ListTokenSource = ListTokenSource;
                }
              ),
              /***/
              "./node_modules/antlr4ts/NoViableAltException.js": (
                /*!*******************************************************!*\
                  !*** ./node_modules/antlr4ts/NoViableAltException.js ***!
                  \*******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.NoViableAltException = void 0;
                  const Parser_1 = __webpack_require__2(
                    /*! ./Parser */
                    "./node_modules/antlr4ts/Parser.js"
                  );
                  const RecognitionException_1 = __webpack_require__2(
                    /*! ./RecognitionException */
                    "./node_modules/antlr4ts/RecognitionException.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class NoViableAltException extends RecognitionException_1.RecognitionException {
                    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
                      if (recognizer instanceof Parser_1.Parser) {
                        if (input === void 0) {
                          input = recognizer.inputStream;
                        }
                        if (startToken === void 0) {
                          startToken = recognizer.currentToken;
                        }
                        if (offendingToken === void 0) {
                          offendingToken = recognizer.currentToken;
                        }
                        if (ctx === void 0) {
                          ctx = recognizer.context;
                        }
                      }
                      super(recognizer, input, ctx);
                      this._deadEndConfigs = deadEndConfigs;
                      this._startToken = startToken;
                      this.setOffendingToken(recognizer, offendingToken);
                    }
                    get startToken() {
                      return this._startToken;
                    }
                    get deadEndConfigs() {
                      return this._deadEndConfigs;
                    }
                  }
                  __decorate([
                    Decorators_1.NotNull
                  ], NoViableAltException.prototype, "_startToken", void 0);
                  exports2.NoViableAltException = NoViableAltException;
                }
              ),
              /***/
              "./node_modules/antlr4ts/Parser.js": (
                /*!*****************************************!*\
                  !*** ./node_modules/antlr4ts/Parser.js ***!
                  \*****************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var process2 = __webpack_require__2(
                    /*! process/browser */
                    "./node_modules/process/browser.js"
                  );
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
                    function adopt(value) {
                      return value instanceof P ? value : new P(function(resolve) {
                        resolve(value);
                      });
                    }
                    return new (P || (P = Promise))(function(resolve, reject) {
                      function fulfilled(value) {
                        try {
                          step(generator.next(value));
                        } catch (e) {
                          reject(e);
                        }
                      }
                      function rejected(value) {
                        try {
                          step(generator["throw"](value));
                        } catch (e) {
                          reject(e);
                        }
                      }
                      function step(result) {
                        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                      }
                      step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Parser = void 0;
                  const Utils = __webpack_require__2(
                    /*! ./misc/Utils */
                    "./node_modules/antlr4ts/misc/Utils.js"
                  );
                  const ATNDeserializationOptions_1 = __webpack_require__2(
                    /*! ./atn/ATNDeserializationOptions */
                    "./node_modules/antlr4ts/atn/ATNDeserializationOptions.js"
                  );
                  const ATNDeserializer_1 = __webpack_require__2(
                    /*! ./atn/ATNDeserializer */
                    "./node_modules/antlr4ts/atn/ATNDeserializer.js"
                  );
                  const DefaultErrorStrategy_1 = __webpack_require__2(
                    /*! ./DefaultErrorStrategy */
                    "./node_modules/antlr4ts/DefaultErrorStrategy.js"
                  );
                  const ErrorNode_1 = __webpack_require__2(
                    /*! ./tree/ErrorNode */
                    "./node_modules/antlr4ts/tree/ErrorNode.js"
                  );
                  const IntegerStack_1 = __webpack_require__2(
                    /*! ./misc/IntegerStack */
                    "./node_modules/antlr4ts/misc/IntegerStack.js"
                  );
                  const Lexer_1 = __webpack_require__2(
                    /*! ./Lexer */
                    "./node_modules/antlr4ts/Lexer.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ParseInfo_1 = __webpack_require__2(
                    /*! ./atn/ParseInfo */
                    "./node_modules/antlr4ts/atn/ParseInfo.js"
                  );
                  const ParserATNSimulator_1 = __webpack_require__2(
                    /*! ./atn/ParserATNSimulator */
                    "./node_modules/antlr4ts/atn/ParserATNSimulator.js"
                  );
                  const ProxyParserErrorListener_1 = __webpack_require__2(
                    /*! ./ProxyParserErrorListener */
                    "./node_modules/antlr4ts/ProxyParserErrorListener.js"
                  );
                  const Recognizer_1 = __webpack_require__2(
                    /*! ./Recognizer */
                    "./node_modules/antlr4ts/Recognizer.js"
                  );
                  const TerminalNode_1 = __webpack_require__2(
                    /*! ./tree/TerminalNode */
                    "./node_modules/antlr4ts/tree/TerminalNode.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  class TraceListener {
                    constructor(ruleNames, tokenStream) {
                      this.ruleNames = ruleNames;
                      this.tokenStream = tokenStream;
                    }
                    enterEveryRule(ctx) {
                      console.log("enter   " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
                    }
                    exitEveryRule(ctx) {
                      console.log("exit    " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
                    }
                    visitErrorNode(node) {
                    }
                    visitTerminal(node) {
                      let parent = node.parent.ruleContext;
                      let token = node.symbol;
                      console.log("consume " + token + " rule " + this.ruleNames[parent.ruleIndex]);
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], TraceListener.prototype, "enterEveryRule", null);
                  __decorate([
                    Decorators_1.Override
                  ], TraceListener.prototype, "exitEveryRule", null);
                  __decorate([
                    Decorators_1.Override
                  ], TraceListener.prototype, "visitErrorNode", null);
                  __decorate([
                    Decorators_1.Override
                  ], TraceListener.prototype, "visitTerminal", null);
                  class Parser extends Recognizer_1.Recognizer {
                    constructor(input) {
                      super();
                      this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();
                      this._precedenceStack = new IntegerStack_1.IntegerStack();
                      this._buildParseTrees = true;
                      this._parseListeners = [];
                      this._syntaxErrors = 0;
                      this.matchedEOF = false;
                      this._precedenceStack.push(0);
                      this.inputStream = input;
                    }
                    reset(resetInput) {
                      if (resetInput === void 0 || resetInput) {
                        this.inputStream.seek(0);
                      }
                      this._errHandler.reset(this);
                      this._ctx = void 0;
                      this._syntaxErrors = 0;
                      this.matchedEOF = false;
                      this.isTrace = false;
                      this._precedenceStack.clear();
                      this._precedenceStack.push(0);
                      let interpreter = this.interpreter;
                      if (interpreter != null) {
                        interpreter.reset();
                      }
                    }
                    /**
                     * Match current input symbol against `ttype`. If the symbol type
                     * matches, {@link ANTLRErrorStrategy#reportMatch} and {@link #consume} are
                     * called to complete the match process.
                     *
                     * If the symbol type does not match,
                     * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
                     * strategy to attempt recovery. If {@link #getBuildParseTree} is
                     * `true` and the token index of the symbol returned by
                     * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
                     * the parse tree by calling {@link #createErrorNode(ParserRuleContext, Token)} then
                     * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
                     *
                     * @param ttype the token type to match
                     * @returns the matched symbol
                     * @ if the current input symbol did not match
                     * `ttype` and the error strategy could not recover from the
                     * mismatched symbol
                     */
                    match(ttype) {
                      let t = this.currentToken;
                      if (t.type === ttype) {
                        if (ttype === Token_1.Token.EOF) {
                          this.matchedEOF = true;
                        }
                        this._errHandler.reportMatch(this);
                        this.consume();
                      } else {
                        t = this._errHandler.recoverInline(this);
                        if (this._buildParseTrees && t.tokenIndex === -1) {
                          this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
                        }
                      }
                      return t;
                    }
                    /**
                     * Match current input symbol as a wildcard. If the symbol type matches
                     * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy#reportMatch}
                     * and {@link #consume} are called to complete the match process.
                     *
                     * If the symbol type does not match,
                     * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
                     * strategy to attempt recovery. If {@link #getBuildParseTree} is
                     * `true` and the token index of the symbol returned by
                     * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
                     * the parse tree by calling {@link Parser#createErrorNode(ParserRuleContext, Token)} then
                     * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
                     *
                     * @returns the matched symbol
                     * @ if the current input symbol did not match
                     * a wildcard and the error strategy could not recover from the mismatched
                     * symbol
                     */
                    matchWildcard() {
                      let t = this.currentToken;
                      if (t.type > 0) {
                        this._errHandler.reportMatch(this);
                        this.consume();
                      } else {
                        t = this._errHandler.recoverInline(this);
                        if (this._buildParseTrees && t.tokenIndex === -1) {
                          this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
                        }
                      }
                      return t;
                    }
                    /**
                     * Track the {@link ParserRuleContext} objects during the parse and hook
                     * them up using the {@link ParserRuleContext#children} list so that it
                     * forms a parse tree. The {@link ParserRuleContext} returned from the start
                     * rule represents the root of the parse tree.
                     *
                     * Note that if we are not building parse trees, rule contexts only point
                     * upwards. When a rule exits, it returns the context but that gets garbage
                     * collected if nobody holds a reference. It points upwards but nobody
                     * points at it.
                     *
                     * When we build parse trees, we are adding all of these contexts to
                     * {@link ParserRuleContext#children} list. Contexts are then not candidates
                     * for garbage collection.
                     */
                    set buildParseTree(buildParseTrees) {
                      this._buildParseTrees = buildParseTrees;
                    }
                    /**
                     * Gets whether or not a complete parse tree will be constructed while
                     * parsing. This property is `true` for a newly constructed parser.
                     *
                     * @returns `true` if a complete parse tree will be constructed while
                     * parsing, otherwise `false`
                     */
                    get buildParseTree() {
                      return this._buildParseTrees;
                    }
                    getParseListeners() {
                      return this._parseListeners;
                    }
                    /**
                     * Registers `listener` to receive events during the parsing process.
                     *
                     * To support output-preserving grammar transformations (including but not
                     * limited to left-recursion removal, automated left-factoring, and
                     * optimized code generation), calls to listener methods during the parse
                     * may differ substantially from calls made by
                     * {@link ParseTreeWalker#DEFAULT} used after the parse is complete. In
                     * particular, rule entry and exit events may occur in a different order
                     * during the parse than after the parser. In addition, calls to certain
                     * rule entry methods may be omitted.
                     *
                     * With the following specific exceptions, calls to listener events are
                     * *deterministic*, i.e. for identical input the calls to listener
                     * methods will be the same.
                     *
                     * * Alterations to the grammar used to generate code may change the
                     *   behavior of the listener calls.
                     * * Alterations to the command line options passed to ANTLR 4 when
                     *   generating the parser may change the behavior of the listener calls.
                     * * Changing the version of the ANTLR Tool used to generate the parser
                     *   may change the behavior of the listener calls.
                     *
                     * @param listener the listener to add
                     *
                     * @throws {@link TypeError} if `listener` is `undefined`
                     */
                    addParseListener(listener) {
                      if (listener == null) {
                        throw new TypeError("listener cannot be null");
                      }
                      this._parseListeners.push(listener);
                    }
                    /**
                     * Remove `listener` from the list of parse listeners.
                     *
                     * If `listener` is `undefined` or has not been added as a parse
                     * listener, this method does nothing.
                     *
                     * @see #addParseListener
                     *
                     * @param listener the listener to remove
                     */
                    removeParseListener(listener) {
                      let index = this._parseListeners.findIndex((l) => l === listener);
                      if (index !== -1) {
                        this._parseListeners.splice(index, 1);
                      }
                    }
                    /**
                     * Remove all parse listeners.
                     *
                     * @see #addParseListener
                     */
                    removeParseListeners() {
                      this._parseListeners.length = 0;
                    }
                    /**
                     * Notify any parse listeners of an enter rule event.
                     *
                     * @see #addParseListener
                     */
                    triggerEnterRuleEvent() {
                      for (let listener of this._parseListeners) {
                        if (listener.enterEveryRule) {
                          listener.enterEveryRule(this._ctx);
                        }
                        this._ctx.enterRule(listener);
                      }
                    }
                    /**
                     * Notify any parse listeners of an exit rule event.
                     *
                     * @see #addParseListener
                     */
                    triggerExitRuleEvent() {
                      for (let i = this._parseListeners.length - 1; i >= 0; i--) {
                        let listener = this._parseListeners[i];
                        this._ctx.exitRule(listener);
                        if (listener.exitEveryRule) {
                          listener.exitEveryRule(this._ctx);
                        }
                      }
                    }
                    /**
                     * Gets the number of syntax errors reported during parsing. This value is
                     * incremented each time {@link #notifyErrorListeners} is called.
                     *
                     * @see #notifyErrorListeners
                     */
                    get numberOfSyntaxErrors() {
                      return this._syntaxErrors;
                    }
                    get tokenFactory() {
                      return this._input.tokenSource.tokenFactory;
                    }
                    /**
                     * The ATN with bypass alternatives is expensive to create so we create it
                     * lazily.
                     *
                     * @ if the current parser does not
                     * implement the `serializedATN` property.
                     */
                    getATNWithBypassAlts() {
                      let serializedAtn = this.serializedATN;
                      if (serializedAtn == null) {
                        throw new Error("The current parser does not support an ATN with bypass alternatives.");
                      }
                      let result = Parser.bypassAltsAtnCache.get(serializedAtn);
                      if (result == null) {
                        let deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();
                        deserializationOptions.isGenerateRuleBypassTransitions = true;
                        result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils.toCharArray(serializedAtn));
                        Parser.bypassAltsAtnCache.set(serializedAtn, result);
                      }
                      return result;
                    }
                    compileParseTreePattern(pattern, patternRuleIndex, lexer) {
                      return __awaiter(this, void 0, void 0, function* () {
                        if (!lexer) {
                          if (this.inputStream) {
                            let tokenSource = this.inputStream.tokenSource;
                            if (tokenSource instanceof Lexer_1.Lexer) {
                              lexer = tokenSource;
                            }
                          }
                          if (!lexer) {
                            throw new Error("Parser can't discover a lexer to use");
                          }
                        }
                        let currentLexer = lexer;
                        let m = yield Promise.resolve().then(() => __webpack_require__2(
                          /*! ./tree/pattern/ParseTreePatternMatcher */
                          "./node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js"
                        ));
                        let matcher = new m.ParseTreePatternMatcher(currentLexer, this);
                        return matcher.compile(pattern, patternRuleIndex);
                      });
                    }
                    get errorHandler() {
                      return this._errHandler;
                    }
                    set errorHandler(handler) {
                      this._errHandler = handler;
                    }
                    get inputStream() {
                      return this._input;
                    }
                    /** Set the token stream and reset the parser. */
                    set inputStream(input) {
                      this.reset(false);
                      this._input = input;
                    }
                    /** Match needs to return the current input symbol, which gets put
                     *  into the label for the associated token ref; e.g., x=ID.
                     */
                    get currentToken() {
                      return this._input.LT(1);
                    }
                    notifyErrorListeners(msg, offendingToken, e) {
                      if (offendingToken === void 0) {
                        offendingToken = this.currentToken;
                      } else if (offendingToken === null) {
                        offendingToken = void 0;
                      }
                      this._syntaxErrors++;
                      let line = -1;
                      let charPositionInLine = -1;
                      if (offendingToken != null) {
                        line = offendingToken.line;
                        charPositionInLine = offendingToken.charPositionInLine;
                      }
                      let listener = this.getErrorListenerDispatch();
                      if (listener.syntaxError) {
                        listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
                      }
                    }
                    /**
                     * Consume and return the [current symbol](`currentToken`).
                     *
                     * E.g., given the following input with `A` being the current
                     * lookahead symbol, this function moves the cursor to `B` and returns
                     * `A`.
                     *
                     * ```
                     * A B
                     * ^
                     * ```
                     *
                     * If the parser is not in error recovery mode, the consumed symbol is added
                     * to the parse tree using {@link ParserRuleContext#addChild(TerminalNode)}, and
                     * {@link ParseTreeListener#visitTerminal} is called on any parse listeners.
                     * If the parser *is* in error recovery mode, the consumed symbol is
                     * added to the parse tree using {@link #createErrorNode(ParserRuleContext, Token)} then
                     * {@link ParserRuleContext#addErrorNode(ErrorNode)} and
                     * {@link ParseTreeListener#visitErrorNode} is called on any parse
                     * listeners.
                     */
                    consume() {
                      let o = this.currentToken;
                      if (o.type !== Parser.EOF) {
                        this.inputStream.consume();
                      }
                      let hasListener = this._parseListeners.length !== 0;
                      if (this._buildParseTrees || hasListener) {
                        if (this._errHandler.inErrorRecoveryMode(this)) {
                          let node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));
                          if (hasListener) {
                            for (let listener of this._parseListeners) {
                              if (listener.visitErrorNode) {
                                listener.visitErrorNode(node);
                              }
                            }
                          }
                        } else {
                          let node = this.createTerminalNode(this._ctx, o);
                          this._ctx.addChild(node);
                          if (hasListener) {
                            for (let listener of this._parseListeners) {
                              if (listener.visitTerminal) {
                                listener.visitTerminal(node);
                              }
                            }
                          }
                        }
                      }
                      return o;
                    }
                    /**
                     * How to create a token leaf node associated with a parent.
                     * Typically, the terminal node to create is not a function of the parent.
                     *
                     * @since 4.7
                     */
                    createTerminalNode(parent, t) {
                      return new TerminalNode_1.TerminalNode(t);
                    }
                    /**
                     * How to create an error node, given a token, associated with a parent.
                     * Typically, the error node to create is not a function of the parent.
                     *
                     * @since 4.7
                     */
                    createErrorNode(parent, t) {
                      return new ErrorNode_1.ErrorNode(t);
                    }
                    addContextToParseTree() {
                      let parent = this._ctx._parent;
                      if (parent != null) {
                        parent.addChild(this._ctx);
                      }
                    }
                    /**
                     * Always called by generated parsers upon entry to a rule. Access field
                     * {@link #_ctx} get the current context.
                     */
                    enterRule(localctx, state, ruleIndex) {
                      this.state = state;
                      this._ctx = localctx;
                      this._ctx._start = this._input.LT(1);
                      if (this._buildParseTrees) {
                        this.addContextToParseTree();
                      }
                      this.triggerEnterRuleEvent();
                    }
                    enterLeftFactoredRule(localctx, state, ruleIndex) {
                      this.state = state;
                      if (this._buildParseTrees) {
                        let factoredContext = this._ctx.getChild(this._ctx.childCount - 1);
                        this._ctx.removeLastChild();
                        factoredContext._parent = localctx;
                        localctx.addChild(factoredContext);
                      }
                      this._ctx = localctx;
                      this._ctx._start = this._input.LT(1);
                      if (this._buildParseTrees) {
                        this.addContextToParseTree();
                      }
                      this.triggerEnterRuleEvent();
                    }
                    exitRule() {
                      if (this.matchedEOF) {
                        this._ctx._stop = this._input.LT(1);
                      } else {
                        this._ctx._stop = this._input.tryLT(-1);
                      }
                      this.triggerExitRuleEvent();
                      this.state = this._ctx.invokingState;
                      this._ctx = this._ctx._parent;
                    }
                    enterOuterAlt(localctx, altNum) {
                      localctx.altNumber = altNum;
                      if (this._buildParseTrees && this._ctx !== localctx) {
                        let parent = this._ctx._parent;
                        if (parent != null) {
                          parent.removeLastChild();
                          parent.addChild(localctx);
                        }
                      }
                      this._ctx = localctx;
                    }
                    /**
                     * Get the precedence level for the top-most precedence rule.
                     *
                     * @returns The precedence level for the top-most precedence rule, or -1 if
                     * the parser context is not nested within a precedence rule.
                     */
                    get precedence() {
                      if (this._precedenceStack.isEmpty) {
                        return -1;
                      }
                      return this._precedenceStack.peek();
                    }
                    enterRecursionRule(localctx, state, ruleIndex, precedence) {
                      this.state = state;
                      this._precedenceStack.push(precedence);
                      this._ctx = localctx;
                      this._ctx._start = this._input.LT(1);
                      this.triggerEnterRuleEvent();
                    }
                    /** Like {@link #enterRule} but for recursive rules.
                     *  Make the current context the child of the incoming localctx.
                     */
                    pushNewRecursionContext(localctx, state, ruleIndex) {
                      let previous = this._ctx;
                      previous._parent = localctx;
                      previous.invokingState = state;
                      previous._stop = this._input.tryLT(-1);
                      this._ctx = localctx;
                      this._ctx._start = previous._start;
                      if (this._buildParseTrees) {
                        this._ctx.addChild(previous);
                      }
                      this.triggerEnterRuleEvent();
                    }
                    unrollRecursionContexts(_parentctx) {
                      this._precedenceStack.pop();
                      this._ctx._stop = this._input.tryLT(-1);
                      let retctx = this._ctx;
                      if (this._parseListeners.length > 0) {
                        while (this._ctx !== _parentctx) {
                          this.triggerExitRuleEvent();
                          this._ctx = this._ctx._parent;
                        }
                      } else {
                        this._ctx = _parentctx;
                      }
                      retctx._parent = _parentctx;
                      if (this._buildParseTrees && _parentctx != null) {
                        _parentctx.addChild(retctx);
                      }
                    }
                    getInvokingContext(ruleIndex) {
                      let p = this._ctx;
                      while (p && p.ruleIndex !== ruleIndex) {
                        p = p._parent;
                      }
                      return p;
                    }
                    get context() {
                      return this._ctx;
                    }
                    set context(ctx) {
                      this._ctx = ctx;
                    }
                    precpred(localctx, precedence) {
                      return precedence >= this._precedenceStack.peek();
                    }
                    getErrorListenerDispatch() {
                      return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());
                    }
                    inContext(context) {
                      return false;
                    }
                    /**
                     * Checks whether or not `symbol` can follow the current state in the
                     * ATN. The behavior of this method is equivalent to the following, but is
                     * implemented such that the complete context-sensitive follow set does not
                     * need to be explicitly constructed.
                     *
                     * ```
                     * return getExpectedTokens().contains(symbol);
                     * ```
                     *
                     * @param symbol the symbol type to check
                     * @returns `true` if `symbol` can follow the current state in
                     * the ATN, otherwise `false`.
                     */
                    isExpectedToken(symbol) {
                      let atn = this.interpreter.atn;
                      let ctx = this._ctx;
                      let s = atn.states[this.state];
                      let following = atn.nextTokens(s);
                      if (following.contains(symbol)) {
                        return true;
                      }
                      if (!following.contains(Token_1.Token.EPSILON)) {
                        return false;
                      }
                      while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
                        let invokingState = atn.states[ctx.invokingState];
                        let rt = invokingState.transition(0);
                        following = atn.nextTokens(rt.followState);
                        if (following.contains(symbol)) {
                          return true;
                        }
                        ctx = ctx._parent;
                      }
                      if (following.contains(Token_1.Token.EPSILON) && symbol === Token_1.Token.EOF) {
                        return true;
                      }
                      return false;
                    }
                    get isMatchedEOF() {
                      return this.matchedEOF;
                    }
                    /**
                     * Computes the set of input symbols which could follow the current parser
                     * state and context, as given by {@link #getState} and {@link #getContext},
                     * respectively.
                     *
                     * @see ATN#getExpectedTokens(int, RuleContext)
                     */
                    getExpectedTokens() {
                      return this.atn.getExpectedTokens(this.state, this.context);
                    }
                    getExpectedTokensWithinCurrentRule() {
                      let atn = this.interpreter.atn;
                      let s = atn.states[this.state];
                      return atn.nextTokens(s);
                    }
                    /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */
                    getRuleIndex(ruleName) {
                      let ruleIndex = this.getRuleIndexMap().get(ruleName);
                      if (ruleIndex != null) {
                        return ruleIndex;
                      }
                      return -1;
                    }
                    get ruleContext() {
                      return this._ctx;
                    }
                    /** Return List&lt;String&gt; of the rule names in your parser instance
                     *  leading up to a call to the current rule.  You could override if
                     *  you want more details such as the file/line info of where
                     *  in the ATN a rule is invoked.
                     *
                     *  This is very useful for error messages.
                     */
                    getRuleInvocationStack(ctx = this._ctx) {
                      let p = ctx;
                      let ruleNames = this.ruleNames;
                      let stack = [];
                      while (p != null) {
                        let ruleIndex = p.ruleIndex;
                        if (ruleIndex < 0) {
                          stack.push("n/a");
                        } else {
                          stack.push(ruleNames[ruleIndex]);
                        }
                        p = p._parent;
                      }
                      return stack;
                    }
                    /** For debugging and other purposes. */
                    getDFAStrings() {
                      let s = [];
                      for (let dfa of this._interp.atn.decisionToDFA) {
                        s.push(dfa.toString(this.vocabulary, this.ruleNames));
                      }
                      return s;
                    }
                    /** For debugging and other purposes. */
                    dumpDFA() {
                      let seenOne = false;
                      for (let dfa of this._interp.atn.decisionToDFA) {
                        if (!dfa.isEmpty) {
                          if (seenOne) {
                            console.log();
                          }
                          console.log("Decision " + dfa.decision + ":");
                          process2.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));
                          seenOne = true;
                        }
                      }
                    }
                    get sourceName() {
                      return this._input.sourceName;
                    }
                    get parseInfo() {
                      return Promise.resolve().then(() => __webpack_require__2(
                        /*! ./atn/ProfilingATNSimulator */
                        "./node_modules/antlr4ts/atn/ProfilingATNSimulator.js"
                      )).then((m) => {
                        let interp = this.interpreter;
                        if (interp instanceof m.ProfilingATNSimulator) {
                          return new ParseInfo_1.ParseInfo(interp);
                        }
                        return void 0;
                      });
                    }
                    /**
                     * @since 4.3
                     */
                    setProfile(profile) {
                      return __awaiter(this, void 0, void 0, function* () {
                        let m = yield Promise.resolve().then(() => __webpack_require__2(
                          /*! ./atn/ProfilingATNSimulator */
                          "./node_modules/antlr4ts/atn/ProfilingATNSimulator.js"
                        ));
                        let interp = this.interpreter;
                        if (profile) {
                          if (!(interp instanceof m.ProfilingATNSimulator)) {
                            this.interpreter = new m.ProfilingATNSimulator(this);
                          }
                        } else if (interp instanceof m.ProfilingATNSimulator) {
                          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);
                        }
                        this.interpreter.setPredictionMode(interp.getPredictionMode());
                      });
                    }
                    /** During a parse is sometimes useful to listen in on the rule entry and exit
                     *  events as well as token matches. This is for quick and dirty debugging.
                     */
                    set isTrace(trace) {
                      if (!trace) {
                        if (this._tracer) {
                          this.removeParseListener(this._tracer);
                          this._tracer = void 0;
                        }
                      } else {
                        if (this._tracer) {
                          this.removeParseListener(this._tracer);
                        } else {
                          this._tracer = new TraceListener(this.ruleNames, this._input);
                        }
                        this.addParseListener(this._tracer);
                      }
                    }
                    /**
                     * Gets whether a {@link TraceListener} is registered as a parse listener
                     * for the parser.
                     */
                    get isTrace() {
                      return this._tracer != null;
                    }
                  }
                  Parser.bypassAltsAtnCache = /* @__PURE__ */ new Map();
                  __decorate([
                    Decorators_1.NotNull
                  ], Parser.prototype, "_errHandler", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], Parser.prototype, "match", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], Parser.prototype, "matchWildcard", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], Parser.prototype, "getParseListeners", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], Parser.prototype, "addParseListener", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], Parser.prototype, "getATNWithBypassAlts", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], Parser.prototype, "errorHandler", null);
                  __decorate([
                    Decorators_1.Override
                  ], Parser.prototype, "inputStream", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], Parser.prototype, "currentToken", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], Parser.prototype, "enterRule", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.Nullable)
                  ], Parser.prototype, "precpred", null);
                  __decorate([
                    Decorators_1.Override
                  ], Parser.prototype, "getErrorListenerDispatch", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], Parser.prototype, "getExpectedTokens", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], Parser.prototype, "getExpectedTokensWithinCurrentRule", null);
                  __decorate([
                    Decorators_1.Override
                  ], Parser.prototype, "parseInfo", null);
                  exports2.Parser = Parser;
                }
              ),
              /***/
              "./node_modules/antlr4ts/ParserErrorListener.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/ParserErrorListener.js ***!
                  \******************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                }
              ),
              /***/
              "./node_modules/antlr4ts/ParserInterpreter.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/ParserInterpreter.js ***!
                  \****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ParserInterpreter = void 0;
                  const ATNState_1 = __webpack_require__2(
                    /*! ./atn/ATNState */
                    "./node_modules/antlr4ts/atn/ATNState.js"
                  );
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./atn/ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const BitSet_1 = __webpack_require__2(
                    /*! ./misc/BitSet */
                    "./node_modules/antlr4ts/misc/BitSet.js"
                  );
                  const FailedPredicateException_1 = __webpack_require__2(
                    /*! ./FailedPredicateException */
                    "./node_modules/antlr4ts/FailedPredicateException.js"
                  );
                  const InputMismatchException_1 = __webpack_require__2(
                    /*! ./InputMismatchException */
                    "./node_modules/antlr4ts/InputMismatchException.js"
                  );
                  const InterpreterRuleContext_1 = __webpack_require__2(
                    /*! ./InterpreterRuleContext */
                    "./node_modules/antlr4ts/InterpreterRuleContext.js"
                  );
                  const LoopEndState_1 = __webpack_require__2(
                    /*! ./atn/LoopEndState */
                    "./node_modules/antlr4ts/atn/LoopEndState.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Decorators_2 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Parser_1 = __webpack_require__2(
                    /*! ./Parser */
                    "./node_modules/antlr4ts/Parser.js"
                  );
                  const ParserATNSimulator_1 = __webpack_require__2(
                    /*! ./atn/ParserATNSimulator */
                    "./node_modules/antlr4ts/atn/ParserATNSimulator.js"
                  );
                  const RecognitionException_1 = __webpack_require__2(
                    /*! ./RecognitionException */
                    "./node_modules/antlr4ts/RecognitionException.js"
                  );
                  const StarLoopEntryState_1 = __webpack_require__2(
                    /*! ./atn/StarLoopEntryState */
                    "./node_modules/antlr4ts/atn/StarLoopEntryState.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  let ParserInterpreter = class ParserInterpreter2 extends Parser_1.Parser {
                    constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
                      super(grammarFileName instanceof ParserInterpreter2 ? grammarFileName.inputStream : input);
                      this._parentContextStack = [];
                      this.overrideDecision = -1;
                      this.overrideDecisionInputIndex = -1;
                      this.overrideDecisionAlt = -1;
                      this.overrideDecisionReached = false;
                      this._overrideDecisionRoot = void 0;
                      if (grammarFileName instanceof ParserInterpreter2) {
                        let old = grammarFileName;
                        this._grammarFileName = old._grammarFileName;
                        this._atn = old._atn;
                        this.pushRecursionContextStates = old.pushRecursionContextStates;
                        this._ruleNames = old._ruleNames;
                        this._vocabulary = old._vocabulary;
                        this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this._atn, this);
                      } else {
                        vocabulary = vocabulary;
                        ruleNames = ruleNames;
                        atn = atn;
                        this._grammarFileName = grammarFileName;
                        this._atn = atn;
                        this._ruleNames = ruleNames.slice(0);
                        this._vocabulary = vocabulary;
                        this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);
                        for (let state of atn.states) {
                          if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                            continue;
                          }
                          if (state.precedenceRuleDecision) {
                            this.pushRecursionContextStates.set(state.stateNumber);
                          }
                        }
                        this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, this);
                      }
                    }
                    reset(resetInput) {
                      if (resetInput === void 0) {
                        super.reset();
                      } else {
                        super.reset(resetInput);
                      }
                      this.overrideDecisionReached = false;
                      this._overrideDecisionRoot = void 0;
                    }
                    get atn() {
                      return this._atn;
                    }
                    get vocabulary() {
                      return this._vocabulary;
                    }
                    get ruleNames() {
                      return this._ruleNames;
                    }
                    get grammarFileName() {
                      return this._grammarFileName;
                    }
                    /** Begin parsing at startRuleIndex */
                    parse(startRuleIndex) {
                      let startRuleStartState = this._atn.ruleToStartState[startRuleIndex];
                      this._rootContext = this.createInterpreterRuleContext(void 0, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);
                      if (startRuleStartState.isPrecedenceRule) {
                        this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
                      } else {
                        this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);
                      }
                      while (true) {
                        let p = this.atnState;
                        switch (p.stateType) {
                          case ATNStateType_1.ATNStateType.RULE_STOP:
                            if (this._ctx.isEmpty) {
                              if (startRuleStartState.isPrecedenceRule) {
                                let result = this._ctx;
                                let parentContext = this._parentContextStack.pop();
                                this.unrollRecursionContexts(parentContext[0]);
                                return result;
                              } else {
                                this.exitRule();
                                return this._rootContext;
                              }
                            }
                            this.visitRuleStopState(p);
                            break;
                          default:
                            try {
                              this.visitState(p);
                            } catch (e) {
                              if (e instanceof RecognitionException_1.RecognitionException) {
                                this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;
                                this.context.exception = e;
                                this.errorHandler.reportError(this, e);
                                this.recover(e);
                              } else {
                                throw e;
                              }
                            }
                            break;
                        }
                      }
                    }
                    enterRecursionRule(localctx, state, ruleIndex, precedence) {
                      this._parentContextStack.push([this._ctx, localctx.invokingState]);
                      super.enterRecursionRule(localctx, state, ruleIndex, precedence);
                    }
                    get atnState() {
                      return this._atn.states[this.state];
                    }
                    visitState(p) {
                      let predictedAlt = 1;
                      if (p.numberOfTransitions > 1) {
                        predictedAlt = this.visitDecisionState(p);
                      }
                      let transition = p.transition(predictedAlt - 1);
                      switch (transition.serializationType) {
                        case 1:
                          if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target instanceof LoopEndState_1.LoopEndState)) {
                            let parentContext = this._parentContextStack[this._parentContextStack.length - 1];
                            let localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);
                            this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);
                          }
                          break;
                        case 5:
                          this.match(transition._label);
                          break;
                        case 2:
                        case 7:
                        case 8:
                          if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {
                            this.recoverInline();
                          }
                          this.matchWildcard();
                          break;
                        case 9:
                          this.matchWildcard();
                          break;
                        case 3:
                          let ruleStartState = transition.target;
                          let ruleIndex = ruleStartState.ruleIndex;
                          let newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);
                          if (ruleStartState.isPrecedenceRule) {
                            this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);
                          } else {
                            this.enterRule(newctx, transition.target.stateNumber, ruleIndex);
                          }
                          break;
                        case 4:
                          let predicateTransition = transition;
                          if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
                            throw new FailedPredicateException_1.FailedPredicateException(this);
                          }
                          break;
                        case 6:
                          let actionTransition = transition;
                          this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);
                          break;
                        case 10:
                          if (!this.precpred(this._ctx, transition.precedence)) {
                            let precedence = transition.precedence;
                            throw new FailedPredicateException_1.FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
                          }
                          break;
                        default:
                          throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
                      }
                      this.state = transition.target.stateNumber;
                    }
                    /** Method visitDecisionState() is called when the interpreter reaches
                     *  a decision state (instance of DecisionState). It gives an opportunity
                     *  for subclasses to track interesting things.
                     */
                    visitDecisionState(p) {
                      let predictedAlt;
                      this.errorHandler.sync(this);
                      let decision = p.decision;
                      if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {
                        predictedAlt = this.overrideDecisionAlt;
                        this.overrideDecisionReached = true;
                      } else {
                        predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);
                      }
                      return predictedAlt;
                    }
                    /** Provide simple "factory" for InterpreterRuleContext's.
                     *  @since 4.5.1
                     */
                    createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
                      return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
                    }
                    visitRuleStopState(p) {
                      let ruleStartState = this._atn.ruleToStartState[p.ruleIndex];
                      if (ruleStartState.isPrecedenceRule) {
                        let parentContext = this._parentContextStack.pop();
                        this.unrollRecursionContexts(parentContext[0]);
                        this.state = parentContext[1];
                      } else {
                        this.exitRule();
                      }
                      let ruleTransition = this._atn.states[this.state].transition(0);
                      this.state = ruleTransition.followState.stateNumber;
                    }
                    /** Override this parser interpreters normal decision-making process
                     *  at a particular decision and input token index. Instead of
                     *  allowing the adaptive prediction mechanism to choose the
                     *  first alternative within a block that leads to a successful parse,
                     *  force it to take the alternative, 1..n for n alternatives.
                     *
                     *  As an implementation limitation right now, you can only specify one
                     *  override. This is sufficient to allow construction of different
                     *  parse trees for ambiguous input. It means re-parsing the entire input
                     *  in general because you're never sure where an ambiguous sequence would
                     *  live in the various parse trees. For example, in one interpretation,
                     *  an ambiguous input sequence would be matched completely in expression
                     *  but in another it could match all the way back to the root.
                     *
                     *  s : e '!'? ;
                     *  e : ID
                     *    | ID '!'
                     *    ;
                     *
                     *  Here, x! can be matched as (s (e ID) !) or (s (e ID !)). In the first
                     *  case, the ambiguous sequence is fully contained only by the root.
                     *  In the second case, the ambiguous sequences fully contained within just
                     *  e, as in: (e ID !).
                     *
                     *  Rather than trying to optimize this and make
                     *  some intelligent decisions for optimization purposes, I settled on
                     *  just re-parsing the whole input and then using
                     *  {link Trees#getRootOfSubtreeEnclosingRegion} to find the minimal
                     *  subtree that contains the ambiguous sequence. I originally tried to
                     *  record the call stack at the point the parser detected and ambiguity but
                     *  left recursive rules create a parse tree stack that does not reflect
                     *  the actual call stack. That impedance mismatch was enough to make
                     *  it it challenging to restart the parser at a deeply nested rule
                     *  invocation.
                     *
                     *  Only parser interpreters can override decisions so as to avoid inserting
                     *  override checking code in the critical ALL(*) prediction execution path.
                     *
                     *  @since 4.5
                     */
                    addDecisionOverride(decision, tokenIndex, forcedAlt) {
                      this.overrideDecision = decision;
                      this.overrideDecisionInputIndex = tokenIndex;
                      this.overrideDecisionAlt = forcedAlt;
                    }
                    get overrideDecisionRoot() {
                      return this._overrideDecisionRoot;
                    }
                    /** Rely on the error handler for this parser but, if no tokens are consumed
                     *  to recover, add an error node. Otherwise, nothing is seen in the parse
                     *  tree.
                     */
                    recover(e) {
                      let i = this._input.index;
                      this.errorHandler.recover(this, e);
                      if (this._input.index === i) {
                        let tok = e.getOffendingToken();
                        if (!tok) {
                          throw new Error("Expected exception to have an offending token");
                        }
                        let source = tok.tokenSource;
                        let stream = source !== void 0 ? source.inputStream : void 0;
                        let sourcePair = { source, stream };
                        if (e instanceof InputMismatchException_1.InputMismatchException) {
                          let expectedTokens = e.expectedTokens;
                          if (expectedTokens === void 0) {
                            throw new Error("Expected the exception to provide expected tokens");
                          }
                          let expectedTokenType = Token_1.Token.INVALID_TYPE;
                          if (!expectedTokens.isNil) {
                            expectedTokenType = expectedTokens.minElement;
                          }
                          let errToken = this.tokenFactory.create(
                            sourcePair,
                            expectedTokenType,
                            tok.text,
                            Token_1.Token.DEFAULT_CHANNEL,
                            -1,
                            -1,
                            // invalid start/stop
                            tok.line,
                            tok.charPositionInLine
                          );
                          this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
                        } else {
                          let source2 = tok.tokenSource;
                          let errToken = this.tokenFactory.create(
                            sourcePair,
                            Token_1.Token.INVALID_TYPE,
                            tok.text,
                            Token_1.Token.DEFAULT_CHANNEL,
                            -1,
                            -1,
                            // invalid start/stop
                            tok.line,
                            tok.charPositionInLine
                          );
                          this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
                        }
                      }
                    }
                    recoverInline() {
                      return this._errHandler.recoverInline(this);
                    }
                    /** Return the root of the parse, which can be useful if the parser
                     *  bails out. You still can access the top node. Note that,
                     *  because of the way left recursive rules add children, it's possible
                     *  that the root will not have any children if the start rule immediately
                     *  called and left recursive rule that fails.
                     *
                     * @since 4.5.1
                     */
                    get rootContext() {
                      return this._rootContext;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], ParserInterpreter.prototype, "_vocabulary", void 0);
                  __decorate([
                    Decorators_2.Override
                  ], ParserInterpreter.prototype, "reset", null);
                  __decorate([
                    Decorators_2.Override
                  ], ParserInterpreter.prototype, "atn", null);
                  __decorate([
                    Decorators_2.Override
                  ], ParserInterpreter.prototype, "vocabulary", null);
                  __decorate([
                    Decorators_2.Override
                  ], ParserInterpreter.prototype, "ruleNames", null);
                  __decorate([
                    Decorators_2.Override
                  ], ParserInterpreter.prototype, "grammarFileName", null);
                  __decorate([
                    Decorators_2.Override
                  ], ParserInterpreter.prototype, "enterRecursionRule", null);
                  ParserInterpreter = __decorate([
                    __param(1, Decorators_1.NotNull)
                  ], ParserInterpreter);
                  exports2.ParserInterpreter = ParserInterpreter;
                }
              ),
              /***/
              "./node_modules/antlr4ts/ParserRuleContext.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/ParserRuleContext.js ***!
                  \****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ParserRuleContext = void 0;
                  const ErrorNode_1 = __webpack_require__2(
                    /*! ./tree/ErrorNode */
                    "./node_modules/antlr4ts/tree/ErrorNode.js"
                  );
                  const Interval_1 = __webpack_require__2(
                    /*! ./misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const RuleContext_1 = __webpack_require__2(
                    /*! ./RuleContext */
                    "./node_modules/antlr4ts/RuleContext.js"
                  );
                  const TerminalNode_1 = __webpack_require__2(
                    /*! ./tree/TerminalNode */
                    "./node_modules/antlr4ts/tree/TerminalNode.js"
                  );
                  class ParserRuleContext extends RuleContext_1.RuleContext {
                    constructor(parent, invokingStateNumber) {
                      if (invokingStateNumber == null) {
                        super();
                      } else {
                        super(parent, invokingStateNumber);
                      }
                    }
                    static emptyContext() {
                      return ParserRuleContext.EMPTY;
                    }
                    /**
                     * COPY a ctx (I'm deliberately not using copy constructor) to avoid
                     * confusion with creating node with parent. Does not copy children
                     * (except error leaves).
                     *
                     * This is used in the generated parser code to flip a generic XContext
                     * node for rule X to a YContext for alt label Y. In that sense, it is not
                     * really a generic copy function.
                     *
                     * If we do an error sync() at start of a rule, we might add error nodes
                     * to the generic XContext so this function must copy those nodes to the
                     * YContext as well else they are lost!
                     */
                    copyFrom(ctx) {
                      this._parent = ctx._parent;
                      this.invokingState = ctx.invokingState;
                      this._start = ctx._start;
                      this._stop = ctx._stop;
                      if (ctx.children) {
                        this.children = [];
                        for (let child of ctx.children) {
                          if (child instanceof ErrorNode_1.ErrorNode) {
                            this.addChild(child);
                          }
                        }
                      }
                    }
                    // Double dispatch methods for listeners
                    enterRule(listener) {
                    }
                    exitRule(listener) {
                    }
                    /** Add a parse tree node to this as a child.  Works for
                     *  internal and leaf nodes. Does not set parent link;
                     *  other add methods must do that. Other addChild methods
                     *  call this.
                     *
                     *  We cannot set the parent pointer of the incoming node
                     *  because the existing interfaces do not have a setParent()
                     *  method and I don't want to break backward compatibility for this.
                     *
                     *  @since 4.7
                     */
                    addAnyChild(t) {
                      if (!this.children) {
                        this.children = [t];
                      } else {
                        this.children.push(t);
                      }
                      return t;
                    }
                    addChild(t) {
                      let result;
                      if (t instanceof TerminalNode_1.TerminalNode) {
                        t.setParent(this);
                        this.addAnyChild(t);
                        return;
                      } else if (t instanceof RuleContext_1.RuleContext) {
                        this.addAnyChild(t);
                        return;
                      } else {
                        t = new TerminalNode_1.TerminalNode(t);
                        this.addAnyChild(t);
                        t.setParent(this);
                        return t;
                      }
                    }
                    addErrorNode(node) {
                      if (node instanceof ErrorNode_1.ErrorNode) {
                        const errorNode = node;
                        errorNode.setParent(this);
                        return this.addAnyChild(errorNode);
                      } else {
                        const badToken = node;
                        let t = new ErrorNode_1.ErrorNode(badToken);
                        this.addAnyChild(t);
                        t.setParent(this);
                        return t;
                      }
                    }
                    //	public void trace(int s) {
                    //		if ( states==null ) states = new ArrayList<Integer>();
                    //		states.add(s);
                    //	}
                    /** Used by enterOuterAlt to toss out a RuleContext previously added as
                     *  we entered a rule. If we have # label, we will need to remove
                     *  generic ruleContext object.
                     */
                    removeLastChild() {
                      if (this.children) {
                        this.children.pop();
                      }
                    }
                    get parent() {
                      let parent = super.parent;
                      if (parent === void 0 || parent instanceof ParserRuleContext) {
                        return parent;
                      }
                      throw new TypeError("Invalid parent type for ParserRuleContext");
                    }
                    // Note: in TypeScript, order or arguments reversed
                    getChild(i, ctxType) {
                      if (!this.children || i < 0 || i >= this.children.length) {
                        throw new RangeError("index parameter must be between >= 0 and <= number of children.");
                      }
                      if (ctxType == null) {
                        return this.children[i];
                      }
                      let result = this.tryGetChild(i, ctxType);
                      if (result === void 0) {
                        throw new Error("The specified node does not exist");
                      }
                      return result;
                    }
                    tryGetChild(i, ctxType) {
                      if (!this.children || i < 0 || i >= this.children.length) {
                        return void 0;
                      }
                      let j = -1;
                      for (let o of this.children) {
                        if (o instanceof ctxType) {
                          j++;
                          if (j === i) {
                            return o;
                          }
                        }
                      }
                      return void 0;
                    }
                    getToken(ttype, i) {
                      let result = this.tryGetToken(ttype, i);
                      if (result === void 0) {
                        throw new Error("The specified token does not exist");
                      }
                      return result;
                    }
                    tryGetToken(ttype, i) {
                      if (!this.children || i < 0 || i >= this.children.length) {
                        return void 0;
                      }
                      let j = -1;
                      for (let o of this.children) {
                        if (o instanceof TerminalNode_1.TerminalNode) {
                          let symbol = o.symbol;
                          if (symbol.type === ttype) {
                            j++;
                            if (j === i) {
                              return o;
                            }
                          }
                        }
                      }
                      return void 0;
                    }
                    getTokens(ttype) {
                      let tokens = [];
                      if (!this.children) {
                        return tokens;
                      }
                      for (let o of this.children) {
                        if (o instanceof TerminalNode_1.TerminalNode) {
                          let symbol = o.symbol;
                          if (symbol.type === ttype) {
                            tokens.push(o);
                          }
                        }
                      }
                      return tokens;
                    }
                    get ruleContext() {
                      return this;
                    }
                    // NOTE: argument order change from Java version
                    getRuleContext(i, ctxType) {
                      return this.getChild(i, ctxType);
                    }
                    tryGetRuleContext(i, ctxType) {
                      return this.tryGetChild(i, ctxType);
                    }
                    getRuleContexts(ctxType) {
                      let contexts = [];
                      if (!this.children) {
                        return contexts;
                      }
                      for (let o of this.children) {
                        if (o instanceof ctxType) {
                          contexts.push(o);
                        }
                      }
                      return contexts;
                    }
                    get childCount() {
                      return this.children ? this.children.length : 0;
                    }
                    get sourceInterval() {
                      if (!this._start) {
                        return Interval_1.Interval.INVALID;
                      }
                      if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {
                        return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1);
                      }
                      return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);
                    }
                    /**
                     * Get the initial token in this context.
                     * Note that the range from start to stop is inclusive, so for rules that do not consume anything
                     * (for example, zero length or error productions) this token may exceed stop.
                     */
                    get start() {
                      return this._start;
                    }
                    /**
                     * Get the final token in this context.
                     * Note that the range from start to stop is inclusive, so for rules that do not consume anything
                     * (for example, zero length or error productions) this token may precede start.
                     */
                    get stop() {
                      return this._stop;
                    }
                    /** Used for rule context info debugging during parse-time, not so much for ATN debugging */
                    toInfoString(recognizer) {
                      let rules = recognizer.getRuleInvocationStack(this).reverse();
                      return "ParserRuleContext" + rules + "{start=" + this._start + ", stop=" + this._stop + "}";
                    }
                  }
                  ParserRuleContext.EMPTY = new ParserRuleContext();
                  __decorate([
                    Decorators_1.Override
                  ], ParserRuleContext.prototype, "parent", null);
                  __decorate([
                    Decorators_1.Override
                  ], ParserRuleContext.prototype, "childCount", null);
                  __decorate([
                    Decorators_1.Override
                  ], ParserRuleContext.prototype, "sourceInterval", null);
                  exports2.ParserRuleContext = ParserRuleContext;
                }
              ),
              /***/
              "./node_modules/antlr4ts/ProxyErrorListener.js": (
                /*!*****************************************************!*\
                  !*** ./node_modules/antlr4ts/ProxyErrorListener.js ***!
                  \*****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ProxyErrorListener = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class ProxyErrorListener {
                    constructor(delegates) {
                      this.delegates = delegates;
                      if (!delegates) {
                        throw new Error("Invalid delegates");
                      }
                    }
                    getDelegates() {
                      return this.delegates;
                    }
                    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
                      this.delegates.forEach((listener) => {
                        if (listener.syntaxError) {
                          listener.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e);
                        }
                      });
                    }
                  }
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull),
                    __param(4, Decorators_1.NotNull)
                  ], ProxyErrorListener.prototype, "syntaxError", null);
                  exports2.ProxyErrorListener = ProxyErrorListener;
                }
              ),
              /***/
              "./node_modules/antlr4ts/ProxyParserErrorListener.js": (
                /*!***********************************************************!*\
                  !*** ./node_modules/antlr4ts/ProxyParserErrorListener.js ***!
                  \***********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ProxyParserErrorListener = void 0;
                  const ProxyErrorListener_1 = __webpack_require__2(
                    /*! ./ProxyErrorListener */
                    "./node_modules/antlr4ts/ProxyErrorListener.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class ProxyParserErrorListener extends ProxyErrorListener_1.ProxyErrorListener {
                    constructor(delegates) {
                      super(delegates);
                    }
                    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
                      this.getDelegates().forEach((listener) => {
                        if (listener.reportAmbiguity) {
                          listener.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
                        }
                      });
                    }
                    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
                      this.getDelegates().forEach((listener) => {
                        if (listener.reportAttemptingFullContext) {
                          listener.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
                        }
                      });
                    }
                    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
                      this.getDelegates().forEach((listener) => {
                        if (listener.reportContextSensitivity) {
                          listener.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState);
                        }
                      });
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], ProxyParserErrorListener.prototype, "reportAmbiguity", null);
                  __decorate([
                    Decorators_1.Override
                  ], ProxyParserErrorListener.prototype, "reportAttemptingFullContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], ProxyParserErrorListener.prototype, "reportContextSensitivity", null);
                  exports2.ProxyParserErrorListener = ProxyParserErrorListener;
                }
              ),
              /***/
              "./node_modules/antlr4ts/RecognitionException.js": (
                /*!*******************************************************!*\
                  !*** ./node_modules/antlr4ts/RecognitionException.js ***!
                  \*******************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RecognitionException = void 0;
                  class RecognitionException extends Error {
                    constructor(recognizer, input, ctx, message) {
                      super(message);
                      this._offendingState = -1;
                      this._recognizer = recognizer;
                      this.input = input;
                      this.ctx = ctx;
                      if (recognizer) {
                        this._offendingState = recognizer.state;
                      }
                    }
                    /**
                     * Get the ATN state number the parser was in at the time the error
                     * occurred. For {@link NoViableAltException} and
                     * {@link LexerNoViableAltException} exceptions, this is the
                     * {@link DecisionState} number. For others, it is the state whose outgoing
                     * edge we couldn't match.
                     *
                     * If the state number is not known, this method returns -1.
                     */
                    get offendingState() {
                      return this._offendingState;
                    }
                    setOffendingState(offendingState) {
                      this._offendingState = offendingState;
                    }
                    /**
                     * Gets the set of input symbols which could potentially follow the
                     * previously matched symbol at the time this exception was thrown.
                     *
                     * If the set of expected tokens is not known and could not be computed,
                     * this method returns `undefined`.
                     *
                     * @returns The set of token types that could potentially follow the current
                     * state in the ATN, or `undefined` if the information is not available.
                     */
                    get expectedTokens() {
                      if (this._recognizer) {
                        return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);
                      }
                      return void 0;
                    }
                    /**
                     * Gets the {@link RuleContext} at the time this exception was thrown.
                     *
                     * If the context is not available, this method returns `undefined`.
                     *
                     * @returns The {@link RuleContext} at the time this exception was thrown.
                     * If the context is not available, this method returns `undefined`.
                     */
                    get context() {
                      return this.ctx;
                    }
                    /**
                     * Gets the input stream which is the symbol source for the recognizer where
                     * this exception was thrown.
                     *
                     * If the input stream is not available, this method returns `undefined`.
                     *
                     * @returns The input stream which is the symbol source for the recognizer
                     * where this exception was thrown, or `undefined` if the stream is not
                     * available.
                     */
                    get inputStream() {
                      return this.input;
                    }
                    getOffendingToken(recognizer) {
                      if (recognizer && recognizer !== this._recognizer) {
                        return void 0;
                      }
                      return this.offendingToken;
                    }
                    setOffendingToken(recognizer, offendingToken) {
                      if (recognizer === this._recognizer) {
                        this.offendingToken = offendingToken;
                      }
                    }
                    /**
                     * Gets the {@link Recognizer} where this exception occurred.
                     *
                     * If the recognizer is not available, this method returns `undefined`.
                     *
                     * @returns The recognizer where this exception occurred, or `undefined` if
                     * the recognizer is not available.
                     */
                    get recognizer() {
                      return this._recognizer;
                    }
                  }
                  exports2.RecognitionException = RecognitionException;
                }
              ),
              /***/
              "./node_modules/antlr4ts/Recognizer.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/antlr4ts/Recognizer.js ***!
                  \*********************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Recognizer = void 0;
                  const ConsoleErrorListener_1 = __webpack_require__2(
                    /*! ./ConsoleErrorListener */
                    "./node_modules/antlr4ts/ConsoleErrorListener.js"
                  );
                  const ProxyErrorListener_1 = __webpack_require__2(
                    /*! ./ProxyErrorListener */
                    "./node_modules/antlr4ts/ProxyErrorListener.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const Utils = __webpack_require__2(
                    /*! ./misc/Utils */
                    "./node_modules/antlr4ts/misc/Utils.js"
                  );
                  class Recognizer {
                    constructor() {
                      this._listeners = [ConsoleErrorListener_1.ConsoleErrorListener.INSTANCE];
                      this._stateNumber = -1;
                    }
                    /**
                     * Get a map from token names to token types.
                     *
                     * Used for XPath and tree pattern compilation.
                     */
                    getTokenTypeMap() {
                      let vocabulary = this.vocabulary;
                      let result = Recognizer.tokenTypeMapCache.get(vocabulary);
                      if (result == null) {
                        let intermediateResult = /* @__PURE__ */ new Map();
                        for (let i = 0; i <= this.atn.maxTokenType; i++) {
                          let literalName = vocabulary.getLiteralName(i);
                          if (literalName != null) {
                            intermediateResult.set(literalName, i);
                          }
                          let symbolicName = vocabulary.getSymbolicName(i);
                          if (symbolicName != null) {
                            intermediateResult.set(symbolicName, i);
                          }
                        }
                        intermediateResult.set("EOF", Token_1.Token.EOF);
                        result = intermediateResult;
                        Recognizer.tokenTypeMapCache.set(vocabulary, result);
                      }
                      return result;
                    }
                    /**
                     * Get a map from rule names to rule indexes.
                     *
                     * Used for XPath and tree pattern compilation.
                     */
                    getRuleIndexMap() {
                      let ruleNames = this.ruleNames;
                      if (ruleNames == null) {
                        throw new Error("The current recognizer does not provide a list of rule names.");
                      }
                      let result = Recognizer.ruleIndexMapCache.get(ruleNames);
                      if (result == null) {
                        result = Utils.toMap(ruleNames);
                        Recognizer.ruleIndexMapCache.set(ruleNames, result);
                      }
                      return result;
                    }
                    getTokenType(tokenName) {
                      let ttype = this.getTokenTypeMap().get(tokenName);
                      if (ttype != null) {
                        return ttype;
                      }
                      return Token_1.Token.INVALID_TYPE;
                    }
                    /**
                     * If this recognizer was generated, it will have a serialized ATN
                     * representation of the grammar.
                     *
                     * For interpreters, we don't know their serialized ATN despite having
                     * created the interpreter from it.
                     */
                    get serializedATN() {
                      throw new Error("there is no serialized ATN");
                    }
                    /**
                     * Get the {@link ATN} used by the recognizer for prediction.
                     *
                     * @returns The {@link ATN} used by the recognizer for prediction.
                     */
                    get atn() {
                      return this._interp.atn;
                    }
                    /**
                     * Get the ATN interpreter used by the recognizer for prediction.
                     *
                     * @returns The ATN interpreter used by the recognizer for prediction.
                     */
                    get interpreter() {
                      return this._interp;
                    }
                    /**
                     * Set the ATN interpreter used by the recognizer for prediction.
                     *
                     * @param interpreter The ATN interpreter used by the recognizer for
                     * prediction.
                     */
                    set interpreter(interpreter) {
                      this._interp = interpreter;
                    }
                    /** If profiling during the parse/lex, this will return DecisionInfo records
                     *  for each decision in recognizer in a ParseInfo object.
                     *
                     * @since 4.3
                     */
                    get parseInfo() {
                      return Promise.resolve(void 0);
                    }
                    /** What is the error header, normally line/character position information? */
                    getErrorHeader(e) {
                      let token = e.getOffendingToken();
                      if (!token) {
                        return "";
                      }
                      let line = token.line;
                      let charPositionInLine = token.charPositionInLine;
                      return "line " + line + ":" + charPositionInLine;
                    }
                    /**
                     * @exception NullPointerException if `listener` is `undefined`.
                     */
                    addErrorListener(listener) {
                      if (!listener) {
                        throw new TypeError("listener must not be null");
                      }
                      this._listeners.push(listener);
                    }
                    removeErrorListener(listener) {
                      let position = this._listeners.indexOf(listener);
                      if (position !== -1) {
                        this._listeners.splice(position, 1);
                      }
                    }
                    removeErrorListeners() {
                      this._listeners.length = 0;
                    }
                    getErrorListeners() {
                      return this._listeners.slice(0);
                    }
                    getErrorListenerDispatch() {
                      return new ProxyErrorListener_1.ProxyErrorListener(this.getErrorListeners());
                    }
                    // subclass needs to override these if there are sempreds or actions
                    // that the ATN interp needs to execute
                    sempred(_localctx, ruleIndex, actionIndex) {
                      return true;
                    }
                    precpred(localctx, precedence) {
                      return true;
                    }
                    action(_localctx, ruleIndex, actionIndex) {
                    }
                    get state() {
                      return this._stateNumber;
                    }
                    /** Indicate that the recognizer has changed internal state that is
                     *  consistent with the ATN state passed in.  This way we always know
                     *  where we are in the ATN as the parser goes along. The rule
                     *  context objects form a stack that lets us see the stack of
                     *  invoking rules. Combine this and we have complete ATN
                     *  configuration information.
                     */
                    set state(atnState) {
                      this._stateNumber = atnState;
                    }
                  }
                  Recognizer.EOF = -1;
                  Recognizer.tokenTypeMapCache = /* @__PURE__ */ new WeakMap();
                  Recognizer.ruleIndexMapCache = /* @__PURE__ */ new WeakMap();
                  __decorate([
                    Decorators_1.SuppressWarnings("serial"),
                    Decorators_1.NotNull
                  ], Recognizer.prototype, "_listeners", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], Recognizer.prototype, "getTokenTypeMap", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], Recognizer.prototype, "getRuleIndexMap", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], Recognizer.prototype, "serializedATN", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], Recognizer.prototype, "atn", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], Recognizer.prototype, "interpreter", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], Recognizer.prototype, "getErrorHeader", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], Recognizer.prototype, "addErrorListener", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], Recognizer.prototype, "removeErrorListener", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], Recognizer.prototype, "getErrorListeners", null);
                  exports2.Recognizer = Recognizer;
                }
              ),
              /***/
              "./node_modules/antlr4ts/RuleContext.js": (
                /*!**********************************************!*\
                  !*** ./node_modules/antlr4ts/RuleContext.js ***!
                  \**********************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RuleContext = void 0;
                  const ATN_1 = __webpack_require__2(
                    /*! ./atn/ATN */
                    "./node_modules/antlr4ts/atn/ATN.js"
                  );
                  const Recognizer_1 = __webpack_require__2(
                    /*! ./Recognizer */
                    "./node_modules/antlr4ts/Recognizer.js"
                  );
                  const RuleNode_1 = __webpack_require__2(
                    /*! ./tree/RuleNode */
                    "./node_modules/antlr4ts/tree/RuleNode.js"
                  );
                  const Interval_1 = __webpack_require__2(
                    /*! ./misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Trees_1 = __webpack_require__2(
                    /*! ./tree/Trees */
                    "./node_modules/antlr4ts/tree/Trees.js"
                  );
                  const ParserRuleContext_1 = __webpack_require__2(
                    /*! ./ParserRuleContext */
                    "./node_modules/antlr4ts/ParserRuleContext.js"
                  );
                  class RuleContext extends RuleNode_1.RuleNode {
                    constructor(parent, invokingState) {
                      super();
                      this._parent = parent;
                      this.invokingState = invokingState != null ? invokingState : -1;
                    }
                    static getChildContext(parent, invokingState) {
                      return new RuleContext(parent, invokingState);
                    }
                    depth() {
                      let n = 0;
                      let p = this;
                      while (p) {
                        p = p._parent;
                        n++;
                      }
                      return n;
                    }
                    /** A context is empty if there is no invoking state; meaning nobody called
                     *  current context.
                     */
                    get isEmpty() {
                      return this.invokingState === -1;
                    }
                    // satisfy the ParseTree / SyntaxTree interface
                    get sourceInterval() {
                      return Interval_1.Interval.INVALID;
                    }
                    get ruleContext() {
                      return this;
                    }
                    get parent() {
                      return this._parent;
                    }
                    /** @since 4.7. {@see ParseTree#setParent} comment */
                    setParent(parent) {
                      this._parent = parent;
                    }
                    get payload() {
                      return this;
                    }
                    /** Return the combined text of all child nodes. This method only considers
                     *  tokens which have been added to the parse tree.
                     *
                     *  Since tokens on hidden channels (e.g. whitespace or comments) are not
                     *  added to the parse trees, they will not appear in the output of this
                     *  method.
                     */
                    get text() {
                      if (this.childCount === 0) {
                        return "";
                      }
                      let builder = "";
                      for (let i = 0; i < this.childCount; i++) {
                        builder += this.getChild(i).text;
                      }
                      return builder.toString();
                    }
                    get ruleIndex() {
                      return -1;
                    }
                    /** For rule associated with this parse tree internal node, return
                     *  the outer alternative number used to match the input. Default
                     *  implementation does not compute nor store this alt num. Create
                     *  a subclass of ParserRuleContext with backing field and set
                     *  option contextSuperClass.
                     *  to set it.
                     *
                     *  @since 4.5.3
                     */
                    get altNumber() {
                      return ATN_1.ATN.INVALID_ALT_NUMBER;
                    }
                    /** Set the outer alternative number for this context node. Default
                     *  implementation does nothing to avoid backing field overhead for
                     *  trees that don't need it.  Create
                     *  a subclass of ParserRuleContext with backing field and set
                     *  option contextSuperClass.
                     *
                     *  @since 4.5.3
                     */
                    set altNumber(altNumber) {
                    }
                    getChild(i) {
                      throw new RangeError("i must be greater than or equal to 0 and less than childCount");
                    }
                    get childCount() {
                      return 0;
                    }
                    accept(visitor) {
                      return visitor.visitChildren(this);
                    }
                    toStringTree(recog) {
                      return Trees_1.Trees.toStringTree(this, recog);
                    }
                    toString(arg1, stop) {
                      const ruleNames = arg1 instanceof Recognizer_1.Recognizer ? arg1.ruleNames : arg1;
                      stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();
                      let buf = "";
                      let p = this;
                      buf += "[";
                      while (p && p !== stop) {
                        if (!ruleNames) {
                          if (!p.isEmpty) {
                            buf += p.invokingState;
                          }
                        } else {
                          let ruleIndex = p.ruleIndex;
                          let ruleName = ruleIndex >= 0 && ruleIndex < ruleNames.length ? ruleNames[ruleIndex] : ruleIndex.toString();
                          buf += ruleName;
                        }
                        if (p._parent && (ruleNames || !p._parent.isEmpty)) {
                          buf += " ";
                        }
                        p = p._parent;
                      }
                      buf += "]";
                      return buf.toString();
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], RuleContext.prototype, "sourceInterval", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleContext.prototype, "ruleContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleContext.prototype, "parent", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleContext.prototype, "setParent", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleContext.prototype, "payload", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleContext.prototype, "text", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleContext.prototype, "getChild", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleContext.prototype, "childCount", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleContext.prototype, "accept", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleContext.prototype, "toStringTree", null);
                  exports2.RuleContext = RuleContext;
                }
              ),
              /***/
              "./node_modules/antlr4ts/RuleContextWithAltNum.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/antlr4ts/RuleContextWithAltNum.js ***!
                  \********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RuleContextWithAltNum = void 0;
                  const ATN_1 = __webpack_require__2(
                    /*! ./atn/ATN */
                    "./node_modules/antlr4ts/atn/ATN.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ParserRuleContext_1 = __webpack_require__2(
                    /*! ./ParserRuleContext */
                    "./node_modules/antlr4ts/ParserRuleContext.js"
                  );
                  class RuleContextWithAltNum extends ParserRuleContext_1.ParserRuleContext {
                    constructor(parent, invokingStateNumber) {
                      if (invokingStateNumber !== void 0) {
                        super(parent, invokingStateNumber);
                      } else {
                        super();
                      }
                      this._altNumber = ATN_1.ATN.INVALID_ALT_NUMBER;
                    }
                    get altNumber() {
                      return this._altNumber;
                    }
                    // @Override
                    set altNumber(altNum) {
                      this._altNumber = altNum;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], RuleContextWithAltNum.prototype, "altNumber", null);
                  exports2.RuleContextWithAltNum = RuleContextWithAltNum;
                }
              ),
              /***/
              "./node_modules/antlr4ts/RuleDependency.js": (
                /*!*************************************************!*\
                  !*** ./node_modules/antlr4ts/RuleDependency.js ***!
                  \*************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RuleDependency = void 0;
                  function RuleDependency(dependency) {
                    return (target, propertyKey, propertyDescriptor) => {
                    };
                  }
                  exports2.RuleDependency = RuleDependency;
                }
              ),
              /***/
              "./node_modules/antlr4ts/RuleVersion.js": (
                /*!**********************************************!*\
                  !*** ./node_modules/antlr4ts/RuleVersion.js ***!
                  \**********************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RuleVersion = void 0;
                  function RuleVersion(version2) {
                    return (target, propertyKey, propertyDescriptor) => {
                    };
                  }
                  exports2.RuleVersion = RuleVersion;
                }
              ),
              /***/
              "./node_modules/antlr4ts/Token.js": (
                /*!****************************************!*\
                  !*** ./node_modules/antlr4ts/Token.js ***!
                  \****************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Token = void 0;
                  const IntStream_1 = __webpack_require__2(
                    /*! ./IntStream */
                    "./node_modules/antlr4ts/IntStream.js"
                  );
                  var Token;
                  (function(Token2) {
                    Token2.INVALID_TYPE = 0;
                    Token2.EPSILON = -2;
                    Token2.MIN_USER_TOKEN_TYPE = 1;
                    Token2.EOF = IntStream_1.IntStream.EOF;
                    Token2.DEFAULT_CHANNEL = 0;
                    Token2.HIDDEN_CHANNEL = 1;
                    Token2.MIN_USER_CHANNEL_VALUE = 2;
                  })(Token = exports2.Token || (exports2.Token = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/TokenFactory.js": (
                /*!***********************************************!*\
                  !*** ./node_modules/antlr4ts/TokenFactory.js ***!
                  \***********************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                }
              ),
              /***/
              "./node_modules/antlr4ts/TokenSource.js": (
                /*!**********************************************!*\
                  !*** ./node_modules/antlr4ts/TokenSource.js ***!
                  \**********************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                }
              ),
              /***/
              "./node_modules/antlr4ts/TokenStream.js": (
                /*!**********************************************!*\
                  !*** ./node_modules/antlr4ts/TokenStream.js ***!
                  \**********************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                }
              ),
              /***/
              "./node_modules/antlr4ts/TokenStreamRewriter.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/TokenStreamRewriter.js ***!
                  \******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RewriteOperation = exports2.TokenStreamRewriter = void 0;
                  const Interval_1 = __webpack_require__2(
                    /*! ./misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  class TokenStreamRewriter {
                    constructor(tokens) {
                      this.tokens = tokens;
                      this.programs = /* @__PURE__ */ new Map();
                      this.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);
                      this.lastRewriteTokenIndexes = /* @__PURE__ */ new Map();
                    }
                    getTokenStream() {
                      return this.tokens;
                    }
                    rollback(instructionIndex, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                      let is = this.programs.get(programName);
                      if (is != null) {
                        this.programs.set(programName, is.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));
                      }
                    }
                    deleteProgram(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                      this.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, programName);
                    }
                    insertAfter(tokenOrIndex, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                      let index;
                      if (typeof tokenOrIndex === "number") {
                        index = tokenOrIndex;
                      } else {
                        index = tokenOrIndex.tokenIndex;
                      }
                      let rewrites = this.getProgram(programName);
                      let op = new InsertAfterOp(this.tokens, index, rewrites.length, text);
                      rewrites.push(op);
                    }
                    insertBefore(tokenOrIndex, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                      let index;
                      if (typeof tokenOrIndex === "number") {
                        index = tokenOrIndex;
                      } else {
                        index = tokenOrIndex.tokenIndex;
                      }
                      let rewrites = this.getProgram(programName);
                      let op = new InsertBeforeOp(this.tokens, index, rewrites.length, text);
                      rewrites.push(op);
                    }
                    replaceSingle(index, text) {
                      if (typeof index === "number") {
                        this.replace(index, index, text);
                      } else {
                        this.replace(index, index, text);
                      }
                    }
                    replace(from, to, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                      if (typeof from !== "number") {
                        from = from.tokenIndex;
                      }
                      if (typeof to !== "number") {
                        to = to.tokenIndex;
                      }
                      if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
                        throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);
                      }
                      let rewrites = this.getProgram(programName);
                      let op = new ReplaceOp(this.tokens, from, to, rewrites.length, text);
                      rewrites.push(op);
                    }
                    delete(from, to, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                      if (to === void 0) {
                        to = from;
                      }
                      if (typeof from === "number") {
                        this.replace(from, to, "", programName);
                      } else {
                        this.replace(from, to, "", programName);
                      }
                    }
                    getLastRewriteTokenIndex(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                      let I = this.lastRewriteTokenIndexes.get(programName);
                      if (I == null) {
                        return -1;
                      }
                      return I;
                    }
                    setLastRewriteTokenIndex(programName, i) {
                      this.lastRewriteTokenIndexes.set(programName, i);
                    }
                    getProgram(name) {
                      let is = this.programs.get(name);
                      if (is == null) {
                        is = this.initializeProgram(name);
                      }
                      return is;
                    }
                    initializeProgram(name) {
                      let is = [];
                      this.programs.set(name, is);
                      return is;
                    }
                    getText(intervalOrProgram, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                      let interval;
                      if (intervalOrProgram instanceof Interval_1.Interval) {
                        interval = intervalOrProgram;
                      } else {
                        interval = Interval_1.Interval.of(0, this.tokens.size - 1);
                      }
                      if (typeof intervalOrProgram === "string") {
                        programName = intervalOrProgram;
                      }
                      let rewrites = this.programs.get(programName);
                      let start = interval.a;
                      let stop = interval.b;
                      if (stop > this.tokens.size - 1) {
                        stop = this.tokens.size - 1;
                      }
                      if (start < 0) {
                        start = 0;
                      }
                      if (rewrites == null || rewrites.length === 0) {
                        return this.tokens.getText(interval);
                      }
                      let buf = [];
                      let indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
                      let i = start;
                      while (i <= stop && i < this.tokens.size) {
                        let op = indexToOp.get(i);
                        indexToOp.delete(i);
                        let t = this.tokens.get(i);
                        if (op == null) {
                          if (t.type !== Token_1.Token.EOF) {
                            buf.push(String(t.text));
                          }
                          i++;
                        } else {
                          i = op.execute(buf);
                        }
                      }
                      if (stop === this.tokens.size - 1) {
                        for (let op of indexToOp.values()) {
                          if (op.index >= this.tokens.size - 1) {
                            buf.push(op.text.toString());
                          }
                        }
                      }
                      return buf.join("");
                    }
                    /** We need to combine operations and report invalid operations (like
                     *  overlapping replaces that are not completed nested). Inserts to
                     *  same index need to be combined etc...  Here are the cases:
                     *
                     *  I.i.u I.j.v								leave alone, nonoverlapping
                     *  I.i.u I.i.v								combine: Iivu
                     *
                     *  R.i-j.u R.x-y.v	| i-j in x-y			delete first R
                     *  R.i-j.u R.i-j.v							delete first R
                     *  R.i-j.u R.x-y.v	| x-y in i-j			ERROR
                     *  R.i-j.u R.x-y.v	| boundaries overlap	ERROR
                     *
                     *  Delete special case of replace (text==undefined):
                     *  D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
                     *
                     *  I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
                     * 											we're not deleting i)
                     *  I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
                     *  R.x-y.v I.i.u | i in x-y				ERROR
                     *  R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
                     *  R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
                     *
                     *  I.i.u = insert u before op @ index i
                     *  R.x-y.u = replace x-y indexed tokens with u
                     *
                     *  First we need to examine replaces. For any replace op:
                     *
                     * 		1. wipe out any insertions before op within that range.
                     * 		2. Drop any replace op before that is contained completely within
                     * 	 that range.
                     * 		3. Throw exception upon boundary overlap with any previous replace.
                     *
                     *  Then we can deal with inserts:
                     *
                     * 		1. for any inserts to same index, combine even if not adjacent.
                     * 		2. for any prior replace with same left boundary, combine this
                     * 	 insert with replace and delete this replace.
                     * 		3. throw exception if index in same range as previous replace
                     *
                     *  Don't actually delete; make op undefined in list. Easier to walk list.
                     *  Later we can throw as we add to index &rarr; op map.
                     *
                     *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
                     *  inserted stuff would be before the replace range. But, if you
                     *  add tokens in front of a method body '{' and then delete the method
                     *  body, I think the stuff before the '{' you added should disappear too.
                     *
                     *  Return a map from token index to operation.
                     */
                    reduceToSingleOperationPerIndex(rewrites) {
                      for (let i = 0; i < rewrites.length; i++) {
                        let op = rewrites[i];
                        if (op == null) {
                          continue;
                        }
                        if (!(op instanceof ReplaceOp)) {
                          continue;
                        }
                        let rop = op;
                        let inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
                        for (let iop of inserts) {
                          if (iop.index === rop.index) {
                            rewrites[iop.instructionIndex] = void 0;
                            rop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : "");
                          } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
                            rewrites[iop.instructionIndex] = void 0;
                          }
                        }
                        let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
                        for (let prevRop of prevReplaces) {
                          if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
                            rewrites[prevRop.instructionIndex] = void 0;
                            continue;
                          }
                          let disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
                          if (prevRop.text == null && rop.text == null && !disjoint) {
                            rewrites[prevRop.instructionIndex] = void 0;
                            rop.index = Math.min(prevRop.index, rop.index);
                            rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
                          } else if (!disjoint) {
                            throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);
                          }
                        }
                      }
                      for (let i = 0; i < rewrites.length; i++) {
                        let op = rewrites[i];
                        if (op == null) {
                          continue;
                        }
                        if (!(op instanceof InsertBeforeOp)) {
                          continue;
                        }
                        let iop = op;
                        let prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
                        for (let prevIop of prevInserts) {
                          if (prevIop.index === iop.index) {
                            if (prevIop instanceof InsertAfterOp) {
                              iop.text = this.catOpText(prevIop.text, iop.text);
                              rewrites[prevIop.instructionIndex] = void 0;
                            } else if (prevIop instanceof InsertBeforeOp) {
                              iop.text = this.catOpText(iop.text, prevIop.text);
                              rewrites[prevIop.instructionIndex] = void 0;
                            }
                          }
                        }
                        let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
                        for (let rop of prevReplaces) {
                          if (iop.index === rop.index) {
                            rop.text = this.catOpText(iop.text, rop.text);
                            rewrites[i] = void 0;
                            continue;
                          }
                          if (iop.index >= rop.index && iop.index <= rop.lastIndex) {
                            throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);
                          }
                        }
                      }
                      let m = /* @__PURE__ */ new Map();
                      for (let op of rewrites) {
                        if (op == null) {
                          continue;
                        }
                        if (m.get(op.index) != null) {
                          throw new Error("should only be one op per index");
                        }
                        m.set(op.index, op);
                      }
                      return m;
                    }
                    catOpText(a, b) {
                      let x = "";
                      let y = "";
                      if (a != null) {
                        x = a.toString();
                      }
                      if (b != null) {
                        y = b.toString();
                      }
                      return x + y;
                    }
                    /** Get all operations before an index of a particular kind */
                    getKindOfOps(rewrites, kind, before) {
                      let ops = [];
                      for (let i = 0; i < before && i < rewrites.length; i++) {
                        let op = rewrites[i];
                        if (op == null) {
                          continue;
                        }
                        if (op instanceof kind) {
                          ops.push(op);
                        }
                      }
                      return ops;
                    }
                  }
                  exports2.TokenStreamRewriter = TokenStreamRewriter;
                  TokenStreamRewriter.DEFAULT_PROGRAM_NAME = "default";
                  TokenStreamRewriter.PROGRAM_INIT_SIZE = 100;
                  TokenStreamRewriter.MIN_TOKEN_INDEX = 0;
                  class RewriteOperation {
                    constructor(tokens, index, instructionIndex, text) {
                      this.tokens = tokens;
                      this.instructionIndex = instructionIndex;
                      this.index = index;
                      this.text = text === void 0 ? "" : text;
                    }
                    /** Execute the rewrite operation by possibly adding to the buffer.
                     *  Return the index of the next token to operate on.
                     */
                    execute(buf) {
                      return this.index;
                    }
                    toString() {
                      let opName = this.constructor.name;
                      let $index = opName.indexOf("$");
                      opName = opName.substring($index + 1, opName.length);
                      return "<" + opName + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], RewriteOperation.prototype, "toString", null);
                  exports2.RewriteOperation = RewriteOperation;
                  class InsertBeforeOp extends RewriteOperation {
                    constructor(tokens, index, instructionIndex, text) {
                      super(tokens, index, instructionIndex, text);
                    }
                    execute(buf) {
                      buf.push(this.text.toString());
                      if (this.tokens.get(this.index).type !== Token_1.Token.EOF) {
                        buf.push(String(this.tokens.get(this.index).text));
                      }
                      return this.index + 1;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], InsertBeforeOp.prototype, "execute", null);
                  class InsertAfterOp extends InsertBeforeOp {
                    constructor(tokens, index, instructionIndex, text) {
                      super(tokens, index + 1, instructionIndex, text);
                    }
                  }
                  class ReplaceOp extends RewriteOperation {
                    constructor(tokens, from, to, instructionIndex, text) {
                      super(tokens, from, instructionIndex, text);
                      this.lastIndex = to;
                    }
                    execute(buf) {
                      if (this.text != null) {
                        buf.push(this.text.toString());
                      }
                      return this.lastIndex + 1;
                    }
                    toString() {
                      if (this.text == null) {
                        return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
                      }
                      return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], ReplaceOp.prototype, "execute", null);
                  __decorate([
                    Decorators_1.Override
                  ], ReplaceOp.prototype, "toString", null);
                }
              ),
              /***/
              "./node_modules/antlr4ts/Vocabulary.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/antlr4ts/Vocabulary.js ***!
                  \*********************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                }
              ),
              /***/
              "./node_modules/antlr4ts/VocabularyImpl.js": (
                /*!*************************************************!*\
                  !*** ./node_modules/antlr4ts/VocabularyImpl.js ***!
                  \*************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.VocabularyImpl = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ./Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  class VocabularyImpl {
                    /**
                     * Constructs a new instance of {@link VocabularyImpl} from the specified
                     * literal, symbolic, and display token names.
                     *
                     * @param literalNames The literal names assigned to tokens, or an empty array
                     * if no literal names are assigned.
                     * @param symbolicNames The symbolic names assigned to tokens, or
                     * an empty array if no symbolic names are assigned.
                     * @param displayNames The display names assigned to tokens, or an empty array
                     * to use the values in `literalNames` and `symbolicNames` as
                     * the source of display names, as described in
                     * {@link #getDisplayName(int)}.
                     *
                     * @see #getLiteralName(int)
                     * @see #getSymbolicName(int)
                     * @see #getDisplayName(int)
                     */
                    constructor(literalNames, symbolicNames, displayNames) {
                      this.literalNames = literalNames;
                      this.symbolicNames = symbolicNames;
                      this.displayNames = displayNames;
                      this._maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
                    }
                    get maxTokenType() {
                      return this._maxTokenType;
                    }
                    getLiteralName(tokenType) {
                      if (tokenType >= 0 && tokenType < this.literalNames.length) {
                        return this.literalNames[tokenType];
                      }
                      return void 0;
                    }
                    getSymbolicName(tokenType) {
                      if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
                        return this.symbolicNames[tokenType];
                      }
                      if (tokenType === Token_1.Token.EOF) {
                        return "EOF";
                      }
                      return void 0;
                    }
                    getDisplayName(tokenType) {
                      if (tokenType >= 0 && tokenType < this.displayNames.length) {
                        let displayName = this.displayNames[tokenType];
                        if (displayName) {
                          return displayName;
                        }
                      }
                      let literalName = this.getLiteralName(tokenType);
                      if (literalName) {
                        return literalName;
                      }
                      let symbolicName = this.getSymbolicName(tokenType);
                      if (symbolicName) {
                        return symbolicName;
                      }
                      return String(tokenType);
                    }
                  }
                  VocabularyImpl.EMPTY_VOCABULARY = new VocabularyImpl([], [], []);
                  __decorate([
                    Decorators_1.NotNull
                  ], VocabularyImpl.prototype, "literalNames", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], VocabularyImpl.prototype, "symbolicNames", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], VocabularyImpl.prototype, "displayNames", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], VocabularyImpl.prototype, "maxTokenType", null);
                  __decorate([
                    Decorators_1.Override
                  ], VocabularyImpl.prototype, "getLiteralName", null);
                  __decorate([
                    Decorators_1.Override
                  ], VocabularyImpl.prototype, "getSymbolicName", null);
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull
                  ], VocabularyImpl.prototype, "getDisplayName", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], VocabularyImpl, "EMPTY_VOCABULARY", void 0);
                  exports2.VocabularyImpl = VocabularyImpl;
                }
              ),
              /***/
              "./node_modules/antlr4ts/WritableToken.js": (
                /*!************************************************!*\
                  !*** ./node_modules/antlr4ts/WritableToken.js ***!
                  \************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ATN.js": (
                /*!******************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ATN.js ***!
                  \******************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ATN = void 0;
                  const Array2DHashMap_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashMap */
                    "./node_modules/antlr4ts/misc/Array2DHashMap.js"
                  );
                  const DFA_1 = __webpack_require__2(
                    /*! ../dfa/DFA */
                    "./node_modules/antlr4ts/dfa/DFA.js"
                  );
                  const IntervalSet_1 = __webpack_require__2(
                    /*! ../misc/IntervalSet */
                    "./node_modules/antlr4ts/misc/IntervalSet.js"
                  );
                  const InvalidState_1 = __webpack_require__2(
                    /*! ./InvalidState */
                    "./node_modules/antlr4ts/atn/InvalidState.js"
                  );
                  const LL1Analyzer_1 = __webpack_require__2(
                    /*! ./LL1Analyzer */
                    "./node_modules/antlr4ts/atn/LL1Analyzer.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ObjectEqualityComparator_1 = __webpack_require__2(
                    /*! ../misc/ObjectEqualityComparator */
                    "./node_modules/antlr4ts/misc/ObjectEqualityComparator.js"
                  );
                  const PredictionContext_1 = __webpack_require__2(
                    /*! ./PredictionContext */
                    "./node_modules/antlr4ts/atn/PredictionContext.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  let ATN = class ATN {
                    /** Used for runtime deserialization of ATNs from strings */
                    constructor(grammarType, maxTokenType) {
                      this.states = [];
                      this.decisionToState = [];
                      this.modeNameToStartState = /* @__PURE__ */ new Map();
                      this.modeToStartState = [];
                      this.contextCache = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
                      this.decisionToDFA = [];
                      this.modeToDFA = [];
                      this.LL1Table = /* @__PURE__ */ new Map();
                      this.grammarType = grammarType;
                      this.maxTokenType = maxTokenType;
                    }
                    clearDFA() {
                      this.decisionToDFA = new Array(this.decisionToState.length);
                      for (let i = 0; i < this.decisionToDFA.length; i++) {
                        this.decisionToDFA[i] = new DFA_1.DFA(this.decisionToState[i], i);
                      }
                      this.modeToDFA = new Array(this.modeToStartState.length);
                      for (let i = 0; i < this.modeToDFA.length; i++) {
                        this.modeToDFA[i] = new DFA_1.DFA(this.modeToStartState[i]);
                      }
                      this.contextCache.clear();
                      this.LL1Table.clear();
                    }
                    get contextCacheSize() {
                      return this.contextCache.size;
                    }
                    getCachedContext(context) {
                      return PredictionContext_1.PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext_1.PredictionContext.IdentityHashMap());
                    }
                    getDecisionToDFA() {
                      assert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);
                      return this.decisionToDFA;
                    }
                    nextTokens(s, ctx) {
                      if (ctx) {
                        let anal = new LL1Analyzer_1.LL1Analyzer(this);
                        let next = anal.LOOK(s, ctx);
                        return next;
                      } else {
                        if (s.nextTokenWithinRule) {
                          return s.nextTokenWithinRule;
                        }
                        s.nextTokenWithinRule = this.nextTokens(s, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
                        s.nextTokenWithinRule.setReadonly(true);
                        return s.nextTokenWithinRule;
                      }
                    }
                    addState(state) {
                      state.atn = this;
                      state.stateNumber = this.states.length;
                      this.states.push(state);
                    }
                    removeState(state) {
                      let invalidState = new InvalidState_1.InvalidState();
                      invalidState.atn = this;
                      invalidState.stateNumber = state.stateNumber;
                      this.states[state.stateNumber] = invalidState;
                    }
                    defineMode(name, s) {
                      this.modeNameToStartState.set(name, s);
                      this.modeToStartState.push(s);
                      this.modeToDFA.push(new DFA_1.DFA(s));
                      this.defineDecisionState(s);
                    }
                    defineDecisionState(s) {
                      this.decisionToState.push(s);
                      s.decision = this.decisionToState.length - 1;
                      this.decisionToDFA.push(new DFA_1.DFA(s, s.decision));
                      return s.decision;
                    }
                    getDecisionState(decision) {
                      if (this.decisionToState.length > 0) {
                        return this.decisionToState[decision];
                      }
                      return void 0;
                    }
                    get numberOfDecisions() {
                      return this.decisionToState.length;
                    }
                    /**
                     * Computes the set of input symbols which could follow ATN state number
                     * `stateNumber` in the specified full `context`. This method
                     * considers the complete parser context, but does not evaluate semantic
                     * predicates (i.e. all predicates encountered during the calculation are
                     * assumed true). If a path in the ATN exists from the starting state to the
                     * {@link RuleStopState} of the outermost context without matching any
                     * symbols, {@link Token#EOF} is added to the returned set.
                     *
                     * If `context` is `undefined`, it is treated as
                     * {@link ParserRuleContext#EMPTY}.
                     *
                     * Note that this does NOT give you the set of all tokens that could
                     * appear at a given token position in the input phrase.  In other words, it
                     * does not answer:
                     *
                     * > Given a specific partial input phrase, return the set of all
                     * > tokens that can follow the last token in the input phrase.
                     *
                     * The big difference is that with just the input, the parser could land
                     * right in the middle of a lookahead decision. Getting all
                     * *possible* tokens given a partial input stream is a separate
                     * computation. See https://github.com/antlr/antlr4/issues/1428
                     *
                     * For this function, we are specifying an ATN state and call stack to
                     * compute what token(s) can come next and specifically: outside of a
                     * lookahead decision. That is what you want for error reporting and
                     * recovery upon parse error.
                     *
                     * @param stateNumber the ATN state number
                     * @param context the full parse context
                     * @returns The set of potentially valid input symbols which could follow the
                     * specified state in the specified context.
                     * @ if the ATN does not contain a state with
                     * number `stateNumber`
                     */
                    getExpectedTokens(stateNumber, context) {
                      if (stateNumber < 0 || stateNumber >= this.states.length) {
                        throw new RangeError("Invalid state number.");
                      }
                      let ctx = context;
                      let s = this.states[stateNumber];
                      let following = this.nextTokens(s);
                      if (!following.contains(Token_1.Token.EPSILON)) {
                        return following;
                      }
                      let expected = new IntervalSet_1.IntervalSet();
                      expected.addAll(following);
                      expected.remove(Token_1.Token.EPSILON);
                      while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
                        let invokingState = this.states[ctx.invokingState];
                        let rt = invokingState.transition(0);
                        following = this.nextTokens(rt.followState);
                        expected.addAll(following);
                        expected.remove(Token_1.Token.EPSILON);
                        ctx = ctx._parent;
                      }
                      if (following.contains(Token_1.Token.EPSILON)) {
                        expected.add(Token_1.Token.EOF);
                      }
                      return expected;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], ATN.prototype, "states", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ATN.prototype, "decisionToState", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ATN.prototype, "modeNameToStartState", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ATN.prototype, "modeToStartState", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ATN.prototype, "decisionToDFA", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ATN.prototype, "modeToDFA", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ATN.prototype, "nextTokens", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ATN.prototype, "removeState", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ATN.prototype, "defineMode", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ATN.prototype, "defineDecisionState", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ATN.prototype, "getExpectedTokens", null);
                  ATN = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ATN);
                  exports2.ATN = ATN;
                  (function(ATN2) {
                    ATN2.INVALID_ALT_NUMBER = 0;
                  })(ATN = exports2.ATN || (exports2.ATN = {}));
                  exports2.ATN = ATN;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ATNConfig.js": (
                /*!************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ATNConfig.js ***!
                  \************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ATNConfig = void 0;
                  const Array2DHashMap_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashMap */
                    "./node_modules/antlr4ts/misc/Array2DHashMap.js"
                  );
                  const DecisionState_1 = __webpack_require__2(
                    /*! ./DecisionState */
                    "./node_modules/antlr4ts/atn/DecisionState.js"
                  );
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ObjectEqualityComparator_1 = __webpack_require__2(
                    /*! ../misc/ObjectEqualityComparator */
                    "./node_modules/antlr4ts/misc/ObjectEqualityComparator.js"
                  );
                  const PredictionContext_1 = __webpack_require__2(
                    /*! ./PredictionContext */
                    "./node_modules/antlr4ts/atn/PredictionContext.js"
                  );
                  const SemanticContext_1 = __webpack_require__2(
                    /*! ./SemanticContext */
                    "./node_modules/antlr4ts/atn/SemanticContext.js"
                  );
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  const SUPPRESS_PRECEDENCE_FILTER = 2147483648;
                  let ATNConfig = class ATNConfig2 {
                    constructor(state, altOrConfig, context) {
                      if (typeof altOrConfig === "number") {
                        assert((altOrConfig & 16777215) === altOrConfig);
                        this._state = state;
                        this.altAndOuterContextDepth = altOrConfig;
                        this._context = context;
                      } else {
                        this._state = state;
                        this.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;
                        this._context = context;
                      }
                    }
                    static create(state, alt, context, semanticContext = SemanticContext_1.SemanticContext.NONE, lexerActionExecutor) {
                      if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
                        if (lexerActionExecutor != null) {
                          return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);
                        } else {
                          return new SemanticContextATNConfig(semanticContext, state, alt, context);
                        }
                      } else if (lexerActionExecutor != null) {
                        return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);
                      } else {
                        return new ATNConfig2(state, alt, context);
                      }
                    }
                    /** Gets the ATN state associated with this configuration */
                    get state() {
                      return this._state;
                    }
                    /** What alt (or lexer rule) is predicted by this configuration */
                    get alt() {
                      return this.altAndOuterContextDepth & 16777215;
                    }
                    get context() {
                      return this._context;
                    }
                    set context(context) {
                      this._context = context;
                    }
                    get reachesIntoOuterContext() {
                      return this.outerContextDepth !== 0;
                    }
                    /**
                     * We cannot execute predicates dependent upon local context unless
                     * we know for sure we are in the correct context. Because there is
                     * no way to do this efficiently, we simply cannot evaluate
                     * dependent predicates unless we are in the rule that initially
                     * invokes the ATN simulator.
                     *
                     * closure() tracks the depth of how far we dip into the outer context:
                     * depth &gt; 0.  Note that it may not be totally accurate depth since I
                     * don't ever decrement. TODO: make it a boolean then
                     */
                    get outerContextDepth() {
                      return this.altAndOuterContextDepth >>> 24 & 127;
                    }
                    set outerContextDepth(outerContextDepth) {
                      assert(outerContextDepth >= 0);
                      outerContextDepth = Math.min(outerContextDepth, 127);
                      this.altAndOuterContextDepth = outerContextDepth << 24 | (this.altAndOuterContextDepth & ~2130706432) >>> 0;
                    }
                    get lexerActionExecutor() {
                      return void 0;
                    }
                    get semanticContext() {
                      return SemanticContext_1.SemanticContext.NONE;
                    }
                    get hasPassedThroughNonGreedyDecision() {
                      return false;
                    }
                    clone() {
                      return this.transform(this.state, false);
                    }
                    transform(state, checkNonGreedy, arg2) {
                      if (arg2 == null) {
                        return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
                      } else if (arg2 instanceof PredictionContext_1.PredictionContext) {
                        return this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
                      } else if (arg2 instanceof SemanticContext_1.SemanticContext) {
                        return this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);
                      } else {
                        return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);
                      }
                    }
                    transformImpl(state, context, semanticContext, checkNonGreedy, lexerActionExecutor) {
                      let passedThroughNonGreedy = checkNonGreedy && ATNConfig2.checkNonGreedyDecision(this, state);
                      if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
                        if (lexerActionExecutor != null || passedThroughNonGreedy) {
                          return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);
                        } else {
                          return new SemanticContextATNConfig(semanticContext, state, this, context);
                        }
                      } else if (lexerActionExecutor != null || passedThroughNonGreedy) {
                        return new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);
                      } else {
                        return new ATNConfig2(state, this, context);
                      }
                    }
                    static checkNonGreedyDecision(source, target) {
                      return source.hasPassedThroughNonGreedyDecision || target instanceof DecisionState_1.DecisionState && target.nonGreedy;
                    }
                    appendContext(context, contextCache) {
                      if (typeof context === "number") {
                        let appendedContext = this.context.appendSingleContext(context, contextCache);
                        let result = this.transform(this.state, false, appendedContext);
                        return result;
                      } else {
                        let appendedContext = this.context.appendContext(context, contextCache);
                        let result = this.transform(this.state, false, appendedContext);
                        return result;
                      }
                    }
                    /**
                     * Determines if this `ATNConfig` fully contains another `ATNConfig`.
                     *
                     * An ATN configuration represents a position (including context) in an ATN during parsing. Since `ATNConfig` stores
                     * the context as a graph, a single `ATNConfig` instance is capable of representing many ATN configurations which
                     * are all in the same "location" but have different contexts. These `ATNConfig` instances are again merged when
                     * they are added to an `ATNConfigSet`. This method supports `ATNConfigSet.contains` by evaluating whether a
                     * particular `ATNConfig` contains all of the ATN configurations represented by another `ATNConfig`.
                     *
                     * An `ATNConfig` _a_ contains another `ATNConfig` _b_ if all of the following conditions are met:
                     *
                     * * The configurations are in the same state (`state`)
                     * * The configurations predict the same alternative (`alt`)
                     * * The semantic context of _a_ implies the semantic context of _b_ (this method performs a weaker equality check)
                     * * Joining the prediction contexts of _a_ and _b_ results in the prediction context of _a_
                     *
                     * This method implements a conservative approximation of containment. As a result, when this method returns `true`
                     * it is known that parsing from `subconfig` can only recognize a subset of the inputs which can be recognized
                     * starting at the current `ATNConfig`. However, due to the imprecise evaluation of implication for the semantic
                     * contexts, no assumptions can be made about the relationship between the configurations when this method returns
                     * `false`.
                     *
                     * @param subconfig The sub configuration.
                     * @returns `true` if this configuration contains `subconfig`; otherwise, `false`.
                     */
                    contains(subconfig) {
                      if (this.state.stateNumber !== subconfig.state.stateNumber || this.alt !== subconfig.alt || !this.semanticContext.equals(subconfig.semanticContext)) {
                        return false;
                      }
                      let leftWorkList = [];
                      let rightWorkList = [];
                      leftWorkList.push(this.context);
                      rightWorkList.push(subconfig.context);
                      while (true) {
                        let left = leftWorkList.pop();
                        let right = rightWorkList.pop();
                        if (!left || !right) {
                          break;
                        }
                        if (left === right) {
                          return true;
                        }
                        if (left.size < right.size) {
                          return false;
                        }
                        if (right.isEmpty) {
                          return left.hasEmpty;
                        } else {
                          for (let i = 0; i < right.size; i++) {
                            let index = left.findReturnState(right.getReturnState(i));
                            if (index < 0) {
                              return false;
                            }
                            leftWorkList.push(left.getParent(index));
                            rightWorkList.push(right.getParent(i));
                          }
                        }
                      }
                      return false;
                    }
                    get isPrecedenceFilterSuppressed() {
                      return (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;
                    }
                    set isPrecedenceFilterSuppressed(value) {
                      if (value) {
                        this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;
                      } else {
                        this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;
                      }
                    }
                    /** An ATN configuration is equal to another if both have
                     *  the same state, they predict the same alternative, and
                     *  syntactic/semantic contexts are the same.
                     */
                    equals(o) {
                      if (this === o) {
                        return true;
                      } else if (!(o instanceof ATNConfig2)) {
                        return false;
                      }
                      return this.state.stateNumber === o.state.stateNumber && this.alt === o.alt && this.reachesIntoOuterContext === o.reachesIntoOuterContext && this.context.equals(o.context) && this.semanticContext.equals(o.semanticContext) && this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed && this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision && ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);
                    }
                    hashCode() {
                      let hashCode = MurmurHash_1.MurmurHash.initialize(7);
                      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.state.stateNumber);
                      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.alt);
                      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);
                      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.context);
                      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.semanticContext);
                      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);
                      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.lexerActionExecutor);
                      hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 7);
                      return hashCode;
                    }
                    /**
                     * Returns a graphical representation of the current `ATNConfig` in Graphviz format. The graph can be stored to a
                     * **.dot** file and then rendered to an image using Graphviz.
                     *
                     * @returns A Graphviz graph representing the current `ATNConfig`.
                     *
                     * @see http://www.graphviz.org/
                     */
                    toDotString() {
                      let builder = "";
                      builder += "digraph G {\n";
                      builder += "rankdir=LR;\n";
                      let visited = new Array2DHashMap_1.Array2DHashMap(PredictionContext_1.PredictionContext.IdentityEqualityComparator.INSTANCE);
                      let workList = [];
                      function getOrAddContext(context) {
                        let newNumber = visited.size;
                        let result = visited.putIfAbsent(context, newNumber);
                        if (result != null) {
                          return result;
                        }
                        workList.push(context);
                        return newNumber;
                      }
                      workList.push(this.context);
                      visited.put(this.context, 0);
                      while (true) {
                        let current = workList.pop();
                        if (!current) {
                          break;
                        }
                        for (let i = 0; i < current.size; i++) {
                          builder += "  s" + getOrAddContext(current);
                          builder += "->";
                          builder += "s" + getOrAddContext(current.getParent(i));
                          builder += '[label="' + current.getReturnState(i) + '"];\n';
                        }
                      }
                      builder += "}\n";
                      return builder.toString();
                    }
                    toString(recog, showAlt, showContext) {
                      if (showContext == null) {
                        showContext = showAlt != null;
                      }
                      if (showAlt == null) {
                        showAlt = true;
                      }
                      let buf = "";
                      let contexts;
                      if (showContext) {
                        contexts = this.context.toStrings(recog, this.state.stateNumber);
                      } else {
                        contexts = ["?"];
                      }
                      let first = true;
                      for (let contextDesc of contexts) {
                        if (first) {
                          first = false;
                        } else {
                          buf += ", ";
                        }
                        buf += "(";
                        buf += this.state;
                        if (showAlt) {
                          buf += ",";
                          buf += this.alt;
                        }
                        if (this.context) {
                          buf += ",";
                          buf += contextDesc;
                        }
                        if (this.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
                          buf += ",";
                          buf += this.semanticContext;
                        }
                        if (this.reachesIntoOuterContext) {
                          buf += ",up=" + this.outerContextDepth;
                        }
                        buf += ")";
                      }
                      return buf.toString();
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], ATNConfig.prototype, "_state", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ATNConfig.prototype, "_context", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ATNConfig.prototype, "state", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], ATNConfig.prototype, "context", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ATNConfig.prototype, "semanticContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfig.prototype, "clone", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ATNConfig.prototype, "transformImpl", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfig.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfig.prototype, "hashCode", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(3, Decorators_1.NotNull)
                  ], ATNConfig, "create", null);
                  ATNConfig = __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ATNConfig);
                  exports2.ATNConfig = ATNConfig;
                  let SemanticContextATNConfig = class SemanticContextATNConfig extends ATNConfig {
                    constructor(semanticContext, state, altOrConfig, context) {
                      if (typeof altOrConfig === "number") {
                        super(state, altOrConfig, context);
                      } else {
                        super(state, altOrConfig, context);
                      }
                      this._semanticContext = semanticContext;
                    }
                    get semanticContext() {
                      return this._semanticContext;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], SemanticContextATNConfig.prototype, "_semanticContext", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], SemanticContextATNConfig.prototype, "semanticContext", null);
                  SemanticContextATNConfig = __decorate([
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], SemanticContextATNConfig);
                  let ActionATNConfig = class ActionATNConfig extends ATNConfig {
                    constructor(lexerActionExecutor, state, altOrConfig, context, passedThroughNonGreedyDecision) {
                      if (typeof altOrConfig === "number") {
                        super(state, altOrConfig, context);
                      } else {
                        super(state, altOrConfig, context);
                        if (altOrConfig.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
                          throw new Error("Not supported");
                        }
                      }
                      this._lexerActionExecutor = lexerActionExecutor;
                      this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
                    }
                    get lexerActionExecutor() {
                      return this._lexerActionExecutor;
                    }
                    get hasPassedThroughNonGreedyDecision() {
                      return this.passedThroughNonGreedyDecision;
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], ActionATNConfig.prototype, "lexerActionExecutor", null);
                  __decorate([
                    Decorators_1.Override
                  ], ActionATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
                  ActionATNConfig = __decorate([
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ActionATNConfig);
                  let ActionSemanticContextATNConfig = class ActionSemanticContextATNConfig extends SemanticContextATNConfig {
                    constructor(lexerActionExecutor, semanticContext, state, altOrConfig, context, passedThroughNonGreedyDecision) {
                      if (typeof altOrConfig === "number") {
                        super(semanticContext, state, altOrConfig, context);
                      } else {
                        super(semanticContext, state, altOrConfig, context);
                      }
                      this._lexerActionExecutor = lexerActionExecutor;
                      this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
                    }
                    get lexerActionExecutor() {
                      return this._lexerActionExecutor;
                    }
                    get hasPassedThroughNonGreedyDecision() {
                      return this.passedThroughNonGreedyDecision;
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], ActionSemanticContextATNConfig.prototype, "lexerActionExecutor", null);
                  __decorate([
                    Decorators_1.Override
                  ], ActionSemanticContextATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
                  ActionSemanticContextATNConfig = __decorate([
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ActionSemanticContextATNConfig);
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ATNConfigSet.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ATNConfigSet.js ***!
                  \***************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ATNConfigSet = void 0;
                  const Array2DHashMap_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashMap */
                    "./node_modules/antlr4ts/misc/Array2DHashMap.js"
                  );
                  const Array2DHashSet_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashSet */
                    "./node_modules/antlr4ts/misc/Array2DHashSet.js"
                  );
                  const ArrayEqualityComparator_1 = __webpack_require__2(
                    /*! ../misc/ArrayEqualityComparator */
                    "./node_modules/antlr4ts/misc/ArrayEqualityComparator.js"
                  );
                  const ATN_1 = __webpack_require__2(
                    /*! ./ATN */
                    "./node_modules/antlr4ts/atn/ATN.js"
                  );
                  const ATNConfig_1 = __webpack_require__2(
                    /*! ./ATNConfig */
                    "./node_modules/antlr4ts/atn/ATNConfig.js"
                  );
                  const BitSet_1 = __webpack_require__2(
                    /*! ../misc/BitSet */
                    "./node_modules/antlr4ts/misc/BitSet.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ObjectEqualityComparator_1 = __webpack_require__2(
                    /*! ../misc/ObjectEqualityComparator */
                    "./node_modules/antlr4ts/misc/ObjectEqualityComparator.js"
                  );
                  const PredictionContext_1 = __webpack_require__2(
                    /*! ./PredictionContext */
                    "./node_modules/antlr4ts/atn/PredictionContext.js"
                  );
                  const PredictionContextCache_1 = __webpack_require__2(
                    /*! ./PredictionContextCache */
                    "./node_modules/antlr4ts/atn/PredictionContextCache.js"
                  );
                  const SemanticContext_1 = __webpack_require__2(
                    /*! ./SemanticContext */
                    "./node_modules/antlr4ts/atn/SemanticContext.js"
                  );
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  const Utils = __webpack_require__2(
                    /*! ../misc/Utils */
                    "./node_modules/antlr4ts/misc/Utils.js"
                  );
                  class KeyTypeEqualityComparer {
                    hashCode(key) {
                      return key.state ^ key.alt;
                    }
                    equals(a, b) {
                      return a.state === b.state && a.alt === b.alt;
                    }
                  }
                  KeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer();
                  function NewKeyedConfigMap(map2) {
                    if (map2) {
                      return new Array2DHashMap_1.Array2DHashMap(map2);
                    } else {
                      return new Array2DHashMap_1.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE);
                    }
                  }
                  class ATNConfigSet {
                    constructor(set2, readonly) {
                      this._uniqueAlt = 0;
                      this._hasSemanticContext = false;
                      this._dipsIntoOuterContext = false;
                      this.outermostConfigSet = false;
                      this.cachedHashCode = -1;
                      if (!set2) {
                        this.mergedConfigs = NewKeyedConfigMap();
                        this.unmerged = [];
                        this.configs = [];
                        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
                      } else {
                        if (readonly) {
                          this.mergedConfigs = void 0;
                          this.unmerged = void 0;
                        } else if (!set2.isReadOnly) {
                          this.mergedConfigs = NewKeyedConfigMap(set2.mergedConfigs);
                          this.unmerged = set2.unmerged.slice(0);
                        } else {
                          this.mergedConfigs = NewKeyedConfigMap();
                          this.unmerged = [];
                        }
                        this.configs = set2.configs.slice(0);
                        this._dipsIntoOuterContext = set2._dipsIntoOuterContext;
                        this._hasSemanticContext = set2._hasSemanticContext;
                        this.outermostConfigSet = set2.outermostConfigSet;
                        if (readonly || !set2.isReadOnly) {
                          this._uniqueAlt = set2._uniqueAlt;
                          this._conflictInfo = set2._conflictInfo;
                        }
                      }
                    }
                    /**
                     * Get the set of all alternatives represented by configurations in this
                     * set.
                     */
                    getRepresentedAlternatives() {
                      if (this._conflictInfo != null) {
                        return this._conflictInfo.conflictedAlts.clone();
                      }
                      let alts = new BitSet_1.BitSet();
                      for (let config of this) {
                        alts.set(config.alt);
                      }
                      return alts;
                    }
                    get isReadOnly() {
                      return this.mergedConfigs == null;
                    }
                    get isOutermostConfigSet() {
                      return this.outermostConfigSet;
                    }
                    set isOutermostConfigSet(outermostConfigSet) {
                      if (this.outermostConfigSet && !outermostConfigSet) {
                        throw new Error("IllegalStateException");
                      }
                      assert(!outermostConfigSet || !this._dipsIntoOuterContext);
                      this.outermostConfigSet = outermostConfigSet;
                    }
                    getStates() {
                      let states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
                      for (let c of this.configs) {
                        states.add(c.state);
                      }
                      return states;
                    }
                    optimizeConfigs(interpreter) {
                      if (this.configs.length === 0) {
                        return;
                      }
                      for (let config of this.configs) {
                        config.context = interpreter.atn.getCachedContext(config.context);
                      }
                    }
                    clone(readonly) {
                      let copy = new ATNConfigSet(this, readonly);
                      if (!readonly && this.isReadOnly) {
                        copy.addAll(this.configs);
                      }
                      return copy;
                    }
                    get size() {
                      return this.configs.length;
                    }
                    get isEmpty() {
                      return this.configs.length === 0;
                    }
                    contains(o) {
                      if (!(o instanceof ATNConfig_1.ATNConfig)) {
                        return false;
                      }
                      if (this.mergedConfigs && this.unmerged) {
                        let config = o;
                        let configKey = this.getKey(config);
                        let mergedConfig = this.mergedConfigs.get(configKey);
                        if (mergedConfig != null && this.canMerge(config, configKey, mergedConfig)) {
                          return mergedConfig.contains(config);
                        }
                        for (let c of this.unmerged) {
                          if (c.contains(o)) {
                            return true;
                          }
                        }
                      } else {
                        for (let c of this.configs) {
                          if (c.contains(o)) {
                            return true;
                          }
                        }
                      }
                      return false;
                    }
                    *[Symbol.iterator]() {
                      yield* this.configs;
                    }
                    toArray() {
                      return this.configs;
                    }
                    add(e, contextCache) {
                      this.ensureWritable();
                      if (!this.mergedConfigs || !this.unmerged) {
                        throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
                      }
                      assert(!this.outermostConfigSet || !e.reachesIntoOuterContext);
                      if (contextCache == null) {
                        contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
                      }
                      let addKey;
                      let key = this.getKey(e);
                      let mergedConfig = this.mergedConfigs.get(key);
                      addKey = mergedConfig == null;
                      if (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {
                        mergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);
                        if (e.isPrecedenceFilterSuppressed) {
                          mergedConfig.isPrecedenceFilterSuppressed = true;
                        }
                        let joined = PredictionContext_1.PredictionContext.join(mergedConfig.context, e.context, contextCache);
                        this.updatePropertiesForMergedConfig(e);
                        if (mergedConfig.context === joined) {
                          return false;
                        }
                        mergedConfig.context = joined;
                        return true;
                      }
                      for (let i = 0; i < this.unmerged.length; i++) {
                        let unmergedConfig = this.unmerged[i];
                        if (this.canMerge(e, key, unmergedConfig)) {
                          unmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);
                          if (e.isPrecedenceFilterSuppressed) {
                            unmergedConfig.isPrecedenceFilterSuppressed = true;
                          }
                          let joined = PredictionContext_1.PredictionContext.join(unmergedConfig.context, e.context, contextCache);
                          this.updatePropertiesForMergedConfig(e);
                          if (unmergedConfig.context === joined) {
                            return false;
                          }
                          unmergedConfig.context = joined;
                          if (addKey) {
                            this.mergedConfigs.put(key, unmergedConfig);
                            this.unmerged.splice(i, 1);
                          }
                          return true;
                        }
                      }
                      this.configs.push(e);
                      if (addKey) {
                        this.mergedConfigs.put(key, e);
                      } else {
                        this.unmerged.push(e);
                      }
                      this.updatePropertiesForAddedConfig(e);
                      return true;
                    }
                    updatePropertiesForMergedConfig(config) {
                      this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
                      assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
                    }
                    updatePropertiesForAddedConfig(config) {
                      if (this.configs.length === 1) {
                        this._uniqueAlt = config.alt;
                      } else if (this._uniqueAlt !== config.alt) {
                        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
                      }
                      this._hasSemanticContext = this._hasSemanticContext || !SemanticContext_1.SemanticContext.NONE.equals(config.semanticContext);
                      this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
                      assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
                    }
                    canMerge(left, leftKey, right) {
                      if (left.state.stateNumber !== right.state.stateNumber) {
                        return false;
                      }
                      if (leftKey.alt !== right.alt) {
                        return false;
                      }
                      return left.semanticContext.equals(right.semanticContext);
                    }
                    getKey(e) {
                      return { state: e.state.stateNumber, alt: e.alt };
                    }
                    containsAll(c) {
                      for (let o of c) {
                        if (!(o instanceof ATNConfig_1.ATNConfig)) {
                          return false;
                        }
                        if (!this.contains(o)) {
                          return false;
                        }
                      }
                      return true;
                    }
                    addAll(c, contextCache) {
                      this.ensureWritable();
                      let changed = false;
                      for (let group of c) {
                        if (this.add(group, contextCache)) {
                          changed = true;
                        }
                      }
                      return changed;
                    }
                    clear() {
                      this.ensureWritable();
                      if (!this.mergedConfigs || !this.unmerged) {
                        throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
                      }
                      this.mergedConfigs.clear();
                      this.unmerged.length = 0;
                      this.configs.length = 0;
                      this._dipsIntoOuterContext = false;
                      this._hasSemanticContext = false;
                      this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
                      this._conflictInfo = void 0;
                    }
                    equals(obj) {
                      if (this === obj) {
                        return true;
                      }
                      if (!(obj instanceof ATNConfigSet)) {
                        return false;
                      }
                      return this.outermostConfigSet === obj.outermostConfigSet && Utils.equals(this._conflictInfo, obj._conflictInfo) && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);
                    }
                    hashCode() {
                      if (this.isReadOnly && this.cachedHashCode !== -1) {
                        return this.cachedHashCode;
                      }
                      let hashCode = 1;
                      hashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);
                      hashCode = 5 * hashCode ^ ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);
                      if (this.isReadOnly) {
                        this.cachedHashCode = hashCode;
                      }
                      return hashCode;
                    }
                    toString(showContext) {
                      if (showContext == null) {
                        showContext = false;
                      }
                      let buf = "";
                      let sortedConfigs = this.configs.slice(0);
                      sortedConfigs.sort((o1, o2) => {
                        if (o1.alt !== o2.alt) {
                          return o1.alt - o2.alt;
                        } else if (o1.state.stateNumber !== o2.state.stateNumber) {
                          return o1.state.stateNumber - o2.state.stateNumber;
                        } else {
                          return o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());
                        }
                      });
                      buf += "[";
                      for (let i = 0; i < sortedConfigs.length; i++) {
                        if (i > 0) {
                          buf += ", ";
                        }
                        buf += sortedConfigs[i].toString(void 0, true, showContext);
                      }
                      buf += "]";
                      if (this._hasSemanticContext) {
                        buf += ",hasSemanticContext=" + this._hasSemanticContext;
                      }
                      if (this._uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                        buf += ",uniqueAlt=" + this._uniqueAlt;
                      }
                      if (this._conflictInfo != null) {
                        buf += ",conflictingAlts=" + this._conflictInfo.conflictedAlts;
                        if (!this._conflictInfo.isExact) {
                          buf += "*";
                        }
                      }
                      if (this._dipsIntoOuterContext) {
                        buf += ",dipsIntoOuterContext";
                      }
                      return buf.toString();
                    }
                    get uniqueAlt() {
                      return this._uniqueAlt;
                    }
                    get hasSemanticContext() {
                      return this._hasSemanticContext;
                    }
                    set hasSemanticContext(value) {
                      this.ensureWritable();
                      this._hasSemanticContext = value;
                    }
                    get conflictInfo() {
                      return this._conflictInfo;
                    }
                    set conflictInfo(conflictInfo) {
                      this.ensureWritable();
                      this._conflictInfo = conflictInfo;
                    }
                    get conflictingAlts() {
                      if (this._conflictInfo == null) {
                        return void 0;
                      }
                      return this._conflictInfo.conflictedAlts;
                    }
                    get isExactConflict() {
                      if (this._conflictInfo == null) {
                        return false;
                      }
                      return this._conflictInfo.isExact;
                    }
                    get dipsIntoOuterContext() {
                      return this._dipsIntoOuterContext;
                    }
                    get(index) {
                      return this.configs[index];
                    }
                    ensureWritable() {
                      if (this.isReadOnly) {
                        throw new Error("This ATNConfigSet is read only.");
                      }
                    }
                  }
                  __decorate([
                    Decorators_1.NotNull
                  ], ATNConfigSet.prototype, "getRepresentedAlternatives", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfigSet.prototype, "size", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfigSet.prototype, "isEmpty", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfigSet.prototype, "contains", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfigSet.prototype, Symbol.iterator, null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfigSet.prototype, "toArray", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfigSet.prototype, "containsAll", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfigSet.prototype, "clear", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfigSet.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNConfigSet.prototype, "hashCode", null);
                  exports2.ATNConfigSet = ATNConfigSet;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ATNDeserializationOptions.js": (
                /*!****************************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ATNDeserializationOptions.js ***!
                  \****************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ATNDeserializationOptions = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class ATNDeserializationOptions {
                    constructor(options) {
                      this.readOnly = false;
                      if (options) {
                        this.verifyATN = options.verifyATN;
                        this.generateRuleBypassTransitions = options.generateRuleBypassTransitions;
                        this.optimize = options.optimize;
                      } else {
                        this.verifyATN = true;
                        this.generateRuleBypassTransitions = false;
                        this.optimize = true;
                      }
                    }
                    static get defaultOptions() {
                      if (ATNDeserializationOptions._defaultOptions == null) {
                        ATNDeserializationOptions._defaultOptions = new ATNDeserializationOptions();
                        ATNDeserializationOptions._defaultOptions.makeReadOnly();
                      }
                      return ATNDeserializationOptions._defaultOptions;
                    }
                    get isReadOnly() {
                      return this.readOnly;
                    }
                    makeReadOnly() {
                      this.readOnly = true;
                    }
                    get isVerifyATN() {
                      return this.verifyATN;
                    }
                    set isVerifyATN(verifyATN) {
                      this.throwIfReadOnly();
                      this.verifyATN = verifyATN;
                    }
                    get isGenerateRuleBypassTransitions() {
                      return this.generateRuleBypassTransitions;
                    }
                    set isGenerateRuleBypassTransitions(generateRuleBypassTransitions) {
                      this.throwIfReadOnly();
                      this.generateRuleBypassTransitions = generateRuleBypassTransitions;
                    }
                    get isOptimize() {
                      return this.optimize;
                    }
                    set isOptimize(optimize) {
                      this.throwIfReadOnly();
                      this.optimize = optimize;
                    }
                    throwIfReadOnly() {
                      if (this.isReadOnly) {
                        throw new Error("The object is read only.");
                      }
                    }
                  }
                  __decorate([
                    Decorators_1.NotNull
                  ], ATNDeserializationOptions, "defaultOptions", null);
                  exports2.ATNDeserializationOptions = ATNDeserializationOptions;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ATNDeserializer.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ATNDeserializer.js ***!
                  \******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ATNDeserializer = void 0;
                  const ActionTransition_1 = __webpack_require__2(
                    /*! ./ActionTransition */
                    "./node_modules/antlr4ts/atn/ActionTransition.js"
                  );
                  const Array2DHashSet_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashSet */
                    "./node_modules/antlr4ts/misc/Array2DHashSet.js"
                  );
                  const ATN_1 = __webpack_require__2(
                    /*! ./ATN */
                    "./node_modules/antlr4ts/atn/ATN.js"
                  );
                  const ATNDeserializationOptions_1 = __webpack_require__2(
                    /*! ./ATNDeserializationOptions */
                    "./node_modules/antlr4ts/atn/ATNDeserializationOptions.js"
                  );
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const AtomTransition_1 = __webpack_require__2(
                    /*! ./AtomTransition */
                    "./node_modules/antlr4ts/atn/AtomTransition.js"
                  );
                  const BasicBlockStartState_1 = __webpack_require__2(
                    /*! ./BasicBlockStartState */
                    "./node_modules/antlr4ts/atn/BasicBlockStartState.js"
                  );
                  const BasicState_1 = __webpack_require__2(
                    /*! ./BasicState */
                    "./node_modules/antlr4ts/atn/BasicState.js"
                  );
                  const BitSet_1 = __webpack_require__2(
                    /*! ../misc/BitSet */
                    "./node_modules/antlr4ts/misc/BitSet.js"
                  );
                  const BlockEndState_1 = __webpack_require__2(
                    /*! ./BlockEndState */
                    "./node_modules/antlr4ts/atn/BlockEndState.js"
                  );
                  const BlockStartState_1 = __webpack_require__2(
                    /*! ./BlockStartState */
                    "./node_modules/antlr4ts/atn/BlockStartState.js"
                  );
                  const DecisionState_1 = __webpack_require__2(
                    /*! ./DecisionState */
                    "./node_modules/antlr4ts/atn/DecisionState.js"
                  );
                  const DFA_1 = __webpack_require__2(
                    /*! ../dfa/DFA */
                    "./node_modules/antlr4ts/dfa/DFA.js"
                  );
                  const EpsilonTransition_1 = __webpack_require__2(
                    /*! ./EpsilonTransition */
                    "./node_modules/antlr4ts/atn/EpsilonTransition.js"
                  );
                  const IntervalSet_1 = __webpack_require__2(
                    /*! ../misc/IntervalSet */
                    "./node_modules/antlr4ts/misc/IntervalSet.js"
                  );
                  const InvalidState_1 = __webpack_require__2(
                    /*! ./InvalidState */
                    "./node_modules/antlr4ts/atn/InvalidState.js"
                  );
                  const LexerChannelAction_1 = __webpack_require__2(
                    /*! ./LexerChannelAction */
                    "./node_modules/antlr4ts/atn/LexerChannelAction.js"
                  );
                  const LexerCustomAction_1 = __webpack_require__2(
                    /*! ./LexerCustomAction */
                    "./node_modules/antlr4ts/atn/LexerCustomAction.js"
                  );
                  const LexerModeAction_1 = __webpack_require__2(
                    /*! ./LexerModeAction */
                    "./node_modules/antlr4ts/atn/LexerModeAction.js"
                  );
                  const LexerMoreAction_1 = __webpack_require__2(
                    /*! ./LexerMoreAction */
                    "./node_modules/antlr4ts/atn/LexerMoreAction.js"
                  );
                  const LexerPopModeAction_1 = __webpack_require__2(
                    /*! ./LexerPopModeAction */
                    "./node_modules/antlr4ts/atn/LexerPopModeAction.js"
                  );
                  const LexerPushModeAction_1 = __webpack_require__2(
                    /*! ./LexerPushModeAction */
                    "./node_modules/antlr4ts/atn/LexerPushModeAction.js"
                  );
                  const LexerSkipAction_1 = __webpack_require__2(
                    /*! ./LexerSkipAction */
                    "./node_modules/antlr4ts/atn/LexerSkipAction.js"
                  );
                  const LexerTypeAction_1 = __webpack_require__2(
                    /*! ./LexerTypeAction */
                    "./node_modules/antlr4ts/atn/LexerTypeAction.js"
                  );
                  const LoopEndState_1 = __webpack_require__2(
                    /*! ./LoopEndState */
                    "./node_modules/antlr4ts/atn/LoopEndState.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const NotSetTransition_1 = __webpack_require__2(
                    /*! ./NotSetTransition */
                    "./node_modules/antlr4ts/atn/NotSetTransition.js"
                  );
                  const ParserATNSimulator_1 = __webpack_require__2(
                    /*! ./ParserATNSimulator */
                    "./node_modules/antlr4ts/atn/ParserATNSimulator.js"
                  );
                  const PlusBlockStartState_1 = __webpack_require__2(
                    /*! ./PlusBlockStartState */
                    "./node_modules/antlr4ts/atn/PlusBlockStartState.js"
                  );
                  const PlusLoopbackState_1 = __webpack_require__2(
                    /*! ./PlusLoopbackState */
                    "./node_modules/antlr4ts/atn/PlusLoopbackState.js"
                  );
                  const PrecedencePredicateTransition_1 = __webpack_require__2(
                    /*! ./PrecedencePredicateTransition */
                    "./node_modules/antlr4ts/atn/PrecedencePredicateTransition.js"
                  );
                  const PredicateTransition_1 = __webpack_require__2(
                    /*! ./PredicateTransition */
                    "./node_modules/antlr4ts/atn/PredicateTransition.js"
                  );
                  const RangeTransition_1 = __webpack_require__2(
                    /*! ./RangeTransition */
                    "./node_modules/antlr4ts/atn/RangeTransition.js"
                  );
                  const RuleStartState_1 = __webpack_require__2(
                    /*! ./RuleStartState */
                    "./node_modules/antlr4ts/atn/RuleStartState.js"
                  );
                  const RuleStopState_1 = __webpack_require__2(
                    /*! ./RuleStopState */
                    "./node_modules/antlr4ts/atn/RuleStopState.js"
                  );
                  const RuleTransition_1 = __webpack_require__2(
                    /*! ./RuleTransition */
                    "./node_modules/antlr4ts/atn/RuleTransition.js"
                  );
                  const SetTransition_1 = __webpack_require__2(
                    /*! ./SetTransition */
                    "./node_modules/antlr4ts/atn/SetTransition.js"
                  );
                  const StarBlockStartState_1 = __webpack_require__2(
                    /*! ./StarBlockStartState */
                    "./node_modules/antlr4ts/atn/StarBlockStartState.js"
                  );
                  const StarLoopbackState_1 = __webpack_require__2(
                    /*! ./StarLoopbackState */
                    "./node_modules/antlr4ts/atn/StarLoopbackState.js"
                  );
                  const StarLoopEntryState_1 = __webpack_require__2(
                    /*! ./StarLoopEntryState */
                    "./node_modules/antlr4ts/atn/StarLoopEntryState.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const TokensStartState_1 = __webpack_require__2(
                    /*! ./TokensStartState */
                    "./node_modules/antlr4ts/atn/TokensStartState.js"
                  );
                  const UUID_1 = __webpack_require__2(
                    /*! ../misc/UUID */
                    "./node_modules/antlr4ts/misc/UUID.js"
                  );
                  const WildcardTransition_1 = __webpack_require__2(
                    /*! ./WildcardTransition */
                    "./node_modules/antlr4ts/atn/WildcardTransition.js"
                  );
                  var UnicodeDeserializingMode;
                  (function(UnicodeDeserializingMode2) {
                    UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_BMP"] = 0] = "UNICODE_BMP";
                    UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_SMP"] = 1] = "UNICODE_SMP";
                  })(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));
                  class ATNDeserializer {
                    constructor(deserializationOptions) {
                      if (deserializationOptions === void 0) {
                        deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;
                      }
                      this.deserializationOptions = deserializationOptions;
                    }
                    static get SERIALIZED_VERSION() {
                      return 3;
                    }
                    /**
                     * Determines if a particular serialized representation of an ATN supports
                     * a particular feature, identified by the {@link UUID} used for serializing
                     * the ATN at the time the feature was first introduced.
                     *
                     * @param feature The {@link UUID} marking the first time the feature was
                     * supported in the serialized ATN.
                     * @param actualUuid The {@link UUID} of the actual serialized ATN which is
                     * currently being deserialized.
                     * @returns `true` if the `actualUuid` value represents a
                     * serialized ATN at or after the feature identified by `feature` was
                     * introduced; otherwise, `false`.
                     */
                    static isFeatureSupported(feature, actualUuid) {
                      let featureIndex = ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));
                      if (featureIndex < 0) {
                        return false;
                      }
                      return ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;
                    }
                    static getUnicodeDeserializer(mode) {
                      if (mode === 0) {
                        return {
                          readUnicode: (data, p) => {
                            return ATNDeserializer.toInt(data[p]);
                          },
                          size: 1
                        };
                      } else {
                        return {
                          readUnicode: (data, p) => {
                            return ATNDeserializer.toInt32(data, p);
                          },
                          size: 2
                        };
                      }
                    }
                    deserialize(data) {
                      data = data.slice(0);
                      for (let i = 1; i < data.length; i++) {
                        data[i] = data[i] - 2 & 65535;
                      }
                      let p = 0;
                      let version2 = ATNDeserializer.toInt(data[p++]);
                      if (version2 !== ATNDeserializer.SERIALIZED_VERSION) {
                        let reason = `Could not deserialize ATN with version ${version2} (expected ${ATNDeserializer.SERIALIZED_VERSION}).`;
                        throw new Error(reason);
                      }
                      let uuid = ATNDeserializer.toUUID(data, p);
                      p += 8;
                      if (ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {
                        let reason = `Could not deserialize ATN with UUID ${uuid} (expected ${ATNDeserializer.SERIALIZED_UUID} or a legacy UUID).`;
                        throw new Error(reason);
                      }
                      let supportsLexerActions = ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, uuid);
                      let grammarType = ATNDeserializer.toInt(data[p++]);
                      let maxTokenType = ATNDeserializer.toInt(data[p++]);
                      let atn = new ATN_1.ATN(grammarType, maxTokenType);
                      let loopBackStateNumbers = [];
                      let endStateNumbers = [];
                      let nstates = ATNDeserializer.toInt(data[p++]);
                      for (let i = 0; i < nstates; i++) {
                        let stype = ATNDeserializer.toInt(data[p++]);
                        if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {
                          atn.addState(new InvalidState_1.InvalidState());
                          continue;
                        }
                        let ruleIndex = ATNDeserializer.toInt(data[p++]);
                        if (ruleIndex === 65535) {
                          ruleIndex = -1;
                        }
                        let s = this.stateFactory(stype, ruleIndex);
                        if (stype === ATNStateType_1.ATNStateType.LOOP_END) {
                          let loopBackStateNumber = ATNDeserializer.toInt(data[p++]);
                          loopBackStateNumbers.push([s, loopBackStateNumber]);
                        } else if (s instanceof BlockStartState_1.BlockStartState) {
                          let endStateNumber = ATNDeserializer.toInt(data[p++]);
                          endStateNumbers.push([s, endStateNumber]);
                        }
                        atn.addState(s);
                      }
                      for (let pair of loopBackStateNumbers) {
                        pair[0].loopBackState = atn.states[pair[1]];
                      }
                      for (let pair of endStateNumbers) {
                        pair[0].endState = atn.states[pair[1]];
                      }
                      let numNonGreedyStates = ATNDeserializer.toInt(data[p++]);
                      for (let i = 0; i < numNonGreedyStates; i++) {
                        let stateNumber = ATNDeserializer.toInt(data[p++]);
                        atn.states[stateNumber].nonGreedy = true;
                      }
                      let numSllDecisions = ATNDeserializer.toInt(data[p++]);
                      for (let i = 0; i < numSllDecisions; i++) {
                        let stateNumber = ATNDeserializer.toInt(data[p++]);
                        atn.states[stateNumber].sll = true;
                      }
                      let numPrecedenceStates = ATNDeserializer.toInt(data[p++]);
                      for (let i = 0; i < numPrecedenceStates; i++) {
                        let stateNumber = ATNDeserializer.toInt(data[p++]);
                        atn.states[stateNumber].isPrecedenceRule = true;
                      }
                      let nrules = ATNDeserializer.toInt(data[p++]);
                      if (atn.grammarType === 0) {
                        atn.ruleToTokenType = new Int32Array(nrules);
                      }
                      atn.ruleToStartState = new Array(nrules);
                      for (let i = 0; i < nrules; i++) {
                        let s = ATNDeserializer.toInt(data[p++]);
                        let startState = atn.states[s];
                        startState.leftFactored = ATNDeserializer.toInt(data[p++]) !== 0;
                        atn.ruleToStartState[i] = startState;
                        if (atn.grammarType === 0) {
                          let tokenType = ATNDeserializer.toInt(data[p++]);
                          if (tokenType === 65535) {
                            tokenType = Token_1.Token.EOF;
                          }
                          atn.ruleToTokenType[i] = tokenType;
                          if (!ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, uuid)) {
                            let actionIndexIgnored = ATNDeserializer.toInt(data[p++]);
                            if (actionIndexIgnored === 65535) {
                              actionIndexIgnored = -1;
                            }
                          }
                        }
                      }
                      atn.ruleToStopState = new Array(nrules);
                      for (let state of atn.states) {
                        if (!(state instanceof RuleStopState_1.RuleStopState)) {
                          continue;
                        }
                        atn.ruleToStopState[state.ruleIndex] = state;
                        atn.ruleToStartState[state.ruleIndex].stopState = state;
                      }
                      let nmodes = ATNDeserializer.toInt(data[p++]);
                      for (let i = 0; i < nmodes; i++) {
                        let s = ATNDeserializer.toInt(data[p++]);
                        atn.modeToStartState.push(atn.states[s]);
                      }
                      atn.modeToDFA = new Array(nmodes);
                      for (let i = 0; i < nmodes; i++) {
                        atn.modeToDFA[i] = new DFA_1.DFA(atn.modeToStartState[i]);
                      }
                      let sets = [];
                      p = this.deserializeSets(data, p, sets, ATNDeserializer.getUnicodeDeserializer(
                        0
                        /* UNICODE_BMP */
                      ));
                      if (ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_UNICODE_SMP, uuid)) {
                        p = this.deserializeSets(data, p, sets, ATNDeserializer.getUnicodeDeserializer(
                          1
                          /* UNICODE_SMP */
                        ));
                      }
                      let nedges = ATNDeserializer.toInt(data[p++]);
                      for (let i = 0; i < nedges; i++) {
                        let src = ATNDeserializer.toInt(data[p]);
                        let trg = ATNDeserializer.toInt(data[p + 1]);
                        let ttype = ATNDeserializer.toInt(data[p + 2]);
                        let arg1 = ATNDeserializer.toInt(data[p + 3]);
                        let arg2 = ATNDeserializer.toInt(data[p + 4]);
                        let arg3 = ATNDeserializer.toInt(data[p + 5]);
                        let trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
                        let srcState = atn.states[src];
                        srcState.addTransition(trans);
                        p += 6;
                      }
                      let returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({
                        hashCode: (o) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,
                        equals: (a, b) => {
                          return a.stopState === b.stopState && a.returnState === b.returnState && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;
                        }
                      });
                      let returnTransitions = [];
                      for (let state of atn.states) {
                        let returningToLeftFactored = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;
                        for (let i = 0; i < state.numberOfTransitions; i++) {
                          let t = state.transition(i);
                          if (!(t instanceof RuleTransition_1.RuleTransition)) {
                            continue;
                          }
                          let ruleTransition = t;
                          let returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;
                          if (!returningFromLeftFactored && returningToLeftFactored) {
                            continue;
                          }
                          let outermostPrecedenceReturn = -1;
                          if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {
                            if (ruleTransition.precedence === 0) {
                              outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
                            }
                          }
                          let current = { stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn };
                          if (returnTransitionsSet.add(current)) {
                            returnTransitions.push(current);
                          }
                        }
                      }
                      for (let returnTransition of returnTransitions) {
                        let transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);
                        atn.ruleToStopState[returnTransition.stopState].addTransition(transition);
                      }
                      for (let state of atn.states) {
                        if (state instanceof BlockStartState_1.BlockStartState) {
                          if (state.endState === void 0) {
                            throw new Error("IllegalStateException");
                          }
                          if (state.endState.startState !== void 0) {
                            throw new Error("IllegalStateException");
                          }
                          state.endState.startState = state;
                        }
                        if (state instanceof PlusLoopbackState_1.PlusLoopbackState) {
                          let loopbackState = state;
                          for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
                            let target = loopbackState.transition(i).target;
                            if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {
                              target.loopBackState = loopbackState;
                            }
                          }
                        } else if (state instanceof StarLoopbackState_1.StarLoopbackState) {
                          let loopbackState = state;
                          for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
                            let target = loopbackState.transition(i).target;
                            if (target instanceof StarLoopEntryState_1.StarLoopEntryState) {
                              target.loopBackState = loopbackState;
                            }
                          }
                        }
                      }
                      let ndecisions = ATNDeserializer.toInt(data[p++]);
                      for (let i = 1; i <= ndecisions; i++) {
                        let s = ATNDeserializer.toInt(data[p++]);
                        let decState = atn.states[s];
                        atn.decisionToState.push(decState);
                        decState.decision = i - 1;
                      }
                      if (atn.grammarType === 0) {
                        if (supportsLexerActions) {
                          atn.lexerActions = new Array(ATNDeserializer.toInt(data[p++]));
                          for (let i = 0; i < atn.lexerActions.length; i++) {
                            let actionType = ATNDeserializer.toInt(data[p++]);
                            let data1 = ATNDeserializer.toInt(data[p++]);
                            if (data1 === 65535) {
                              data1 = -1;
                            }
                            let data2 = ATNDeserializer.toInt(data[p++]);
                            if (data2 === 65535) {
                              data2 = -1;
                            }
                            let lexerAction = this.lexerActionFactory(actionType, data1, data2);
                            atn.lexerActions[i] = lexerAction;
                          }
                        } else {
                          let legacyLexerActions = [];
                          for (let state of atn.states) {
                            for (let i = 0; i < state.numberOfTransitions; i++) {
                              let transition = state.transition(i);
                              if (!(transition instanceof ActionTransition_1.ActionTransition)) {
                                continue;
                              }
                              let ruleIndex = transition.ruleIndex;
                              let actionIndex = transition.actionIndex;
                              let lexerAction = new LexerCustomAction_1.LexerCustomAction(ruleIndex, actionIndex);
                              state.setTransition(i, new ActionTransition_1.ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));
                              legacyLexerActions.push(lexerAction);
                            }
                          }
                          atn.lexerActions = legacyLexerActions;
                        }
                      }
                      this.markPrecedenceDecisions(atn);
                      atn.decisionToDFA = new Array(ndecisions);
                      for (let i = 0; i < ndecisions; i++) {
                        atn.decisionToDFA[i] = new DFA_1.DFA(atn.decisionToState[i], i);
                      }
                      if (this.deserializationOptions.isVerifyATN) {
                        this.verifyATN(atn);
                      }
                      if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1) {
                        atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);
                        for (let i = 0; i < atn.ruleToStartState.length; i++) {
                          atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
                        }
                        for (let i = 0; i < atn.ruleToStartState.length; i++) {
                          let bypassStart = new BasicBlockStartState_1.BasicBlockStartState();
                          bypassStart.ruleIndex = i;
                          atn.addState(bypassStart);
                          let bypassStop = new BlockEndState_1.BlockEndState();
                          bypassStop.ruleIndex = i;
                          atn.addState(bypassStop);
                          bypassStart.endState = bypassStop;
                          atn.defineDecisionState(bypassStart);
                          bypassStop.startState = bypassStart;
                          let endState;
                          let excludeTransition;
                          if (atn.ruleToStartState[i].isPrecedenceRule) {
                            endState = void 0;
                            for (let state of atn.states) {
                              if (state.ruleIndex !== i) {
                                continue;
                              }
                              if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                                continue;
                              }
                              let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
                              if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {
                                continue;
                              }
                              if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                                endState = state;
                                break;
                              }
                            }
                            if (!endState) {
                              throw new Error("Couldn't identify final state of the precedence rule prefix section.");
                            }
                            excludeTransition = endState.loopBackState.transition(0);
                          } else {
                            endState = atn.ruleToStopState[i];
                          }
                          for (let state of atn.states) {
                            for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {
                              let transition = state.transition(i2);
                              if (transition === excludeTransition) {
                                continue;
                              }
                              if (transition.target === endState) {
                                transition.target = bypassStop;
                              }
                            }
                          }
                          while (atn.ruleToStartState[i].numberOfTransitions > 0) {
                            let transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);
                            bypassStart.addTransition(transition);
                          }
                          atn.ruleToStartState[i].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));
                          bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));
                          let matchState = new BasicState_1.BasicState();
                          atn.addState(matchState);
                          matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[i]));
                          bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));
                        }
                        if (this.deserializationOptions.isVerifyATN) {
                          this.verifyATN(atn);
                        }
                      }
                      if (this.deserializationOptions.isOptimize) {
                        while (true) {
                          let optimizationCount = 0;
                          optimizationCount += ATNDeserializer.inlineSetRules(atn);
                          optimizationCount += ATNDeserializer.combineChainedEpsilons(atn);
                          let preserveOrder = atn.grammarType === 0;
                          optimizationCount += ATNDeserializer.optimizeSets(atn, preserveOrder);
                          if (optimizationCount === 0) {
                            break;
                          }
                        }
                        if (this.deserializationOptions.isVerifyATN) {
                          this.verifyATN(atn);
                        }
                      }
                      ATNDeserializer.identifyTailCalls(atn);
                      return atn;
                    }
                    deserializeSets(data, p, sets, unicodeDeserializer) {
                      let nsets = ATNDeserializer.toInt(data[p++]);
                      for (let i = 0; i < nsets; i++) {
                        let nintervals = ATNDeserializer.toInt(data[p]);
                        p++;
                        let set2 = new IntervalSet_1.IntervalSet();
                        sets.push(set2);
                        let containsEof = ATNDeserializer.toInt(data[p++]) !== 0;
                        if (containsEof) {
                          set2.add(-1);
                        }
                        for (let j = 0; j < nintervals; j++) {
                          let a = unicodeDeserializer.readUnicode(data, p);
                          p += unicodeDeserializer.size;
                          let b = unicodeDeserializer.readUnicode(data, p);
                          p += unicodeDeserializer.size;
                          set2.add(a, b);
                        }
                      }
                      return p;
                    }
                    /**
                     * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
                     * the {@link StarLoopEntryState#precedenceRuleDecision} field to the
                     * correct value.
                     *
                     * @param atn The ATN.
                     */
                    markPrecedenceDecisions(atn) {
                      let rulePrecedenceDecisions = /* @__PURE__ */ new Map();
                      for (let state of atn.states) {
                        if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                          continue;
                        }
                        if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
                          let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
                          if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {
                            if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                              rulePrecedenceDecisions.set(state.ruleIndex, state);
                              state.precedenceRuleDecision = true;
                              state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);
                            }
                          }
                        }
                      }
                      for (let precedenceDecision of rulePrecedenceDecisions) {
                        for (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {
                          if (transition.serializationType !== 1) {
                            continue;
                          }
                          let epsilonTransition = transition;
                          if (epsilonTransition.outermostPrecedenceReturn !== -1) {
                            continue;
                          }
                          precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);
                        }
                      }
                    }
                    verifyATN(atn) {
                      for (let state of atn.states) {
                        this.checkCondition(state !== void 0, "ATN states should not be undefined.");
                        if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {
                          continue;
                        }
                        this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);
                        if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {
                          this.checkCondition(state.loopBackState !== void 0);
                        }
                        if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {
                          let starLoopEntryState = state;
                          this.checkCondition(starLoopEntryState.loopBackState !== void 0);
                          this.checkCondition(starLoopEntryState.numberOfTransitions === 2);
                          if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {
                            this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);
                            this.checkCondition(!starLoopEntryState.nonGreedy);
                          } else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {
                            this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);
                            this.checkCondition(starLoopEntryState.nonGreedy);
                          } else {
                            throw new Error("IllegalStateException");
                          }
                        }
                        if (state instanceof StarLoopbackState_1.StarLoopbackState) {
                          this.checkCondition(state.numberOfTransitions === 1);
                          this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);
                        }
                        if (state instanceof LoopEndState_1.LoopEndState) {
                          this.checkCondition(state.loopBackState !== void 0);
                        }
                        if (state instanceof RuleStartState_1.RuleStartState) {
                          this.checkCondition(state.stopState !== void 0);
                        }
                        if (state instanceof BlockStartState_1.BlockStartState) {
                          this.checkCondition(state.endState !== void 0);
                        }
                        if (state instanceof BlockEndState_1.BlockEndState) {
                          this.checkCondition(state.startState !== void 0);
                        }
                        if (state instanceof DecisionState_1.DecisionState) {
                          let decisionState = state;
                          this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);
                        } else {
                          this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);
                        }
                      }
                    }
                    checkCondition(condition, message) {
                      if (!condition) {
                        throw new Error("IllegalStateException: " + message);
                      }
                    }
                    static inlineSetRules(atn) {
                      let inlinedCalls = 0;
                      let ruleToInlineTransition = new Array(atn.ruleToStartState.length);
                      for (let i = 0; i < atn.ruleToStartState.length; i++) {
                        let startState = atn.ruleToStartState[i];
                        let middleState = startState;
                        while (middleState.onlyHasEpsilonTransitions && middleState.numberOfOptimizedTransitions === 1 && middleState.getOptimizedTransition(0).serializationType === 1) {
                          middleState = middleState.getOptimizedTransition(0).target;
                        }
                        if (middleState.numberOfOptimizedTransitions !== 1) {
                          continue;
                        }
                        let matchTransition = middleState.getOptimizedTransition(0);
                        let matchTarget = matchTransition.target;
                        if (matchTransition.isEpsilon || !matchTarget.onlyHasEpsilonTransitions || matchTarget.numberOfOptimizedTransitions !== 1 || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {
                          continue;
                        }
                        switch (matchTransition.serializationType) {
                          case 5:
                          case 2:
                          case 7:
                            ruleToInlineTransition[i] = matchTransition;
                            break;
                          case 8:
                          case 9:
                            continue;
                          default:
                            continue;
                        }
                      }
                      for (let state of atn.states) {
                        if (state.ruleIndex < 0) {
                          continue;
                        }
                        let optimizedTransitions;
                        for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
                          let transition = state.getOptimizedTransition(i);
                          if (!(transition instanceof RuleTransition_1.RuleTransition)) {
                            if (optimizedTransitions !== void 0) {
                              optimizedTransitions.push(transition);
                            }
                            continue;
                          }
                          let ruleTransition = transition;
                          let effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
                          if (effective === void 0) {
                            if (optimizedTransitions !== void 0) {
                              optimizedTransitions.push(transition);
                            }
                            continue;
                          }
                          if (optimizedTransitions === void 0) {
                            optimizedTransitions = [];
                            for (let j = 0; j < i; j++) {
                              optimizedTransitions.push(state.getOptimizedTransition(i));
                            }
                          }
                          inlinedCalls++;
                          let target = ruleTransition.followState;
                          let intermediateState = new BasicState_1.BasicState();
                          intermediateState.setRuleIndex(target.ruleIndex);
                          atn.addState(intermediateState);
                          optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));
                          switch (effective.serializationType) {
                            case 5:
                              intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));
                              break;
                            case 2:
                              intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));
                              break;
                            case 7:
                              intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));
                              break;
                            default:
                              throw new Error("UnsupportedOperationException");
                          }
                        }
                        if (optimizedTransitions !== void 0) {
                          if (state.isOptimized) {
                            while (state.numberOfOptimizedTransitions > 0) {
                              state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
                            }
                          }
                          for (let transition of optimizedTransitions) {
                            state.addOptimizedTransition(transition);
                          }
                        }
                      }
                      if (ParserATNSimulator_1.ParserATNSimulator.debug) {
                        console.log("ATN runtime optimizer removed " + inlinedCalls + " rule invocations by inlining sets.");
                      }
                      return inlinedCalls;
                    }
                    static combineChainedEpsilons(atn) {
                      let removedEdges = 0;
                      for (let state of atn.states) {
                        if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {
                          continue;
                        }
                        let optimizedTransitions;
                        nextTransition: for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
                          let transition = state.getOptimizedTransition(i);
                          let intermediate = transition.target;
                          if (transition.serializationType !== 1 || transition.outermostPrecedenceReturn !== -1 || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC || !intermediate.onlyHasEpsilonTransitions) {
                            if (optimizedTransitions !== void 0) {
                              optimizedTransitions.push(transition);
                            }
                            continue nextTransition;
                          }
                          for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                            if (intermediate.getOptimizedTransition(j).serializationType !== 1 || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {
                              if (optimizedTransitions !== void 0) {
                                optimizedTransitions.push(transition);
                              }
                              continue nextTransition;
                            }
                          }
                          removedEdges++;
                          if (optimizedTransitions === void 0) {
                            optimizedTransitions = [];
                            for (let j = 0; j < i; j++) {
                              optimizedTransitions.push(state.getOptimizedTransition(j));
                            }
                          }
                          for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
                            let target = intermediate.getOptimizedTransition(j).target;
                            optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));
                          }
                        }
                        if (optimizedTransitions !== void 0) {
                          if (state.isOptimized) {
                            while (state.numberOfOptimizedTransitions > 0) {
                              state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
                            }
                          }
                          for (let transition of optimizedTransitions) {
                            state.addOptimizedTransition(transition);
                          }
                        }
                      }
                      if (ParserATNSimulator_1.ParserATNSimulator.debug) {
                        console.log("ATN runtime optimizer removed " + removedEdges + " transitions by combining chained epsilon transitions.");
                      }
                      return removedEdges;
                    }
                    static optimizeSets(atn, preserveOrder) {
                      if (preserveOrder) {
                        return 0;
                      }
                      let removedPaths = 0;
                      let decisions = atn.decisionToState;
                      for (let decision of decisions) {
                        let setTransitions = new IntervalSet_1.IntervalSet();
                        for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
                          let epsTransition = decision.getOptimizedTransition(i);
                          if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {
                            continue;
                          }
                          if (epsTransition.target.numberOfOptimizedTransitions !== 1) {
                            continue;
                          }
                          let transition = epsTransition.target.getOptimizedTransition(0);
                          if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {
                            continue;
                          }
                          if (transition instanceof NotSetTransition_1.NotSetTransition) {
                            continue;
                          }
                          if (transition instanceof AtomTransition_1.AtomTransition || transition instanceof RangeTransition_1.RangeTransition || transition instanceof SetTransition_1.SetTransition) {
                            setTransitions.add(i);
                          }
                        }
                        if (setTransitions.size <= 1) {
                          continue;
                        }
                        let optimizedTransitions = [];
                        for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
                          if (!setTransitions.contains(i)) {
                            optimizedTransitions.push(decision.getOptimizedTransition(i));
                          }
                        }
                        let blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;
                        let matchSet = new IntervalSet_1.IntervalSet();
                        for (let interval of setTransitions.intervals) {
                          for (let j = interval.a; j <= interval.b; j++) {
                            let matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);
                            if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {
                              throw new Error("Not yet implemented.");
                            } else {
                              matchSet.addAll(matchTransition.label);
                            }
                          }
                        }
                        let newTransition;
                        if (matchSet.intervals.length === 1) {
                          if (matchSet.size === 1) {
                            newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);
                          } else {
                            let matchInterval = matchSet.intervals[0];
                            newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
                          }
                        } else {
                          newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);
                        }
                        let setOptimizedState = new BasicState_1.BasicState();
                        setOptimizedState.setRuleIndex(decision.ruleIndex);
                        atn.addState(setOptimizedState);
                        setOptimizedState.addTransition(newTransition);
                        optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));
                        removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;
                        if (decision.isOptimized) {
                          while (decision.numberOfOptimizedTransitions > 0) {
                            decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);
                          }
                        }
                        for (let transition of optimizedTransitions) {
                          decision.addOptimizedTransition(transition);
                        }
                      }
                      if (ParserATNSimulator_1.ParserATNSimulator.debug) {
                        console.log("ATN runtime optimizer removed " + removedPaths + " paths by collapsing sets.");
                      }
                      return removedPaths;
                    }
                    static identifyTailCalls(atn) {
                      for (let state of atn.states) {
                        for (let i = 0; i < state.numberOfTransitions; i++) {
                          let transition = state.transition(i);
                          if (!(transition instanceof RuleTransition_1.RuleTransition)) {
                            continue;
                          }
                          transition.tailCall = this.testTailCall(atn, transition, false);
                          transition.optimizedTailCall = this.testTailCall(atn, transition, true);
                        }
                        if (!state.isOptimized) {
                          continue;
                        }
                        for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
                          let transition = state.getOptimizedTransition(i);
                          if (!(transition instanceof RuleTransition_1.RuleTransition)) {
                            continue;
                          }
                          transition.tailCall = this.testTailCall(atn, transition, false);
                          transition.optimizedTailCall = this.testTailCall(atn, transition, true);
                        }
                      }
                    }
                    static testTailCall(atn, transition, optimizedPath) {
                      if (!optimizedPath && transition.tailCall) {
                        return true;
                      }
                      if (optimizedPath && transition.optimizedTailCall) {
                        return true;
                      }
                      let reachable = new BitSet_1.BitSet(atn.states.length);
                      let worklist = [];
                      worklist.push(transition.followState);
                      while (true) {
                        let state = worklist.pop();
                        if (!state) {
                          break;
                        }
                        if (reachable.get(state.stateNumber)) {
                          continue;
                        }
                        if (state instanceof RuleStopState_1.RuleStopState) {
                          continue;
                        }
                        if (!state.onlyHasEpsilonTransitions) {
                          return false;
                        }
                        let transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;
                        for (let i = 0; i < transitionCount; i++) {
                          let t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);
                          if (t.serializationType !== 1) {
                            return false;
                          }
                          worklist.push(t.target);
                        }
                      }
                      return true;
                    }
                    static toInt(c) {
                      return c;
                    }
                    static toInt32(data, offset) {
                      return (data[offset] | data[offset + 1] << 16) >>> 0;
                    }
                    static toUUID(data, offset) {
                      let leastSigBits = ATNDeserializer.toInt32(data, offset);
                      let lessSigBits = ATNDeserializer.toInt32(data, offset + 2);
                      let moreSigBits = ATNDeserializer.toInt32(data, offset + 4);
                      let mostSigBits = ATNDeserializer.toInt32(data, offset + 6);
                      return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
                    }
                    edgeFactory(atn, type2, src, trg, arg1, arg2, arg3, sets) {
                      let target = atn.states[trg];
                      switch (type2) {
                        case 1:
                          return new EpsilonTransition_1.EpsilonTransition(target);
                        case 2:
                          if (arg3 !== 0) {
                            return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);
                          } else {
                            return new RangeTransition_1.RangeTransition(target, arg1, arg2);
                          }
                        case 3:
                          let rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);
                          return rt;
                        case 4:
                          let pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);
                          return pt;
                        case 10:
                          return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);
                        case 5:
                          if (arg3 !== 0) {
                            return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);
                          } else {
                            return new AtomTransition_1.AtomTransition(target, arg1);
                          }
                        case 6:
                          let a = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);
                          return a;
                        case 7:
                          return new SetTransition_1.SetTransition(target, sets[arg1]);
                        case 8:
                          return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);
                        case 9:
                          return new WildcardTransition_1.WildcardTransition(target);
                      }
                      throw new Error("The specified transition type is not valid.");
                    }
                    stateFactory(type2, ruleIndex) {
                      let s;
                      switch (type2) {
                        case ATNStateType_1.ATNStateType.INVALID_TYPE:
                          return new InvalidState_1.InvalidState();
                        case ATNStateType_1.ATNStateType.BASIC:
                          s = new BasicState_1.BasicState();
                          break;
                        case ATNStateType_1.ATNStateType.RULE_START:
                          s = new RuleStartState_1.RuleStartState();
                          break;
                        case ATNStateType_1.ATNStateType.BLOCK_START:
                          s = new BasicBlockStartState_1.BasicBlockStartState();
                          break;
                        case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
                          s = new PlusBlockStartState_1.PlusBlockStartState();
                          break;
                        case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
                          s = new StarBlockStartState_1.StarBlockStartState();
                          break;
                        case ATNStateType_1.ATNStateType.TOKEN_START:
                          s = new TokensStartState_1.TokensStartState();
                          break;
                        case ATNStateType_1.ATNStateType.RULE_STOP:
                          s = new RuleStopState_1.RuleStopState();
                          break;
                        case ATNStateType_1.ATNStateType.BLOCK_END:
                          s = new BlockEndState_1.BlockEndState();
                          break;
                        case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
                          s = new StarLoopbackState_1.StarLoopbackState();
                          break;
                        case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
                          s = new StarLoopEntryState_1.StarLoopEntryState();
                          break;
                        case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
                          s = new PlusLoopbackState_1.PlusLoopbackState();
                          break;
                        case ATNStateType_1.ATNStateType.LOOP_END:
                          s = new LoopEndState_1.LoopEndState();
                          break;
                        default:
                          let message = `The specified state type ${type2} is not valid.`;
                          throw new Error(message);
                      }
                      s.ruleIndex = ruleIndex;
                      return s;
                    }
                    lexerActionFactory(type2, data1, data2) {
                      switch (type2) {
                        case 0:
                          return new LexerChannelAction_1.LexerChannelAction(data1);
                        case 1:
                          return new LexerCustomAction_1.LexerCustomAction(data1, data2);
                        case 2:
                          return new LexerModeAction_1.LexerModeAction(data1);
                        case 3:
                          return LexerMoreAction_1.LexerMoreAction.INSTANCE;
                        case 4:
                          return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;
                        case 5:
                          return new LexerPushModeAction_1.LexerPushModeAction(data1);
                        case 6:
                          return LexerSkipAction_1.LexerSkipAction.INSTANCE;
                        case 7:
                          return new LexerTypeAction_1.LexerTypeAction(data1);
                        default:
                          let message = `The specified lexer action type ${type2} is not valid.`;
                          throw new Error(message);
                      }
                    }
                  }
                  ATNDeserializer.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3");
                  ATNDeserializer.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D");
                  ATNDeserializer.ADDED_UNICODE_SMP = UUID_1.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B");
                  ATNDeserializer.SUPPORTED_UUIDS = [
                    ATNDeserializer.BASE_SERIALIZED_UUID,
                    ATNDeserializer.ADDED_LEXER_ACTIONS,
                    ATNDeserializer.ADDED_UNICODE_SMP
                  ];
                  ATNDeserializer.SERIALIZED_UUID = ATNDeserializer.ADDED_UNICODE_SMP;
                  __decorate([
                    Decorators_1.NotNull
                  ], ATNDeserializer.prototype, "deserializationOptions", void 0);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ATNDeserializer.prototype, "deserialize", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ATNDeserializer.prototype, "markPrecedenceDecisions", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], ATNDeserializer.prototype, "edgeFactory", null);
                  exports2.ATNDeserializer = ATNDeserializer;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ATNSimulator.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ATNSimulator.js ***!
                  \***************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ATNSimulator = void 0;
                  const ATNConfigSet_1 = __webpack_require__2(
                    /*! ./ATNConfigSet */
                    "./node_modules/antlr4ts/atn/ATNConfigSet.js"
                  );
                  const DFAState_1 = __webpack_require__2(
                    /*! ../dfa/DFAState */
                    "./node_modules/antlr4ts/dfa/DFAState.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const PredictionContext_1 = __webpack_require__2(
                    /*! ./PredictionContext */
                    "./node_modules/antlr4ts/atn/PredictionContext.js"
                  );
                  let ATNSimulator = class ATNSimulator2 {
                    constructor(atn) {
                      this.atn = atn;
                    }
                    static get ERROR() {
                      if (!ATNSimulator2._ERROR) {
                        ATNSimulator2._ERROR = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
                        ATNSimulator2._ERROR.stateNumber = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                      }
                      return ATNSimulator2._ERROR;
                    }
                    /**
                     * Clear the DFA cache used by the current instance. Since the DFA cache may
                     * be shared by multiple ATN simulators, this method may affect the
                     * performance (but not accuracy) of other parsers which are being used
                     * concurrently.
                     *
                     * @ if the current instance does not
                     * support clearing the DFA.
                     *
                     * @since 4.3
                     */
                    clearDFA() {
                      this.atn.clearDFA();
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], ATNSimulator.prototype, "atn", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ATNSimulator, "ERROR", null);
                  ATNSimulator = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ATNSimulator);
                  exports2.ATNSimulator = ATNSimulator;
                  /* @__PURE__ */ (function(ATNSimulator2) {
                    const RULE_VARIANT_DELIMITER = "$";
                    const RULE_LF_VARIANT_MARKER = "$lf$";
                    const RULE_NOLF_VARIANT_MARKER = "$nolf$";
                  })(ATNSimulator = exports2.ATNSimulator || (exports2.ATNSimulator = {}));
                  exports2.ATNSimulator = ATNSimulator;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ATNState.js": (
                /*!***********************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ATNState.js ***!
                  \***********************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ATNState = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const INITIAL_NUM_TRANSITIONS = 4;
                  class ATNState {
                    constructor() {
                      this.stateNumber = ATNState.INVALID_STATE_NUMBER;
                      this.ruleIndex = 0;
                      this.epsilonOnlyTransitions = false;
                      this.transitions = [];
                      this.optimizedTransitions = this.transitions;
                    }
                    /**
                     * Gets the state number.
                     *
                     * @returns the state number
                     */
                    getStateNumber() {
                      return this.stateNumber;
                    }
                    /**
                     * For all states except {@link RuleStopState}, this returns the state
                     * number. Returns -1 for stop states.
                     *
                     * @returns -1 for {@link RuleStopState}, otherwise the state number
                     */
                    get nonStopStateNumber() {
                      return this.getStateNumber();
                    }
                    hashCode() {
                      return this.stateNumber;
                    }
                    equals(o) {
                      if (o instanceof ATNState) {
                        return this.stateNumber === o.stateNumber;
                      }
                      return false;
                    }
                    get isNonGreedyExitState() {
                      return false;
                    }
                    toString() {
                      return String(this.stateNumber);
                    }
                    getTransitions() {
                      return this.transitions.slice(0);
                    }
                    get numberOfTransitions() {
                      return this.transitions.length;
                    }
                    addTransition(e, index) {
                      if (this.transitions.length === 0) {
                        this.epsilonOnlyTransitions = e.isEpsilon;
                      } else if (this.epsilonOnlyTransitions !== e.isEpsilon) {
                        this.epsilonOnlyTransitions = false;
                        throw new Error("ATN state " + this.stateNumber + " has both epsilon and non-epsilon transitions.");
                      }
                      this.transitions.splice(index !== void 0 ? index : this.transitions.length, 0, e);
                    }
                    transition(i) {
                      return this.transitions[i];
                    }
                    setTransition(i, e) {
                      this.transitions[i] = e;
                    }
                    removeTransition(index) {
                      return this.transitions.splice(index, 1)[0];
                    }
                    get onlyHasEpsilonTransitions() {
                      return this.epsilonOnlyTransitions;
                    }
                    setRuleIndex(ruleIndex) {
                      this.ruleIndex = ruleIndex;
                    }
                    get isOptimized() {
                      return this.optimizedTransitions !== this.transitions;
                    }
                    get numberOfOptimizedTransitions() {
                      return this.optimizedTransitions.length;
                    }
                    getOptimizedTransition(i) {
                      return this.optimizedTransitions[i];
                    }
                    addOptimizedTransition(e) {
                      if (!this.isOptimized) {
                        this.optimizedTransitions = new Array();
                      }
                      this.optimizedTransitions.push(e);
                    }
                    setOptimizedTransition(i, e) {
                      if (!this.isOptimized) {
                        throw new Error("This ATNState is not optimized.");
                      }
                      this.optimizedTransitions[i] = e;
                    }
                    removeOptimizedTransition(i) {
                      if (!this.isOptimized) {
                        throw new Error("This ATNState is not optimized.");
                      }
                      this.optimizedTransitions.splice(i, 1);
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], ATNState.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNState.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], ATNState.prototype, "toString", null);
                  exports2.ATNState = ATNState;
                  (function(ATNState2) {
                    ATNState2.INVALID_STATE_NUMBER = -1;
                  })(ATNState = exports2.ATNState || (exports2.ATNState = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ATNStateType.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ATNStateType.js ***!
                  \***************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ATNStateType = void 0;
                  var ATNStateType;
                  (function(ATNStateType2) {
                    ATNStateType2[ATNStateType2["INVALID_TYPE"] = 0] = "INVALID_TYPE";
                    ATNStateType2[ATNStateType2["BASIC"] = 1] = "BASIC";
                    ATNStateType2[ATNStateType2["RULE_START"] = 2] = "RULE_START";
                    ATNStateType2[ATNStateType2["BLOCK_START"] = 3] = "BLOCK_START";
                    ATNStateType2[ATNStateType2["PLUS_BLOCK_START"] = 4] = "PLUS_BLOCK_START";
                    ATNStateType2[ATNStateType2["STAR_BLOCK_START"] = 5] = "STAR_BLOCK_START";
                    ATNStateType2[ATNStateType2["TOKEN_START"] = 6] = "TOKEN_START";
                    ATNStateType2[ATNStateType2["RULE_STOP"] = 7] = "RULE_STOP";
                    ATNStateType2[ATNStateType2["BLOCK_END"] = 8] = "BLOCK_END";
                    ATNStateType2[ATNStateType2["STAR_LOOP_BACK"] = 9] = "STAR_LOOP_BACK";
                    ATNStateType2[ATNStateType2["STAR_LOOP_ENTRY"] = 10] = "STAR_LOOP_ENTRY";
                    ATNStateType2[ATNStateType2["PLUS_LOOP_BACK"] = 11] = "PLUS_LOOP_BACK";
                    ATNStateType2[ATNStateType2["LOOP_END"] = 12] = "LOOP_END";
                  })(ATNStateType = exports2.ATNStateType || (exports2.ATNStateType = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/AbstractPredicateTransition.js": (
                /*!******************************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/AbstractPredicateTransition.js ***!
                  \******************************************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.AbstractPredicateTransition = void 0;
                  const Transition_1 = __webpack_require__2(
                    /*! ./Transition */
                    "./node_modules/antlr4ts/atn/Transition.js"
                  );
                  class AbstractPredicateTransition extends Transition_1.Transition {
                    constructor(target) {
                      super(target);
                    }
                  }
                  exports2.AbstractPredicateTransition = AbstractPredicateTransition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ActionTransition.js": (
                /*!*******************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ActionTransition.js ***!
                  \*******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ActionTransition = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Transition_1 = __webpack_require__2(
                    /*! ./Transition */
                    "./node_modules/antlr4ts/atn/Transition.js"
                  );
                  let ActionTransition = class ActionTransition extends Transition_1.Transition {
                    constructor(target, ruleIndex, actionIndex = -1, isCtxDependent = false) {
                      super(target);
                      this.ruleIndex = ruleIndex;
                      this.actionIndex = actionIndex;
                      this.isCtxDependent = isCtxDependent;
                    }
                    get serializationType() {
                      return 6;
                    }
                    get isEpsilon() {
                      return true;
                    }
                    matches(symbol, minVocabSymbol, maxVocabSymbol) {
                      return false;
                    }
                    toString() {
                      return "action_" + this.ruleIndex + ":" + this.actionIndex;
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], ActionTransition.prototype, "serializationType", null);
                  __decorate([
                    Decorators_1.Override
                  ], ActionTransition.prototype, "isEpsilon", null);
                  __decorate([
                    Decorators_1.Override
                  ], ActionTransition.prototype, "matches", null);
                  __decorate([
                    Decorators_1.Override
                  ], ActionTransition.prototype, "toString", null);
                  ActionTransition = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ActionTransition);
                  exports2.ActionTransition = ActionTransition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/AmbiguityInfo.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/AmbiguityInfo.js ***!
                  \****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.AmbiguityInfo = void 0;
                  const DecisionEventInfo_1 = __webpack_require__2(
                    /*! ./DecisionEventInfo */
                    "./node_modules/antlr4ts/atn/DecisionEventInfo.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let AmbiguityInfo = class AmbiguityInfo extends DecisionEventInfo_1.DecisionEventInfo {
                    /**
                     * Constructs a new instance of the {@link AmbiguityInfo} class with the
                     * specified detailed ambiguity information.
                     *
                     * @param decision The decision number
                     * @param state The final simulator state identifying the ambiguous
                     * alternatives for the current input
                     * @param ambigAlts The set of alternatives in the decision that lead to a valid parse.
                     *                  The predicted alt is the min(ambigAlts)
                     * @param input The input token stream
                     * @param startIndex The start index for the current prediction
                     * @param stopIndex The index at which the ambiguity was identified during
                     * prediction
                     */
                    constructor(decision, state, ambigAlts, input, startIndex, stopIndex) {
                      super(decision, state, input, startIndex, stopIndex, state.useContext);
                      this.ambigAlts = ambigAlts;
                    }
                    /**
                     * Gets the set of alternatives in the decision that lead to a valid parse.
                     *
                     * @since 4.5
                     */
                    get ambiguousAlternatives() {
                      return this.ambigAlts;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], AmbiguityInfo.prototype, "ambigAlts", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], AmbiguityInfo.prototype, "ambiguousAlternatives", null);
                  AmbiguityInfo = __decorate([
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull),
                    __param(3, Decorators_1.NotNull)
                  ], AmbiguityInfo);
                  exports2.AmbiguityInfo = AmbiguityInfo;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/AtomTransition.js": (
                /*!*****************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/AtomTransition.js ***!
                  \*****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.AtomTransition = void 0;
                  const IntervalSet_1 = __webpack_require__2(
                    /*! ../misc/IntervalSet */
                    "./node_modules/antlr4ts/misc/IntervalSet.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Transition_1 = __webpack_require__2(
                    /*! ./Transition */
                    "./node_modules/antlr4ts/atn/Transition.js"
                  );
                  let AtomTransition = class AtomTransition extends Transition_1.Transition {
                    constructor(target, label) {
                      super(target);
                      this._label = label;
                    }
                    get serializationType() {
                      return 5;
                    }
                    get label() {
                      return IntervalSet_1.IntervalSet.of(this._label);
                    }
                    matches(symbol, minVocabSymbol, maxVocabSymbol) {
                      return this._label === symbol;
                    }
                    toString() {
                      return String(this.label);
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], AtomTransition.prototype, "serializationType", null);
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull
                  ], AtomTransition.prototype, "label", null);
                  __decorate([
                    Decorators_1.Override
                  ], AtomTransition.prototype, "matches", null);
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull
                  ], AtomTransition.prototype, "toString", null);
                  AtomTransition = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], AtomTransition);
                  exports2.AtomTransition = AtomTransition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/BasicBlockStartState.js": (
                /*!***********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/BasicBlockStartState.js ***!
                  \***********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.BasicBlockStartState = void 0;
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const BlockStartState_1 = __webpack_require__2(
                    /*! ./BlockStartState */
                    "./node_modules/antlr4ts/atn/BlockStartState.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class BasicBlockStartState extends BlockStartState_1.BlockStartState {
                    get stateType() {
                      return ATNStateType_1.ATNStateType.BLOCK_START;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], BasicBlockStartState.prototype, "stateType", null);
                  exports2.BasicBlockStartState = BasicBlockStartState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/BasicState.js": (
                /*!*************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/BasicState.js ***!
                  \*************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.BasicState = void 0;
                  const ATNState_1 = __webpack_require__2(
                    /*! ./ATNState */
                    "./node_modules/antlr4ts/atn/ATNState.js"
                  );
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class BasicState extends ATNState_1.ATNState {
                    get stateType() {
                      return ATNStateType_1.ATNStateType.BASIC;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], BasicState.prototype, "stateType", null);
                  exports2.BasicState = BasicState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/BlockEndState.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/BlockEndState.js ***!
                  \****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.BlockEndState = void 0;
                  const ATNState_1 = __webpack_require__2(
                    /*! ./ATNState */
                    "./node_modules/antlr4ts/atn/ATNState.js"
                  );
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class BlockEndState extends ATNState_1.ATNState {
                    get stateType() {
                      return ATNStateType_1.ATNStateType.BLOCK_END;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], BlockEndState.prototype, "stateType", null);
                  exports2.BlockEndState = BlockEndState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/BlockStartState.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/BlockStartState.js ***!
                  \******************************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.BlockStartState = void 0;
                  const DecisionState_1 = __webpack_require__2(
                    /*! ./DecisionState */
                    "./node_modules/antlr4ts/atn/DecisionState.js"
                  );
                  class BlockStartState extends DecisionState_1.DecisionState {
                  }
                  exports2.BlockStartState = BlockStartState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ConflictInfo.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ConflictInfo.js ***!
                  \***************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ConflictInfo = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Utils = __webpack_require__2(
                    /*! ../misc/Utils */
                    "./node_modules/antlr4ts/misc/Utils.js"
                  );
                  class ConflictInfo {
                    constructor(conflictedAlts, exact) {
                      this._conflictedAlts = conflictedAlts;
                      this.exact = exact;
                    }
                    /**
                     * Gets the set of conflicting alternatives for the configuration set.
                     */
                    get conflictedAlts() {
                      return this._conflictedAlts;
                    }
                    /**
                     * Gets whether or not the configuration conflict is an exact conflict.
                     * An exact conflict occurs when the prediction algorithm determines that
                     * the represented alternatives for a particular configuration set cannot be
                     * further reduced by consuming additional input. After reaching an exact
                     * conflict during an SLL prediction, only switch to full-context prediction
                     * could reduce the set of viable alternatives. In LL prediction, an exact
                     * conflict indicates a true ambiguity in the input.
                     *
                     * For the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction mode,
                     * accept states are conflicting but not exact are treated as non-accept
                     * states.
                     */
                    get isExact() {
                      return this.exact;
                    }
                    equals(obj) {
                      if (obj === this) {
                        return true;
                      } else if (!(obj instanceof ConflictInfo)) {
                        return false;
                      }
                      return this.isExact === obj.isExact && Utils.equals(this.conflictedAlts, obj.conflictedAlts);
                    }
                    hashCode() {
                      return this.conflictedAlts.hashCode();
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], ConflictInfo.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], ConflictInfo.prototype, "hashCode", null);
                  exports2.ConflictInfo = ConflictInfo;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ContextSensitivityInfo.js": (
                /*!*************************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ContextSensitivityInfo.js ***!
                  \*************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ContextSensitivityInfo = void 0;
                  const DecisionEventInfo_1 = __webpack_require__2(
                    /*! ./DecisionEventInfo */
                    "./node_modules/antlr4ts/atn/DecisionEventInfo.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let ContextSensitivityInfo = class ContextSensitivityInfo extends DecisionEventInfo_1.DecisionEventInfo {
                    /**
                     * Constructs a new instance of the {@link ContextSensitivityInfo} class
                     * with the specified detailed context sensitivity information.
                     *
                     * @param decision The decision number
                     * @param state The final simulator state containing the unique
                     * alternative identified by full-context prediction
                     * @param input The input token stream
                     * @param startIndex The start index for the current prediction
                     * @param stopIndex The index at which the context sensitivity was
                     * identified during full-context prediction
                     */
                    constructor(decision, state, input, startIndex, stopIndex) {
                      super(decision, state, input, startIndex, stopIndex, true);
                    }
                  };
                  ContextSensitivityInfo = __decorate([
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ContextSensitivityInfo);
                  exports2.ContextSensitivityInfo = ContextSensitivityInfo;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/DecisionEventInfo.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/DecisionEventInfo.js ***!
                  \********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.DecisionEventInfo = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let DecisionEventInfo = class DecisionEventInfo {
                    constructor(decision, state, input, startIndex, stopIndex, fullCtx) {
                      this.decision = decision;
                      this.fullCtx = fullCtx;
                      this.stopIndex = stopIndex;
                      this.input = input;
                      this.startIndex = startIndex;
                      this.state = state;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], DecisionEventInfo.prototype, "input", void 0);
                  DecisionEventInfo = __decorate([
                    __param(2, Decorators_1.NotNull)
                  ], DecisionEventInfo);
                  exports2.DecisionEventInfo = DecisionEventInfo;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/DecisionInfo.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/DecisionInfo.js ***!
                  \***************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.DecisionInfo = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class DecisionInfo {
                    /**
                     * Constructs a new instance of the {@link DecisionInfo} class to contain
                     * statistics for a particular decision.
                     *
                     * @param decision The decision number
                     */
                    constructor(decision) {
                      this.invocations = 0;
                      this.timeInPrediction = 0;
                      this.SLL_TotalLook = 0;
                      this.SLL_MinLook = 0;
                      this.SLL_MaxLook = 0;
                      this.LL_TotalLook = 0;
                      this.LL_MinLook = 0;
                      this.LL_MaxLook = 0;
                      this.contextSensitivities = [];
                      this.errors = [];
                      this.ambiguities = [];
                      this.predicateEvals = [];
                      this.SLL_ATNTransitions = 0;
                      this.SLL_DFATransitions = 0;
                      this.LL_Fallback = 0;
                      this.LL_ATNTransitions = 0;
                      this.LL_DFATransitions = 0;
                      this.decision = decision;
                    }
                    toString() {
                      return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", SLL_lookahead=" + this.SLL_TotalLook + ", SLL_ATNTransitions=" + this.SLL_ATNTransitions + ", SLL_DFATransitions=" + this.SLL_DFATransitions + ", LL_Fallback=" + this.LL_Fallback + ", LL_lookahead=" + this.LL_TotalLook + ", LL_ATNTransitions=" + this.LL_ATNTransitions + "}";
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], DecisionInfo.prototype, "toString", null);
                  exports2.DecisionInfo = DecisionInfo;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/DecisionState.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/DecisionState.js ***!
                  \****************************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.DecisionState = void 0;
                  const ATNState_1 = __webpack_require__2(
                    /*! ./ATNState */
                    "./node_modules/antlr4ts/atn/ATNState.js"
                  );
                  class DecisionState extends ATNState_1.ATNState {
                    constructor() {
                      super(...arguments);
                      this.decision = -1;
                      this.nonGreedy = false;
                      this.sll = false;
                    }
                  }
                  exports2.DecisionState = DecisionState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/EpsilonTransition.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/EpsilonTransition.js ***!
                  \********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.EpsilonTransition = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Transition_1 = __webpack_require__2(
                    /*! ./Transition */
                    "./node_modules/antlr4ts/atn/Transition.js"
                  );
                  let EpsilonTransition = class EpsilonTransition extends Transition_1.Transition {
                    constructor(target, outermostPrecedenceReturn = -1) {
                      super(target);
                      this._outermostPrecedenceReturn = outermostPrecedenceReturn;
                    }
                    /**
                     * @returns the rule index of a precedence rule for which this transition is
                     * returning from, where the precedence value is 0; otherwise, -1.
                     *
                     * @see ATNConfig.isPrecedenceFilterSuppressed
                     * @see ParserATNSimulator#applyPrecedenceFilter(ATNConfigSet, ParserRuleContext, PredictionContextCache)
                     * @since 4.4.1
                     */
                    get outermostPrecedenceReturn() {
                      return this._outermostPrecedenceReturn;
                    }
                    get serializationType() {
                      return 1;
                    }
                    get isEpsilon() {
                      return true;
                    }
                    matches(symbol, minVocabSymbol, maxVocabSymbol) {
                      return false;
                    }
                    toString() {
                      return "epsilon";
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], EpsilonTransition.prototype, "serializationType", null);
                  __decorate([
                    Decorators_1.Override
                  ], EpsilonTransition.prototype, "isEpsilon", null);
                  __decorate([
                    Decorators_1.Override
                  ], EpsilonTransition.prototype, "matches", null);
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull
                  ], EpsilonTransition.prototype, "toString", null);
                  EpsilonTransition = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], EpsilonTransition);
                  exports2.EpsilonTransition = EpsilonTransition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ErrorInfo.js": (
                /*!************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ErrorInfo.js ***!
                  \************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ErrorInfo = void 0;
                  const DecisionEventInfo_1 = __webpack_require__2(
                    /*! ./DecisionEventInfo */
                    "./node_modules/antlr4ts/atn/DecisionEventInfo.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let ErrorInfo = class ErrorInfo extends DecisionEventInfo_1.DecisionEventInfo {
                    /**
                     * Constructs a new instance of the {@link ErrorInfo} class with the
                     * specified detailed syntax error information.
                     *
                     * @param decision The decision number
                     * @param state The final simulator state reached during prediction
                     * prior to reaching the {@link ATNSimulator#ERROR} state
                     * @param input The input token stream
                     * @param startIndex The start index for the current prediction
                     * @param stopIndex The index at which the syntax error was identified
                     */
                    constructor(decision, state, input, startIndex, stopIndex) {
                      super(decision, state, input, startIndex, stopIndex, state.useContext);
                    }
                  };
                  ErrorInfo = __decorate([
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ErrorInfo);
                  exports2.ErrorInfo = ErrorInfo;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/InvalidState.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/InvalidState.js ***!
                  \***************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.InvalidState = void 0;
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const BasicState_1 = __webpack_require__2(
                    /*! ./BasicState */
                    "./node_modules/antlr4ts/atn/BasicState.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class InvalidState extends BasicState_1.BasicState {
                    get stateType() {
                      return ATNStateType_1.ATNStateType.INVALID_TYPE;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], InvalidState.prototype, "stateType", null);
                  exports2.InvalidState = InvalidState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LL1Analyzer.js": (
                /*!**************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LL1Analyzer.js ***!
                  \**************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LL1Analyzer = void 0;
                  const AbstractPredicateTransition_1 = __webpack_require__2(
                    /*! ./AbstractPredicateTransition */
                    "./node_modules/antlr4ts/atn/AbstractPredicateTransition.js"
                  );
                  const Array2DHashSet_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashSet */
                    "./node_modules/antlr4ts/misc/Array2DHashSet.js"
                  );
                  const ATNConfig_1 = __webpack_require__2(
                    /*! ./ATNConfig */
                    "./node_modules/antlr4ts/atn/ATNConfig.js"
                  );
                  const BitSet_1 = __webpack_require__2(
                    /*! ../misc/BitSet */
                    "./node_modules/antlr4ts/misc/BitSet.js"
                  );
                  const IntervalSet_1 = __webpack_require__2(
                    /*! ../misc/IntervalSet */
                    "./node_modules/antlr4ts/misc/IntervalSet.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const NotSetTransition_1 = __webpack_require__2(
                    /*! ./NotSetTransition */
                    "./node_modules/antlr4ts/atn/NotSetTransition.js"
                  );
                  const ObjectEqualityComparator_1 = __webpack_require__2(
                    /*! ../misc/ObjectEqualityComparator */
                    "./node_modules/antlr4ts/misc/ObjectEqualityComparator.js"
                  );
                  const PredictionContext_1 = __webpack_require__2(
                    /*! ./PredictionContext */
                    "./node_modules/antlr4ts/atn/PredictionContext.js"
                  );
                  const RuleStopState_1 = __webpack_require__2(
                    /*! ./RuleStopState */
                    "./node_modules/antlr4ts/atn/RuleStopState.js"
                  );
                  const RuleTransition_1 = __webpack_require__2(
                    /*! ./RuleTransition */
                    "./node_modules/antlr4ts/atn/RuleTransition.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const WildcardTransition_1 = __webpack_require__2(
                    /*! ./WildcardTransition */
                    "./node_modules/antlr4ts/atn/WildcardTransition.js"
                  );
                  let LL1Analyzer = class LL1Analyzer2 {
                    constructor(atn) {
                      this.atn = atn;
                    }
                    /**
                     * Calculates the SLL(1) expected lookahead set for each outgoing transition
                     * of an {@link ATNState}. The returned array has one element for each
                     * outgoing transition in `s`. If the closure from transition
                     * *i* leads to a semantic predicate before matching a symbol, the
                     * element at index *i* of the result will be `undefined`.
                     *
                     * @param s the ATN state
                     * @returns the expected symbols for each outgoing transition of `s`.
                     */
                    getDecisionLookahead(s) {
                      if (s == null) {
                        return void 0;
                      }
                      let look = new Array(s.numberOfTransitions);
                      for (let alt = 0; alt < s.numberOfTransitions; alt++) {
                        let current = new IntervalSet_1.IntervalSet();
                        look[alt] = current;
                        let lookBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
                        let seeThruPreds = false;
                        this._LOOK(s.transition(alt).target, void 0, PredictionContext_1.PredictionContext.EMPTY_LOCAL, current, lookBusy, new BitSet_1.BitSet(), seeThruPreds, false);
                        if (current.size === 0 || current.contains(LL1Analyzer2.HIT_PRED)) {
                          current = void 0;
                          look[alt] = current;
                        }
                      }
                      return look;
                    }
                    LOOK(s, ctx, stopState) {
                      if (stopState === void 0) {
                        if (s.atn == null) {
                          throw new Error("Illegal state");
                        }
                        stopState = s.atn.ruleToStopState[s.ruleIndex];
                      } else if (stopState === null) {
                        stopState = void 0;
                      }
                      let r = new IntervalSet_1.IntervalSet();
                      let seeThruPreds = true;
                      let addEOF = true;
                      this._LOOK(s, stopState, ctx, r, new Array2DHashSet_1.Array2DHashSet(), new BitSet_1.BitSet(), seeThruPreds, addEOF);
                      return r;
                    }
                    /**
                     * Compute set of tokens that can follow `s` in the ATN in the
                     * specified `ctx`.
                     * <p/>
                     * If `ctx` is {@link PredictionContext#EMPTY_LOCAL} and
                     * `stopState` or the end of the rule containing `s` is reached,
                     * {@link Token#EPSILON} is added to the result set. If `ctx` is not
                     * {@link PredictionContext#EMPTY_LOCAL} and `addEOF` is `true`
                     * and `stopState` or the end of the outermost rule is reached,
                     * {@link Token#EOF} is added to the result set.
                     *
                     * @param s the ATN state.
                     * @param stopState the ATN state to stop at. This can be a
                     * {@link BlockEndState} to detect epsilon paths through a closure.
                     * @param ctx The outer context, or {@link PredictionContext#EMPTY_LOCAL} if
                     * the outer context should not be used.
                     * @param look The result lookahead set.
                     * @param lookBusy A set used for preventing epsilon closures in the ATN
                     * from causing a stack overflow. Outside code should pass
                     * `new HashSet<ATNConfig>` for this argument.
                     * @param calledRuleStack A set used for preventing left recursion in the
                     * ATN from causing a stack overflow. Outside code should pass
                     * `new BitSet()` for this argument.
                     * @param seeThruPreds `true` to true semantic predicates as
                     * implicitly `true` and "see through them", otherwise `false`
                     * to treat semantic predicates as opaque and add {@link #HIT_PRED} to the
                     * result if one is encountered.
                     * @param addEOF Add {@link Token#EOF} to the result if the end of the
                     * outermost context is reached. This parameter has no effect if `ctx`
                     * is {@link PredictionContext#EMPTY_LOCAL}.
                     */
                    _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
                      let c = ATNConfig_1.ATNConfig.create(s, 0, ctx);
                      if (!lookBusy.add(c)) {
                        return;
                      }
                      if (s === stopState) {
                        if (PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
                          look.add(Token_1.Token.EPSILON);
                          return;
                        } else if (ctx.isEmpty) {
                          if (addEOF) {
                            look.add(Token_1.Token.EOF);
                          }
                          return;
                        }
                      }
                      if (s instanceof RuleStopState_1.RuleStopState) {
                        if (ctx.isEmpty && !PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
                          if (addEOF) {
                            look.add(Token_1.Token.EOF);
                          }
                          return;
                        }
                        let removed = calledRuleStack.get(s.ruleIndex);
                        try {
                          calledRuleStack.clear(s.ruleIndex);
                          for (let i = 0; i < ctx.size; i++) {
                            if (ctx.getReturnState(i) === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                              continue;
                            }
                            let returnState = this.atn.states[ctx.getReturnState(i)];
                            this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                          }
                        } finally {
                          if (removed) {
                            calledRuleStack.set(s.ruleIndex);
                          }
                        }
                      }
                      let n = s.numberOfTransitions;
                      for (let i = 0; i < n; i++) {
                        let t = s.transition(i);
                        if (t instanceof RuleTransition_1.RuleTransition) {
                          if (calledRuleStack.get(t.ruleIndex)) {
                            continue;
                          }
                          let newContext = ctx.getChild(t.followState.stateNumber);
                          try {
                            calledRuleStack.set(t.ruleIndex);
                            this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                          } finally {
                            calledRuleStack.clear(t.ruleIndex);
                          }
                        } else if (t instanceof AbstractPredicateTransition_1.AbstractPredicateTransition) {
                          if (seeThruPreds) {
                            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                          } else {
                            look.add(LL1Analyzer2.HIT_PRED);
                          }
                        } else if (t.isEpsilon) {
                          this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                        } else if (t instanceof WildcardTransition_1.WildcardTransition) {
                          look.addAll(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
                        } else {
                          let set2 = t.label;
                          if (set2 != null) {
                            if (t instanceof NotSetTransition_1.NotSetTransition) {
                              set2 = set2.complement(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
                            }
                            look.addAll(set2);
                          }
                        }
                      }
                    }
                  };
                  LL1Analyzer.HIT_PRED = Token_1.Token.INVALID_TYPE;
                  __decorate([
                    Decorators_1.NotNull
                  ], LL1Analyzer.prototype, "atn", void 0);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], LL1Analyzer.prototype, "LOOK", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull),
                    __param(3, Decorators_1.NotNull),
                    __param(4, Decorators_1.NotNull),
                    __param(5, Decorators_1.NotNull)
                  ], LL1Analyzer.prototype, "_LOOK", null);
                  LL1Analyzer = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LL1Analyzer);
                  exports2.LL1Analyzer = LL1Analyzer;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LexerATNSimulator.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LexerATNSimulator.js ***!
                  \********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerATNSimulator = void 0;
                  const AcceptStateInfo_1 = __webpack_require__2(
                    /*! ../dfa/AcceptStateInfo */
                    "./node_modules/antlr4ts/dfa/AcceptStateInfo.js"
                  );
                  const ATN_1 = __webpack_require__2(
                    /*! ./ATN */
                    "./node_modules/antlr4ts/atn/ATN.js"
                  );
                  const ATNConfig_1 = __webpack_require__2(
                    /*! ./ATNConfig */
                    "./node_modules/antlr4ts/atn/ATNConfig.js"
                  );
                  const ATNConfigSet_1 = __webpack_require__2(
                    /*! ./ATNConfigSet */
                    "./node_modules/antlr4ts/atn/ATNConfigSet.js"
                  );
                  const ATNSimulator_1 = __webpack_require__2(
                    /*! ./ATNSimulator */
                    "./node_modules/antlr4ts/atn/ATNSimulator.js"
                  );
                  const DFAState_1 = __webpack_require__2(
                    /*! ../dfa/DFAState */
                    "./node_modules/antlr4ts/dfa/DFAState.js"
                  );
                  const Interval_1 = __webpack_require__2(
                    /*! ../misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const IntStream_1 = __webpack_require__2(
                    /*! ../IntStream */
                    "./node_modules/antlr4ts/IntStream.js"
                  );
                  const Lexer_1 = __webpack_require__2(
                    /*! ../Lexer */
                    "./node_modules/antlr4ts/Lexer.js"
                  );
                  const LexerActionExecutor_1 = __webpack_require__2(
                    /*! ./LexerActionExecutor */
                    "./node_modules/antlr4ts/atn/LexerActionExecutor.js"
                  );
                  const LexerNoViableAltException_1 = __webpack_require__2(
                    /*! ../LexerNoViableAltException */
                    "./node_modules/antlr4ts/LexerNoViableAltException.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const OrderedATNConfigSet_1 = __webpack_require__2(
                    /*! ./OrderedATNConfigSet */
                    "./node_modules/antlr4ts/atn/OrderedATNConfigSet.js"
                  );
                  const PredictionContext_1 = __webpack_require__2(
                    /*! ./PredictionContext */
                    "./node_modules/antlr4ts/atn/PredictionContext.js"
                  );
                  const RuleStopState_1 = __webpack_require__2(
                    /*! ./RuleStopState */
                    "./node_modules/antlr4ts/atn/RuleStopState.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  let LexerATNSimulator = class LexerATNSimulator2 extends ATNSimulator_1.ATNSimulator {
                    constructor(atn, recog) {
                      super(atn);
                      this.optimize_tail_calls = true;
                      this.startIndex = -1;
                      this._line = 1;
                      this._charPositionInLine = 0;
                      this.mode = Lexer_1.Lexer.DEFAULT_MODE;
                      this.prevAccept = new LexerATNSimulator2.SimState();
                      this.recog = recog;
                    }
                    copyState(simulator) {
                      this._charPositionInLine = simulator.charPositionInLine;
                      this._line = simulator._line;
                      this.mode = simulator.mode;
                      this.startIndex = simulator.startIndex;
                    }
                    match(input, mode) {
                      this.mode = mode;
                      let mark = input.mark();
                      try {
                        this.startIndex = input.index;
                        this.prevAccept.reset();
                        let s0 = this.atn.modeToDFA[mode].s0;
                        if (s0 == null) {
                          return this.matchATN(input);
                        } else {
                          return this.execATN(input, s0);
                        }
                      } finally {
                        input.release(mark);
                      }
                    }
                    reset() {
                      this.prevAccept.reset();
                      this.startIndex = -1;
                      this._line = 1;
                      this._charPositionInLine = 0;
                      this.mode = Lexer_1.Lexer.DEFAULT_MODE;
                    }
                    matchATN(input) {
                      let startState = this.atn.modeToStartState[this.mode];
                      if (LexerATNSimulator2.debug) {
                        console.log(`matchATN mode ${this.mode} start: ${startState}`);
                      }
                      let old_mode = this.mode;
                      let s0_closure = this.computeStartState(input, startState);
                      let suppressEdge = s0_closure.hasSemanticContext;
                      if (suppressEdge) {
                        s0_closure.hasSemanticContext = false;
                      }
                      let next = this.addDFAState(s0_closure);
                      if (!suppressEdge) {
                        let dfa = this.atn.modeToDFA[this.mode];
                        if (!dfa.s0) {
                          dfa.s0 = next;
                        } else {
                          next = dfa.s0;
                        }
                      }
                      let predict = this.execATN(input, next);
                      if (LexerATNSimulator2.debug) {
                        console.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);
                      }
                      return predict;
                    }
                    execATN(input, ds0) {
                      if (LexerATNSimulator2.debug) {
                        console.log(`start state closure=${ds0.configs}`);
                      }
                      if (ds0.isAcceptState) {
                        this.captureSimState(this.prevAccept, input, ds0);
                      }
                      let t = input.LA(1);
                      let s = ds0;
                      while (true) {
                        if (LexerATNSimulator2.debug) {
                          console.log(`execATN loop starting closure: ${s.configs}`);
                        }
                        let target = this.getExistingTargetState(s, t);
                        if (target == null) {
                          target = this.computeTargetState(input, s, t);
                        }
                        if (target === ATNSimulator_1.ATNSimulator.ERROR) {
                          break;
                        }
                        if (t !== IntStream_1.IntStream.EOF) {
                          this.consume(input);
                        }
                        if (target.isAcceptState) {
                          this.captureSimState(this.prevAccept, input, target);
                          if (t === IntStream_1.IntStream.EOF) {
                            break;
                          }
                        }
                        t = input.LA(1);
                        s = target;
                      }
                      return this.failOrAccept(this.prevAccept, input, s.configs, t);
                    }
                    /**
                     * Get an existing target state for an edge in the DFA. If the target state
                     * for the edge has not yet been computed or is otherwise not available,
                     * this method returns `undefined`.
                     *
                     * @param s The current DFA state
                     * @param t The next input symbol
                     * @returns The existing target DFA state for the given input symbol
                     * `t`, or `undefined` if the target state for this edge is not
                     * already cached
                     */
                    getExistingTargetState(s, t) {
                      let target = s.getTarget(t);
                      if (LexerATNSimulator2.debug && target != null) {
                        console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
                      }
                      return target;
                    }
                    /**
                     * Compute a target state for an edge in the DFA, and attempt to add the
                     * computed state and corresponding edge to the DFA.
                     *
                     * @param input The input stream
                     * @param s The current DFA state
                     * @param t The next input symbol
                     *
                     * @returns The computed target DFA state for the given input symbol
                     * `t`. If `t` does not lead to a valid DFA state, this method
                     * returns {@link #ERROR}.
                     */
                    computeTargetState(input, s, t) {
                      let reach = new OrderedATNConfigSet_1.OrderedATNConfigSet();
                      this.getReachableConfigSet(input, s.configs, reach, t);
                      if (reach.isEmpty) {
                        if (!reach.hasSemanticContext) {
                          this.addDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
                        }
                        return ATNSimulator_1.ATNSimulator.ERROR;
                      }
                      return this.addDFAEdge(s, t, reach);
                    }
                    failOrAccept(prevAccept, input, reach, t) {
                      if (prevAccept.dfaState != null) {
                        let lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
                        this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.charPos);
                        return prevAccept.dfaState.prediction;
                      } else {
                        if (t === IntStream_1.IntStream.EOF && input.index === this.startIndex) {
                          return Token_1.Token.EOF;
                        }
                        throw new LexerNoViableAltException_1.LexerNoViableAltException(this.recog, input, this.startIndex, reach);
                      }
                    }
                    /** Given a starting configuration set, figure out all ATN configurations
                     *  we can reach upon input `t`. Parameter `reach` is a return
                     *  parameter.
                     */
                    getReachableConfigSet(input, closure, reach, t) {
                      let skipAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
                      for (let c of closure) {
                        let currentAltReachedAcceptState = c.alt === skipAlt;
                        if (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {
                          continue;
                        }
                        if (LexerATNSimulator2.debug) {
                          console.log(`testing ${this.getTokenName(t)} at ${c.toString(this.recog, true)}`);
                        }
                        let n = c.state.numberOfOptimizedTransitions;
                        for (let ti = 0; ti < n; ti++) {
                          let trans = c.state.getOptimizedTransition(ti);
                          let target = this.getReachableTarget(trans, t);
                          if (target != null) {
                            let lexerActionExecutor = c.lexerActionExecutor;
                            let config;
                            if (lexerActionExecutor != null) {
                              lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
                              config = c.transform(target, true, lexerActionExecutor);
                            } else {
                              assert(c.lexerActionExecutor == null);
                              config = c.transform(target, true);
                            }
                            let treatEofAsEpsilon = t === IntStream_1.IntStream.EOF;
                            if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
                              skipAlt = c.alt;
                              break;
                            }
                          }
                        }
                      }
                    }
                    accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
                      if (LexerATNSimulator2.debug) {
                        console.log(`ACTION ${lexerActionExecutor}`);
                      }
                      input.seek(index);
                      this._line = line;
                      this._charPositionInLine = charPos;
                      if (lexerActionExecutor != null && this.recog != null) {
                        lexerActionExecutor.execute(this.recog, input, startIndex);
                      }
                    }
                    getReachableTarget(trans, t) {
                      if (trans.matches(t, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
                        return trans.target;
                      }
                      return void 0;
                    }
                    computeStartState(input, p) {
                      let initialContext = PredictionContext_1.PredictionContext.EMPTY_FULL;
                      let configs = new OrderedATNConfigSet_1.OrderedATNConfigSet();
                      for (let i = 0; i < p.numberOfTransitions; i++) {
                        let target = p.transition(i).target;
                        let c = ATNConfig_1.ATNConfig.create(target, i + 1, initialContext);
                        this.closure(input, c, configs, false, false, false);
                      }
                      return configs;
                    }
                    /**
                     * Since the alternatives within any lexer decision are ordered by
                     * preference, this method stops pursuing the closure as soon as an accept
                     * state is reached. After the first accept state is reached by depth-first
                     * search from `config`, all other (potentially reachable) states for
                     * this rule would have a lower priority.
                     *
                     * @returns `true` if an accept state is reached, otherwise
                     * `false`.
                     */
                    closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
                      if (LexerATNSimulator2.debug) {
                        console.log("closure(" + config.toString(this.recog, true) + ")");
                      }
                      if (config.state instanceof RuleStopState_1.RuleStopState) {
                        if (LexerATNSimulator2.debug) {
                          if (this.recog != null) {
                            console.log(`closure at ${this.recog.ruleNames[config.state.ruleIndex]} rule stop ${config}`);
                          } else {
                            console.log(`closure at rule stop ${config}`);
                          }
                        }
                        let context = config.context;
                        if (context.isEmpty) {
                          configs.add(config);
                          return true;
                        } else if (context.hasEmpty) {
                          configs.add(config.transform(config.state, true, PredictionContext_1.PredictionContext.EMPTY_FULL));
                          currentAltReachedAcceptState = true;
                        }
                        for (let i = 0; i < context.size; i++) {
                          let returnStateNumber = context.getReturnState(i);
                          if (returnStateNumber === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                            continue;
                          }
                          let newContext = context.getParent(i);
                          let returnState = this.atn.states[returnStateNumber];
                          let c = config.transform(returnState, false, newContext);
                          currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
                        }
                        return currentAltReachedAcceptState;
                      }
                      if (!config.state.onlyHasEpsilonTransitions) {
                        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision) {
                          configs.add(config);
                        }
                      }
                      let p = config.state;
                      for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
                        let t = p.getOptimizedTransition(i);
                        let c = this.getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon);
                        if (c != null) {
                          currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
                        }
                      }
                      return currentAltReachedAcceptState;
                    }
                    // side-effect: can alter configs.hasSemanticContext
                    getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon) {
                      let c;
                      switch (t.serializationType) {
                        case 3:
                          let ruleTransition = t;
                          if (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config.context.hasEmpty) {
                            c = config.transform(t.target, true);
                          } else {
                            let newContext = config.context.getChild(ruleTransition.followState.stateNumber);
                            c = config.transform(t.target, true, newContext);
                          }
                          break;
                        case 10:
                          throw new Error("Precedence predicates are not supported in lexers.");
                        case 4:
                          let pt = t;
                          if (LexerATNSimulator2.debug) {
                            console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
                          }
                          configs.hasSemanticContext = true;
                          if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
                            c = config.transform(t.target, true);
                          } else {
                            c = void 0;
                          }
                          break;
                        case 6:
                          if (config.context.hasEmpty) {
                            let lexerActionExecutor = LexerActionExecutor_1.LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[t.actionIndex]);
                            c = config.transform(t.target, true, lexerActionExecutor);
                            break;
                          } else {
                            c = config.transform(t.target, true);
                            break;
                          }
                        case 1:
                          c = config.transform(t.target, true);
                          break;
                        case 5:
                        case 2:
                        case 7:
                          if (treatEofAsEpsilon) {
                            if (t.matches(IntStream_1.IntStream.EOF, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
                              c = config.transform(t.target, false);
                              break;
                            }
                          }
                          c = void 0;
                          break;
                        default:
                          c = void 0;
                          break;
                      }
                      return c;
                    }
                    /**
                     * Evaluate a predicate specified in the lexer.
                     *
                     * If `speculative` is `true`, this method was called before
                     * {@link #consume} for the matched character. This method should call
                     * {@link #consume} before evaluating the predicate to ensure position
                     * sensitive values, including {@link Lexer#getText}, {@link Lexer#getLine},
                     * and {@link Lexer#getCharPositionInLine}, properly reflect the current
                     * lexer state. This method should restore `input` and the simulator
                     * to the original state before returning (i.e. undo the actions made by the
                     * call to {@link #consume}.
                     *
                     * @param input The input stream.
                     * @param ruleIndex The rule containing the predicate.
                     * @param predIndex The index of the predicate within the rule.
                     * @param speculative `true` if the current index in `input` is
                     * one character before the predicate's location.
                     *
                     * @returns `true` if the specified predicate evaluates to
                     * `true`.
                     */
                    evaluatePredicate(input, ruleIndex, predIndex, speculative) {
                      if (this.recog == null) {
                        return true;
                      }
                      if (!speculative) {
                        return this.recog.sempred(void 0, ruleIndex, predIndex);
                      }
                      let savedCharPositionInLine = this._charPositionInLine;
                      let savedLine = this._line;
                      let index = input.index;
                      let marker = input.mark();
                      try {
                        this.consume(input);
                        return this.recog.sempred(void 0, ruleIndex, predIndex);
                      } finally {
                        this._charPositionInLine = savedCharPositionInLine;
                        this._line = savedLine;
                        input.seek(index);
                        input.release(marker);
                      }
                    }
                    captureSimState(settings, input, dfaState) {
                      settings.index = input.index;
                      settings.line = this._line;
                      settings.charPos = this._charPositionInLine;
                      settings.dfaState = dfaState;
                    }
                    addDFAEdge(p, t, q) {
                      if (q instanceof ATNConfigSet_1.ATNConfigSet) {
                        let suppressEdge = q.hasSemanticContext;
                        if (suppressEdge) {
                          q.hasSemanticContext = false;
                        }
                        let to = this.addDFAState(q);
                        if (suppressEdge) {
                          return to;
                        }
                        this.addDFAEdge(p, t, to);
                        return to;
                      } else {
                        if (LexerATNSimulator2.debug) {
                          console.log("EDGE " + p + " -> " + q + " upon " + String.fromCharCode(t));
                        }
                        if (p != null) {
                          p.setTarget(t, q);
                        }
                      }
                    }
                    /** Add a new DFA state if there isn't one with this set of
                     * 	configurations already. This method also detects the first
                     * 	configuration containing an ATN rule stop state. Later, when
                     * 	traversing the DFA, we will know which rule to accept.
                     */
                    addDFAState(configs) {
                      assert(!configs.hasSemanticContext);
                      let proposed = new DFAState_1.DFAState(configs);
                      let existing = this.atn.modeToDFA[this.mode].states.get(proposed);
                      if (existing != null) {
                        return existing;
                      }
                      configs.optimizeConfigs(this);
                      let newState = new DFAState_1.DFAState(configs.clone(true));
                      let firstConfigWithRuleStopState;
                      for (let c of configs) {
                        if (c.state instanceof RuleStopState_1.RuleStopState) {
                          firstConfigWithRuleStopState = c;
                          break;
                        }
                      }
                      if (firstConfigWithRuleStopState != null) {
                        let prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
                        let lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
                        newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(prediction, lexerActionExecutor);
                      }
                      return this.atn.modeToDFA[this.mode].addState(newState);
                    }
                    getDFA(mode) {
                      return this.atn.modeToDFA[mode];
                    }
                    /** Get the text matched so far for the current token.
                     */
                    getText(input) {
                      return input.getText(Interval_1.Interval.of(this.startIndex, input.index - 1));
                    }
                    get line() {
                      return this._line;
                    }
                    set line(line) {
                      this._line = line;
                    }
                    get charPositionInLine() {
                      return this._charPositionInLine;
                    }
                    set charPositionInLine(charPositionInLine) {
                      this._charPositionInLine = charPositionInLine;
                    }
                    consume(input) {
                      let curChar = input.LA(1);
                      if (curChar === "\n".charCodeAt(0)) {
                        this._line++;
                        this._charPositionInLine = 0;
                      } else {
                        this._charPositionInLine++;
                      }
                      input.consume();
                    }
                    getTokenName(t) {
                      if (t === -1) {
                        return "EOF";
                      }
                      return "'" + String.fromCharCode(t) + "'";
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], LexerATNSimulator.prototype, "prevAccept", void 0);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "copyState", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "match", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerATNSimulator.prototype, "reset", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "matchATN", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "execATN", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "getExistingTargetState", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "computeTargetState", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "getReachableConfigSet", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "accept", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "computeStartState", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "closure", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull),
                    __param(3, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "getEpsilonTarget", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "evaluatePredicate", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "captureSimState", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "addDFAState", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], LexerATNSimulator.prototype, "getDFA", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "getText", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LexerATNSimulator.prototype, "consume", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], LexerATNSimulator.prototype, "getTokenName", null);
                  LexerATNSimulator = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LexerATNSimulator);
                  exports2.LexerATNSimulator = LexerATNSimulator;
                  (function(LexerATNSimulator2) {
                    LexerATNSimulator2.debug = false;
                    LexerATNSimulator2.dfa_debug = false;
                    class SimState {
                      constructor() {
                        this.index = -1;
                        this.line = 0;
                        this.charPos = -1;
                      }
                      reset() {
                        this.index = -1;
                        this.line = 0;
                        this.charPos = -1;
                        this.dfaState = void 0;
                      }
                    }
                    LexerATNSimulator2.SimState = SimState;
                  })(LexerATNSimulator = exports2.LexerATNSimulator || (exports2.LexerATNSimulator = {}));
                  exports2.LexerATNSimulator = LexerATNSimulator;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LexerActionExecutor.js": (
                /*!**********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LexerActionExecutor.js ***!
                  \**********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerActionExecutor = void 0;
                  const ArrayEqualityComparator_1 = __webpack_require__2(
                    /*! ../misc/ArrayEqualityComparator */
                    "./node_modules/antlr4ts/misc/ArrayEqualityComparator.js"
                  );
                  const LexerIndexedCustomAction_1 = __webpack_require__2(
                    /*! ./LexerIndexedCustomAction */
                    "./node_modules/antlr4ts/atn/LexerIndexedCustomAction.js"
                  );
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let LexerActionExecutor = class LexerActionExecutor2 {
                    /**
                     * Constructs an executor for a sequence of {@link LexerAction} actions.
                     * @param lexerActions The lexer actions to execute.
                     */
                    constructor(lexerActions) {
                      this._lexerActions = lexerActions;
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      for (let lexerAction of lexerActions) {
                        hash = MurmurHash_1.MurmurHash.update(hash, lexerAction);
                      }
                      this.cachedHashCode = MurmurHash_1.MurmurHash.finish(hash, lexerActions.length);
                    }
                    /**
                     * Creates a {@link LexerActionExecutor} which executes the actions for
                     * the input `lexerActionExecutor` followed by a specified
                     * `lexerAction`.
                     *
                     * @param lexerActionExecutor The executor for actions already traversed by
                     * the lexer while matching a token within a particular
                     * {@link ATNConfig}. If this is `undefined`, the method behaves as though
                     * it were an empty executor.
                     * @param lexerAction The lexer action to execute after the actions
                     * specified in `lexerActionExecutor`.
                     *
                     * @returns A {@link LexerActionExecutor} for executing the combine actions
                     * of `lexerActionExecutor` and `lexerAction`.
                     */
                    static append(lexerActionExecutor, lexerAction) {
                      if (!lexerActionExecutor) {
                        return new LexerActionExecutor2([lexerAction]);
                      }
                      let lexerActions = lexerActionExecutor._lexerActions.slice(0);
                      lexerActions.push(lexerAction);
                      return new LexerActionExecutor2(lexerActions);
                    }
                    /**
                     * Creates a {@link LexerActionExecutor} which encodes the current offset
                     * for position-dependent lexer actions.
                     *
                     * Normally, when the executor encounters lexer actions where
                     * {@link LexerAction#isPositionDependent} returns `true`, it calls
                     * {@link IntStream#seek} on the input {@link CharStream} to set the input
                     * position to the *end* of the current token. This behavior provides
                     * for efficient DFA representation of lexer actions which appear at the end
                     * of a lexer rule, even when the lexer rule matches a variable number of
                     * characters.
                     *
                     * Prior to traversing a match transition in the ATN, the current offset
                     * from the token start index is assigned to all position-dependent lexer
                     * actions which have not already been assigned a fixed offset. By storing
                     * the offsets relative to the token start index, the DFA representation of
                     * lexer actions which appear in the middle of tokens remains efficient due
                     * to sharing among tokens of the same length, regardless of their absolute
                     * position in the input stream.
                     *
                     * If the current executor already has offsets assigned to all
                     * position-dependent lexer actions, the method returns `this`.
                     *
                     * @param offset The current offset to assign to all position-dependent
                     * lexer actions which do not already have offsets assigned.
                     *
                     * @returns A {@link LexerActionExecutor} which stores input stream offsets
                     * for all position-dependent lexer actions.
                     */
                    fixOffsetBeforeMatch(offset) {
                      let updatedLexerActions;
                      for (let i = 0; i < this._lexerActions.length; i++) {
                        if (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction)) {
                          if (!updatedLexerActions) {
                            updatedLexerActions = this._lexerActions.slice(0);
                          }
                          updatedLexerActions[i] = new LexerIndexedCustomAction_1.LexerIndexedCustomAction(offset, this._lexerActions[i]);
                        }
                      }
                      if (!updatedLexerActions) {
                        return this;
                      }
                      return new LexerActionExecutor2(updatedLexerActions);
                    }
                    /**
                     * Gets the lexer actions to be executed by this executor.
                     * @returns The lexer actions to be executed by this executor.
                     */
                    get lexerActions() {
                      return this._lexerActions;
                    }
                    /**
                     * Execute the actions encapsulated by this executor within the context of a
                     * particular {@link Lexer}.
                     *
                     * This method calls {@link IntStream#seek} to set the position of the
                     * `input` {@link CharStream} prior to calling
                     * {@link LexerAction#execute} on a position-dependent action. Before the
                     * method returns, the input position will be restored to the same position
                     * it was in when the method was invoked.
                     *
                     * @param lexer The lexer instance.
                     * @param input The input stream which is the source for the current token.
                     * When this method is called, the current {@link IntStream#index} for
                     * `input` should be the start of the following token, i.e. 1
                     * character past the end of the current token.
                     * @param startIndex The token start index. This value may be passed to
                     * {@link IntStream#seek} to set the `input` position to the beginning
                     * of the token.
                     */
                    execute(lexer, input, startIndex) {
                      let requiresSeek = false;
                      let stopIndex = input.index;
                      try {
                        for (let lexerAction of this._lexerActions) {
                          if (lexerAction instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction) {
                            let offset = lexerAction.offset;
                            input.seek(startIndex + offset);
                            lexerAction = lexerAction.action;
                            requiresSeek = startIndex + offset !== stopIndex;
                          } else if (lexerAction.isPositionDependent) {
                            input.seek(stopIndex);
                            requiresSeek = false;
                          }
                          lexerAction.execute(lexer);
                        }
                      } finally {
                        if (requiresSeek) {
                          input.seek(stopIndex);
                        }
                      }
                    }
                    hashCode() {
                      return this.cachedHashCode;
                    }
                    equals(obj) {
                      if (obj === this) {
                        return true;
                      } else if (!(obj instanceof LexerActionExecutor2)) {
                        return false;
                      }
                      return this.cachedHashCode === obj.cachedHashCode && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], LexerActionExecutor.prototype, "_lexerActions", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], LexerActionExecutor.prototype, "lexerActions", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LexerActionExecutor.prototype, "execute", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerActionExecutor.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerActionExecutor.prototype, "equals", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(1, Decorators_1.NotNull)
                  ], LexerActionExecutor, "append", null);
                  LexerActionExecutor = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LexerActionExecutor);
                  exports2.LexerActionExecutor = LexerActionExecutor;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LexerChannelAction.js": (
                /*!*********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LexerChannelAction.js ***!
                  \*********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerChannelAction = void 0;
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class LexerChannelAction {
                    /**
                     * Constructs a new `channel` action with the specified channel value.
                     * @param channel The channel value to pass to {@link Lexer#setChannel}.
                     */
                    constructor(channel) {
                      this._channel = channel;
                    }
                    /**
                     * Gets the channel to use for the {@link Token} created by the lexer.
                     *
                     * @returns The channel to use for the {@link Token} created by the lexer.
                     */
                    get channel() {
                      return this._channel;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns {@link LexerActionType#CHANNEL}.
                     */
                    get actionType() {
                      return 0;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns `false`.
                     */
                    get isPositionDependent() {
                      return false;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This action is implemented by calling {@link Lexer#setChannel} with the
                     * value provided by {@link #getChannel}.
                     */
                    execute(lexer) {
                      lexer.channel = this._channel;
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
                      hash = MurmurHash_1.MurmurHash.update(hash, this._channel);
                      return MurmurHash_1.MurmurHash.finish(hash, 2);
                    }
                    equals(obj) {
                      if (obj === this) {
                        return true;
                      } else if (!(obj instanceof LexerChannelAction)) {
                        return false;
                      }
                      return this._channel === obj._channel;
                    }
                    toString() {
                      return `channel(${this._channel})`;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], LexerChannelAction.prototype, "actionType", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerChannelAction.prototype, "isPositionDependent", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], LexerChannelAction.prototype, "execute", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerChannelAction.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerChannelAction.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerChannelAction.prototype, "toString", null);
                  exports2.LexerChannelAction = LexerChannelAction;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LexerCustomAction.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LexerCustomAction.js ***!
                  \********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerCustomAction = void 0;
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class LexerCustomAction {
                    /**
                     * Constructs a custom lexer action with the specified rule and action
                     * indexes.
                     *
                     * @param ruleIndex The rule index to use for calls to
                     * {@link Recognizer#action}.
                     * @param actionIndex The action index to use for calls to
                     * {@link Recognizer#action}.
                     */
                    constructor(ruleIndex, actionIndex) {
                      this._ruleIndex = ruleIndex;
                      this._actionIndex = actionIndex;
                    }
                    /**
                     * Gets the rule index to use for calls to {@link Recognizer#action}.
                     *
                     * @returns The rule index for the custom action.
                     */
                    get ruleIndex() {
                      return this._ruleIndex;
                    }
                    /**
                     * Gets the action index to use for calls to {@link Recognizer#action}.
                     *
                     * @returns The action index for the custom action.
                     */
                    get actionIndex() {
                      return this._actionIndex;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @returns This method returns {@link LexerActionType#CUSTOM}.
                     */
                    get actionType() {
                      return 1;
                    }
                    /**
                     * Gets whether the lexer action is position-dependent. Position-dependent
                     * actions may have different semantics depending on the {@link CharStream}
                     * index at the time the action is executed.
                     *
                     * Custom actions are position-dependent since they may represent a
                     * user-defined embedded action which makes calls to methods like
                     * {@link Lexer#getText}.
                     *
                     * @returns This method returns `true`.
                     */
                    get isPositionDependent() {
                      return true;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * Custom actions are implemented by calling {@link Lexer#action} with the
                     * appropriate rule and action indexes.
                     */
                    execute(lexer) {
                      lexer.action(void 0, this._ruleIndex, this._actionIndex);
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
                      hash = MurmurHash_1.MurmurHash.update(hash, this._ruleIndex);
                      hash = MurmurHash_1.MurmurHash.update(hash, this._actionIndex);
                      return MurmurHash_1.MurmurHash.finish(hash, 3);
                    }
                    equals(obj) {
                      if (obj === this) {
                        return true;
                      } else if (!(obj instanceof LexerCustomAction)) {
                        return false;
                      }
                      return this._ruleIndex === obj._ruleIndex && this._actionIndex === obj._actionIndex;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], LexerCustomAction.prototype, "actionType", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerCustomAction.prototype, "isPositionDependent", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], LexerCustomAction.prototype, "execute", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerCustomAction.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerCustomAction.prototype, "equals", null);
                  exports2.LexerCustomAction = LexerCustomAction;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LexerIndexedCustomAction.js": (
                /*!***************************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LexerIndexedCustomAction.js ***!
                  \***************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerIndexedCustomAction = void 0;
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let LexerIndexedCustomAction = class LexerIndexedCustomAction2 {
                    /**
                     * Constructs a new indexed custom action by associating a character offset
                     * with a {@link LexerAction}.
                     *
                     * Note: This class is only required for lexer actions for which
                     * {@link LexerAction#isPositionDependent} returns `true`.
                     *
                     * @param offset The offset into the input {@link CharStream}, relative to
                     * the token start index, at which the specified lexer action should be
                     * executed.
                     * @param action The lexer action to execute at a particular offset in the
                     * input {@link CharStream}.
                     */
                    constructor(offset, action) {
                      this._offset = offset;
                      this._action = action;
                    }
                    /**
                     * Gets the location in the input {@link CharStream} at which the lexer
                     * action should be executed. The value is interpreted as an offset relative
                     * to the token start index.
                     *
                     * @returns The location in the input {@link CharStream} at which the lexer
                     * action should be executed.
                     */
                    get offset() {
                      return this._offset;
                    }
                    /**
                     * Gets the lexer action to execute.
                     *
                     * @returns A {@link LexerAction} object which executes the lexer action.
                     */
                    get action() {
                      return this._action;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * @returns This method returns the result of calling {@link #getActionType}
                     * on the {@link LexerAction} returned by {@link #getAction}.
                     */
                    get actionType() {
                      return this._action.actionType;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns `true`.
                     */
                    get isPositionDependent() {
                      return true;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This method calls {@link #execute} on the result of {@link #getAction}
                     * using the provided `lexer`.
                     */
                    execute(lexer) {
                      this._action.execute(lexer);
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      hash = MurmurHash_1.MurmurHash.update(hash, this._offset);
                      hash = MurmurHash_1.MurmurHash.update(hash, this._action);
                      return MurmurHash_1.MurmurHash.finish(hash, 2);
                    }
                    equals(obj) {
                      if (obj === this) {
                        return true;
                      } else if (!(obj instanceof LexerIndexedCustomAction2)) {
                        return false;
                      }
                      return this._offset === obj._offset && this._action.equals(obj._action);
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], LexerIndexedCustomAction.prototype, "action", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerIndexedCustomAction.prototype, "actionType", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerIndexedCustomAction.prototype, "isPositionDependent", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerIndexedCustomAction.prototype, "execute", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerIndexedCustomAction.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerIndexedCustomAction.prototype, "equals", null);
                  LexerIndexedCustomAction = __decorate([
                    __param(1, Decorators_1.NotNull)
                  ], LexerIndexedCustomAction);
                  exports2.LexerIndexedCustomAction = LexerIndexedCustomAction;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LexerModeAction.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LexerModeAction.js ***!
                  \******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerModeAction = void 0;
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class LexerModeAction {
                    /**
                     * Constructs a new `mode` action with the specified mode value.
                     * @param mode The mode value to pass to {@link Lexer#mode}.
                     */
                    constructor(mode) {
                      this._mode = mode;
                    }
                    /**
                     * Get the lexer mode this action should transition the lexer to.
                     *
                     * @returns The lexer mode for this `mode` command.
                     */
                    get mode() {
                      return this._mode;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns {@link LexerActionType#MODE}.
                     */
                    get actionType() {
                      return 2;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns `false`.
                     */
                    get isPositionDependent() {
                      return false;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This action is implemented by calling {@link Lexer#mode} with the
                     * value provided by {@link #getMode}.
                     */
                    execute(lexer) {
                      lexer.mode(this._mode);
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
                      hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
                      return MurmurHash_1.MurmurHash.finish(hash, 2);
                    }
                    equals(obj) {
                      if (obj === this) {
                        return true;
                      } else if (!(obj instanceof LexerModeAction)) {
                        return false;
                      }
                      return this._mode === obj._mode;
                    }
                    toString() {
                      return `mode(${this._mode})`;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], LexerModeAction.prototype, "actionType", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerModeAction.prototype, "isPositionDependent", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], LexerModeAction.prototype, "execute", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerModeAction.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerModeAction.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerModeAction.prototype, "toString", null);
                  exports2.LexerModeAction = LexerModeAction;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LexerMoreAction.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LexerMoreAction.js ***!
                  \******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerMoreAction = void 0;
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class LexerMoreAction {
                    /**
                     * Constructs the singleton instance of the lexer `more` command.
                     */
                    constructor() {
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns {@link LexerActionType#MORE}.
                     */
                    get actionType() {
                      return 3;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns `false`.
                     */
                    get isPositionDependent() {
                      return false;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This action is implemented by calling {@link Lexer#more}.
                     */
                    execute(lexer) {
                      lexer.more();
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
                      return MurmurHash_1.MurmurHash.finish(hash, 1);
                    }
                    equals(obj) {
                      return obj === this;
                    }
                    toString() {
                      return "more";
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], LexerMoreAction.prototype, "actionType", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerMoreAction.prototype, "isPositionDependent", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], LexerMoreAction.prototype, "execute", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerMoreAction.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerMoreAction.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerMoreAction.prototype, "toString", null);
                  exports2.LexerMoreAction = LexerMoreAction;
                  (function(LexerMoreAction2) {
                    LexerMoreAction2.INSTANCE = new LexerMoreAction2();
                  })(LexerMoreAction = exports2.LexerMoreAction || (exports2.LexerMoreAction = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LexerPopModeAction.js": (
                /*!*********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LexerPopModeAction.js ***!
                  \*********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerPopModeAction = void 0;
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class LexerPopModeAction {
                    /**
                     * Constructs the singleton instance of the lexer `popMode` command.
                     */
                    constructor() {
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns {@link LexerActionType#POP_MODE}.
                     */
                    get actionType() {
                      return 4;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns `false`.
                     */
                    get isPositionDependent() {
                      return false;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This action is implemented by calling {@link Lexer#popMode}.
                     */
                    execute(lexer) {
                      lexer.popMode();
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
                      return MurmurHash_1.MurmurHash.finish(hash, 1);
                    }
                    equals(obj) {
                      return obj === this;
                    }
                    toString() {
                      return "popMode";
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], LexerPopModeAction.prototype, "actionType", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerPopModeAction.prototype, "isPositionDependent", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], LexerPopModeAction.prototype, "execute", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerPopModeAction.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerPopModeAction.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerPopModeAction.prototype, "toString", null);
                  exports2.LexerPopModeAction = LexerPopModeAction;
                  (function(LexerPopModeAction2) {
                    LexerPopModeAction2.INSTANCE = new LexerPopModeAction2();
                  })(LexerPopModeAction = exports2.LexerPopModeAction || (exports2.LexerPopModeAction = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LexerPushModeAction.js": (
                /*!**********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LexerPushModeAction.js ***!
                  \**********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerPushModeAction = void 0;
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class LexerPushModeAction {
                    /**
                     * Constructs a new `pushMode` action with the specified mode value.
                     * @param mode The mode value to pass to {@link Lexer#pushMode}.
                     */
                    constructor(mode) {
                      this._mode = mode;
                    }
                    /**
                     * Get the lexer mode this action should transition the lexer to.
                     *
                     * @returns The lexer mode for this `pushMode` command.
                     */
                    get mode() {
                      return this._mode;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns {@link LexerActionType#PUSH_MODE}.
                     */
                    get actionType() {
                      return 5;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns `false`.
                     */
                    get isPositionDependent() {
                      return false;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This action is implemented by calling {@link Lexer#pushMode} with the
                     * value provided by {@link #getMode}.
                     */
                    execute(lexer) {
                      lexer.pushMode(this._mode);
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
                      hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
                      return MurmurHash_1.MurmurHash.finish(hash, 2);
                    }
                    equals(obj) {
                      if (obj === this) {
                        return true;
                      } else if (!(obj instanceof LexerPushModeAction)) {
                        return false;
                      }
                      return this._mode === obj._mode;
                    }
                    toString() {
                      return `pushMode(${this._mode})`;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], LexerPushModeAction.prototype, "actionType", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerPushModeAction.prototype, "isPositionDependent", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], LexerPushModeAction.prototype, "execute", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerPushModeAction.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerPushModeAction.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerPushModeAction.prototype, "toString", null);
                  exports2.LexerPushModeAction = LexerPushModeAction;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LexerSkipAction.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LexerSkipAction.js ***!
                  \******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerSkipAction = void 0;
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class LexerSkipAction {
                    /**
                     * Constructs the singleton instance of the lexer `skip` command.
                     */
                    constructor() {
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns {@link LexerActionType#SKIP}.
                     */
                    get actionType() {
                      return 6;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns `false`.
                     */
                    get isPositionDependent() {
                      return false;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This action is implemented by calling {@link Lexer#skip}.
                     */
                    execute(lexer) {
                      lexer.skip();
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
                      return MurmurHash_1.MurmurHash.finish(hash, 1);
                    }
                    equals(obj) {
                      return obj === this;
                    }
                    toString() {
                      return "skip";
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], LexerSkipAction.prototype, "actionType", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerSkipAction.prototype, "isPositionDependent", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], LexerSkipAction.prototype, "execute", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerSkipAction.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerSkipAction.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerSkipAction.prototype, "toString", null);
                  exports2.LexerSkipAction = LexerSkipAction;
                  (function(LexerSkipAction2) {
                    LexerSkipAction2.INSTANCE = new LexerSkipAction2();
                  })(LexerSkipAction = exports2.LexerSkipAction || (exports2.LexerSkipAction = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LexerTypeAction.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LexerTypeAction.js ***!
                  \******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerTypeAction = void 0;
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class LexerTypeAction {
                    /**
                     * Constructs a new `type` action with the specified token type value.
                     * @param type The type to assign to the token using `Lexer.type`.
                     */
                    constructor(type2) {
                      this._type = type2;
                    }
                    /**
                     * Gets the type to assign to a token created by the lexer.
                     * @returns The type to assign to a token created by the lexer.
                     */
                    get type() {
                      return this._type;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns {@link LexerActionType#TYPE}.
                     */
                    get actionType() {
                      return 7;
                    }
                    /**
                     * {@inheritDoc}
                     * @returns This method returns `false`.
                     */
                    get isPositionDependent() {
                      return false;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This action is implemented by setting `Lexer.type` with the
                     * value provided by `type`.
                     */
                    execute(lexer) {
                      lexer.type = this._type;
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
                      hash = MurmurHash_1.MurmurHash.update(hash, this._type);
                      return MurmurHash_1.MurmurHash.finish(hash, 2);
                    }
                    equals(obj) {
                      if (obj === this) {
                        return true;
                      } else if (!(obj instanceof LexerTypeAction)) {
                        return false;
                      }
                      return this._type === obj._type;
                    }
                    toString() {
                      return `type(${this._type})`;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], LexerTypeAction.prototype, "actionType", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerTypeAction.prototype, "isPositionDependent", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], LexerTypeAction.prototype, "execute", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerTypeAction.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerTypeAction.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], LexerTypeAction.prototype, "toString", null);
                  exports2.LexerTypeAction = LexerTypeAction;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LookaheadEventInfo.js": (
                /*!*********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LookaheadEventInfo.js ***!
                  \*********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LookaheadEventInfo = void 0;
                  const DecisionEventInfo_1 = __webpack_require__2(
                    /*! ./DecisionEventInfo */
                    "./node_modules/antlr4ts/atn/DecisionEventInfo.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let LookaheadEventInfo = class LookaheadEventInfo extends DecisionEventInfo_1.DecisionEventInfo {
                    /**
                     * Constructs a new instance of the {@link LookaheadEventInfo} class with
                     * the specified detailed lookahead information.
                     *
                     * @param decision The decision number
                     * @param state The final simulator state containing the necessary
                     * information to determine the result of a prediction, or `undefined` if
                     * the final state is not available
                     * @param input The input token stream
                     * @param startIndex The start index for the current prediction
                     * @param stopIndex The index at which the prediction was finally made
                     * @param fullCtx `true` if the current lookahead is part of an LL
                     * prediction; otherwise, `false` if the current lookahead is part of
                     * an SLL prediction
                     */
                    constructor(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {
                      super(decision, state, input, startIndex, stopIndex, fullCtx);
                      this.predictedAlt = predictedAlt;
                    }
                  };
                  LookaheadEventInfo = __decorate([
                    __param(3, Decorators_1.NotNull)
                  ], LookaheadEventInfo);
                  exports2.LookaheadEventInfo = LookaheadEventInfo;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/LoopEndState.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/LoopEndState.js ***!
                  \***************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LoopEndState = void 0;
                  const ATNState_1 = __webpack_require__2(
                    /*! ./ATNState */
                    "./node_modules/antlr4ts/atn/ATNState.js"
                  );
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class LoopEndState extends ATNState_1.ATNState {
                    get stateType() {
                      return ATNStateType_1.ATNStateType.LOOP_END;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], LoopEndState.prototype, "stateType", null);
                  exports2.LoopEndState = LoopEndState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/NotSetTransition.js": (
                /*!*******************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/NotSetTransition.js ***!
                  \*******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.NotSetTransition = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const SetTransition_1 = __webpack_require__2(
                    /*! ./SetTransition */
                    "./node_modules/antlr4ts/atn/SetTransition.js"
                  );
                  let NotSetTransition = class NotSetTransition extends SetTransition_1.SetTransition {
                    constructor(target, set2) {
                      super(target, set2);
                    }
                    get serializationType() {
                      return 8;
                    }
                    matches(symbol, minVocabSymbol, maxVocabSymbol) {
                      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
                    }
                    toString() {
                      return "~" + super.toString();
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], NotSetTransition.prototype, "serializationType", null);
                  __decorate([
                    Decorators_1.Override
                  ], NotSetTransition.prototype, "matches", null);
                  __decorate([
                    Decorators_1.Override
                  ], NotSetTransition.prototype, "toString", null);
                  NotSetTransition = __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.Nullable)
                  ], NotSetTransition);
                  exports2.NotSetTransition = NotSetTransition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/OrderedATNConfigSet.js": (
                /*!**********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/OrderedATNConfigSet.js ***!
                  \**********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.OrderedATNConfigSet = void 0;
                  const ATNConfigSet_1 = __webpack_require__2(
                    /*! ./ATNConfigSet */
                    "./node_modules/antlr4ts/atn/ATNConfigSet.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class OrderedATNConfigSet extends ATNConfigSet_1.ATNConfigSet {
                    constructor(set2, readonly) {
                      if (set2 != null && readonly != null) {
                        super(set2, readonly);
                      } else {
                        super();
                      }
                    }
                    clone(readonly) {
                      let copy = new OrderedATNConfigSet(this, readonly);
                      if (!readonly && this.isReadOnly) {
                        copy.addAll(this);
                      }
                      return copy;
                    }
                    getKey(e) {
                      return { state: 0, alt: e.hashCode() };
                    }
                    canMerge(left, leftKey, right) {
                      return left.equals(right);
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], OrderedATNConfigSet.prototype, "clone", null);
                  __decorate([
                    Decorators_1.Override
                  ], OrderedATNConfigSet.prototype, "getKey", null);
                  __decorate([
                    Decorators_1.Override
                  ], OrderedATNConfigSet.prototype, "canMerge", null);
                  exports2.OrderedATNConfigSet = OrderedATNConfigSet;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ParseInfo.js": (
                /*!************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ParseInfo.js ***!
                  \************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ParseInfo = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let ParseInfo = class ParseInfo {
                    constructor(atnSimulator) {
                      this.atnSimulator = atnSimulator;
                    }
                    /**
                     * Gets an array of {@link DecisionInfo} instances containing the profiling
                     * information gathered for each decision in the ATN.
                     *
                     * @returns An array of {@link DecisionInfo} instances, indexed by decision
                     * number.
                     */
                    getDecisionInfo() {
                      return this.atnSimulator.getDecisionInfo();
                    }
                    /**
                     * Gets the decision numbers for decisions that required one or more
                     * full-context predictions during parsing. These are decisions for which
                     * {@link DecisionInfo#LL_Fallback} is non-zero.
                     *
                     * @returns A list of decision numbers which required one or more
                     * full-context predictions during parsing.
                     */
                    getLLDecisions() {
                      let decisions = this.atnSimulator.getDecisionInfo();
                      let LL = [];
                      for (let i = 0; i < decisions.length; i++) {
                        let fallBack = decisions[i].LL_Fallback;
                        if (fallBack > 0) {
                          LL.push(i);
                        }
                      }
                      return LL;
                    }
                    /**
                     * Gets the total time spent during prediction across all decisions made
                     * during parsing. This value is the sum of
                     * {@link DecisionInfo#timeInPrediction} for all decisions.
                     */
                    getTotalTimeInPrediction() {
                      let decisions = this.atnSimulator.getDecisionInfo();
                      let t = 0;
                      for (let decision of decisions) {
                        t += decision.timeInPrediction;
                      }
                      return t;
                    }
                    /**
                     * Gets the total number of SLL lookahead operations across all decisions
                     * made during parsing. This value is the sum of
                     * {@link DecisionInfo#SLL_TotalLook} for all decisions.
                     */
                    getTotalSLLLookaheadOps() {
                      let decisions = this.atnSimulator.getDecisionInfo();
                      let k = 0;
                      for (let decision of decisions) {
                        k += decision.SLL_TotalLook;
                      }
                      return k;
                    }
                    /**
                     * Gets the total number of LL lookahead operations across all decisions
                     * made during parsing. This value is the sum of
                     * {@link DecisionInfo#LL_TotalLook} for all decisions.
                     */
                    getTotalLLLookaheadOps() {
                      let decisions = this.atnSimulator.getDecisionInfo();
                      let k = 0;
                      for (let decision of decisions) {
                        k += decision.LL_TotalLook;
                      }
                      return k;
                    }
                    /**
                     * Gets the total number of ATN lookahead operations for SLL prediction
                     * across all decisions made during parsing.
                     */
                    getTotalSLLATNLookaheadOps() {
                      let decisions = this.atnSimulator.getDecisionInfo();
                      let k = 0;
                      for (let decision of decisions) {
                        k += decision.SLL_ATNTransitions;
                      }
                      return k;
                    }
                    /**
                     * Gets the total number of ATN lookahead operations for LL prediction
                     * across all decisions made during parsing.
                     */
                    getTotalLLATNLookaheadOps() {
                      let decisions = this.atnSimulator.getDecisionInfo();
                      let k = 0;
                      for (let decision of decisions) {
                        k += decision.LL_ATNTransitions;
                      }
                      return k;
                    }
                    /**
                     * Gets the total number of ATN lookahead operations for SLL and LL
                     * prediction across all decisions made during parsing.
                     *
                     * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and
                     * {@link #getTotalLLATNLookaheadOps}.
                     */
                    getTotalATNLookaheadOps() {
                      let decisions = this.atnSimulator.getDecisionInfo();
                      let k = 0;
                      for (let decision of decisions) {
                        k += decision.SLL_ATNTransitions;
                        k += decision.LL_ATNTransitions;
                      }
                      return k;
                    }
                    getDFASize(decision) {
                      if (decision) {
                        let decisionToDFA = this.atnSimulator.atn.decisionToDFA[decision];
                        return decisionToDFA.states.size;
                      } else {
                        let n = 0;
                        let decisionToDFA = this.atnSimulator.atn.decisionToDFA;
                        for (let i = 0; i < decisionToDFA.length; i++) {
                          n += this.getDFASize(i);
                        }
                        return n;
                      }
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseInfo.prototype, "getDecisionInfo", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseInfo.prototype, "getLLDecisions", null);
                  ParseInfo = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParseInfo);
                  exports2.ParseInfo = ParseInfo;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ParserATNSimulator.js": (
                /*!*********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ParserATNSimulator.js ***!
                  \*********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ParserATNSimulator = void 0;
                  const AcceptStateInfo_1 = __webpack_require__2(
                    /*! ../dfa/AcceptStateInfo */
                    "./node_modules/antlr4ts/dfa/AcceptStateInfo.js"
                  );
                  const ActionTransition_1 = __webpack_require__2(
                    /*! ./ActionTransition */
                    "./node_modules/antlr4ts/atn/ActionTransition.js"
                  );
                  const Array2DHashSet_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashSet */
                    "./node_modules/antlr4ts/misc/Array2DHashSet.js"
                  );
                  const Arrays_1 = __webpack_require__2(
                    /*! ../misc/Arrays */
                    "./node_modules/antlr4ts/misc/Arrays.js"
                  );
                  const ATN_1 = __webpack_require__2(
                    /*! ./ATN */
                    "./node_modules/antlr4ts/atn/ATN.js"
                  );
                  const ATNConfig_1 = __webpack_require__2(
                    /*! ./ATNConfig */
                    "./node_modules/antlr4ts/atn/ATNConfig.js"
                  );
                  const ATNConfigSet_1 = __webpack_require__2(
                    /*! ./ATNConfigSet */
                    "./node_modules/antlr4ts/atn/ATNConfigSet.js"
                  );
                  const ATNSimulator_1 = __webpack_require__2(
                    /*! ./ATNSimulator */
                    "./node_modules/antlr4ts/atn/ATNSimulator.js"
                  );
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const AtomTransition_1 = __webpack_require__2(
                    /*! ./AtomTransition */
                    "./node_modules/antlr4ts/atn/AtomTransition.js"
                  );
                  const BitSet_1 = __webpack_require__2(
                    /*! ../misc/BitSet */
                    "./node_modules/antlr4ts/misc/BitSet.js"
                  );
                  const ConflictInfo_1 = __webpack_require__2(
                    /*! ./ConflictInfo */
                    "./node_modules/antlr4ts/atn/ConflictInfo.js"
                  );
                  const DecisionState_1 = __webpack_require__2(
                    /*! ./DecisionState */
                    "./node_modules/antlr4ts/atn/DecisionState.js"
                  );
                  const DFAState_1 = __webpack_require__2(
                    /*! ../dfa/DFAState */
                    "./node_modules/antlr4ts/dfa/DFAState.js"
                  );
                  const IntegerList_1 = __webpack_require__2(
                    /*! ../misc/IntegerList */
                    "./node_modules/antlr4ts/misc/IntegerList.js"
                  );
                  const Interval_1 = __webpack_require__2(
                    /*! ../misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const IntStream_1 = __webpack_require__2(
                    /*! ../IntStream */
                    "./node_modules/antlr4ts/IntStream.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const NotSetTransition_1 = __webpack_require__2(
                    /*! ./NotSetTransition */
                    "./node_modules/antlr4ts/atn/NotSetTransition.js"
                  );
                  const NoViableAltException_1 = __webpack_require__2(
                    /*! ../NoViableAltException */
                    "./node_modules/antlr4ts/NoViableAltException.js"
                  );
                  const ObjectEqualityComparator_1 = __webpack_require__2(
                    /*! ../misc/ObjectEqualityComparator */
                    "./node_modules/antlr4ts/misc/ObjectEqualityComparator.js"
                  );
                  const ParserRuleContext_1 = __webpack_require__2(
                    /*! ../ParserRuleContext */
                    "./node_modules/antlr4ts/ParserRuleContext.js"
                  );
                  const PredictionContext_1 = __webpack_require__2(
                    /*! ./PredictionContext */
                    "./node_modules/antlr4ts/atn/PredictionContext.js"
                  );
                  const PredictionContextCache_1 = __webpack_require__2(
                    /*! ./PredictionContextCache */
                    "./node_modules/antlr4ts/atn/PredictionContextCache.js"
                  );
                  const PredictionMode_1 = __webpack_require__2(
                    /*! ./PredictionMode */
                    "./node_modules/antlr4ts/atn/PredictionMode.js"
                  );
                  const RuleStopState_1 = __webpack_require__2(
                    /*! ./RuleStopState */
                    "./node_modules/antlr4ts/atn/RuleStopState.js"
                  );
                  const RuleTransition_1 = __webpack_require__2(
                    /*! ./RuleTransition */
                    "./node_modules/antlr4ts/atn/RuleTransition.js"
                  );
                  const SemanticContext_1 = __webpack_require__2(
                    /*! ./SemanticContext */
                    "./node_modules/antlr4ts/atn/SemanticContext.js"
                  );
                  const SetTransition_1 = __webpack_require__2(
                    /*! ./SetTransition */
                    "./node_modules/antlr4ts/atn/SetTransition.js"
                  );
                  const SimulatorState_1 = __webpack_require__2(
                    /*! ./SimulatorState */
                    "./node_modules/antlr4ts/atn/SimulatorState.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const VocabularyImpl_1 = __webpack_require__2(
                    /*! ../VocabularyImpl */
                    "./node_modules/antlr4ts/VocabularyImpl.js"
                  );
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  const MAX_SHORT_VALUE = 65535;
                  const MIN_INTEGER_VALUE = -(1 << 31 >>> 0);
                  let ParserATNSimulator = class ParserATNSimulator2 extends ATNSimulator_1.ATNSimulator {
                    constructor(atn, parser) {
                      super(atn);
                      this.predictionMode = PredictionMode_1.PredictionMode.LL;
                      this.force_global_context = false;
                      this.always_try_local_context = true;
                      this.enable_global_context_dfa = false;
                      this.optimize_unique_closure = true;
                      this.optimize_ll1 = true;
                      this.optimize_tail_calls = true;
                      this.tail_call_preserves_sll = true;
                      this.treat_sllk1_conflict_as_ambiguity = false;
                      this.reportAmbiguities = false;
                      this.userWantsCtxSensitive = true;
                      this._parser = parser;
                    }
                    getPredictionMode() {
                      return this.predictionMode;
                    }
                    setPredictionMode(predictionMode) {
                      this.predictionMode = predictionMode;
                    }
                    reset() {
                    }
                    adaptivePredict(input, decision, outerContext, useContext) {
                      if (useContext === void 0) {
                        useContext = false;
                      }
                      let dfa = this.atn.decisionToDFA[decision];
                      assert(dfa != null);
                      if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {
                        let ll_1 = input.LA(1);
                        if (ll_1 >= 0 && ll_1 <= 65535) {
                          let key = (decision << 16 >>> 0) + ll_1;
                          let alt = this.atn.LL1Table.get(key);
                          if (alt != null) {
                            return alt;
                          }
                        }
                      }
                      this.dfa = dfa;
                      if (this.force_global_context) {
                        useContext = true;
                      } else if (!this.always_try_local_context) {
                        useContext = useContext || dfa.isContextSensitive;
                      }
                      this.userWantsCtxSensitive = useContext || this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll;
                      if (outerContext == null) {
                        outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
                      }
                      let state;
                      if (!dfa.isEmpty) {
                        state = this.getStartState(dfa, input, outerContext, useContext);
                      }
                      if (state == null) {
                        if (outerContext == null) {
                          outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
                        }
                        if (ParserATNSimulator2.debug) {
                          console.log("ATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
                        }
                        state = this.computeStartState(dfa, outerContext, useContext);
                      }
                      let m = input.mark();
                      let index = input.index;
                      try {
                        let alt = this.execDFA(dfa, input, index, state);
                        if (ParserATNSimulator2.debug) {
                          console.log("DFA after predictATN: " + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
                        }
                        return alt;
                      } finally {
                        this.dfa = void 0;
                        input.seek(index);
                        input.release(m);
                      }
                    }
                    getStartState(dfa, input, outerContext, useContext) {
                      if (!useContext) {
                        if (dfa.isPrecedenceDfa) {
                          let state = dfa.getPrecedenceStartState(this._parser.precedence, false);
                          if (state == null) {
                            return void 0;
                          }
                          return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);
                        } else {
                          if (dfa.s0 == null) {
                            return void 0;
                          }
                          return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);
                        }
                      }
                      if (!this.enable_global_context_dfa) {
                        return void 0;
                      }
                      let remainingContext = outerContext;
                      assert(outerContext != null);
                      let s0;
                      if (dfa.isPrecedenceDfa) {
                        s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);
                      } else {
                        s0 = dfa.s0full;
                      }
                      while (remainingContext != null && s0 != null && s0.isContextSensitive) {
                        remainingContext = this.skipTailCalls(remainingContext);
                        s0 = s0.getContextTarget(this.getReturnState(remainingContext));
                        if (remainingContext.isEmpty) {
                          assert(s0 == null || !s0.isContextSensitive);
                        } else {
                          remainingContext = remainingContext.parent;
                        }
                      }
                      if (s0 == null) {
                        return void 0;
                      }
                      return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);
                    }
                    execDFA(dfa, input, startIndex, state) {
                      let outerContext = state.outerContext;
                      if (ParserATNSimulator2.dfa_debug) {
                        console.log("DFA decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
                      }
                      if (ParserATNSimulator2.dfa_debug) {
                        console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
                      }
                      let s = state.s0;
                      let t = input.LA(1);
                      let remainingOuterContext = state.remainingOuterContext;
                      while (true) {
                        if (ParserATNSimulator2.dfa_debug) {
                          console.log("DFA state " + s.stateNumber + " LA(1)==" + this.getLookaheadName(input));
                        }
                        if (state.useContext) {
                          while (s.isContextSymbol(t)) {
                            let next;
                            if (remainingOuterContext != null) {
                              remainingOuterContext = this.skipTailCalls(remainingOuterContext);
                              next = s.getContextTarget(this.getReturnState(remainingOuterContext));
                            }
                            if (next == null) {
                              let initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);
                              return this.execATN(dfa, input, startIndex, initialState);
                            }
                            assert(remainingOuterContext != null);
                            remainingOuterContext = remainingOuterContext.parent;
                            s = next;
                          }
                        }
                        if (this.isAcceptState(s, state.useContext)) {
                          if (s.predicates != null) {
                            if (ParserATNSimulator2.dfa_debug) {
                              console.log("accept " + s);
                            }
                          } else {
                            if (ParserATNSimulator2.dfa_debug) {
                              console.log("accept; predict " + s.prediction + " in state " + s.stateNumber);
                            }
                          }
                          break;
                        }
                        assert(!this.isAcceptState(s, state.useContext));
                        let target = this.getExistingTargetState(s, t);
                        if (target == null) {
                          if (ParserATNSimulator2.dfa_debug && t >= 0) {
                            console.log("no edge for " + this._parser.vocabulary.getDisplayName(t));
                          }
                          let alt;
                          if (ParserATNSimulator2.dfa_debug) {
                            let interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);
                            console.log("ATN exec upon " + this._parser.inputStream.getText(interval) + " at DFA state " + s.stateNumber);
                          }
                          let initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
                          alt = this.execATN(dfa, input, startIndex, initialState);
                          if (ParserATNSimulator2.dfa_debug) {
                            console.log("back from DFA update, alt=" + alt + ", dfa=\n" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
                          }
                          if (ParserATNSimulator2.dfa_debug) {
                            console.log("DFA decision " + dfa.decision + " predicts " + alt);
                          }
                          return alt;
                        } else if (target === ATNSimulator_1.ATNSimulator.ERROR) {
                          let errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
                          return this.handleNoViableAlt(input, startIndex, errorState);
                        }
                        s = target;
                        if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {
                          input.consume();
                          t = input.LA(1);
                        }
                      }
                      if (!state.useContext && s.configs.conflictInfo != null) {
                        if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {
                          if (!this.userWantsCtxSensitive || !s.configs.dipsIntoOuterContext && s.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex) {
                          } else {
                            assert(!state.useContext);
                            let conflictingAlts;
                            let predicates2 = s.predicates;
                            if (predicates2 != null) {
                              let conflictIndex = input.index;
                              if (conflictIndex !== startIndex) {
                                input.seek(startIndex);
                              }
                              conflictingAlts = this.evalSemanticContext(predicates2, outerContext, true);
                              if (conflictingAlts.cardinality() === 1) {
                                return conflictingAlts.nextSetBit(0);
                              }
                              if (conflictIndex !== startIndex) {
                                input.seek(conflictIndex);
                              }
                            }
                            if (this.reportAmbiguities) {
                              let conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
                              this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);
                            }
                            input.seek(startIndex);
                            return this.adaptivePredict(input, dfa.decision, outerContext, true);
                          }
                        }
                      }
                      let predicates = s.predicates;
                      if (predicates != null) {
                        let stopIndex = input.index;
                        if (startIndex !== stopIndex) {
                          input.seek(startIndex);
                        }
                        let alts = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);
                        switch (alts.cardinality()) {
                          case 0:
                            throw this.noViableAlt(input, outerContext, s.configs, startIndex);
                          case 1:
                            return alts.nextSetBit(0);
                          default:
                            if (startIndex !== stopIndex) {
                              input.seek(stopIndex);
                            }
                            this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);
                            return alts.nextSetBit(0);
                        }
                      }
                      if (ParserATNSimulator2.dfa_debug) {
                        console.log("DFA decision " + dfa.decision + " predicts " + s.prediction);
                      }
                      return s.prediction;
                    }
                    /**
                     * Determines if a particular DFA state should be treated as an accept state
                     * for the current prediction mode. In addition to the `useContext`
                     * parameter, the {@link #getPredictionMode()} method provides the
                     * prediction mode controlling the prediction algorithm as a whole.
                     *
                     * The default implementation simply returns the value of
                     * `DFAState.isAcceptState` except for conflict states when
                     * `useContext` is `true` and {@link #getPredictionMode()} is
                     * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}. In that case, only
                     * conflict states where {@link ATNConfigSet#isExactConflict} is
                     * `true` are considered accept states.
                     *
                     * @param state The DFA state to check.
                     * @param useContext `true` if the prediction algorithm is currently
                     * considering the full parser context; otherwise, `false` if the
                     * algorithm is currently performing a local context prediction.
                     *
                     * @returns `true` if the specified `state` is an accept state;
                     * otherwise, `false`.
                     */
                    isAcceptState(state, useContext) {
                      if (!state.isAcceptState) {
                        return false;
                      }
                      if (state.configs.conflictingAlts == null) {
                        return true;
                      }
                      if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {
                        return state.configs.isExactConflict;
                      }
                      return true;
                    }
                    /** Performs ATN simulation to compute a predicted alternative based
                     *  upon the remaining input, but also updates the DFA cache to avoid
                     *  having to traverse the ATN again for the same input sequence.
                     *
                     * There are some key conditions we're looking for after computing a new
                     * set of ATN configs (proposed DFA state):
                     *
                     * * if the set is empty, there is no viable alternative for current symbol
                     * * does the state uniquely predict an alternative?
                     * * does the state have a conflict that would prevent us from
                     *   putting it on the work list?
                     * * if in non-greedy decision is there a config at a rule stop state?
                     *
                     * We also have some key operations to do:
                     *
                     * * add an edge from previous DFA state to potentially new DFA state, D,
                     *   upon current symbol but only if adding to work list, which means in all
                     *   cases except no viable alternative (and possibly non-greedy decisions?)
                     * * collecting predicates and adding semantic context to DFA accept states
                     * * adding rule context to context-sensitive DFA accept states
                     * * consuming an input symbol
                     * * reporting a conflict
                     * * reporting an ambiguity
                     * * reporting a context sensitivity
                     * * reporting insufficient predicates
                     *
                     * We should isolate those operations, which are side-effecting, to the
                     * main work loop. We can isolate lots of code into other functions, but
                     * they should be side effect free. They can return package that
                     * indicates whether we should report something, whether we need to add a
                     * DFA edge, whether we need to augment accept state with semantic
                     * context or rule invocation context. Actually, it seems like we always
                     * add predicates if they exist, so that can simply be done in the main
                     * loop for any accept state creation or modification request.
                     *
                     * cover these cases:
                     *   dead end
                     *   single alt
                     *   single alt + preds
                     *   conflict
                     *   conflict + preds
                     *
                     * TODO: greedy + those
                     */
                    execATN(dfa, input, startIndex, initialState) {
                      if (ParserATNSimulator2.debug) {
                        console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input));
                      }
                      let outerContext = initialState.outerContext;
                      let useContext = initialState.useContext;
                      let t = input.LA(1);
                      let previous = initialState;
                      let contextCache = new PredictionContextCache_1.PredictionContextCache();
                      while (true) {
                        let nextState = this.computeReachSet(dfa, previous, t, contextCache);
                        if (nextState == null) {
                          this.setDFAEdge(previous.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);
                          return this.handleNoViableAlt(input, startIndex, previous);
                        }
                        let D = nextState.s0;
                        assert(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);
                        assert(D.isAcceptState || D.configs.conflictInfo == null);
                        if (this.isAcceptState(D, useContext)) {
                          let conflictingAlts = D.configs.conflictingAlts;
                          let predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;
                          if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (this.optimize_ll1 && input.index === startIndex && !dfa.isPrecedenceDfa && nextState.outerContext === nextState.remainingOuterContext && dfa.decision >= 0 && !D.configs.hasSemanticContext) {
                              if (t >= 0 && t <= MAX_SHORT_VALUE) {
                                let key = (dfa.decision << 16 >>> 0) + t;
                                this.atn.LL1Table.set(key, predictedAlt);
                              }
                            }
                            if (useContext && this.always_try_local_context) {
                              this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);
                            }
                          }
                          predictedAlt = D.prediction;
                          let attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;
                          if (attemptFullContext) {
                            attemptFullContext = !useContext && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);
                          }
                          if (D.configs.hasSemanticContext) {
                            let predPredictions = D.predicates;
                            if (predPredictions != null) {
                              let conflictIndex = input.index;
                              if (conflictIndex !== startIndex) {
                                input.seek(startIndex);
                              }
                              conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);
                              switch (conflictingAlts.cardinality()) {
                                case 0:
                                  throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                                case 1:
                                  return conflictingAlts.nextSetBit(0);
                                default:
                                  break;
                              }
                              if (conflictIndex !== startIndex) {
                                input.seek(conflictIndex);
                              }
                            }
                          }
                          if (!attemptFullContext) {
                            if (conflictingAlts != null) {
                              if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {
                                this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);
                              }
                              predictedAlt = conflictingAlts.nextSetBit(0);
                            }
                            return predictedAlt;
                          } else {
                            assert(!useContext);
                            assert(this.isAcceptState(D, false));
                            if (ParserATNSimulator2.debug) {
                              console.log("RETRY with outerContext=" + outerContext);
                            }
                            let fullContextState = this.computeStartState(dfa, outerContext, true);
                            if (this.reportAmbiguities) {
                              this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);
                            }
                            input.seek(startIndex);
                            return this.execATN(dfa, input, startIndex, fullContextState);
                          }
                        }
                        previous = nextState;
                        if (t !== IntStream_1.IntStream.EOF) {
                          input.consume();
                          t = input.LA(1);
                        }
                      }
                    }
                    /**
                     * This method is used to improve the localization of error messages by
                     * choosing an alternative rather than throwing a
                     * {@link NoViableAltException} in particular prediction scenarios where the
                     * {@link #ERROR} state was reached during ATN simulation.
                     *
                     * The default implementation of this method uses the following
                     * algorithm to identify an ATN configuration which successfully parsed the
                     * decision entry rule. Choosing such an alternative ensures that the
                     * {@link ParserRuleContext} returned by the calling rule will be complete
                     * and valid, and the syntax error will be reported later at a more
                     * localized location.
                     *
                     * * If no configuration in `configs` reached the end of the
                     *   decision rule, return {@link ATN#INVALID_ALT_NUMBER}.
                     * * If all configurations in `configs` which reached the end of the
                     *   decision rule predict the same alternative, return that alternative.
                     * * If the configurations in `configs` which reached the end of the
                     *   decision rule predict multiple alternatives (call this *S*),
                     *   choose an alternative in the following order.
                     *
                     *     1. Filter the configurations in `configs` to only those
                     *        configurations which remain viable after evaluating semantic predicates.
                     *        If the set of these filtered configurations which also reached the end of
                     *        the decision rule is not empty, return the minimum alternative
                     *        represented in this set.
                     *     1. Otherwise, choose the minimum alternative in *S*.
                     *
                     * In some scenarios, the algorithm described above could predict an
                     * alternative which will result in a {@link FailedPredicateException} in
                     * parser. Specifically, this could occur if the *only* configuration
                     * capable of successfully parsing to the end of the decision rule is
                     * blocked by a semantic predicate. By choosing this alternative within
                     * {@link #adaptivePredict} instead of throwing a
                     * {@link NoViableAltException}, the resulting
                     * {@link FailedPredicateException} in the parser will identify the specific
                     * predicate which is preventing the parser from successfully parsing the
                     * decision rule, which helps developers identify and correct logic errors
                     * in semantic predicates.
                     *
                     * @param input The input {@link TokenStream}
                     * @param startIndex The start index for the current prediction, which is
                     * the input index where any semantic context in `configs` should be
                     * evaluated
                     * @param previous The ATN simulation state immediately before the
                     * {@link #ERROR} state was reached
                     *
                     * @returns The value to return from {@link #adaptivePredict}, or
                     * {@link ATN#INVALID_ALT_NUMBER} if a suitable alternative was not
                     * identified and {@link #adaptivePredict} should report an error instead.
                     */
                    handleNoViableAlt(input, startIndex, previous) {
                      if (previous.s0 != null) {
                        let alts = new BitSet_1.BitSet();
                        let maxAlt = 0;
                        for (let config of previous.s0.configs) {
                          if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
                            alts.set(config.alt);
                            maxAlt = Math.max(maxAlt, config.alt);
                          }
                        }
                        switch (alts.cardinality()) {
                          case 0:
                            break;
                          case 1:
                            return alts.nextSetBit(0);
                          default:
                            if (!previous.s0.configs.hasSemanticContext) {
                              return alts.nextSetBit(0);
                            }
                            let filteredConfigs = new ATNConfigSet_1.ATNConfigSet();
                            for (let config of previous.s0.configs) {
                              if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
                                filteredConfigs.add(config);
                              }
                            }
                            let altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);
                            if (altToPred != null) {
                              let predicates = this.getPredicatePredictions(alts, altToPred);
                              if (predicates != null) {
                                let stopIndex = input.index;
                                try {
                                  input.seek(startIndex);
                                  let filteredAlts = this.evalSemanticContext(predicates, previous.outerContext, false);
                                  if (!filteredAlts.isEmpty) {
                                    return filteredAlts.nextSetBit(0);
                                  }
                                } finally {
                                  input.seek(stopIndex);
                                }
                              }
                            }
                            return alts.nextSetBit(0);
                        }
                      }
                      throw this.noViableAlt(input, previous.outerContext, previous.s0.configs, startIndex);
                    }
                    computeReachSet(dfa, previous, t, contextCache) {
                      let useContext = previous.useContext;
                      let remainingGlobalContext = previous.remainingOuterContext;
                      let s = previous.s0;
                      if (useContext) {
                        while (s.isContextSymbol(t)) {
                          let next;
                          if (remainingGlobalContext != null) {
                            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
                            next = s.getContextTarget(this.getReturnState(remainingGlobalContext));
                          }
                          if (next == null) {
                            break;
                          }
                          assert(remainingGlobalContext != null);
                          remainingGlobalContext = remainingGlobalContext.parent;
                          s = next;
                        }
                      }
                      assert(!this.isAcceptState(s, useContext));
                      if (this.isAcceptState(s, useContext)) {
                        return new SimulatorState_1.SimulatorState(previous.outerContext, s, useContext, remainingGlobalContext);
                      }
                      let s0 = s;
                      let target = this.getExistingTargetState(s0, t);
                      if (target == null) {
                        let result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);
                        target = result[0];
                        remainingGlobalContext = result[1];
                      }
                      if (target === ATNSimulator_1.ATNSimulator.ERROR) {
                        return void 0;
                      }
                      assert(!useContext || !target.configs.dipsIntoOuterContext);
                      return new SimulatorState_1.SimulatorState(previous.outerContext, target, useContext, remainingGlobalContext);
                    }
                    /**
                     * Get an existing target state for an edge in the DFA. If the target state
                     * for the edge has not yet been computed or is otherwise not available,
                     * this method returns `undefined`.
                     *
                     * @param s The current DFA state
                     * @param t The next input symbol
                     * @returns The existing target DFA state for the given input symbol
                     * `t`, or `undefined` if the target state for this edge is not
                     * already cached
                     */
                    getExistingTargetState(s, t) {
                      return s.getTarget(t);
                    }
                    /**
                     * Compute a target state for an edge in the DFA, and attempt to add the
                     * computed state and corresponding edge to the DFA.
                     *
                     * @param dfa
                     * @param s The current DFA state
                     * @param remainingGlobalContext
                     * @param t The next input symbol
                     * @param useContext
                     * @param contextCache
                     *
                     * @returns The computed target DFA state for the given input symbol
                     * `t`. If `t` does not lead to a valid DFA state, this method
                     * returns {@link #ERROR}.
                     */
                    computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
                      let closureConfigs = s.configs.toArray();
                      let contextElements;
                      let reach = new ATNConfigSet_1.ATNConfigSet();
                      let stepIntoGlobal;
                      do {
                        let hasMoreContext = !useContext || remainingGlobalContext != null;
                        if (!hasMoreContext) {
                          reach.isOutermostConfigSet = true;
                        }
                        let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
                        let skippedStopStates;
                        for (let c of closureConfigs) {
                          if (ParserATNSimulator2.debug) {
                            console.log("testing " + this.getTokenName(t) + " at " + c.toString());
                          }
                          if (c.state instanceof RuleStopState_1.RuleStopState) {
                            assert(c.context.isEmpty);
                            if (useContext && !c.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {
                              if (skippedStopStates == null) {
                                skippedStopStates = [];
                              }
                              skippedStopStates.push(c);
                            }
                            continue;
                          }
                          let n = c.state.numberOfOptimizedTransitions;
                          for (let ti = 0; ti < n; ti++) {
                            let trans = c.state.getOptimizedTransition(ti);
                            let target = this.getReachableTarget(c, trans, t);
                            if (target != null) {
                              reachIntermediate.add(c.transform(target, false), contextCache);
                            }
                          }
                        }
                        if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                          reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;
                          reach = reachIntermediate;
                          break;
                        }
                        let collectPredicates = false;
                        let treatEofAsEpsilon = t === Token_1.Token.EOF;
                        this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);
                        stepIntoGlobal = reach.dipsIntoOuterContext;
                        if (t === IntStream_1.IntStream.EOF) {
                          reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);
                        }
                        if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {
                          assert(skippedStopStates.length > 0);
                          for (let c of skippedStopStates) {
                            reach.add(c, contextCache);
                          }
                        }
                        if (useContext && stepIntoGlobal) {
                          reach.clear();
                          remainingGlobalContext = remainingGlobalContext;
                          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
                          let nextContextElement = this.getReturnState(remainingGlobalContext);
                          if (contextElements == null) {
                            contextElements = new IntegerList_1.IntegerList();
                          }
                          if (remainingGlobalContext.isEmpty) {
                            remainingGlobalContext = void 0;
                          } else {
                            remainingGlobalContext = remainingGlobalContext.parent;
                          }
                          contextElements.add(nextContextElement);
                          if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                            for (let i = 0; i < closureConfigs.length; i++) {
                              closureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);
                            }
                          }
                        }
                      } while (useContext && stepIntoGlobal);
                      if (reach.isEmpty) {
                        this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
                        return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];
                      }
                      let result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);
                      return [result, remainingGlobalContext];
                    }
                    /**
                     * Return a configuration set containing only the configurations from
                     * `configs` which are in a {@link RuleStopState}. If all
                     * configurations in `configs` are already in a rule stop state, this
                     * method simply returns `configs`.
                     *
                     * @param configs the configuration set to update
                     * @param contextCache the {@link PredictionContext} cache
                     *
                     * @returns `configs` if all configurations in `configs` are in a
                     * rule stop state, otherwise return a new configuration set containing only
                     * the configurations from `configs` which are in a rule stop state
                     */
                    removeAllConfigsNotInRuleStopState(configs, contextCache) {
                      if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {
                        return configs;
                      }
                      let result = new ATNConfigSet_1.ATNConfigSet();
                      for (let config of configs) {
                        if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
                          continue;
                        }
                        result.add(config, contextCache);
                      }
                      return result;
                    }
                    computeStartState(dfa, globalContext, useContext) {
                      let s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) : useContext ? dfa.s0full : dfa.s0;
                      if (s0 != null) {
                        if (!useContext) {
                          return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);
                        }
                        s0.setContextSensitive(this.atn);
                      }
                      let decision = dfa.decision;
                      let p = dfa.atnStartState;
                      let previousContext = 0;
                      let remainingGlobalContext = globalContext;
                      let initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL;
                      let contextCache = new PredictionContextCache_1.PredictionContextCache();
                      if (useContext) {
                        if (!this.enable_global_context_dfa) {
                          while (remainingGlobalContext != null) {
                            if (remainingGlobalContext.isEmpty) {
                              previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                              remainingGlobalContext = void 0;
                            } else {
                              previousContext = this.getReturnState(remainingGlobalContext);
                              initialContext = initialContext.appendSingleContext(previousContext, contextCache);
                              remainingGlobalContext = remainingGlobalContext.parent;
                            }
                          }
                        }
                        while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {
                          let next;
                          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
                          if (remainingGlobalContext.isEmpty) {
                            next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);
                            previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                            remainingGlobalContext = void 0;
                          } else {
                            previousContext = this.getReturnState(remainingGlobalContext);
                            next = s0.getContextTarget(previousContext);
                            initialContext = initialContext.appendSingleContext(previousContext, contextCache);
                            remainingGlobalContext = remainingGlobalContext.parent;
                          }
                          if (next == null) {
                            break;
                          }
                          s0 = next;
                        }
                      }
                      if (s0 != null && !s0.isContextSensitive) {
                        return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
                      }
                      let configs = new ATNConfigSet_1.ATNConfigSet();
                      while (true) {
                        let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
                        let n = p.numberOfTransitions;
                        for (let ti = 0; ti < n; ti++) {
                          let target = p.transition(ti).target;
                          reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));
                        }
                        let hasMoreContext = remainingGlobalContext != null;
                        if (!hasMoreContext) {
                          configs.isOutermostConfigSet = true;
                        }
                        let collectPredicates = true;
                        this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);
                        let stepIntoGlobal = configs.dipsIntoOuterContext;
                        let next;
                        if (useContext && !this.enable_global_context_dfa) {
                          s0 = this.addDFAState(dfa, configs, contextCache);
                          break;
                        } else if (s0 == null) {
                          if (!dfa.isPrecedenceDfa) {
                            next = this.addDFAState(dfa, configs, contextCache);
                            if (useContext) {
                              if (!dfa.s0full) {
                                dfa.s0full = next;
                              } else {
                                next = dfa.s0full;
                              }
                            } else {
                              if (!dfa.s0) {
                                dfa.s0 = next;
                              } else {
                                next = dfa.s0;
                              }
                            }
                          } else {
                            configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
                            next = this.addDFAState(dfa, configs, contextCache);
                            dfa.setPrecedenceStartState(this._parser.precedence, useContext, next);
                          }
                        } else {
                          if (dfa.isPrecedenceDfa) {
                            configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
                          }
                          next = this.addDFAState(dfa, configs, contextCache);
                          s0.setContextTarget(previousContext, next);
                        }
                        s0 = next;
                        if (!useContext || !stepIntoGlobal) {
                          break;
                        }
                        next.setContextSensitive(this.atn);
                        remainingGlobalContext = remainingGlobalContext;
                        configs.clear();
                        remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
                        let nextContextElement = this.getReturnState(remainingGlobalContext);
                        if (remainingGlobalContext.isEmpty) {
                          remainingGlobalContext = void 0;
                        } else {
                          remainingGlobalContext = remainingGlobalContext.parent;
                        }
                        if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                          initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);
                        }
                        previousContext = nextContextElement;
                      }
                      return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
                    }
                    /**
                     * This method transforms the start state computed by
                     * {@link #computeStartState} to the special start state used by a
                     * precedence DFA for a particular precedence value. The transformation
                     * process applies the following changes to the start state's configuration
                     * set.
                     *
                     * 1. Evaluate the precedence predicates for each configuration using
                     *    {@link SemanticContext#evalPrecedence}.
                     * 1. When {@link ATNConfig#isPrecedenceFilterSuppressed} is `false`,
                     *    remove all configurations which predict an alternative greater than 1,
                     *    for which another configuration that predicts alternative 1 is in the
                     *    same ATN state with the same prediction context. This transformation is
                     *    valid for the following reasons:
                     *
                     *     * The closure block cannot contain any epsilon transitions which bypass
                     *       the body of the closure, so all states reachable via alternative 1 are
                     *       part of the precedence alternatives of the transformed left-recursive
                     *       rule.
                     *     * The "primary" portion of a left recursive rule cannot contain an
                     *       epsilon transition, so the only way an alternative other than 1 can exist
                     *       in a state that is also reachable via alternative 1 is by nesting calls
                     *       to the left-recursive rule, with the outer calls not being at the
                     *       preferred precedence level. The
                     *       {@link ATNConfig#isPrecedenceFilterSuppressed} property marks ATN
                     *       configurations which do not meet this condition, and therefore are not
                     *       eligible for elimination during the filtering process.
                     *
                     * The prediction context must be considered by this filter to address
                     * situations like the following.
                     *
                     * ```antlr
                     * grammar TA;
                     * prog: statement* EOF;
                     * statement: letterA | statement letterA 'b' ;
                     * letterA: 'a';
                     * ```
                     *
                     * If the above grammar, the ATN state immediately before the token
                     * reference `'a'` in `letterA` is reachable from the left edge
                     * of both the primary and closure blocks of the left-recursive rule
                     * `statement`. The prediction context associated with each of these
                     * configurations distinguishes between them, and prevents the alternative
                     * which stepped out to `prog` (and then back in to `statement`
                     * from being eliminated by the filter.
                     *
                     * @param configs The configuration set computed by
                     * {@link #computeStartState} as the start state for the DFA.
                     * @returns The transformed configuration set representing the start state
                     * for a precedence DFA at a particular precedence level (determined by
                     * calling {@link Parser#getPrecedence}).
                     */
                    applyPrecedenceFilter(configs, globalContext, contextCache) {
                      let statesFromAlt1 = /* @__PURE__ */ new Map();
                      let configSet = new ATNConfigSet_1.ATNConfigSet();
                      for (let config of configs) {
                        if (config.alt !== 1) {
                          continue;
                        }
                        let updatedContext = config.semanticContext.evalPrecedence(this._parser, globalContext);
                        if (updatedContext == null) {
                          continue;
                        }
                        statesFromAlt1.set(config.state.stateNumber, config.context);
                        if (updatedContext !== config.semanticContext) {
                          configSet.add(config.transform(config.state, false, updatedContext), contextCache);
                        } else {
                          configSet.add(config, contextCache);
                        }
                      }
                      for (let config of configs) {
                        if (config.alt === 1) {
                          continue;
                        }
                        if (!config.isPrecedenceFilterSuppressed) {
                          let context = statesFromAlt1.get(config.state.stateNumber);
                          if (context != null && context.equals(config.context)) {
                            continue;
                          }
                        }
                        configSet.add(config, contextCache);
                      }
                      return configSet;
                    }
                    getReachableTarget(source, trans, ttype) {
                      if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
                        return trans.target;
                      }
                      return void 0;
                    }
                    /** collect and set D's semantic context */
                    predicateDFAState(D, configs, nalts) {
                      let conflictingAlts = this.getConflictingAltsFromConfigSet(configs);
                      if (!conflictingAlts) {
                        throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");
                      }
                      if (ParserATNSimulator2.debug) {
                        console.log("predicateDFAState " + D);
                      }
                      let altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);
                      let predPredictions;
                      if (altToPred != null) {
                        predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);
                        D.predicates = predPredictions;
                      }
                      return predPredictions;
                    }
                    getPredsForAmbigAlts(ambigAlts, configs, nalts) {
                      let altToPred = new Array(nalts + 1);
                      let n = altToPred.length;
                      for (let c of configs) {
                        if (ambigAlts.get(c.alt)) {
                          altToPred[c.alt] = SemanticContext_1.SemanticContext.or(altToPred[c.alt], c.semanticContext);
                        }
                      }
                      let nPredAlts = 0;
                      for (let i = 0; i < n; i++) {
                        if (altToPred[i] == null) {
                          altToPred[i] = SemanticContext_1.SemanticContext.NONE;
                        } else if (altToPred[i] !== SemanticContext_1.SemanticContext.NONE) {
                          nPredAlts++;
                        }
                      }
                      let result = altToPred;
                      if (nPredAlts === 0) {
                        result = void 0;
                      }
                      if (ParserATNSimulator2.debug) {
                        console.log("getPredsForAmbigAlts result " + (result ? Arrays_1.Arrays.toString(result) : "undefined"));
                      }
                      return result;
                    }
                    getPredicatePredictions(ambigAlts, altToPred) {
                      let pairs2 = [];
                      let containsPredicate = false;
                      for (let i = 1; i < altToPred.length; i++) {
                        let pred = altToPred[i];
                        assert(pred != null);
                        if (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext_1.SemanticContext.NONE) {
                          pairs2.push(new DFAState_1.DFAState.PredPrediction(pred, i));
                        } else if (pred !== SemanticContext_1.SemanticContext.NONE) {
                          containsPredicate = true;
                          pairs2.push(new DFAState_1.DFAState.PredPrediction(pred, i));
                        }
                      }
                      if (!containsPredicate) {
                        return void 0;
                      }
                      return pairs2;
                    }
                    /** Look through a list of predicate/alt pairs, returning alts for the
                     *  pairs that win. An `undefined` predicate indicates an alt containing an
                     *  unpredicated config which behaves as "always true."
                     */
                    evalSemanticContext(predPredictions, outerContext, complete) {
                      let predictions = new BitSet_1.BitSet();
                      for (let pair of predPredictions) {
                        if (pair.pred === SemanticContext_1.SemanticContext.NONE) {
                          predictions.set(pair.alt);
                          if (!complete) {
                            break;
                          }
                          continue;
                        }
                        let evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);
                        if (ParserATNSimulator2.debug || ParserATNSimulator2.dfa_debug) {
                          console.log("eval pred " + pair + "=" + evaluatedResult);
                        }
                        if (evaluatedResult) {
                          if (ParserATNSimulator2.debug || ParserATNSimulator2.dfa_debug) {
                            console.log("PREDICT " + pair.alt);
                          }
                          predictions.set(pair.alt);
                          if (!complete) {
                            break;
                          }
                        }
                      }
                      return predictions;
                    }
                    /**
                     * Evaluate a semantic context within a specific parser context.
                     *
                     * This method might not be called for every semantic context evaluated
                     * during the prediction process. In particular, we currently do not
                     * evaluate the following but it may change in the future:
                     *
                     * * Precedence predicates (represented by
                     *   {@link SemanticContext.PrecedencePredicate}) are not currently evaluated
                     *   through this method.
                     * * Operator predicates (represented by {@link SemanticContext.AND} and
                     *   {@link SemanticContext.OR}) are evaluated as a single semantic
                     *   context, rather than evaluating the operands individually.
                     *   Implementations which require evaluation results from individual
                     *   predicates should override this method to explicitly handle evaluation of
                     *   the operands within operator predicates.
                     *
                     * @param pred The semantic context to evaluate
                     * @param parserCallStack The parser context in which to evaluate the
                     * semantic context
                     * @param alt The alternative which is guarded by `pred`
                     *
                     * @since 4.3
                     */
                    evalSemanticContextImpl(pred, parserCallStack, alt) {
                      return pred.eval(this._parser, parserCallStack);
                    }
                    /* TODO: If we are doing predicates, there is no point in pursuing
                         closure operations if we reach a DFA state that uniquely predicts
                         alternative. We will not be caching that DFA state and it is a
                         waste to pursue the closure. Might have to advance when we do
                         ambig detection thought :(
                          */
                    closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {
                      if (contextCache == null) {
                        contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
                      }
                      let currentConfigs = sourceConfigs;
                      let closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
                      while (currentConfigs.size > 0) {
                        let intermediate = new ATNConfigSet_1.ATNConfigSet();
                        for (let config of currentConfigs) {
                          this.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);
                        }
                        currentConfigs = intermediate;
                      }
                    }
                    closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {
                      if (ParserATNSimulator2.debug) {
                        console.log("closure(" + config.toString(this._parser, true) + ")");
                      }
                      if (config.state instanceof RuleStopState_1.RuleStopState) {
                        if (!config.context.isEmpty) {
                          let hasEmpty = config.context.hasEmpty;
                          let nonEmptySize = config.context.size - (hasEmpty ? 1 : 0);
                          for (let i = 0; i < nonEmptySize; i++) {
                            let newContext = config.context.getParent(i);
                            let returnState = this.atn.states[config.context.getReturnState(i)];
                            let c = ATNConfig_1.ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);
                            c.outerContextDepth = config.outerContextDepth;
                            c.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;
                            assert(depth > MIN_INTEGER_VALUE);
                            this.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);
                          }
                          if (!hasEmpty || !hasMoreContexts) {
                            return;
                          }
                          config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
                        } else if (!hasMoreContexts) {
                          configs.add(config, contextCache);
                          return;
                        } else {
                          if (ParserATNSimulator2.debug) {
                            console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                          }
                          if (config.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {
                            config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
                          } else if (!config.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
                            configs.add(config, contextCache);
                          }
                        }
                      }
                      let p = config.state;
                      if (!p.onlyHasEpsilonTransitions) {
                        configs.add(config, contextCache);
                        if (ParserATNSimulator2.debug) {
                          console.log("added config " + configs);
                        }
                      }
                      for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
                        if (i === 0 && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY && p.precedenceRuleDecision && !config.context.hasEmpty) {
                          let precedenceDecision = p;
                          let suppress = true;
                          for (let j = 0; j < config.context.size; j++) {
                            if (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {
                              suppress = false;
                              break;
                            }
                          }
                          if (suppress) {
                            continue;
                          }
                        }
                        let t = p.getOptimizedTransition(i);
                        let continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;
                        let c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);
                        if (c != null) {
                          if (t instanceof RuleTransition_1.RuleTransition) {
                            if (intermediate != null && !collectPredicates) {
                              intermediate.add(c, contextCache);
                              continue;
                            }
                          }
                          let newDepth = depth;
                          if (config.state instanceof RuleStopState_1.RuleStopState) {
                            if (this.dfa != null && this.dfa.isPrecedenceDfa) {
                              let outermostPrecedenceReturn = t.outermostPrecedenceReturn;
                              if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {
                                c.isPrecedenceFilterSuppressed = true;
                              }
                            }
                            c.outerContextDepth = c.outerContextDepth + 1;
                            if (!closureBusy.add(c)) {
                              continue;
                            }
                            assert(newDepth > MIN_INTEGER_VALUE);
                            newDepth--;
                            if (ParserATNSimulator2.debug) {
                              console.log("dips into outer ctx: " + c);
                            }
                          } else if (t instanceof RuleTransition_1.RuleTransition) {
                            if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
                              assert(c.context === config.context);
                              if (newDepth === 0) {
                                newDepth--;
                                if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
                                  c.outerContextDepth = c.outerContextDepth + 1;
                                }
                              }
                            } else {
                              if (newDepth >= 0) {
                                newDepth++;
                              }
                            }
                          } else {
                            if (!t.isEpsilon && !closureBusy.add(c)) {
                              continue;
                            }
                          }
                          this.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);
                        }
                      }
                    }
                    getRuleName(index) {
                      if (this._parser != null && index >= 0) {
                        return this._parser.ruleNames[index];
                      }
                      return "<rule " + index + ">";
                    }
                    getEpsilonTarget(config, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {
                      switch (t.serializationType) {
                        case 3:
                          return this.ruleTransition(config, t, contextCache);
                        case 10:
                          return this.precedenceTransition(config, t, collectPredicates, inContext);
                        case 4:
                          return this.predTransition(config, t, collectPredicates, inContext);
                        case 6:
                          return this.actionTransition(config, t);
                        case 1:
                          return config.transform(t.target, false);
                        case 5:
                        case 2:
                        case 7:
                          if (treatEofAsEpsilon) {
                            if (t.matches(Token_1.Token.EOF, 0, 1)) {
                              return config.transform(t.target, false);
                            }
                          }
                          return void 0;
                        default:
                          return void 0;
                      }
                    }
                    actionTransition(config, t) {
                      if (ParserATNSimulator2.debug) {
                        console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
                      }
                      return config.transform(t.target, false);
                    }
                    precedenceTransition(config, pt, collectPredicates, inContext) {
                      if (ParserATNSimulator2.debug) {
                        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
                        if (this._parser != null) {
                          console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
                        }
                      }
                      let c;
                      if (collectPredicates && inContext) {
                        let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
                        c = config.transform(pt.target, false, newSemCtx);
                      } else {
                        c = config.transform(pt.target, false);
                      }
                      if (ParserATNSimulator2.debug) {
                        console.log("config from pred transition=" + c);
                      }
                      return c;
                    }
                    predTransition(config, pt, collectPredicates, inContext) {
                      if (ParserATNSimulator2.debug) {
                        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
                        if (this._parser != null) {
                          console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
                        }
                      }
                      let c;
                      if (collectPredicates && (!pt.isCtxDependent || pt.isCtxDependent && inContext)) {
                        let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
                        c = config.transform(pt.target, false, newSemCtx);
                      } else {
                        c = config.transform(pt.target, false);
                      }
                      if (ParserATNSimulator2.debug) {
                        console.log("config from pred transition=" + c);
                      }
                      return c;
                    }
                    ruleTransition(config, t, contextCache) {
                      if (ParserATNSimulator2.debug) {
                        console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
                      }
                      let returnState = t.followState;
                      let newContext;
                      if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
                        newContext = config.context;
                      } else if (contextCache != null) {
                        newContext = contextCache.getChild(config.context, returnState.stateNumber);
                      } else {
                        newContext = config.context.getChild(returnState.stateNumber);
                      }
                      return config.transform(t.target, false, newContext);
                    }
                    isConflicted(configset, contextCache) {
                      if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {
                        return void 0;
                      }
                      let configs = configset.toArray();
                      configs.sort(ParserATNSimulator2.STATE_ALT_SORT_COMPARATOR);
                      let exact = !configset.dipsIntoOuterContext;
                      let alts = new BitSet_1.BitSet();
                      let minAlt = configs[0].alt;
                      alts.set(minAlt);
                      let currentState = configs[0].state.nonStopStateNumber;
                      for (let config of configs) {
                        let stateNumber = config.state.nonStopStateNumber;
                        if (stateNumber !== currentState) {
                          if (config.alt !== minAlt) {
                            return void 0;
                          }
                          currentState = stateNumber;
                        }
                      }
                      let representedAlts;
                      if (exact) {
                        currentState = configs[0].state.nonStopStateNumber;
                        representedAlts = new BitSet_1.BitSet();
                        let maxAlt = minAlt;
                        for (let config of configs) {
                          if (config.state.nonStopStateNumber !== currentState) {
                            break;
                          }
                          let alt = config.alt;
                          representedAlts.set(alt);
                          maxAlt = alt;
                        }
                        currentState = configs[0].state.nonStopStateNumber;
                        let currentAlt = minAlt;
                        for (let config of configs) {
                          let stateNumber = config.state.nonStopStateNumber;
                          let alt = config.alt;
                          if (stateNumber !== currentState) {
                            if (currentAlt !== maxAlt) {
                              exact = false;
                              break;
                            }
                            currentState = stateNumber;
                            currentAlt = minAlt;
                          } else if (alt !== currentAlt) {
                            if (alt !== representedAlts.nextSetBit(currentAlt + 1)) {
                              exact = false;
                              break;
                            }
                            currentAlt = alt;
                          }
                        }
                      }
                      currentState = configs[0].state.nonStopStateNumber;
                      let firstIndexCurrentState = 0;
                      let lastIndexCurrentStateMinAlt = 0;
                      let joinedCheckContext = configs[0].context;
                      for (let i = 1; i < configs.length; i++) {
                        let config = configs[i];
                        if (config.alt !== minAlt) {
                          break;
                        }
                        if (config.state.nonStopStateNumber !== currentState) {
                          break;
                        }
                        lastIndexCurrentStateMinAlt = i;
                        joinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);
                      }
                      for (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {
                        let config = configs[i];
                        let state = config.state;
                        alts.set(config.alt);
                        if (state.nonStopStateNumber !== currentState) {
                          currentState = state.nonStopStateNumber;
                          firstIndexCurrentState = i;
                          lastIndexCurrentStateMinAlt = i;
                          joinedCheckContext = config.context;
                          for (let j = firstIndexCurrentState + 1; j < configs.length; j++) {
                            let config2 = configs[j];
                            if (config2.alt !== minAlt) {
                              break;
                            }
                            if (config2.state.nonStopStateNumber !== currentState) {
                              break;
                            }
                            lastIndexCurrentStateMinAlt = j;
                            joinedCheckContext = contextCache.join(joinedCheckContext, config2.context);
                          }
                          i = lastIndexCurrentStateMinAlt;
                          continue;
                        }
                        let joinedCheckContext2 = config.context;
                        let currentAlt = config.alt;
                        let lastIndexCurrentStateCurrentAlt = i;
                        for (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {
                          let config2 = configs[j];
                          if (config2.alt !== currentAlt) {
                            break;
                          }
                          if (config2.state.nonStopStateNumber !== currentState) {
                            break;
                          }
                          lastIndexCurrentStateCurrentAlt = j;
                          joinedCheckContext2 = contextCache.join(joinedCheckContext2, config2.context);
                        }
                        i = lastIndexCurrentStateCurrentAlt;
                        let check = contextCache.join(joinedCheckContext, joinedCheckContext2);
                        if (!joinedCheckContext.equals(check)) {
                          return void 0;
                        }
                        exact = exact && joinedCheckContext.equals(joinedCheckContext2);
                      }
                      return new ConflictInfo_1.ConflictInfo(alts, exact);
                    }
                    getConflictingAltsFromConfigSet(configs) {
                      let conflictingAlts = configs.conflictingAlts;
                      if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                        conflictingAlts = new BitSet_1.BitSet();
                        conflictingAlts.set(configs.uniqueAlt);
                      }
                      return conflictingAlts;
                    }
                    getTokenName(t) {
                      if (t === Token_1.Token.EOF) {
                        return "EOF";
                      }
                      let vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
                      let displayName = vocabulary.getDisplayName(t);
                      if (displayName === String(t)) {
                        return displayName;
                      }
                      return displayName + "<" + t + ">";
                    }
                    getLookaheadName(input) {
                      return this.getTokenName(input.LA(1));
                    }
                    dumpDeadEndConfigs(nvae) {
                      console.log("dead end configs: ");
                      let deadEndConfigs = nvae.deadEndConfigs;
                      if (!deadEndConfigs) {
                        return;
                      }
                      for (let c of deadEndConfigs) {
                        let trans = "no edges";
                        if (c.state.numberOfOptimizedTransitions > 0) {
                          let t = c.state.getOptimizedTransition(0);
                          if (t instanceof AtomTransition_1.AtomTransition) {
                            trans = "Atom " + this.getTokenName(t._label);
                          } else if (t instanceof SetTransition_1.SetTransition) {
                            let not = t instanceof NotSetTransition_1.NotSetTransition;
                            trans = (not ? "~" : "") + "Set " + t.set.toString();
                          }
                        }
                        console.log(c.toString(this._parser, true) + ":" + trans);
                      }
                    }
                    noViableAlt(input, outerContext, configs, startIndex) {
                      return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
                    }
                    getUniqueAlt(configs) {
                      let alt = ATN_1.ATN.INVALID_ALT_NUMBER;
                      for (let c of configs) {
                        if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {
                          alt = c.alt;
                        } else if (c.alt !== alt) {
                          return ATN_1.ATN.INVALID_ALT_NUMBER;
                        }
                      }
                      return alt;
                    }
                    configWithAltAtStopState(configs, alt) {
                      for (let c of configs) {
                        if (c.alt === alt) {
                          if (c.state instanceof RuleStopState_1.RuleStopState) {
                            return true;
                          }
                        }
                      }
                      return false;
                    }
                    addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {
                      assert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);
                      let from = fromState;
                      let to = this.addDFAState(dfa, toConfigs, contextCache);
                      if (contextTransitions != null) {
                        for (let context of contextTransitions.toArray()) {
                          if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                            if (from.configs.isOutermostConfigSet) {
                              continue;
                            }
                          }
                          from.setContextSensitive(this.atn);
                          from.setContextSymbol(t);
                          let next = from.getContextTarget(context);
                          if (next != null) {
                            from = next;
                            continue;
                          }
                          next = this.addDFAContextState(dfa, from.configs, context, contextCache);
                          assert(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);
                          from.setContextTarget(context, next);
                          from = next;
                        }
                      }
                      if (ParserATNSimulator2.debug) {
                        console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
                      }
                      this.setDFAEdge(from, t, to);
                      if (ParserATNSimulator2.debug) {
                        console.log("DFA=\n" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : void 0));
                      }
                      return to;
                    }
                    setDFAEdge(p, t, q) {
                      if (p != null) {
                        p.setTarget(t, q);
                      }
                    }
                    /** See comment on LexerInterpreter.addDFAState. */
                    addDFAContextState(dfa, configs, returnContext, contextCache) {
                      if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                        let contextConfigs = new ATNConfigSet_1.ATNConfigSet();
                        for (let config of configs) {
                          contextConfigs.add(config.appendContext(returnContext, contextCache));
                        }
                        return this.addDFAState(dfa, contextConfigs, contextCache);
                      } else {
                        assert(!configs.isOutermostConfigSet, "Shouldn't be adding a duplicate edge.");
                        configs = configs.clone(true);
                        configs.isOutermostConfigSet = true;
                        return this.addDFAState(dfa, configs, contextCache);
                      }
                    }
                    /** See comment on LexerInterpreter.addDFAState. */
                    addDFAState(dfa, configs, contextCache) {
                      let enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;
                      if (enableDfa) {
                        if (!configs.isReadOnly) {
                          configs.optimizeConfigs(this);
                        }
                        let proposed = this.createDFAState(dfa, configs);
                        let existing = dfa.states.get(proposed);
                        if (existing != null) {
                          return existing;
                        }
                      }
                      if (!configs.isReadOnly) {
                        if (configs.conflictInfo == null) {
                          configs.conflictInfo = this.isConflicted(configs, contextCache);
                        }
                      }
                      let newState = this.createDFAState(dfa, configs.clone(true));
                      let decisionState = this.atn.getDecisionState(dfa.decision);
                      let predictedAlt = this.getUniqueAlt(configs);
                      if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                        newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);
                      } else if (configs.conflictingAlts != null) {
                        let conflictingAlts = configs.conflictingAlts;
                        if (conflictingAlts) {
                          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));
                        }
                      }
                      if (newState.isAcceptState && configs.hasSemanticContext) {
                        this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);
                      }
                      if (!enableDfa) {
                        return newState;
                      }
                      let added = dfa.addState(newState);
                      if (ParserATNSimulator2.debug && added === newState) {
                        console.log("adding new DFA state: " + newState);
                      }
                      return added;
                    }
                    createDFAState(dfa, configs) {
                      return new DFAState_1.DFAState(configs);
                    }
                    reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
                      if (ParserATNSimulator2.debug || ParserATNSimulator2.retry_debug) {
                        let interval = Interval_1.Interval.of(startIndex, stopIndex);
                        console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + conflictState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
                      }
                      if (this._parser != null) {
                        let listener = this._parser.getErrorListenerDispatch();
                        if (listener.reportAttemptingFullContext) {
                          listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
                        }
                      }
                    }
                    reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
                      if (ParserATNSimulator2.debug || ParserATNSimulator2.retry_debug) {
                        let interval = Interval_1.Interval.of(startIndex, stopIndex);
                        console.log("reportContextSensitivity decision=" + dfa.decision + ":" + acceptState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
                      }
                      if (this._parser != null) {
                        let listener = this._parser.getErrorListenerDispatch();
                        if (listener.reportContextSensitivity) {
                          listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);
                        }
                      }
                    }
                    /** If context sensitive parsing, we know it's ambiguity not conflict */
                    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
                      if (ParserATNSimulator2.debug || ParserATNSimulator2.retry_debug) {
                        let interval = Interval_1.Interval.of(startIndex, stopIndex);
                        console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this._parser.inputStream.getText(interval));
                      }
                      if (this._parser != null) {
                        let listener = this._parser.getErrorListenerDispatch();
                        if (listener.reportAmbiguity) {
                          listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
                        }
                      }
                    }
                    getReturnState(context) {
                      if (context.isEmpty) {
                        return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                      }
                      let state = this.atn.states[context.invokingState];
                      let transition = state.transition(0);
                      return transition.followState.stateNumber;
                    }
                    skipTailCalls(context) {
                      if (!this.optimize_tail_calls) {
                        return context;
                      }
                      while (!context.isEmpty) {
                        let state = this.atn.states[context.invokingState];
                        assert(
                          state.numberOfTransitions === 1 && state.transition(0).serializationType === 3
                          /* RULE */
                        );
                        let transition = state.transition(0);
                        if (!transition.tailCall) {
                          break;
                        }
                        context = context.parent;
                      }
                      return context;
                    }
                    /**
                     * @since 4.3
                     */
                    get parser() {
                      return this._parser;
                    }
                  };
                  ParserATNSimulator.debug = false;
                  ParserATNSimulator.dfa_debug = false;
                  ParserATNSimulator.retry_debug = false;
                  ParserATNSimulator.STATE_ALT_SORT_COMPARATOR = (o1, o2) => {
                    let diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;
                    if (diff !== 0) {
                      return diff;
                    }
                    diff = o1.alt - o2.alt;
                    if (diff !== 0) {
                      return diff;
                    }
                    return 0;
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], ParserATNSimulator.prototype, "predictionMode", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParserATNSimulator.prototype, "getPredictionMode", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "setPredictionMode", null);
                  __decorate([
                    Decorators_1.Override
                  ], ParserATNSimulator.prototype, "reset", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "adaptivePredict", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "getStartState", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(3, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "execDFA", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(3, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "execATN", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "handleNoViableAlt", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "getExistingTargetState", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "computeTargetState", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "removeAllConfigsNotInRuleStopState", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParserATNSimulator.prototype, "computeStartState", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "applyPrecedenceFilter", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "getReachableTarget", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "getPredsForAmbigAlts", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "evalSemanticContext", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "evalSemanticContextImpl", null);
                  __decorate([
                    __param(1, Decorators_1.NotNull),
                    __param(4, Decorators_1.Nullable)
                  ], ParserATNSimulator.prototype, "closure", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.Nullable),
                    __param(3, Decorators_1.NotNull),
                    __param(6, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "closureImpl", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParserATNSimulator.prototype, "getRuleName", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "getEpsilonTarget", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "actionTransition", null);
                  __decorate([
                    Decorators_1.Nullable,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "precedenceTransition", null);
                  __decorate([
                    Decorators_1.Nullable,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "predTransition", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.Nullable)
                  ], ParserATNSimulator.prototype, "ruleTransition", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "isConflicted", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParserATNSimulator.prototype, "getTokenName", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "dumpDeadEndConfigs", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "noViableAlt", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "getUniqueAlt", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "configWithAltAtStopState", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(4, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "addDFAEdge", null);
                  __decorate([
                    __param(0, Decorators_1.Nullable),
                    __param(2, Decorators_1.Nullable)
                  ], ParserATNSimulator.prototype, "setDFAEdge", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "addDFAContextState", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "addDFAState", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "createDFAState", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "reportAttemptingFullContext", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "reportContextSensitivity", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(5, Decorators_1.NotNull),
                    __param(6, Decorators_1.NotNull)
                  ], ParserATNSimulator.prototype, "reportAmbiguity", null);
                  ParserATNSimulator = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParserATNSimulator);
                  exports2.ParserATNSimulator = ParserATNSimulator;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/PlusBlockStartState.js": (
                /*!**********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/PlusBlockStartState.js ***!
                  \**********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.PlusBlockStartState = void 0;
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const BlockStartState_1 = __webpack_require__2(
                    /*! ./BlockStartState */
                    "./node_modules/antlr4ts/atn/BlockStartState.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class PlusBlockStartState extends BlockStartState_1.BlockStartState {
                    get stateType() {
                      return ATNStateType_1.ATNStateType.PLUS_BLOCK_START;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], PlusBlockStartState.prototype, "stateType", null);
                  exports2.PlusBlockStartState = PlusBlockStartState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/PlusLoopbackState.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/PlusLoopbackState.js ***!
                  \********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.PlusLoopbackState = void 0;
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const DecisionState_1 = __webpack_require__2(
                    /*! ./DecisionState */
                    "./node_modules/antlr4ts/atn/DecisionState.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class PlusLoopbackState extends DecisionState_1.DecisionState {
                    get stateType() {
                      return ATNStateType_1.ATNStateType.PLUS_LOOP_BACK;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], PlusLoopbackState.prototype, "stateType", null);
                  exports2.PlusLoopbackState = PlusLoopbackState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/PrecedencePredicateTransition.js": (
                /*!********************************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/PrecedencePredicateTransition.js ***!
                  \********************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.PrecedencePredicateTransition = void 0;
                  const AbstractPredicateTransition_1 = __webpack_require__2(
                    /*! ./AbstractPredicateTransition */
                    "./node_modules/antlr4ts/atn/AbstractPredicateTransition.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const SemanticContext_1 = __webpack_require__2(
                    /*! ./SemanticContext */
                    "./node_modules/antlr4ts/atn/SemanticContext.js"
                  );
                  let PrecedencePredicateTransition = class PrecedencePredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
                    constructor(target, precedence) {
                      super(target);
                      this.precedence = precedence;
                    }
                    get serializationType() {
                      return 10;
                    }
                    get isEpsilon() {
                      return true;
                    }
                    matches(symbol, minVocabSymbol, maxVocabSymbol) {
                      return false;
                    }
                    get predicate() {
                      return new SemanticContext_1.SemanticContext.PrecedencePredicate(this.precedence);
                    }
                    toString() {
                      return this.precedence + " >= _p";
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], PrecedencePredicateTransition.prototype, "serializationType", null);
                  __decorate([
                    Decorators_1.Override
                  ], PrecedencePredicateTransition.prototype, "isEpsilon", null);
                  __decorate([
                    Decorators_1.Override
                  ], PrecedencePredicateTransition.prototype, "matches", null);
                  __decorate([
                    Decorators_1.Override
                  ], PrecedencePredicateTransition.prototype, "toString", null);
                  PrecedencePredicateTransition = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], PrecedencePredicateTransition);
                  exports2.PrecedencePredicateTransition = PrecedencePredicateTransition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/PredicateEvalInfo.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/PredicateEvalInfo.js ***!
                  \********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.PredicateEvalInfo = void 0;
                  const DecisionEventInfo_1 = __webpack_require__2(
                    /*! ./DecisionEventInfo */
                    "./node_modules/antlr4ts/atn/DecisionEventInfo.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let PredicateEvalInfo = class PredicateEvalInfo extends DecisionEventInfo_1.DecisionEventInfo {
                    /**
                     * Constructs a new instance of the {@link PredicateEvalInfo} class with the
                     * specified detailed predicate evaluation information.
                     *
                     * @param state The simulator state
                     * @param decision The decision number
                     * @param input The input token stream
                     * @param startIndex The start index for the current prediction
                     * @param stopIndex The index at which the predicate evaluation was
                     * triggered. Note that the input stream may be reset to other positions for
                     * the actual evaluation of individual predicates.
                     * @param semctx The semantic context which was evaluated
                     * @param evalResult The results of evaluating the semantic context
                     * @param predictedAlt The alternative number for the decision which is
                     * guarded by the semantic context `semctx`. See {@link #predictedAlt}
                     * for more information.
                     *
                     * @see ParserATNSimulator#evalSemanticContext(SemanticContext, ParserRuleContext, int)
                     * @see SemanticContext#eval(Recognizer, RuleContext)
                     */
                    constructor(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {
                      super(decision, state, input, startIndex, stopIndex, state.useContext);
                      this.semctx = semctx;
                      this.evalResult = evalResult;
                      this.predictedAlt = predictedAlt;
                    }
                  };
                  PredicateEvalInfo = __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull),
                    __param(5, Decorators_1.NotNull)
                  ], PredicateEvalInfo);
                  exports2.PredicateEvalInfo = PredicateEvalInfo;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/PredicateTransition.js": (
                /*!**********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/PredicateTransition.js ***!
                  \**********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.PredicateTransition = void 0;
                  const AbstractPredicateTransition_1 = __webpack_require__2(
                    /*! ./AbstractPredicateTransition */
                    "./node_modules/antlr4ts/atn/AbstractPredicateTransition.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const SemanticContext_1 = __webpack_require__2(
                    /*! ./SemanticContext */
                    "./node_modules/antlr4ts/atn/SemanticContext.js"
                  );
                  let PredicateTransition = class PredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
                    constructor(target, ruleIndex, predIndex, isCtxDependent) {
                      super(target);
                      this.ruleIndex = ruleIndex;
                      this.predIndex = predIndex;
                      this.isCtxDependent = isCtxDependent;
                    }
                    get serializationType() {
                      return 4;
                    }
                    get isEpsilon() {
                      return true;
                    }
                    matches(symbol, minVocabSymbol, maxVocabSymbol) {
                      return false;
                    }
                    get predicate() {
                      return new SemanticContext_1.SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
                    }
                    toString() {
                      return "pred_" + this.ruleIndex + ":" + this.predIndex;
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], PredicateTransition.prototype, "serializationType", null);
                  __decorate([
                    Decorators_1.Override
                  ], PredicateTransition.prototype, "isEpsilon", null);
                  __decorate([
                    Decorators_1.Override
                  ], PredicateTransition.prototype, "matches", null);
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull
                  ], PredicateTransition.prototype, "toString", null);
                  PredicateTransition = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], PredicateTransition);
                  exports2.PredicateTransition = PredicateTransition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/PredictionContext.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/PredictionContext.js ***!
                  \********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.SingletonPredictionContext = exports2.PredictionContext = void 0;
                  const Array2DHashMap_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashMap */
                    "./node_modules/antlr4ts/misc/Array2DHashMap.js"
                  );
                  const Array2DHashSet_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashSet */
                    "./node_modules/antlr4ts/misc/Array2DHashSet.js"
                  );
                  const Arrays_1 = __webpack_require__2(
                    /*! ../misc/Arrays */
                    "./node_modules/antlr4ts/misc/Arrays.js"
                  );
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const PredictionContextCache_1 = __webpack_require__2(
                    /*! ./PredictionContextCache */
                    "./node_modules/antlr4ts/atn/PredictionContextCache.js"
                  );
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  const INITIAL_HASH = 1;
                  class PredictionContext {
                    constructor(cachedHashCode) {
                      this.cachedHashCode = cachedHashCode;
                    }
                    static calculateEmptyHashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
                      hash = MurmurHash_1.MurmurHash.finish(hash, 0);
                      return hash;
                    }
                    static calculateSingleHashCode(parent, returnState) {
                      let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
                      hash = MurmurHash_1.MurmurHash.update(hash, parent);
                      hash = MurmurHash_1.MurmurHash.update(hash, returnState);
                      hash = MurmurHash_1.MurmurHash.finish(hash, 2);
                      return hash;
                    }
                    static calculateHashCode(parents, returnStates) {
                      let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
                      for (let parent of parents) {
                        hash = MurmurHash_1.MurmurHash.update(hash, parent);
                      }
                      for (let returnState of returnStates) {
                        hash = MurmurHash_1.MurmurHash.update(hash, returnState);
                      }
                      hash = MurmurHash_1.MurmurHash.finish(hash, 2 * parents.length);
                      return hash;
                    }
                    static fromRuleContext(atn, outerContext, fullContext = true) {
                      if (outerContext.isEmpty) {
                        return fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
                      }
                      let parent;
                      if (outerContext._parent) {
                        parent = PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);
                      } else {
                        parent = fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
                      }
                      let state = atn.states[outerContext.invokingState];
                      let transition = state.transition(0);
                      return parent.getChild(transition.followState.stateNumber);
                    }
                    static addEmptyContext(context) {
                      return context.addEmptyContext();
                    }
                    static removeEmptyContext(context) {
                      return context.removeEmptyContext();
                    }
                    static join(context0, context1, contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED) {
                      if (context0 === context1) {
                        return context0;
                      }
                      if (context0.isEmpty) {
                        return PredictionContext.isEmptyLocal(context0) ? context0 : PredictionContext.addEmptyContext(context1);
                      } else if (context1.isEmpty) {
                        return PredictionContext.isEmptyLocal(context1) ? context1 : PredictionContext.addEmptyContext(context0);
                      }
                      let context0size = context0.size;
                      let context1size = context1.size;
                      if (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {
                        let merged = contextCache.join(context0.getParent(0), context1.getParent(0));
                        if (merged === context0.getParent(0)) {
                          return context0;
                        } else if (merged === context1.getParent(0)) {
                          return context1;
                        } else {
                          return merged.getChild(context0.getReturnState(0));
                        }
                      }
                      let count = 0;
                      let parentsList = new Array(context0size + context1size);
                      let returnStatesList = new Array(parentsList.length);
                      let leftIndex = 0;
                      let rightIndex = 0;
                      let canReturnLeft = true;
                      let canReturnRight = true;
                      while (leftIndex < context0size && rightIndex < context1size) {
                        if (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {
                          parentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));
                          returnStatesList[count] = context0.getReturnState(leftIndex);
                          canReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);
                          canReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);
                          leftIndex++;
                          rightIndex++;
                        } else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {
                          parentsList[count] = context0.getParent(leftIndex);
                          returnStatesList[count] = context0.getReturnState(leftIndex);
                          canReturnRight = false;
                          leftIndex++;
                        } else {
                          assert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));
                          parentsList[count] = context1.getParent(rightIndex);
                          returnStatesList[count] = context1.getReturnState(rightIndex);
                          canReturnLeft = false;
                          rightIndex++;
                        }
                        count++;
                      }
                      while (leftIndex < context0size) {
                        parentsList[count] = context0.getParent(leftIndex);
                        returnStatesList[count] = context0.getReturnState(leftIndex);
                        leftIndex++;
                        canReturnRight = false;
                        count++;
                      }
                      while (rightIndex < context1size) {
                        parentsList[count] = context1.getParent(rightIndex);
                        returnStatesList[count] = context1.getReturnState(rightIndex);
                        rightIndex++;
                        canReturnLeft = false;
                        count++;
                      }
                      if (canReturnLeft) {
                        return context0;
                      } else if (canReturnRight) {
                        return context1;
                      }
                      if (count < parentsList.length) {
                        parentsList = parentsList.slice(0, count);
                        returnStatesList = returnStatesList.slice(0, count);
                      }
                      if (parentsList.length === 0) {
                        return PredictionContext.EMPTY_FULL;
                      } else if (parentsList.length === 1) {
                        return new SingletonPredictionContext(parentsList[0], returnStatesList[0]);
                      } else {
                        return new ArrayPredictionContext(parentsList, returnStatesList);
                      }
                    }
                    static isEmptyLocal(context) {
                      return context === PredictionContext.EMPTY_LOCAL;
                    }
                    static getCachedContext(context, contextCache, visited) {
                      if (context.isEmpty) {
                        return context;
                      }
                      let existing = visited.get(context);
                      if (existing) {
                        return existing;
                      }
                      existing = contextCache.get(context);
                      if (existing) {
                        visited.put(context, existing);
                        return existing;
                      }
                      let changed = false;
                      let parents = new Array(context.size);
                      for (let i = 0; i < parents.length; i++) {
                        let parent = PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);
                        if (changed || parent !== context.getParent(i)) {
                          if (!changed) {
                            parents = new Array(context.size);
                            for (let j = 0; j < context.size; j++) {
                              parents[j] = context.getParent(j);
                            }
                            changed = true;
                          }
                          parents[i] = parent;
                        }
                      }
                      if (!changed) {
                        existing = contextCache.putIfAbsent(context, context);
                        visited.put(context, existing != null ? existing : context);
                        return context;
                      }
                      let updated;
                      if (parents.length === 1) {
                        updated = new SingletonPredictionContext(parents[0], context.getReturnState(0));
                      } else {
                        let returnStates = new Array(context.size);
                        for (let i = 0; i < context.size; i++) {
                          returnStates[i] = context.getReturnState(i);
                        }
                        updated = new ArrayPredictionContext(parents, returnStates, context.hashCode());
                      }
                      existing = contextCache.putIfAbsent(updated, updated);
                      visited.put(updated, existing || updated);
                      visited.put(context, existing || updated);
                      return updated;
                    }
                    appendSingleContext(returnContext, contextCache) {
                      return this.appendContext(PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);
                    }
                    getChild(returnState) {
                      return new SingletonPredictionContext(this, returnState);
                    }
                    hashCode() {
                      return this.cachedHashCode;
                    }
                    toStrings(recognizer, currentState, stop = PredictionContext.EMPTY_FULL) {
                      let result = [];
                      outer: for (let perm = 0; ; perm++) {
                        let offset = 0;
                        let last = true;
                        let p = this;
                        let stateNumber = currentState;
                        let localBuffer = "";
                        localBuffer += "[";
                        while (!p.isEmpty && p !== stop) {
                          let index = 0;
                          if (p.size > 0) {
                            let bits = 1;
                            while (1 << bits >>> 0 < p.size) {
                              bits++;
                            }
                            let mask = (1 << bits >>> 0) - 1;
                            index = perm >> offset & mask;
                            last = last && index >= p.size - 1;
                            if (index >= p.size) {
                              continue outer;
                            }
                            offset += bits;
                          }
                          if (recognizer) {
                            if (localBuffer.length > 1) {
                              localBuffer += " ";
                            }
                            let atn = recognizer.atn;
                            let s = atn.states[stateNumber];
                            let ruleName = recognizer.ruleNames[s.ruleIndex];
                            localBuffer += ruleName;
                          } else if (p.getReturnState(index) !== PredictionContext.EMPTY_FULL_STATE_KEY) {
                            if (!p.isEmpty) {
                              if (localBuffer.length > 1) {
                                localBuffer += " ";
                              }
                              localBuffer += p.getReturnState(index);
                            }
                          }
                          stateNumber = p.getReturnState(index);
                          p = p.getParent(index);
                        }
                        localBuffer += "]";
                        result.push(localBuffer);
                        if (last) {
                          break;
                        }
                      }
                      return result;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], PredictionContext.prototype, "hashCode", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], PredictionContext, "join", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], PredictionContext, "getCachedContext", null);
                  exports2.PredictionContext = PredictionContext;
                  class EmptyPredictionContext extends PredictionContext {
                    constructor(fullContext) {
                      super(PredictionContext.calculateEmptyHashCode());
                      this.fullContext = fullContext;
                    }
                    get isFullContext() {
                      return this.fullContext;
                    }
                    addEmptyContext() {
                      return this;
                    }
                    removeEmptyContext() {
                      throw new Error("Cannot remove the empty context from itself.");
                    }
                    getParent(index) {
                      throw new Error("index out of bounds");
                    }
                    getReturnState(index) {
                      throw new Error("index out of bounds");
                    }
                    findReturnState(returnState) {
                      return -1;
                    }
                    get size() {
                      return 0;
                    }
                    appendSingleContext(returnContext, contextCache) {
                      return contextCache.getChild(this, returnContext);
                    }
                    appendContext(suffix, contextCache) {
                      return suffix;
                    }
                    get isEmpty() {
                      return true;
                    }
                    get hasEmpty() {
                      return true;
                    }
                    equals(o) {
                      return this === o;
                    }
                    toStrings(recognizer, currentState, stop) {
                      return ["[]"];
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "addEmptyContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "removeEmptyContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "getParent", null);
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "getReturnState", null);
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "findReturnState", null);
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "size", null);
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "appendSingleContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "appendContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "isEmpty", null);
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "hasEmpty", null);
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], EmptyPredictionContext.prototype, "toStrings", null);
                  let ArrayPredictionContext = class ArrayPredictionContext2 extends PredictionContext {
                    constructor(parents, returnStates, hashCode) {
                      super(hashCode || PredictionContext.calculateHashCode(parents, returnStates));
                      assert(parents.length === returnStates.length);
                      assert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, "Should be using PredictionContext.EMPTY instead.");
                      this.parents = parents;
                      this.returnStates = returnStates;
                    }
                    getParent(index) {
                      return this.parents[index];
                    }
                    getReturnState(index) {
                      return this.returnStates[index];
                    }
                    findReturnState(returnState) {
                      return Arrays_1.Arrays.binarySearch(this.returnStates, returnState);
                    }
                    get size() {
                      return this.returnStates.length;
                    }
                    get isEmpty() {
                      return false;
                    }
                    get hasEmpty() {
                      return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;
                    }
                    addEmptyContext() {
                      if (this.hasEmpty) {
                        return this;
                      }
                      let parents2 = this.parents.slice(0);
                      let returnStates2 = this.returnStates.slice(0);
                      parents2.push(PredictionContext.EMPTY_FULL);
                      returnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);
                      return new ArrayPredictionContext2(parents2, returnStates2);
                    }
                    removeEmptyContext() {
                      if (!this.hasEmpty) {
                        return this;
                      }
                      if (this.returnStates.length === 2) {
                        return new SingletonPredictionContext(this.parents[0], this.returnStates[0]);
                      } else {
                        let parents2 = this.parents.slice(0, this.parents.length - 1);
                        let returnStates2 = this.returnStates.slice(0, this.returnStates.length - 1);
                        return new ArrayPredictionContext2(parents2, returnStates2);
                      }
                    }
                    appendContext(suffix, contextCache) {
                      return ArrayPredictionContext2.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());
                    }
                    static appendContextImpl(context, suffix, visited) {
                      if (suffix.isEmpty) {
                        if (PredictionContext.isEmptyLocal(suffix)) {
                          if (context.hasEmpty) {
                            return PredictionContext.EMPTY_LOCAL;
                          }
                          throw new Error("what to do here?");
                        }
                        return context;
                      }
                      if (suffix.size !== 1) {
                        throw new Error("Appending a tree suffix is not yet supported.");
                      }
                      let result = visited.get(context);
                      if (!result) {
                        if (context.isEmpty) {
                          result = suffix;
                        } else {
                          let parentCount = context.size;
                          if (context.hasEmpty) {
                            parentCount--;
                          }
                          let updatedParents = new Array(parentCount);
                          let updatedReturnStates = new Array(parentCount);
                          for (let i = 0; i < parentCount; i++) {
                            updatedReturnStates[i] = context.getReturnState(i);
                          }
                          for (let i = 0; i < parentCount; i++) {
                            updatedParents[i] = ArrayPredictionContext2.appendContextImpl(context.getParent(i), suffix, visited);
                          }
                          if (updatedParents.length === 1) {
                            result = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);
                          } else {
                            assert(updatedParents.length > 1);
                            result = new ArrayPredictionContext2(updatedParents, updatedReturnStates);
                          }
                          if (context.hasEmpty) {
                            result = PredictionContext.join(result, suffix);
                          }
                        }
                        visited.put(context, result);
                      }
                      return result;
                    }
                    equals(o) {
                      if (this === o) {
                        return true;
                      } else if (!(o instanceof ArrayPredictionContext2)) {
                        return false;
                      }
                      if (this.hashCode() !== o.hashCode()) {
                        return false;
                      }
                      let other = o;
                      return this.equalsImpl(other, new Array2DHashSet_1.Array2DHashSet());
                    }
                    equalsImpl(other, visited) {
                      let selfWorkList = [];
                      let otherWorkList = [];
                      selfWorkList.push(this);
                      otherWorkList.push(other);
                      while (true) {
                        let currentSelf = selfWorkList.pop();
                        let currentOther = otherWorkList.pop();
                        if (!currentSelf || !currentOther) {
                          break;
                        }
                        let operands = new PredictionContextCache_1.PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);
                        if (!visited.add(operands)) {
                          continue;
                        }
                        let selfSize = operands.x.size;
                        if (selfSize === 0) {
                          if (!operands.x.equals(operands.y)) {
                            return false;
                          }
                          continue;
                        }
                        let otherSize = operands.y.size;
                        if (selfSize !== otherSize) {
                          return false;
                        }
                        for (let i = 0; i < selfSize; i++) {
                          if (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {
                            return false;
                          }
                          let selfParent = operands.x.getParent(i);
                          let otherParent = operands.y.getParent(i);
                          if (selfParent.hashCode() !== otherParent.hashCode()) {
                            return false;
                          }
                          if (selfParent !== otherParent) {
                            selfWorkList.push(selfParent);
                            otherWorkList.push(otherParent);
                          }
                        }
                      }
                      return true;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], ArrayPredictionContext.prototype, "parents", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ArrayPredictionContext.prototype, "returnStates", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], ArrayPredictionContext.prototype, "getParent", null);
                  __decorate([
                    Decorators_1.Override
                  ], ArrayPredictionContext.prototype, "getReturnState", null);
                  __decorate([
                    Decorators_1.Override
                  ], ArrayPredictionContext.prototype, "findReturnState", null);
                  __decorate([
                    Decorators_1.Override
                  ], ArrayPredictionContext.prototype, "size", null);
                  __decorate([
                    Decorators_1.Override
                  ], ArrayPredictionContext.prototype, "isEmpty", null);
                  __decorate([
                    Decorators_1.Override
                  ], ArrayPredictionContext.prototype, "hasEmpty", null);
                  __decorate([
                    Decorators_1.Override
                  ], ArrayPredictionContext.prototype, "addEmptyContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], ArrayPredictionContext.prototype, "removeEmptyContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], ArrayPredictionContext.prototype, "appendContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], ArrayPredictionContext.prototype, "equals", null);
                  ArrayPredictionContext = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ArrayPredictionContext);
                  let SingletonPredictionContext = class SingletonPredictionContext2 extends PredictionContext {
                    constructor(parent, returnState) {
                      super(PredictionContext.calculateSingleHashCode(parent, returnState));
                      this.parent = parent;
                      this.returnState = returnState;
                    }
                    getParent(index) {
                      return this.parent;
                    }
                    getReturnState(index) {
                      return this.returnState;
                    }
                    findReturnState(returnState) {
                      return this.returnState === returnState ? 0 : -1;
                    }
                    get size() {
                      return 1;
                    }
                    get isEmpty() {
                      return false;
                    }
                    get hasEmpty() {
                      return false;
                    }
                    appendContext(suffix, contextCache) {
                      return contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);
                    }
                    addEmptyContext() {
                      let parents = [this.parent, PredictionContext.EMPTY_FULL];
                      let returnStates = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];
                      return new ArrayPredictionContext(parents, returnStates);
                    }
                    removeEmptyContext() {
                      return this;
                    }
                    equals(o) {
                      if (o === this) {
                        return true;
                      } else if (!(o instanceof SingletonPredictionContext2)) {
                        return false;
                      }
                      let other = o;
                      if (this.hashCode() !== other.hashCode()) {
                        return false;
                      }
                      return this.returnState === other.returnState && this.parent.equals(other.parent);
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], SingletonPredictionContext.prototype, "parent", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], SingletonPredictionContext.prototype, "getParent", null);
                  __decorate([
                    Decorators_1.Override
                  ], SingletonPredictionContext.prototype, "getReturnState", null);
                  __decorate([
                    Decorators_1.Override
                  ], SingletonPredictionContext.prototype, "findReturnState", null);
                  __decorate([
                    Decorators_1.Override
                  ], SingletonPredictionContext.prototype, "size", null);
                  __decorate([
                    Decorators_1.Override
                  ], SingletonPredictionContext.prototype, "isEmpty", null);
                  __decorate([
                    Decorators_1.Override
                  ], SingletonPredictionContext.prototype, "hasEmpty", null);
                  __decorate([
                    Decorators_1.Override
                  ], SingletonPredictionContext.prototype, "appendContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], SingletonPredictionContext.prototype, "addEmptyContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], SingletonPredictionContext.prototype, "removeEmptyContext", null);
                  __decorate([
                    Decorators_1.Override
                  ], SingletonPredictionContext.prototype, "equals", null);
                  SingletonPredictionContext = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], SingletonPredictionContext);
                  exports2.SingletonPredictionContext = SingletonPredictionContext;
                  (function(PredictionContext2) {
                    PredictionContext2.EMPTY_LOCAL = new EmptyPredictionContext(false);
                    PredictionContext2.EMPTY_FULL = new EmptyPredictionContext(true);
                    PredictionContext2.EMPTY_LOCAL_STATE_KEY = -(1 << 31 >>> 0);
                    PredictionContext2.EMPTY_FULL_STATE_KEY = (1 << 31 >>> 0) - 1;
                    class IdentityHashMap extends Array2DHashMap_1.Array2DHashMap {
                      constructor() {
                        super(IdentityEqualityComparator.INSTANCE);
                      }
                    }
                    PredictionContext2.IdentityHashMap = IdentityHashMap;
                    class IdentityEqualityComparator {
                      IdentityEqualityComparator() {
                      }
                      hashCode(obj) {
                        return obj.hashCode();
                      }
                      equals(a, b) {
                        return a === b;
                      }
                    }
                    IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator();
                    __decorate([
                      Decorators_1.Override
                    ], IdentityEqualityComparator.prototype, "hashCode", null);
                    __decorate([
                      Decorators_1.Override
                    ], IdentityEqualityComparator.prototype, "equals", null);
                    PredictionContext2.IdentityEqualityComparator = IdentityEqualityComparator;
                  })(PredictionContext = exports2.PredictionContext || (exports2.PredictionContext = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/PredictionContextCache.js": (
                /*!*************************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/PredictionContextCache.js ***!
                  \*************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.PredictionContextCache = void 0;
                  const Array2DHashMap_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashMap */
                    "./node_modules/antlr4ts/misc/Array2DHashMap.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ObjectEqualityComparator_1 = __webpack_require__2(
                    /*! ../misc/ObjectEqualityComparator */
                    "./node_modules/antlr4ts/misc/ObjectEqualityComparator.js"
                  );
                  const PredictionContext_1 = __webpack_require__2(
                    /*! ./PredictionContext */
                    "./node_modules/antlr4ts/atn/PredictionContext.js"
                  );
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  class PredictionContextCache {
                    constructor(enableCache = true) {
                      this.contexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
                      this.childContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
                      this.joinContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
                      this.enableCache = enableCache;
                    }
                    getAsCached(context) {
                      if (!this.enableCache) {
                        return context;
                      }
                      let result = this.contexts.get(context);
                      if (!result) {
                        result = context;
                        this.contexts.put(context, context);
                      }
                      return result;
                    }
                    getChild(context, invokingState) {
                      if (!this.enableCache) {
                        return context.getChild(invokingState);
                      }
                      let operands = new PredictionContextCache.PredictionContextAndInt(context, invokingState);
                      let result = this.childContexts.get(operands);
                      if (!result) {
                        result = context.getChild(invokingState);
                        result = this.getAsCached(result);
                        this.childContexts.put(operands, result);
                      }
                      return result;
                    }
                    join(x, y) {
                      if (!this.enableCache) {
                        return PredictionContext_1.PredictionContext.join(x, y, this);
                      }
                      let operands = new PredictionContextCache.IdentityCommutativePredictionContextOperands(x, y);
                      let result = this.joinContexts.get(operands);
                      if (result) {
                        return result;
                      }
                      result = PredictionContext_1.PredictionContext.join(x, y, this);
                      result = this.getAsCached(result);
                      this.joinContexts.put(operands, result);
                      return result;
                    }
                  }
                  exports2.PredictionContextCache = PredictionContextCache;
                  PredictionContextCache.UNCACHED = new PredictionContextCache(false);
                  (function(PredictionContextCache2) {
                    class PredictionContextAndInt {
                      constructor(obj, value) {
                        this.obj = obj;
                        this.value = value;
                      }
                      equals(obj) {
                        if (!(obj instanceof PredictionContextAndInt)) {
                          return false;
                        } else if (obj === this) {
                          return true;
                        }
                        let other = obj;
                        return this.value === other.value && (this.obj === other.obj || this.obj != null && this.obj.equals(other.obj));
                      }
                      hashCode() {
                        let hashCode = 5;
                        hashCode = 7 * hashCode + (this.obj != null ? this.obj.hashCode() : 0);
                        hashCode = 7 * hashCode + this.value;
                        return hashCode;
                      }
                    }
                    __decorate([
                      Decorators_1.Override
                    ], PredictionContextAndInt.prototype, "equals", null);
                    __decorate([
                      Decorators_1.Override
                    ], PredictionContextAndInt.prototype, "hashCode", null);
                    PredictionContextCache2.PredictionContextAndInt = PredictionContextAndInt;
                    class IdentityCommutativePredictionContextOperands {
                      constructor(x, y) {
                        assert(x != null);
                        assert(y != null);
                        this._x = x;
                        this._y = y;
                      }
                      get x() {
                        return this._x;
                      }
                      get y() {
                        return this._y;
                      }
                      equals(o) {
                        if (!(o instanceof IdentityCommutativePredictionContextOperands)) {
                          return false;
                        } else if (this === o) {
                          return true;
                        }
                        let other = o;
                        return this._x === other._x && this._y === other._y || this._x === other._y && this._y === other._x;
                      }
                      hashCode() {
                        return this._x.hashCode() ^ this._y.hashCode();
                      }
                    }
                    __decorate([
                      Decorators_1.Override
                    ], IdentityCommutativePredictionContextOperands.prototype, "equals", null);
                    __decorate([
                      Decorators_1.Override
                    ], IdentityCommutativePredictionContextOperands.prototype, "hashCode", null);
                    PredictionContextCache2.IdentityCommutativePredictionContextOperands = IdentityCommutativePredictionContextOperands;
                  })(PredictionContextCache = exports2.PredictionContextCache || (exports2.PredictionContextCache = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/PredictionMode.js": (
                /*!*****************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/PredictionMode.js ***!
                  \*****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.PredictionMode = void 0;
                  const Array2DHashMap_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashMap */
                    "./node_modules/antlr4ts/misc/Array2DHashMap.js"
                  );
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const RuleStopState_1 = __webpack_require__2(
                    /*! ./RuleStopState */
                    "./node_modules/antlr4ts/atn/RuleStopState.js"
                  );
                  var PredictionMode;
                  (function(PredictionMode2) {
                    PredictionMode2[PredictionMode2["SLL"] = 0] = "SLL";
                    PredictionMode2[PredictionMode2["LL"] = 1] = "LL";
                    PredictionMode2[PredictionMode2["LL_EXACT_AMBIG_DETECTION"] = 2] = "LL_EXACT_AMBIG_DETECTION";
                  })(PredictionMode = exports2.PredictionMode || (exports2.PredictionMode = {}));
                  (function(PredictionMode2) {
                    class AltAndContextMap extends Array2DHashMap_1.Array2DHashMap {
                      constructor() {
                        super(AltAndContextConfigEqualityComparator.INSTANCE);
                      }
                    }
                    class AltAndContextConfigEqualityComparator {
                      AltAndContextConfigEqualityComparator() {
                      }
                      /**
                       * The hash code is only a function of the {@link ATNState#stateNumber}
                       * and {@link ATNConfig#context}.
                       */
                      hashCode(o) {
                        let hashCode = MurmurHash_1.MurmurHash.initialize(7);
                        hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.state.stateNumber);
                        hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.context);
                        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 2);
                        return hashCode;
                      }
                      equals(a, b) {
                        if (a === b) {
                          return true;
                        }
                        if (a == null || b == null) {
                          return false;
                        }
                        return a.state.stateNumber === b.state.stateNumber && a.context.equals(b.context);
                      }
                    }
                    AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator();
                    __decorate([
                      Decorators_1.Override
                    ], AltAndContextConfigEqualityComparator.prototype, "hashCode", null);
                    __decorate([
                      Decorators_1.Override
                    ], AltAndContextConfigEqualityComparator.prototype, "equals", null);
                    function hasConfigInRuleStopState(configs) {
                      for (let c of configs) {
                        if (c.state instanceof RuleStopState_1.RuleStopState) {
                          return true;
                        }
                      }
                      return false;
                    }
                    PredictionMode2.hasConfigInRuleStopState = hasConfigInRuleStopState;
                    function allConfigsInRuleStopStates(configs) {
                      for (let config of configs) {
                        if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
                          return false;
                        }
                      }
                      return true;
                    }
                    PredictionMode2.allConfigsInRuleStopStates = allConfigsInRuleStopStates;
                  })(PredictionMode = exports2.PredictionMode || (exports2.PredictionMode = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/ProfilingATNSimulator.js": (
                /*!************************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/ProfilingATNSimulator.js ***!
                  \************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var process2 = __webpack_require__2(
                    /*! process/browser */
                    "./node_modules/process/browser.js"
                  );
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ProfilingATNSimulator = void 0;
                  const AmbiguityInfo_1 = __webpack_require__2(
                    /*! ./AmbiguityInfo */
                    "./node_modules/antlr4ts/atn/AmbiguityInfo.js"
                  );
                  const ATN_1 = __webpack_require__2(
                    /*! ./ATN */
                    "./node_modules/antlr4ts/atn/ATN.js"
                  );
                  const ATNSimulator_1 = __webpack_require__2(
                    /*! ./ATNSimulator */
                    "./node_modules/antlr4ts/atn/ATNSimulator.js"
                  );
                  const ContextSensitivityInfo_1 = __webpack_require__2(
                    /*! ./ContextSensitivityInfo */
                    "./node_modules/antlr4ts/atn/ContextSensitivityInfo.js"
                  );
                  const DecisionInfo_1 = __webpack_require__2(
                    /*! ./DecisionInfo */
                    "./node_modules/antlr4ts/atn/DecisionInfo.js"
                  );
                  const ErrorInfo_1 = __webpack_require__2(
                    /*! ./ErrorInfo */
                    "./node_modules/antlr4ts/atn/ErrorInfo.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const LookaheadEventInfo_1 = __webpack_require__2(
                    /*! ./LookaheadEventInfo */
                    "./node_modules/antlr4ts/atn/LookaheadEventInfo.js"
                  );
                  const ParserATNSimulator_1 = __webpack_require__2(
                    /*! ./ParserATNSimulator */
                    "./node_modules/antlr4ts/atn/ParserATNSimulator.js"
                  );
                  const PredicateEvalInfo_1 = __webpack_require__2(
                    /*! ./PredicateEvalInfo */
                    "./node_modules/antlr4ts/atn/PredicateEvalInfo.js"
                  );
                  const SemanticContext_1 = __webpack_require__2(
                    /*! ./SemanticContext */
                    "./node_modules/antlr4ts/atn/SemanticContext.js"
                  );
                  const SimulatorState_1 = __webpack_require__2(
                    /*! ./SimulatorState */
                    "./node_modules/antlr4ts/atn/SimulatorState.js"
                  );
                  class ProfilingATNSimulator extends ParserATNSimulator_1.ParserATNSimulator {
                    constructor(parser) {
                      super(parser.interpreter.atn, parser);
                      this._startIndex = 0;
                      this._sllStopIndex = 0;
                      this._llStopIndex = 0;
                      this.currentDecision = 0;
                      this.conflictingAltResolvedBySLL = 0;
                      this.optimize_ll1 = false;
                      this.reportAmbiguities = true;
                      this.numDecisions = this.atn.decisionToState.length;
                      this.decisions = [];
                      for (let i = 0; i < this.numDecisions; i++) {
                        this.decisions.push(new DecisionInfo_1.DecisionInfo(i));
                      }
                    }
                    adaptivePredict(input, decision, outerContext, useContext) {
                      if (useContext !== void 0) {
                        return super.adaptivePredict(input, decision, outerContext, useContext);
                      }
                      try {
                        this._input = input;
                        this._startIndex = input.index;
                        this._sllStopIndex = this._startIndex - 1;
                        this._llStopIndex = -1;
                        this.currentDecision = decision;
                        this.currentState = void 0;
                        this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;
                        let start = process2.hrtime();
                        let alt = super.adaptivePredict(input, decision, outerContext);
                        let stop = process2.hrtime();
                        let nanoseconds = (stop[0] - start[0]) * 1e9;
                        if (nanoseconds === 0) {
                          nanoseconds = stop[1] - start[1];
                        } else {
                          nanoseconds += 1e9 - start[1] + stop[1];
                        }
                        this.decisions[decision].timeInPrediction += nanoseconds;
                        this.decisions[decision].invocations++;
                        let SLL_k = this._sllStopIndex - this._startIndex + 1;
                        this.decisions[decision].SLL_TotalLook += SLL_k;
                        this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);
                        if (SLL_k > this.decisions[decision].SLL_MaxLook) {
                          this.decisions[decision].SLL_MaxLook = SLL_k;
                          this.decisions[decision].SLL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._sllStopIndex, false);
                        }
                        if (this._llStopIndex >= 0) {
                          let LL_k = this._llStopIndex - this._startIndex + 1;
                          this.decisions[decision].LL_TotalLook += LL_k;
                          this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);
                          if (LL_k > this.decisions[decision].LL_MaxLook) {
                            this.decisions[decision].LL_MaxLook = LL_k;
                            this.decisions[decision].LL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._llStopIndex, true);
                          }
                        }
                        return alt;
                      } finally {
                        this._input = void 0;
                        this.currentDecision = -1;
                      }
                    }
                    getStartState(dfa, input, outerContext, useContext) {
                      let state = super.getStartState(dfa, input, outerContext, useContext);
                      this.currentState = state;
                      return state;
                    }
                    computeStartState(dfa, globalContext, useContext) {
                      let state = super.computeStartState(dfa, globalContext, useContext);
                      this.currentState = state;
                      return state;
                    }
                    computeReachSet(dfa, previous, t, contextCache) {
                      if (this._input === void 0) {
                        throw new Error("Invalid state");
                      }
                      let reachState = super.computeReachSet(dfa, previous, t, contextCache);
                      if (reachState == null) {
                        this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index));
                      }
                      this.currentState = reachState;
                      return reachState;
                    }
                    getExistingTargetState(previousD, t) {
                      if (this.currentState === void 0 || this._input === void 0) {
                        throw new Error("Invalid state");
                      }
                      if (this.currentState.useContext) {
                        this._llStopIndex = this._input.index;
                      } else {
                        this._sllStopIndex = this._input.index;
                      }
                      let existingTargetState = super.getExistingTargetState(previousD, t);
                      if (existingTargetState != null) {
                        this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);
                        if (this.currentState.useContext) {
                          this.decisions[this.currentDecision].LL_DFATransitions++;
                        } else {
                          this.decisions[this.currentDecision].SLL_DFATransitions++;
                        }
                        if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {
                          let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);
                          this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));
                        }
                      }
                      return existingTargetState;
                    }
                    computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
                      let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);
                      if (useContext) {
                        this.decisions[this.currentDecision].LL_ATNTransitions++;
                      } else {
                        this.decisions[this.currentDecision].SLL_ATNTransitions++;
                      }
                      return targetState;
                    }
                    evalSemanticContextImpl(pred, parserCallStack, alt) {
                      if (this.currentState === void 0 || this._input === void 0) {
                        throw new Error("Invalid state");
                      }
                      let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);
                      if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {
                        let fullContext = this._llStopIndex >= 0;
                        let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;
                        this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));
                      }
                      return result;
                    }
                    reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
                      if (this._input === void 0) {
                        throw new Error("Invalid state");
                      }
                      if (prediction !== this.conflictingAltResolvedBySLL) {
                        this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));
                      }
                      super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);
                    }
                    reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
                      if (conflictingAlts != null) {
                        this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
                      } else {
                        this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);
                      }
                      this.decisions[this.currentDecision].LL_Fallback++;
                      super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);
                    }
                    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
                      if (this.currentState === void 0 || this._input === void 0) {
                        throw new Error("Invalid state");
                      }
                      let prediction;
                      if (ambigAlts != null) {
                        prediction = ambigAlts.nextSetBit(0);
                      } else {
                        prediction = configs.getRepresentedAlternatives().nextSetBit(0);
                      }
                      if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {
                        this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));
                      }
                      this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));
                      super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);
                    }
                    // ---------------------------------------------------------------------
                    getDecisionInfo() {
                      return this.decisions;
                    }
                    getCurrentState() {
                      return this.currentState;
                    }
                  }
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], ProfilingATNSimulator.prototype, "adaptivePredict", null);
                  __decorate([
                    Decorators_1.Override
                  ], ProfilingATNSimulator.prototype, "getStartState", null);
                  __decorate([
                    Decorators_1.Override
                  ], ProfilingATNSimulator.prototype, "computeStartState", null);
                  __decorate([
                    Decorators_1.Override
                  ], ProfilingATNSimulator.prototype, "computeReachSet", null);
                  __decorate([
                    Decorators_1.Override
                  ], ProfilingATNSimulator.prototype, "getExistingTargetState", null);
                  __decorate([
                    Decorators_1.Override
                  ], ProfilingATNSimulator.prototype, "computeTargetState", null);
                  __decorate([
                    Decorators_1.Override
                  ], ProfilingATNSimulator.prototype, "evalSemanticContextImpl", null);
                  __decorate([
                    Decorators_1.Override
                  ], ProfilingATNSimulator.prototype, "reportContextSensitivity", null);
                  __decorate([
                    Decorators_1.Override
                  ], ProfilingATNSimulator.prototype, "reportAttemptingFullContext", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull),
                    __param(5, Decorators_1.NotNull),
                    __param(6, Decorators_1.NotNull)
                  ], ProfilingATNSimulator.prototype, "reportAmbiguity", null);
                  exports2.ProfilingATNSimulator = ProfilingATNSimulator;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/RangeTransition.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/RangeTransition.js ***!
                  \******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RangeTransition = void 0;
                  const IntervalSet_1 = __webpack_require__2(
                    /*! ../misc/IntervalSet */
                    "./node_modules/antlr4ts/misc/IntervalSet.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Transition_1 = __webpack_require__2(
                    /*! ./Transition */
                    "./node_modules/antlr4ts/atn/Transition.js"
                  );
                  let RangeTransition = class RangeTransition extends Transition_1.Transition {
                    constructor(target, from, to) {
                      super(target);
                      this.from = from;
                      this.to = to;
                    }
                    get serializationType() {
                      return 2;
                    }
                    get label() {
                      return IntervalSet_1.IntervalSet.of(this.from, this.to);
                    }
                    matches(symbol, minVocabSymbol, maxVocabSymbol) {
                      return symbol >= this.from && symbol <= this.to;
                    }
                    toString() {
                      return "'" + String.fromCodePoint(this.from) + "'..'" + String.fromCodePoint(this.to) + "'";
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], RangeTransition.prototype, "serializationType", null);
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull
                  ], RangeTransition.prototype, "label", null);
                  __decorate([
                    Decorators_1.Override
                  ], RangeTransition.prototype, "matches", null);
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull
                  ], RangeTransition.prototype, "toString", null);
                  RangeTransition = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], RangeTransition);
                  exports2.RangeTransition = RangeTransition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/RuleStartState.js": (
                /*!*****************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/RuleStartState.js ***!
                  \*****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RuleStartState = void 0;
                  const ATNState_1 = __webpack_require__2(
                    /*! ./ATNState */
                    "./node_modules/antlr4ts/atn/ATNState.js"
                  );
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class RuleStartState extends ATNState_1.ATNState {
                    constructor() {
                      super(...arguments);
                      this.isPrecedenceRule = false;
                      this.leftFactored = false;
                    }
                    get stateType() {
                      return ATNStateType_1.ATNStateType.RULE_START;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], RuleStartState.prototype, "stateType", null);
                  exports2.RuleStartState = RuleStartState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/RuleStopState.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/RuleStopState.js ***!
                  \****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RuleStopState = void 0;
                  const ATNState_1 = __webpack_require__2(
                    /*! ./ATNState */
                    "./node_modules/antlr4ts/atn/ATNState.js"
                  );
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class RuleStopState extends ATNState_1.ATNState {
                    get nonStopStateNumber() {
                      return -1;
                    }
                    get stateType() {
                      return ATNStateType_1.ATNStateType.RULE_STOP;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], RuleStopState.prototype, "nonStopStateNumber", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleStopState.prototype, "stateType", null);
                  exports2.RuleStopState = RuleStopState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/RuleTransition.js": (
                /*!*****************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/RuleTransition.js ***!
                  \*****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RuleTransition = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Transition_1 = __webpack_require__2(
                    /*! ./Transition */
                    "./node_modules/antlr4ts/atn/Transition.js"
                  );
                  let RuleTransition = class RuleTransition extends Transition_1.Transition {
                    constructor(ruleStart, ruleIndex, precedence, followState) {
                      super(ruleStart);
                      this.tailCall = false;
                      this.optimizedTailCall = false;
                      this.ruleIndex = ruleIndex;
                      this.precedence = precedence;
                      this.followState = followState;
                    }
                    get serializationType() {
                      return 3;
                    }
                    get isEpsilon() {
                      return true;
                    }
                    matches(symbol, minVocabSymbol, maxVocabSymbol) {
                      return false;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], RuleTransition.prototype, "followState", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTransition.prototype, "serializationType", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTransition.prototype, "isEpsilon", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTransition.prototype, "matches", null);
                  RuleTransition = __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(3, Decorators_1.NotNull)
                  ], RuleTransition);
                  exports2.RuleTransition = RuleTransition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/SemanticContext.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/SemanticContext.js ***!
                  \******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.SemanticContext = void 0;
                  const Array2DHashSet_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashSet */
                    "./node_modules/antlr4ts/misc/Array2DHashSet.js"
                  );
                  const ArrayEqualityComparator_1 = __webpack_require__2(
                    /*! ../misc/ArrayEqualityComparator */
                    "./node_modules/antlr4ts/misc/ArrayEqualityComparator.js"
                  );
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ObjectEqualityComparator_1 = __webpack_require__2(
                    /*! ../misc/ObjectEqualityComparator */
                    "./node_modules/antlr4ts/misc/ObjectEqualityComparator.js"
                  );
                  const Utils = __webpack_require__2(
                    /*! ../misc/Utils */
                    "./node_modules/antlr4ts/misc/Utils.js"
                  );
                  function max6(items) {
                    let result;
                    for (let current of items) {
                      if (result === void 0) {
                        result = current;
                        continue;
                      }
                      let comparison = result.compareTo(current);
                      if (comparison < 0) {
                        result = current;
                      }
                    }
                    return result;
                  }
                  function min6(items) {
                    let result;
                    for (let current of items) {
                      if (result === void 0) {
                        result = current;
                        continue;
                      }
                      let comparison = result.compareTo(current);
                      if (comparison > 0) {
                        result = current;
                      }
                    }
                    return result;
                  }
                  class SemanticContext {
                    /**
                     * The default {@link SemanticContext}, which is semantically equivalent to
                     * a predicate of the form `{true}?`.
                     */
                    static get NONE() {
                      if (SemanticContext._NONE === void 0) {
                        SemanticContext._NONE = new SemanticContext.Predicate();
                      }
                      return SemanticContext._NONE;
                    }
                    /**
                     * Evaluate the precedence predicates for the context and reduce the result.
                     *
                     * @param parser The parser instance.
                     * @param parserCallStack
                     * @returns The simplified semantic context after precedence predicates are
                     * evaluated, which will be one of the following values.
                     *
                     * * {@link #NONE}: if the predicate simplifies to `true` after
                     *   precedence predicates are evaluated.
                     * * `undefined`: if the predicate simplifies to `false` after
                     *   precedence predicates are evaluated.
                     * * `this`: if the semantic context is not changed as a result of
                     *   precedence predicate evaluation.
                     * * A non-`undefined` {@link SemanticContext}: the new simplified
                     *   semantic context after precedence predicates are evaluated.
                     */
                    evalPrecedence(parser, parserCallStack) {
                      return this;
                    }
                    static and(a, b) {
                      if (!a || a === SemanticContext.NONE) {
                        return b;
                      }
                      if (b === SemanticContext.NONE) {
                        return a;
                      }
                      let result = new SemanticContext.AND(a, b);
                      if (result.opnds.length === 1) {
                        return result.opnds[0];
                      }
                      return result;
                    }
                    /**
                     *
                     *  @see ParserATNSimulator#getPredsForAmbigAlts
                     */
                    static or(a, b) {
                      if (!a) {
                        return b;
                      }
                      if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
                        return SemanticContext.NONE;
                      }
                      let result = new SemanticContext.OR(a, b);
                      if (result.opnds.length === 1) {
                        return result.opnds[0];
                      }
                      return result;
                    }
                  }
                  exports2.SemanticContext = SemanticContext;
                  (function(SemanticContext2) {
                    const AND_HASHCODE = 40363613;
                    const OR_HASHCODE = 486279973;
                    function filterPrecedencePredicates(collection) {
                      let result = [];
                      for (let i = 0; i < collection.length; i++) {
                        let context = collection[i];
                        if (context instanceof SemanticContext2.PrecedencePredicate) {
                          result.push(context);
                          collection.splice(i, 1);
                          i--;
                        }
                      }
                      return result;
                    }
                    class Predicate extends SemanticContext2 {
                      constructor(ruleIndex = -1, predIndex = -1, isCtxDependent = false) {
                        super();
                        this.ruleIndex = ruleIndex;
                        this.predIndex = predIndex;
                        this.isCtxDependent = isCtxDependent;
                      }
                      eval(parser, parserCallStack) {
                        let localctx = this.isCtxDependent ? parserCallStack : void 0;
                        return parser.sempred(localctx, this.ruleIndex, this.predIndex);
                      }
                      hashCode() {
                        let hashCode = MurmurHash_1.MurmurHash.initialize();
                        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);
                        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);
                        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
                        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);
                        return hashCode;
                      }
                      equals(obj) {
                        if (!(obj instanceof Predicate)) {
                          return false;
                        }
                        if (this === obj) {
                          return true;
                        }
                        return this.ruleIndex === obj.ruleIndex && this.predIndex === obj.predIndex && this.isCtxDependent === obj.isCtxDependent;
                      }
                      toString() {
                        return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
                      }
                    }
                    __decorate([
                      Decorators_1.Override
                    ], Predicate.prototype, "eval", null);
                    __decorate([
                      Decorators_1.Override
                    ], Predicate.prototype, "hashCode", null);
                    __decorate([
                      Decorators_1.Override
                    ], Predicate.prototype, "equals", null);
                    __decorate([
                      Decorators_1.Override
                    ], Predicate.prototype, "toString", null);
                    SemanticContext2.Predicate = Predicate;
                    class PrecedencePredicate extends SemanticContext2 {
                      constructor(precedence) {
                        super();
                        this.precedence = precedence;
                      }
                      eval(parser, parserCallStack) {
                        return parser.precpred(parserCallStack, this.precedence);
                      }
                      evalPrecedence(parser, parserCallStack) {
                        if (parser.precpred(parserCallStack, this.precedence)) {
                          return SemanticContext2.NONE;
                        } else {
                          return void 0;
                        }
                      }
                      compareTo(o) {
                        return this.precedence - o.precedence;
                      }
                      hashCode() {
                        let hashCode = 1;
                        hashCode = 31 * hashCode + this.precedence;
                        return hashCode;
                      }
                      equals(obj) {
                        if (!(obj instanceof PrecedencePredicate)) {
                          return false;
                        }
                        if (this === obj) {
                          return true;
                        }
                        return this.precedence === obj.precedence;
                      }
                      toString() {
                        return "{" + this.precedence + ">=prec}?";
                      }
                    }
                    __decorate([
                      Decorators_1.Override
                    ], PrecedencePredicate.prototype, "eval", null);
                    __decorate([
                      Decorators_1.Override
                    ], PrecedencePredicate.prototype, "evalPrecedence", null);
                    __decorate([
                      Decorators_1.Override
                    ], PrecedencePredicate.prototype, "compareTo", null);
                    __decorate([
                      Decorators_1.Override
                    ], PrecedencePredicate.prototype, "hashCode", null);
                    __decorate([
                      Decorators_1.Override
                    ], PrecedencePredicate.prototype, "equals", null);
                    __decorate([
                      Decorators_1.Override
                    ], PrecedencePredicate.prototype, "toString", null);
                    SemanticContext2.PrecedencePredicate = PrecedencePredicate;
                    class Operator2 extends SemanticContext2 {
                    }
                    SemanticContext2.Operator = Operator2;
                    let AND = class AND2 extends Operator2 {
                      constructor(a, b) {
                        super();
                        let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
                        if (a instanceof AND2) {
                          operands.addAll(a.opnds);
                        } else {
                          operands.add(a);
                        }
                        if (b instanceof AND2) {
                          operands.addAll(b.opnds);
                        } else {
                          operands.add(b);
                        }
                        this.opnds = operands.toArray();
                        let precedencePredicates = filterPrecedencePredicates(this.opnds);
                        let reduced = min6(precedencePredicates);
                        if (reduced) {
                          this.opnds.push(reduced);
                        }
                      }
                      get operands() {
                        return this.opnds;
                      }
                      equals(obj) {
                        if (this === obj) {
                          return true;
                        }
                        if (!(obj instanceof AND2)) {
                          return false;
                        }
                        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
                      }
                      hashCode() {
                        return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);
                      }
                      /**
                       * {@inheritDoc}
                       *
                       * The evaluation of predicates by this context is short-circuiting, but
                       * unordered.
                       */
                      eval(parser, parserCallStack) {
                        for (let opnd of this.opnds) {
                          if (!opnd.eval(parser, parserCallStack)) {
                            return false;
                          }
                        }
                        return true;
                      }
                      evalPrecedence(parser, parserCallStack) {
                        let differs = false;
                        let operands = [];
                        for (let context of this.opnds) {
                          let evaluated = context.evalPrecedence(parser, parserCallStack);
                          differs = differs || evaluated !== context;
                          if (evaluated == null) {
                            return void 0;
                          } else if (evaluated !== SemanticContext2.NONE) {
                            operands.push(evaluated);
                          }
                        }
                        if (!differs) {
                          return this;
                        }
                        if (operands.length === 0) {
                          return SemanticContext2.NONE;
                        }
                        let result = operands[0];
                        for (let i = 1; i < operands.length; i++) {
                          result = SemanticContext2.and(result, operands[i]);
                        }
                        return result;
                      }
                      toString() {
                        return Utils.join(this.opnds, "&&");
                      }
                    };
                    __decorate([
                      Decorators_1.Override
                    ], AND.prototype, "operands", null);
                    __decorate([
                      Decorators_1.Override
                    ], AND.prototype, "equals", null);
                    __decorate([
                      Decorators_1.Override
                    ], AND.prototype, "hashCode", null);
                    __decorate([
                      Decorators_1.Override
                    ], AND.prototype, "eval", null);
                    __decorate([
                      Decorators_1.Override
                    ], AND.prototype, "evalPrecedence", null);
                    __decorate([
                      Decorators_1.Override
                    ], AND.prototype, "toString", null);
                    AND = __decorate([
                      __param(0, Decorators_1.NotNull),
                      __param(1, Decorators_1.NotNull)
                    ], AND);
                    SemanticContext2.AND = AND;
                    let OR = class OR2 extends Operator2 {
                      constructor(a, b) {
                        super();
                        let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
                        if (a instanceof OR2) {
                          operands.addAll(a.opnds);
                        } else {
                          operands.add(a);
                        }
                        if (b instanceof OR2) {
                          operands.addAll(b.opnds);
                        } else {
                          operands.add(b);
                        }
                        this.opnds = operands.toArray();
                        let precedencePredicates = filterPrecedencePredicates(this.opnds);
                        let reduced = max6(precedencePredicates);
                        if (reduced) {
                          this.opnds.push(reduced);
                        }
                      }
                      get operands() {
                        return this.opnds;
                      }
                      equals(obj) {
                        if (this === obj) {
                          return true;
                        }
                        if (!(obj instanceof OR2)) {
                          return false;
                        }
                        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
                      }
                      hashCode() {
                        return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);
                      }
                      /**
                       * {@inheritDoc}
                       *
                       * The evaluation of predicates by this context is short-circuiting, but
                       * unordered.
                       */
                      eval(parser, parserCallStack) {
                        for (let opnd of this.opnds) {
                          if (opnd.eval(parser, parserCallStack)) {
                            return true;
                          }
                        }
                        return false;
                      }
                      evalPrecedence(parser, parserCallStack) {
                        let differs = false;
                        let operands = [];
                        for (let context of this.opnds) {
                          let evaluated = context.evalPrecedence(parser, parserCallStack);
                          differs = differs || evaluated !== context;
                          if (evaluated === SemanticContext2.NONE) {
                            return SemanticContext2.NONE;
                          } else if (evaluated) {
                            operands.push(evaluated);
                          }
                        }
                        if (!differs) {
                          return this;
                        }
                        if (operands.length === 0) {
                          return void 0;
                        }
                        let result = operands[0];
                        for (let i = 1; i < operands.length; i++) {
                          result = SemanticContext2.or(result, operands[i]);
                        }
                        return result;
                      }
                      toString() {
                        return Utils.join(this.opnds, "||");
                      }
                    };
                    __decorate([
                      Decorators_1.Override
                    ], OR.prototype, "operands", null);
                    __decorate([
                      Decorators_1.Override
                    ], OR.prototype, "equals", null);
                    __decorate([
                      Decorators_1.Override
                    ], OR.prototype, "hashCode", null);
                    __decorate([
                      Decorators_1.Override
                    ], OR.prototype, "eval", null);
                    __decorate([
                      Decorators_1.Override
                    ], OR.prototype, "evalPrecedence", null);
                    __decorate([
                      Decorators_1.Override
                    ], OR.prototype, "toString", null);
                    OR = __decorate([
                      __param(0, Decorators_1.NotNull),
                      __param(1, Decorators_1.NotNull)
                    ], OR);
                    SemanticContext2.OR = OR;
                  })(SemanticContext = exports2.SemanticContext || (exports2.SemanticContext = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/SetTransition.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/SetTransition.js ***!
                  \****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.SetTransition = void 0;
                  const IntervalSet_1 = __webpack_require__2(
                    /*! ../misc/IntervalSet */
                    "./node_modules/antlr4ts/misc/IntervalSet.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const Transition_1 = __webpack_require__2(
                    /*! ./Transition */
                    "./node_modules/antlr4ts/atn/Transition.js"
                  );
                  let SetTransition = class SetTransition extends Transition_1.Transition {
                    // TODO (sam): should we really allow undefined here?
                    constructor(target, set2) {
                      super(target);
                      if (set2 == null) {
                        set2 = IntervalSet_1.IntervalSet.of(Token_1.Token.INVALID_TYPE);
                      }
                      this.set = set2;
                    }
                    get serializationType() {
                      return 7;
                    }
                    get label() {
                      return this.set;
                    }
                    matches(symbol, minVocabSymbol, maxVocabSymbol) {
                      return this.set.contains(symbol);
                    }
                    toString() {
                      return this.set.toString();
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], SetTransition.prototype, "set", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], SetTransition.prototype, "serializationType", null);
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull
                  ], SetTransition.prototype, "label", null);
                  __decorate([
                    Decorators_1.Override
                  ], SetTransition.prototype, "matches", null);
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull
                  ], SetTransition.prototype, "toString", null);
                  SetTransition = __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.Nullable)
                  ], SetTransition);
                  exports2.SetTransition = SetTransition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/SimulatorState.js": (
                /*!*****************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/SimulatorState.js ***!
                  \*****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.SimulatorState = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ParserRuleContext_1 = __webpack_require__2(
                    /*! ../ParserRuleContext */
                    "./node_modules/antlr4ts/ParserRuleContext.js"
                  );
                  let SimulatorState = class SimulatorState {
                    constructor(outerContext, s0, useContext, remainingOuterContext) {
                      this.outerContext = outerContext != null ? outerContext : ParserRuleContext_1.ParserRuleContext.emptyContext();
                      this.s0 = s0;
                      this.useContext = useContext;
                      this.remainingOuterContext = remainingOuterContext;
                    }
                  };
                  SimulatorState = __decorate([
                    __param(1, Decorators_1.NotNull)
                  ], SimulatorState);
                  exports2.SimulatorState = SimulatorState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/StarBlockStartState.js": (
                /*!**********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/StarBlockStartState.js ***!
                  \**********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.StarBlockStartState = void 0;
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const BlockStartState_1 = __webpack_require__2(
                    /*! ./BlockStartState */
                    "./node_modules/antlr4ts/atn/BlockStartState.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class StarBlockStartState extends BlockStartState_1.BlockStartState {
                    get stateType() {
                      return ATNStateType_1.ATNStateType.STAR_BLOCK_START;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], StarBlockStartState.prototype, "stateType", null);
                  exports2.StarBlockStartState = StarBlockStartState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/StarLoopEntryState.js": (
                /*!*********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/StarLoopEntryState.js ***!
                  \*********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.StarLoopEntryState = void 0;
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const BitSet_1 = __webpack_require__2(
                    /*! ../misc/BitSet */
                    "./node_modules/antlr4ts/misc/BitSet.js"
                  );
                  const DecisionState_1 = __webpack_require__2(
                    /*! ./DecisionState */
                    "./node_modules/antlr4ts/atn/DecisionState.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class StarLoopEntryState extends DecisionState_1.DecisionState {
                    constructor() {
                      super(...arguments);
                      this.precedenceRuleDecision = false;
                      this.precedenceLoopbackStates = new BitSet_1.BitSet();
                    }
                    get stateType() {
                      return ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], StarLoopEntryState.prototype, "stateType", null);
                  exports2.StarLoopEntryState = StarLoopEntryState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/StarLoopbackState.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/StarLoopbackState.js ***!
                  \********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.StarLoopbackState = void 0;
                  const ATNState_1 = __webpack_require__2(
                    /*! ./ATNState */
                    "./node_modules/antlr4ts/atn/ATNState.js"
                  );
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class StarLoopbackState extends ATNState_1.ATNState {
                    get loopEntryState() {
                      return this.transition(0).target;
                    }
                    get stateType() {
                      return ATNStateType_1.ATNStateType.STAR_LOOP_BACK;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], StarLoopbackState.prototype, "stateType", null);
                  exports2.StarLoopbackState = StarLoopbackState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/TokensStartState.js": (
                /*!*******************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/TokensStartState.js ***!
                  \*******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.TokensStartState = void 0;
                  const ATNStateType_1 = __webpack_require__2(
                    /*! ./ATNStateType */
                    "./node_modules/antlr4ts/atn/ATNStateType.js"
                  );
                  const DecisionState_1 = __webpack_require__2(
                    /*! ./DecisionState */
                    "./node_modules/antlr4ts/atn/DecisionState.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class TokensStartState extends DecisionState_1.DecisionState {
                    get stateType() {
                      return ATNStateType_1.ATNStateType.TOKEN_START;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], TokensStartState.prototype, "stateType", null);
                  exports2.TokensStartState = TokensStartState;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/Transition.js": (
                /*!*************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/Transition.js ***!
                  \*************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Transition = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let Transition = class Transition {
                    constructor(target) {
                      if (target == null) {
                        throw new Error("target cannot be null.");
                      }
                      this.target = target;
                    }
                    /**
                     * Determines if the transition is an "epsilon" transition.
                     *
                     * The default implementation returns `false`.
                     *
                     * @returns `true` if traversing this transition in the ATN does not
                     * consume an input symbol; otherwise, `false` if traversing this
                     * transition consumes (matches) an input symbol.
                     */
                    get isEpsilon() {
                      return false;
                    }
                    get label() {
                      return void 0;
                    }
                  };
                  Transition.serializationNames = [
                    "INVALID",
                    "EPSILON",
                    "RANGE",
                    "RULE",
                    "PREDICATE",
                    "ATOM",
                    "ACTION",
                    "SET",
                    "NOT_SET",
                    "WILDCARD",
                    "PRECEDENCE"
                  ];
                  __decorate([
                    Decorators_1.NotNull
                  ], Transition.prototype, "target", void 0);
                  Transition = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], Transition);
                  exports2.Transition = Transition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/atn/WildcardTransition.js": (
                /*!*********************************************************!*\
                  !*** ./node_modules/antlr4ts/atn/WildcardTransition.js ***!
                  \*********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.WildcardTransition = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Transition_1 = __webpack_require__2(
                    /*! ./Transition */
                    "./node_modules/antlr4ts/atn/Transition.js"
                  );
                  let WildcardTransition = class WildcardTransition extends Transition_1.Transition {
                    constructor(target) {
                      super(target);
                    }
                    get serializationType() {
                      return 9;
                    }
                    matches(symbol, minVocabSymbol, maxVocabSymbol) {
                      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
                    }
                    toString() {
                      return ".";
                    }
                  };
                  __decorate([
                    Decorators_1.Override
                  ], WildcardTransition.prototype, "serializationType", null);
                  __decorate([
                    Decorators_1.Override
                  ], WildcardTransition.prototype, "matches", null);
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull
                  ], WildcardTransition.prototype, "toString", null);
                  WildcardTransition = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], WildcardTransition);
                  exports2.WildcardTransition = WildcardTransition;
                }
              ),
              /***/
              "./node_modules/antlr4ts/dfa/AcceptStateInfo.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/dfa/AcceptStateInfo.js ***!
                  \******************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.AcceptStateInfo = void 0;
                  class AcceptStateInfo {
                    constructor(prediction, lexerActionExecutor) {
                      this._prediction = prediction;
                      this._lexerActionExecutor = lexerActionExecutor;
                    }
                    /**
                     * Gets the prediction made by this accept state. Note that this value
                     * assumes the predicates, if any, in the {@link DFAState} evaluate to
                     * `true`. If predicate evaluation is enabled, the final prediction of
                     * the accept state will be determined by the result of predicate
                     * evaluation.
                     */
                    get prediction() {
                      return this._prediction;
                    }
                    /**
                     * Gets the {@link LexerActionExecutor} which can be used to execute actions
                     * and/or commands after the lexer matches a token.
                     */
                    get lexerActionExecutor() {
                      return this._lexerActionExecutor;
                    }
                  }
                  exports2.AcceptStateInfo = AcceptStateInfo;
                }
              ),
              /***/
              "./node_modules/antlr4ts/dfa/DFA.js": (
                /*!******************************************!*\
                  !*** ./node_modules/antlr4ts/dfa/DFA.js ***!
                  \******************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.DFA = void 0;
                  const Array2DHashSet_1 = __webpack_require__2(
                    /*! ../misc/Array2DHashSet */
                    "./node_modules/antlr4ts/misc/Array2DHashSet.js"
                  );
                  const ATNConfigSet_1 = __webpack_require__2(
                    /*! ../atn/ATNConfigSet */
                    "./node_modules/antlr4ts/atn/ATNConfigSet.js"
                  );
                  const DFASerializer_1 = __webpack_require__2(
                    /*! ./DFASerializer */
                    "./node_modules/antlr4ts/dfa/DFASerializer.js"
                  );
                  const DFAState_1 = __webpack_require__2(
                    /*! ./DFAState */
                    "./node_modules/antlr4ts/dfa/DFAState.js"
                  );
                  const LexerDFASerializer_1 = __webpack_require__2(
                    /*! ./LexerDFASerializer */
                    "./node_modules/antlr4ts/dfa/LexerDFASerializer.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ObjectEqualityComparator_1 = __webpack_require__2(
                    /*! ../misc/ObjectEqualityComparator */
                    "./node_modules/antlr4ts/misc/ObjectEqualityComparator.js"
                  );
                  const StarLoopEntryState_1 = __webpack_require__2(
                    /*! ../atn/StarLoopEntryState */
                    "./node_modules/antlr4ts/atn/StarLoopEntryState.js"
                  );
                  const VocabularyImpl_1 = __webpack_require__2(
                    /*! ../VocabularyImpl */
                    "./node_modules/antlr4ts/VocabularyImpl.js"
                  );
                  let DFA = class DFA {
                    constructor(atnStartState, decision = 0) {
                      this.states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
                      this.nextStateNumber = 0;
                      if (!atnStartState.atn) {
                        throw new Error("The ATNState must be associated with an ATN");
                      }
                      this.atnStartState = atnStartState;
                      this.atn = atnStartState.atn;
                      this.decision = decision;
                      let isPrecedenceDfa = false;
                      if (atnStartState instanceof StarLoopEntryState_1.StarLoopEntryState) {
                        if (atnStartState.precedenceRuleDecision) {
                          isPrecedenceDfa = true;
                          this.s0 = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
                          this.s0full = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
                        }
                      }
                      this.precedenceDfa = isPrecedenceDfa;
                    }
                    /**
                     * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
                     * start state {@link #s0} which is not stored in {@link #states}. The
                     * {@link DFAState#edges} array for this start state contains outgoing edges
                     * supplying individual start states corresponding to specific precedence
                     * values.
                     *
                     * @returns `true` if this is a precedence DFA; otherwise,
                     * `false`.
                     * @see Parser.precedence
                     */
                    get isPrecedenceDfa() {
                      return this.precedenceDfa;
                    }
                    /**
                     * Get the start state for a specific precedence value.
                     *
                     * @param precedence The current precedence.
                     * @returns The start state corresponding to the specified precedence, or
                     * `undefined` if no start state exists for the specified precedence.
                     *
                     * @ if this is not a precedence DFA.
                     * @see `isPrecedenceDfa`
                     */
                    getPrecedenceStartState(precedence, fullContext) {
                      if (!this.isPrecedenceDfa) {
                        throw new Error("Only precedence DFAs may contain a precedence start state.");
                      }
                      if (fullContext) {
                        return this.s0full.getTarget(precedence);
                      } else {
                        return this.s0.getTarget(precedence);
                      }
                    }
                    /**
                     * Set the start state for a specific precedence value.
                     *
                     * @param precedence The current precedence.
                     * @param startState The start state corresponding to the specified
                     * precedence.
                     *
                     * @ if this is not a precedence DFA.
                     * @see `isPrecedenceDfa`
                     */
                    setPrecedenceStartState(precedence, fullContext, startState) {
                      if (!this.isPrecedenceDfa) {
                        throw new Error("Only precedence DFAs may contain a precedence start state.");
                      }
                      if (precedence < 0) {
                        return;
                      }
                      if (fullContext) {
                        this.s0full.setTarget(precedence, startState);
                      } else {
                        this.s0.setTarget(precedence, startState);
                      }
                    }
                    get isEmpty() {
                      if (this.isPrecedenceDfa) {
                        return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0;
                      }
                      return this.s0 == null && this.s0full == null;
                    }
                    get isContextSensitive() {
                      if (this.isPrecedenceDfa) {
                        return this.s0full.getEdgeMap().size > 0;
                      }
                      return this.s0full != null;
                    }
                    addState(state) {
                      state.stateNumber = this.nextStateNumber++;
                      return this.states.getOrAdd(state);
                    }
                    toString(vocabulary, ruleNames) {
                      if (!vocabulary) {
                        vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
                      }
                      if (!this.s0) {
                        return "";
                      }
                      let serializer;
                      if (ruleNames) {
                        serializer = new DFASerializer_1.DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);
                      } else {
                        serializer = new DFASerializer_1.DFASerializer(this, vocabulary);
                      }
                      return serializer.toString();
                    }
                    toLexerString() {
                      if (!this.s0) {
                        return "";
                      }
                      let serializer = new LexerDFASerializer_1.LexerDFASerializer(this);
                      return serializer.toString();
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], DFA.prototype, "states", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], DFA.prototype, "atnStartState", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], DFA.prototype, "atn", void 0);
                  DFA = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], DFA);
                  exports2.DFA = DFA;
                }
              ),
              /***/
              "./node_modules/antlr4ts/dfa/DFASerializer.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/dfa/DFASerializer.js ***!
                  \****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.DFASerializer = void 0;
                  const ATNSimulator_1 = __webpack_require__2(
                    /*! ../atn/ATNSimulator */
                    "./node_modules/antlr4ts/atn/ATNSimulator.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const PredictionContext_1 = __webpack_require__2(
                    /*! ../atn/PredictionContext */
                    "./node_modules/antlr4ts/atn/PredictionContext.js"
                  );
                  const Recognizer_1 = __webpack_require__2(
                    /*! ../Recognizer */
                    "./node_modules/antlr4ts/Recognizer.js"
                  );
                  const VocabularyImpl_1 = __webpack_require__2(
                    /*! ../VocabularyImpl */
                    "./node_modules/antlr4ts/VocabularyImpl.js"
                  );
                  class DFASerializer {
                    constructor(dfa, vocabulary, ruleNames, atn) {
                      if (vocabulary instanceof Recognizer_1.Recognizer) {
                        ruleNames = vocabulary.ruleNames;
                        atn = vocabulary.atn;
                        vocabulary = vocabulary.vocabulary;
                      } else if (!vocabulary) {
                        vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
                      }
                      this.dfa = dfa;
                      this.vocabulary = vocabulary;
                      this.ruleNames = ruleNames;
                      this.atn = atn;
                    }
                    toString() {
                      if (!this.dfa.s0) {
                        return "";
                      }
                      let buf = "";
                      if (this.dfa.states) {
                        let states = new Array(...this.dfa.states.toArray());
                        states.sort((o1, o2) => o1.stateNumber - o2.stateNumber);
                        for (let s of states) {
                          let edges = s.getEdgeMap();
                          let edgeKeys = [...edges.keys()].sort((a, b) => a - b);
                          let contextEdges = s.getContextEdgeMap();
                          let contextEdgeKeys = [...contextEdges.keys()].sort((a, b) => a - b);
                          for (let entry of edgeKeys) {
                            let value = edges.get(entry);
                            if ((value == null || value === ATNSimulator_1.ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {
                              continue;
                            }
                            let contextSymbol = false;
                            buf += this.getStateString(s) + "-" + this.getEdgeLabel(entry) + "->";
                            if (s.isContextSymbol(entry)) {
                              buf += "!";
                              contextSymbol = true;
                            }
                            let t = value;
                            if (t && t.stateNumber !== ATNSimulator_1.ATNSimulator.ERROR.stateNumber) {
                              buf += this.getStateString(t) + "\n";
                            } else if (contextSymbol) {
                              buf += "ctx\n";
                            }
                          }
                          if (s.isContextSensitive) {
                            for (let entry of contextEdgeKeys) {
                              buf += this.getStateString(s) + "-" + this.getContextLabel(entry) + "->" + this.getStateString(contextEdges.get(entry)) + "\n";
                            }
                          }
                        }
                      }
                      let output = buf;
                      if (output.length === 0) {
                        return "";
                      }
                      return output;
                    }
                    getContextLabel(i) {
                      if (i === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                        return "ctx:EMPTY_FULL";
                      } else if (i === PredictionContext_1.PredictionContext.EMPTY_LOCAL_STATE_KEY) {
                        return "ctx:EMPTY_LOCAL";
                      }
                      if (this.atn && i > 0 && i <= this.atn.states.length) {
                        let state = this.atn.states[i];
                        let ruleIndex = state.ruleIndex;
                        if (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {
                          return "ctx:" + String(i) + "(" + this.ruleNames[ruleIndex] + ")";
                        }
                      }
                      return "ctx:" + String(i);
                    }
                    getEdgeLabel(i) {
                      return this.vocabulary.getDisplayName(i);
                    }
                    getStateString(s) {
                      if (s === ATNSimulator_1.ATNSimulator.ERROR) {
                        return "ERROR";
                      }
                      let n = s.stateNumber;
                      let stateStr = "s" + n;
                      if (s.isAcceptState) {
                        if (s.predicates) {
                          stateStr = ":s" + n + "=>" + s.predicates;
                        } else {
                          stateStr = ":s" + n + "=>" + s.prediction;
                        }
                      }
                      if (s.isContextSensitive) {
                        stateStr += "*";
                        for (let config of s.configs) {
                          if (config.reachesIntoOuterContext) {
                            stateStr += "*";
                            break;
                          }
                        }
                      }
                      return stateStr;
                    }
                  }
                  __decorate([
                    Decorators_1.NotNull
                  ], DFASerializer.prototype, "dfa", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], DFASerializer.prototype, "vocabulary", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], DFASerializer.prototype, "toString", null);
                  exports2.DFASerializer = DFASerializer;
                }
              ),
              /***/
              "./node_modules/antlr4ts/dfa/DFAState.js": (
                /*!***********************************************!*\
                  !*** ./node_modules/antlr4ts/dfa/DFAState.js ***!
                  \***********************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.DFAState = void 0;
                  const ATN_1 = __webpack_require__2(
                    /*! ../atn/ATN */
                    "./node_modules/antlr4ts/atn/ATN.js"
                  );
                  const BitSet_1 = __webpack_require__2(
                    /*! ../misc/BitSet */
                    "./node_modules/antlr4ts/misc/BitSet.js"
                  );
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ../misc/MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const PredictionContext_1 = __webpack_require__2(
                    /*! ../atn/PredictionContext */
                    "./node_modules/antlr4ts/atn/PredictionContext.js"
                  );
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  class DFAState {
                    /**
                     * Constructs a new `DFAState`.
                     *
                     * @param configs The set of ATN configurations defining this state.
                     */
                    constructor(configs) {
                      this.stateNumber = -1;
                      this.configs = configs;
                      this.edges = /* @__PURE__ */ new Map();
                      this.contextEdges = /* @__PURE__ */ new Map();
                    }
                    get isContextSensitive() {
                      return !!this.contextSymbols;
                    }
                    isContextSymbol(symbol) {
                      if (!this.isContextSensitive) {
                        return false;
                      }
                      return this.contextSymbols.get(symbol);
                    }
                    setContextSymbol(symbol) {
                      assert(this.isContextSensitive);
                      this.contextSymbols.set(symbol);
                    }
                    setContextSensitive(atn) {
                      assert(!this.configs.isOutermostConfigSet);
                      if (this.isContextSensitive) {
                        return;
                      }
                      if (!this.contextSymbols) {
                        this.contextSymbols = new BitSet_1.BitSet();
                      }
                    }
                    get acceptStateInfo() {
                      return this._acceptStateInfo;
                    }
                    set acceptStateInfo(acceptStateInfo) {
                      this._acceptStateInfo = acceptStateInfo;
                    }
                    get isAcceptState() {
                      return !!this._acceptStateInfo;
                    }
                    get prediction() {
                      if (!this._acceptStateInfo) {
                        return ATN_1.ATN.INVALID_ALT_NUMBER;
                      }
                      return this._acceptStateInfo.prediction;
                    }
                    get lexerActionExecutor() {
                      if (!this._acceptStateInfo) {
                        return void 0;
                      }
                      return this._acceptStateInfo.lexerActionExecutor;
                    }
                    getTarget(symbol) {
                      return this.edges.get(symbol);
                    }
                    setTarget(symbol, target) {
                      this.edges.set(symbol, target);
                    }
                    getEdgeMap() {
                      return this.edges;
                    }
                    getContextTarget(invokingState) {
                      if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                        invokingState = -1;
                      }
                      return this.contextEdges.get(invokingState);
                    }
                    setContextTarget(invokingState, target) {
                      if (!this.isContextSensitive) {
                        throw new Error("The state is not context sensitive.");
                      }
                      if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
                        invokingState = -1;
                      }
                      this.contextEdges.set(invokingState, target);
                    }
                    getContextEdgeMap() {
                      let map2 = new Map(this.contextEdges);
                      let existing = map2.get(-1);
                      if (existing !== void 0) {
                        if (map2.size === 1) {
                          let result = /* @__PURE__ */ new Map();
                          result.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
                          return result;
                        } else {
                          map2.delete(-1);
                          map2.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
                        }
                      }
                      return map2;
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize(7);
                      hash = MurmurHash_1.MurmurHash.update(hash, this.configs.hashCode());
                      hash = MurmurHash_1.MurmurHash.finish(hash, 1);
                      return hash;
                    }
                    /**
                     * Two {@link DFAState} instances are equal if their ATN configuration sets
                     * are the same. This method is used to see if a state already exists.
                     *
                     * Because the number of alternatives and number of ATN configurations are
                     * finite, there is a finite number of DFA states that can be processed.
                     * This is necessary to show that the algorithm terminates.
                     *
                     * Cannot test the DFA state numbers here because in
                     * {@link ParserATNSimulator#addDFAState} we need to know if any other state
                     * exists that has this exact set of ATN configurations. The
                     * {@link #stateNumber} is irrelevant.
                     */
                    equals(o) {
                      if (this === o) {
                        return true;
                      }
                      if (!(o instanceof DFAState)) {
                        return false;
                      }
                      let other = o;
                      let sameSet = this.configs.equals(other.configs);
                      return sameSet;
                    }
                    toString() {
                      let buf = "";
                      buf += this.stateNumber + ":" + this.configs;
                      if (this.isAcceptState) {
                        buf += "=>";
                        if (this.predicates) {
                          buf += this.predicates;
                        } else {
                          buf += this.prediction;
                        }
                      }
                      return buf.toString();
                    }
                  }
                  __decorate([
                    Decorators_1.NotNull
                  ], DFAState.prototype, "configs", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], DFAState.prototype, "edges", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], DFAState.prototype, "contextEdges", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], DFAState.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], DFAState.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], DFAState.prototype, "toString", null);
                  exports2.DFAState = DFAState;
                  (function(DFAState2) {
                    let PredPrediction = class PredPrediction {
                      constructor(pred, alt) {
                        this.alt = alt;
                        this.pred = pred;
                      }
                      toString() {
                        return "(" + this.pred + ", " + this.alt + ")";
                      }
                    };
                    __decorate([
                      Decorators_1.NotNull
                    ], PredPrediction.prototype, "pred", void 0);
                    __decorate([
                      Decorators_1.Override
                    ], PredPrediction.prototype, "toString", null);
                    PredPrediction = __decorate([
                      __param(0, Decorators_1.NotNull)
                    ], PredPrediction);
                    DFAState2.PredPrediction = PredPrediction;
                  })(DFAState = exports2.DFAState || (exports2.DFAState = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/dfa/LexerDFASerializer.js": (
                /*!*********************************************************!*\
                  !*** ./node_modules/antlr4ts/dfa/LexerDFASerializer.js ***!
                  \*********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.LexerDFASerializer = void 0;
                  const DFASerializer_1 = __webpack_require__2(
                    /*! ./DFASerializer */
                    "./node_modules/antlr4ts/dfa/DFASerializer.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const VocabularyImpl_1 = __webpack_require__2(
                    /*! ../VocabularyImpl */
                    "./node_modules/antlr4ts/VocabularyImpl.js"
                  );
                  let LexerDFASerializer = class LexerDFASerializer extends DFASerializer_1.DFASerializer {
                    constructor(dfa) {
                      super(dfa, VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY);
                    }
                    getEdgeLabel(i) {
                      return "'" + String.fromCodePoint(i) + "'";
                    }
                  };
                  __decorate([
                    Decorators_1.Override,
                    Decorators_1.NotNull
                  ], LexerDFASerializer.prototype, "getEdgeLabel", null);
                  LexerDFASerializer = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], LexerDFASerializer);
                  exports2.LexerDFASerializer = LexerDFASerializer;
                }
              ),
              /***/
              "./node_modules/antlr4ts/index.js": (
                /*!****************************************!*\
                  !*** ./node_modules/antlr4ts/index.js ***!
                  \****************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === void 0) k2 = k;
                    Object.defineProperty(o, k2, { enumerable: true, get: function() {
                      return m[k];
                    } });
                  } : function(o, m, k, k2) {
                    if (k2 === void 0) k2 = k;
                    o[k2] = m[k];
                  });
                  var __exportStar = this && this.__exportStar || function(m, exports3) {
                    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  __exportStar(__webpack_require__2(
                    /*! ./ANTLRErrorListener */
                    "./node_modules/antlr4ts/ANTLRErrorListener.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./ANTLRErrorStrategy */
                    "./node_modules/antlr4ts/ANTLRErrorStrategy.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./ANTLRInputStream */
                    "./node_modules/antlr4ts/ANTLRInputStream.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./BailErrorStrategy */
                    "./node_modules/antlr4ts/BailErrorStrategy.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./BufferedTokenStream */
                    "./node_modules/antlr4ts/BufferedTokenStream.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./CharStream */
                    "./node_modules/antlr4ts/CharStream.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./CharStreams */
                    "./node_modules/antlr4ts/CharStreams.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./CodePointBuffer */
                    "./node_modules/antlr4ts/CodePointBuffer.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./CodePointCharStream */
                    "./node_modules/antlr4ts/CodePointCharStream.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./CommonToken */
                    "./node_modules/antlr4ts/CommonToken.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./CommonTokenFactory */
                    "./node_modules/antlr4ts/CommonTokenFactory.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./CommonTokenStream */
                    "./node_modules/antlr4ts/CommonTokenStream.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./ConsoleErrorListener */
                    "./node_modules/antlr4ts/ConsoleErrorListener.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./DefaultErrorStrategy */
                    "./node_modules/antlr4ts/DefaultErrorStrategy.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./Dependents */
                    "./node_modules/antlr4ts/Dependents.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./DiagnosticErrorListener */
                    "./node_modules/antlr4ts/DiagnosticErrorListener.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./FailedPredicateException */
                    "./node_modules/antlr4ts/FailedPredicateException.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./InputMismatchException */
                    "./node_modules/antlr4ts/InputMismatchException.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./InterpreterRuleContext */
                    "./node_modules/antlr4ts/InterpreterRuleContext.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./IntStream */
                    "./node_modules/antlr4ts/IntStream.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./Lexer */
                    "./node_modules/antlr4ts/Lexer.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./LexerInterpreter */
                    "./node_modules/antlr4ts/LexerInterpreter.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./LexerNoViableAltException */
                    "./node_modules/antlr4ts/LexerNoViableAltException.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./ListTokenSource */
                    "./node_modules/antlr4ts/ListTokenSource.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./NoViableAltException */
                    "./node_modules/antlr4ts/NoViableAltException.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./Parser */
                    "./node_modules/antlr4ts/Parser.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./ParserErrorListener */
                    "./node_modules/antlr4ts/ParserErrorListener.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./ParserInterpreter */
                    "./node_modules/antlr4ts/ParserInterpreter.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./ParserRuleContext */
                    "./node_modules/antlr4ts/ParserRuleContext.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./ProxyErrorListener */
                    "./node_modules/antlr4ts/ProxyErrorListener.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./ProxyParserErrorListener */
                    "./node_modules/antlr4ts/ProxyParserErrorListener.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./RecognitionException */
                    "./node_modules/antlr4ts/RecognitionException.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./Recognizer */
                    "./node_modules/antlr4ts/Recognizer.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./RuleContext */
                    "./node_modules/antlr4ts/RuleContext.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./RuleContextWithAltNum */
                    "./node_modules/antlr4ts/RuleContextWithAltNum.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./RuleDependency */
                    "./node_modules/antlr4ts/RuleDependency.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./RuleVersion */
                    "./node_modules/antlr4ts/RuleVersion.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./Token */
                    "./node_modules/antlr4ts/Token.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./TokenFactory */
                    "./node_modules/antlr4ts/TokenFactory.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./TokenSource */
                    "./node_modules/antlr4ts/TokenSource.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./TokenStream */
                    "./node_modules/antlr4ts/TokenStream.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./TokenStreamRewriter */
                    "./node_modules/antlr4ts/TokenStreamRewriter.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./Vocabulary */
                    "./node_modules/antlr4ts/Vocabulary.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./VocabularyImpl */
                    "./node_modules/antlr4ts/VocabularyImpl.js"
                  ), exports2);
                  __exportStar(__webpack_require__2(
                    /*! ./WritableToken */
                    "./node_modules/antlr4ts/WritableToken.js"
                  ), exports2);
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/Array2DHashMap.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/Array2DHashMap.js ***!
                  \******************************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Array2DHashMap = void 0;
                  const Array2DHashSet_1 = __webpack_require__2(
                    /*! ./Array2DHashSet */
                    "./node_modules/antlr4ts/misc/Array2DHashSet.js"
                  );
                  class MapKeyEqualityComparator {
                    constructor(keyComparator) {
                      this.keyComparator = keyComparator;
                    }
                    hashCode(obj) {
                      return this.keyComparator.hashCode(obj.key);
                    }
                    equals(a, b) {
                      return this.keyComparator.equals(a.key, b.key);
                    }
                  }
                  class Array2DHashMap {
                    constructor(keyComparer) {
                      if (keyComparer instanceof Array2DHashMap) {
                        this.backingStore = new Array2DHashSet_1.Array2DHashSet(keyComparer.backingStore);
                      } else {
                        this.backingStore = new Array2DHashSet_1.Array2DHashSet(new MapKeyEqualityComparator(keyComparer));
                      }
                    }
                    clear() {
                      this.backingStore.clear();
                    }
                    containsKey(key) {
                      return this.backingStore.contains({ key });
                    }
                    get(key) {
                      let bucket = this.backingStore.get({ key });
                      if (!bucket) {
                        return void 0;
                      }
                      return bucket.value;
                    }
                    get isEmpty() {
                      return this.backingStore.isEmpty;
                    }
                    put(key, value) {
                      let element = this.backingStore.get({ key, value });
                      let result;
                      if (!element) {
                        this.backingStore.add({ key, value });
                      } else {
                        result = element.value;
                        element.value = value;
                      }
                      return result;
                    }
                    putIfAbsent(key, value) {
                      let element = this.backingStore.get({ key, value });
                      let result;
                      if (!element) {
                        this.backingStore.add({ key, value });
                      } else {
                        result = element.value;
                      }
                      return result;
                    }
                    get size() {
                      return this.backingStore.size;
                    }
                    hashCode() {
                      return this.backingStore.hashCode();
                    }
                    equals(o) {
                      if (!(o instanceof Array2DHashMap)) {
                        return false;
                      }
                      return this.backingStore.equals(o.backingStore);
                    }
                  }
                  exports2.Array2DHashMap = Array2DHashMap;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/Array2DHashSet.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/Array2DHashSet.js ***!
                  \******************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Array2DHashSet = void 0;
                  const assert = __webpack_require__2(
                    /*! assert */
                    "./node_modules/assert/build/assert.js"
                  );
                  const DefaultEqualityComparator_1 = __webpack_require__2(
                    /*! ./DefaultEqualityComparator */
                    "./node_modules/antlr4ts/misc/DefaultEqualityComparator.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ./MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const INITAL_CAPACITY = 16;
                  const LOAD_FACTOR = 0.75;
                  class Array2DHashSet {
                    constructor(comparatorOrSet, initialCapacity = INITAL_CAPACITY) {
                      this.n = 0;
                      this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
                      if (comparatorOrSet instanceof Array2DHashSet) {
                        this.comparator = comparatorOrSet.comparator;
                        this.buckets = comparatorOrSet.buckets.slice(0);
                        for (let i = 0; i < this.buckets.length; i++) {
                          let bucket = this.buckets[i];
                          if (bucket) {
                            this.buckets[i] = bucket.slice(0);
                          }
                        }
                        this.n = comparatorOrSet.n;
                        this.threshold = comparatorOrSet.threshold;
                      } else {
                        this.comparator = comparatorOrSet || DefaultEqualityComparator_1.DefaultEqualityComparator.INSTANCE;
                        this.buckets = this.createBuckets(initialCapacity);
                      }
                    }
                    /**
                     * Add `o` to set if not there; return existing value if already
                     * there. This method performs the same operation as {@link #add} aside from
                     * the return value.
                     */
                    getOrAdd(o) {
                      if (this.n > this.threshold) {
                        this.expand();
                      }
                      return this.getOrAddImpl(o);
                    }
                    getOrAddImpl(o) {
                      let b = this.getBucket(o);
                      let bucket = this.buckets[b];
                      if (!bucket) {
                        bucket = [o];
                        this.buckets[b] = bucket;
                        this.n++;
                        return o;
                      }
                      for (let existing of bucket) {
                        if (this.comparator.equals(existing, o)) {
                          return existing;
                        }
                      }
                      bucket.push(o);
                      this.n++;
                      return o;
                    }
                    get(o) {
                      if (o == null) {
                        return o;
                      }
                      let b = this.getBucket(o);
                      let bucket = this.buckets[b];
                      if (!bucket) {
                        return void 0;
                      }
                      for (let e of bucket) {
                        if (this.comparator.equals(e, o)) {
                          return e;
                        }
                      }
                      return void 0;
                    }
                    getBucket(o) {
                      let hash = this.comparator.hashCode(o);
                      let b = hash & this.buckets.length - 1;
                      return b;
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      for (let bucket of this.buckets) {
                        if (bucket == null) {
                          continue;
                        }
                        for (let o of bucket) {
                          if (o == null) {
                            break;
                          }
                          hash = MurmurHash_1.MurmurHash.update(hash, this.comparator.hashCode(o));
                        }
                      }
                      hash = MurmurHash_1.MurmurHash.finish(hash, this.size);
                      return hash;
                    }
                    equals(o) {
                      if (o === this) {
                        return true;
                      }
                      if (!(o instanceof Array2DHashSet)) {
                        return false;
                      }
                      if (o.size !== this.size) {
                        return false;
                      }
                      let same = this.containsAll(o);
                      return same;
                    }
                    expand() {
                      let old = this.buckets;
                      let newCapacity = this.buckets.length * 2;
                      let newTable = this.createBuckets(newCapacity);
                      this.buckets = newTable;
                      this.threshold = Math.floor(newCapacity * LOAD_FACTOR);
                      let oldSize = this.size;
                      for (let bucket of old) {
                        if (!bucket) {
                          continue;
                        }
                        for (let o of bucket) {
                          let b = this.getBucket(o);
                          let newBucket = this.buckets[b];
                          if (!newBucket) {
                            newBucket = [];
                            this.buckets[b] = newBucket;
                          }
                          newBucket.push(o);
                        }
                      }
                      assert(this.n === oldSize);
                    }
                    add(t) {
                      let existing = this.getOrAdd(t);
                      return existing === t;
                    }
                    get size() {
                      return this.n;
                    }
                    get isEmpty() {
                      return this.n === 0;
                    }
                    contains(o) {
                      return this.containsFast(this.asElementType(o));
                    }
                    containsFast(obj) {
                      if (obj == null) {
                        return false;
                      }
                      return this.get(obj) != null;
                    }
                    *[Symbol.iterator]() {
                      yield* this.toArray();
                    }
                    toArray() {
                      const a = new Array(this.size);
                      let i = 0;
                      for (let bucket of this.buckets) {
                        if (bucket == null) {
                          continue;
                        }
                        for (let o of bucket) {
                          if (o == null) {
                            break;
                          }
                          a[i++] = o;
                        }
                      }
                      return a;
                    }
                    containsAll(collection) {
                      if (collection instanceof Array2DHashSet) {
                        let s = collection;
                        for (let bucket of s.buckets) {
                          if (bucket == null) {
                            continue;
                          }
                          for (let o of bucket) {
                            if (o == null) {
                              break;
                            }
                            if (!this.containsFast(this.asElementType(o))) {
                              return false;
                            }
                          }
                        }
                      } else {
                        for (let o of collection) {
                          if (!this.containsFast(this.asElementType(o))) {
                            return false;
                          }
                        }
                      }
                      return true;
                    }
                    addAll(c) {
                      let changed = false;
                      for (let o of c) {
                        let existing = this.getOrAdd(o);
                        if (existing !== o) {
                          changed = true;
                        }
                      }
                      return changed;
                    }
                    clear() {
                      this.buckets = this.createBuckets(INITAL_CAPACITY);
                      this.n = 0;
                      this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
                    }
                    toString() {
                      if (this.size === 0) {
                        return "{}";
                      }
                      let buf = "{";
                      let first = true;
                      for (let bucket of this.buckets) {
                        if (bucket == null) {
                          continue;
                        }
                        for (let o of bucket) {
                          if (o == null) {
                            break;
                          }
                          if (first) {
                            first = false;
                          } else {
                            buf += ", ";
                          }
                          buf += o.toString();
                        }
                      }
                      buf += "}";
                      return buf;
                    }
                    toTableString() {
                      let buf = "";
                      for (let bucket of this.buckets) {
                        if (bucket == null) {
                          buf += "null\n";
                          continue;
                        }
                        buf += "[";
                        let first = true;
                        for (let o of bucket) {
                          if (first) {
                            first = false;
                          } else {
                            buf += " ";
                          }
                          if (o == null) {
                            buf += "_";
                          } else {
                            buf += o.toString();
                          }
                        }
                        buf += "]\n";
                      }
                      return buf;
                    }
                    /**
                     * Return `o` as an instance of the element type `T`. If
                     * `o` is non-undefined but known to not be an instance of `T`, this
                     * method returns `undefined`. The base implementation does not perform any
                     * type checks; override this method to provide strong type checks for the
                     * {@link #contains} and {@link #remove} methods to ensure the arguments to
                     * the {@link EqualityComparator} for the set always have the expected
                     * types.
                     *
                     * @param o the object to try and cast to the element type of the set
                     * @returns `o` if it could be an instance of `T`, otherwise
                     * `undefined`.
                     */
                    asElementType(o) {
                      return o;
                    }
                    /**
                     * Return an array of `T[]` with length `capacity`.
                     *
                     * @param capacity the length of the array to return
                     * @returns the newly constructed array
                     */
                    createBuckets(capacity) {
                      return new Array(capacity);
                    }
                  }
                  __decorate([
                    Decorators_1.NotNull
                  ], Array2DHashSet.prototype, "comparator", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, "add", null);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, "size", null);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, "isEmpty", null);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, "contains", null);
                  __decorate([
                    __param(0, Decorators_1.Nullable)
                  ], Array2DHashSet.prototype, "containsFast", null);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, Symbol.iterator, null);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, "toArray", null);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, "containsAll", null);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, "addAll", null);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, "clear", null);
                  __decorate([
                    Decorators_1.Override
                  ], Array2DHashSet.prototype, "toString", null);
                  __decorate([
                    Decorators_1.SuppressWarnings("unchecked")
                  ], Array2DHashSet.prototype, "asElementType", null);
                  __decorate([
                    Decorators_1.SuppressWarnings("unchecked")
                  ], Array2DHashSet.prototype, "createBuckets", null);
                  exports2.Array2DHashSet = Array2DHashSet;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/ArrayEqualityComparator.js": (
                /*!***************************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/ArrayEqualityComparator.js ***!
                  \***************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ArrayEqualityComparator = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ./MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const ObjectEqualityComparator_1 = __webpack_require__2(
                    /*! ./ObjectEqualityComparator */
                    "./node_modules/antlr4ts/misc/ObjectEqualityComparator.js"
                  );
                  class ArrayEqualityComparator {
                    /**
                     * {@inheritDoc}
                     *
                     * This implementation returns
                     * `obj.`{@link Object#hashCode hashCode()}.
                     */
                    hashCode(obj) {
                      if (obj == null) {
                        return 0;
                      }
                      return MurmurHash_1.MurmurHash.hashCode(obj, 0);
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This implementation relies on object equality. If both objects are
                     * `undefined`, this method returns `true`. Otherwise if only
                     * `a` is `undefined`, this method returns `false`. Otherwise,
                     * this method returns the result of
                     * `a.`{@link Object#equals equals}`(b)`.
                     */
                    equals(a, b) {
                      if (a == null) {
                        return b == null;
                      } else if (b == null) {
                        return false;
                      }
                      if (a.length !== b.length) {
                        return false;
                      }
                      for (let i = 0; i < a.length; i++) {
                        if (!ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a[i], b[i])) {
                          return false;
                        }
                      }
                      return true;
                    }
                  }
                  ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator();
                  __decorate([
                    Decorators_1.Override
                  ], ArrayEqualityComparator.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], ArrayEqualityComparator.prototype, "equals", null);
                  exports2.ArrayEqualityComparator = ArrayEqualityComparator;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/Arrays.js": (
                /*!**********************************************!*\
                  !*** ./node_modules/antlr4ts/misc/Arrays.js ***!
                  \**********************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Arrays = void 0;
                  var Arrays;
                  (function(Arrays2) {
                    function binarySearch(array, key, fromIndex, toIndex) {
                      return binarySearch0(array, fromIndex !== void 0 ? fromIndex : 0, toIndex !== void 0 ? toIndex : array.length, key);
                    }
                    Arrays2.binarySearch = binarySearch;
                    function binarySearch0(array, fromIndex, toIndex, key) {
                      let low = fromIndex;
                      let high = toIndex - 1;
                      while (low <= high) {
                        let mid = low + high >>> 1;
                        let midVal = array[mid];
                        if (midVal < key) {
                          low = mid + 1;
                        } else if (midVal > key) {
                          high = mid - 1;
                        } else {
                          return mid;
                        }
                      }
                      return -(low + 1);
                    }
                    function toString2(array) {
                      let result = "[";
                      let first = true;
                      for (let element of array) {
                        if (first) {
                          first = false;
                        } else {
                          result += ", ";
                        }
                        if (element === null) {
                          result += "null";
                        } else if (element === void 0) {
                          result += "undefined";
                        } else {
                          result += element;
                        }
                      }
                      result += "]";
                      return result;
                    }
                    Arrays2.toString = toString2;
                  })(Arrays = exports2.Arrays || (exports2.Arrays = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/BitSet.js": (
                /*!**********************************************!*\
                  !*** ./node_modules/antlr4ts/misc/BitSet.js ***!
                  \**********************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.BitSet = void 0;
                  const util = __webpack_require__2(
                    /*! util */
                    "./node_modules/util/util.js"
                  );
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ./MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const EMPTY_DATA = new Uint16Array(0);
                  function getIndex(bitNumber) {
                    return bitNumber >>> 4;
                  }
                  function unIndex(n) {
                    return n * 16;
                  }
                  function findLSBSet(word) {
                    let bit = 1;
                    for (let i = 0; i < 16; i++) {
                      if ((word & bit) !== 0) {
                        return i;
                      }
                      bit = bit << 1 >>> 0;
                    }
                    throw new RangeError("No specified bit found");
                  }
                  function findMSBSet(word) {
                    let bit = 1 << 15 >>> 0;
                    for (let i = 15; i >= 0; i--) {
                      if ((word & bit) !== 0) {
                        return i;
                      }
                      bit = bit >>> 1;
                    }
                    throw new RangeError("No specified bit found");
                  }
                  function bitsFor(fromBit, toBit) {
                    fromBit &= 15;
                    toBit &= 15;
                    if (fromBit === toBit) {
                      return 1 << fromBit >>> 0;
                    }
                    return 65535 >>> 15 - toBit ^ 65535 >>> 16 - fromBit;
                  }
                  const POP_CNT = new Uint8Array(65536);
                  for (let i = 0; i < 16; i++) {
                    const stride = 1 << i >>> 0;
                    let index = 0;
                    while (index < POP_CNT.length) {
                      index += stride;
                      for (let j = 0; j < stride; j++) {
                        POP_CNT[index]++;
                        index++;
                      }
                    }
                  }
                  class BitSet {
                    /*
                    ** constructor implementation
                    */
                    constructor(arg) {
                      if (!arg) {
                        this.data = EMPTY_DATA;
                      } else if (typeof arg === "number") {
                        if (arg < 0) {
                          throw new RangeError("nbits cannot be negative");
                        } else {
                          this.data = new Uint16Array(getIndex(arg - 1) + 1);
                        }
                      } else {
                        if (arg instanceof BitSet) {
                          this.data = arg.data.slice(0);
                        } else {
                          let max6 = -1;
                          for (let v of arg) {
                            if (max6 < v) {
                              max6 = v;
                            }
                          }
                          this.data = new Uint16Array(getIndex(max6 - 1) + 1);
                          for (let v of arg) {
                            this.set(v);
                          }
                        }
                      }
                    }
                    /**
                     * Performs a logical **AND** of this target bit set with the argument bit set. This bit set is modified so that
                     * each bit in it has the value `true` if and only if it both initially had the value `true` and the corresponding
                     * bit in the bit set argument also had the value `true`.
                     */
                    and(set2) {
                      const data = this.data;
                      const other = set2.data;
                      const words = Math.min(data.length, other.length);
                      let lastWord = -1;
                      for (let i = 0; i < words; i++) {
                        let value = data[i] &= other[i];
                        if (value !== 0) {
                          lastWord = i;
                        }
                      }
                      if (lastWord === -1) {
                        this.data = EMPTY_DATA;
                      }
                      if (lastWord < data.length - 1) {
                        this.data = data.slice(0, lastWord + 1);
                      }
                    }
                    /**
                     * Clears all of the bits in this `BitSet` whose corresponding bit is set in the specified `BitSet`.
                     */
                    andNot(set2) {
                      const data = this.data;
                      const other = set2.data;
                      const words = Math.min(data.length, other.length);
                      let lastWord = -1;
                      for (let i = 0; i < words; i++) {
                        let value = data[i] &= other[i] ^ 65535;
                        if (value !== 0) {
                          lastWord = i;
                        }
                      }
                      if (lastWord === -1) {
                        this.data = EMPTY_DATA;
                      }
                      if (lastWord < data.length - 1) {
                        this.data = data.slice(0, lastWord + 1);
                      }
                    }
                    /**
                     * Returns the number of bits set to `true` in this `BitSet`.
                     */
                    cardinality() {
                      if (this.isEmpty) {
                        return 0;
                      }
                      const data = this.data;
                      const length = data.length;
                      let result = 0;
                      for (let i = 0; i < length; i++) {
                        result += POP_CNT[data[i]];
                      }
                      return result;
                    }
                    clear(fromIndex, toIndex) {
                      if (fromIndex == null) {
                        this.data.fill(0);
                      } else if (toIndex == null) {
                        this.set(fromIndex, false);
                      } else {
                        this.set(fromIndex, toIndex, false);
                      }
                    }
                    flip(fromIndex, toIndex) {
                      if (toIndex == null) {
                        toIndex = fromIndex;
                      }
                      if (fromIndex < 0 || toIndex < fromIndex) {
                        throw new RangeError();
                      }
                      let word = getIndex(fromIndex);
                      const lastWord = getIndex(toIndex);
                      if (word === lastWord) {
                        this.data[word] ^= bitsFor(fromIndex, toIndex);
                      } else {
                        this.data[word++] ^= bitsFor(fromIndex, 15);
                        while (word < lastWord) {
                          this.data[word++] ^= 65535;
                        }
                        this.data[word++] ^= bitsFor(0, toIndex);
                      }
                    }
                    get(fromIndex, toIndex) {
                      if (toIndex === void 0) {
                        return !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));
                      } else {
                        let result = new BitSet(toIndex + 1);
                        for (let i = fromIndex; i <= toIndex; i++) {
                          result.set(i, this.get(i));
                        }
                        return result;
                      }
                    }
                    /**
                     * Returns true if the specified `BitSet` has any bits set to `true` that are also set to `true` in this `BitSet`.
                     *
                     * @param set `BitSet` to intersect with
                     */
                    intersects(set2) {
                      let smallerLength = Math.min(this.length(), set2.length());
                      if (smallerLength === 0) {
                        return false;
                      }
                      let bound = getIndex(smallerLength - 1);
                      for (let i = 0; i <= bound; i++) {
                        if ((this.data[i] & set2.data[i]) !== 0) {
                          return true;
                        }
                      }
                      return false;
                    }
                    /**
                     * Returns true if this `BitSet` contains no bits that are set to `true`.
                     */
                    get isEmpty() {
                      return this.length() === 0;
                    }
                    /**
                     * Returns the "logical size" of this `BitSet`: the index of the highest set bit in the `BitSet` plus one. Returns
                     * zero if the `BitSet` contains no set bits.
                     */
                    length() {
                      if (!this.data.length) {
                        return 0;
                      }
                      return this.previousSetBit(unIndex(this.data.length) - 1) + 1;
                    }
                    /**
                     * Returns the index of the first bit that is set to `false` that occurs on or after the specified starting index,
                     * If no such bit exists then `-1` is returned.
                     *
                     * @param fromIndex the index to start checking from (inclusive)
                     *
                     * @throws RangeError if the specified index is negative
                     */
                    nextClearBit(fromIndex) {
                      if (fromIndex < 0) {
                        throw new RangeError("fromIndex cannot be negative");
                      }
                      const data = this.data;
                      const length = data.length;
                      let word = getIndex(fromIndex);
                      if (word > length) {
                        return -1;
                      }
                      let ignore = 65535 ^ bitsFor(fromIndex, 15);
                      if ((data[word] | ignore) === 65535) {
                        word++;
                        ignore = 0;
                        for (; word < length; word++) {
                          if (data[word] !== 65535) {
                            break;
                          }
                        }
                        if (word === length) {
                          return -1;
                        }
                      }
                      return unIndex(word) + findLSBSet((data[word] | ignore) ^ 65535);
                    }
                    /**
                     * Returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.
                     * If no such bit exists then `-1` is returned.
                     *
                     * To iterate over the `true` bits in a `BitSet`, use the following loop:
                     *
                     * ```
                     * for (let i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
                     *   // operate on index i here
                     * }
                     * ```
                     *
                     * @param fromIndex the index to start checking from (inclusive)
                     *
                     * @throws RangeError if the specified index is negative
                     */
                    nextSetBit(fromIndex) {
                      if (fromIndex < 0) {
                        throw new RangeError("fromIndex cannot be negative");
                      }
                      const data = this.data;
                      const length = data.length;
                      let word = getIndex(fromIndex);
                      if (word > length) {
                        return -1;
                      }
                      let mask = bitsFor(fromIndex, 15);
                      if ((data[word] & mask) === 0) {
                        word++;
                        mask = 65535;
                        for (; word < length; word++) {
                          if (data[word] !== 0) {
                            break;
                          }
                        }
                        if (word >= length) {
                          return -1;
                        }
                      }
                      return unIndex(word) + findLSBSet(data[word] & mask);
                    }
                    /**
                     * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it
                     * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit
                     * set argument has the value `true`.
                     */
                    or(set2) {
                      const data = this.data;
                      const other = set2.data;
                      const minWords = Math.min(data.length, other.length);
                      const words = Math.max(data.length, other.length);
                      const dest = data.length === words ? data : new Uint16Array(words);
                      let lastWord = -1;
                      for (let i = 0; i < minWords; i++) {
                        let value = dest[i] = data[i] | other[i];
                        if (value !== 0) {
                          lastWord = i;
                        }
                      }
                      const longer = data.length > other.length ? data : other;
                      for (let i = minWords; i < words; i++) {
                        let value = dest[i] = longer[i];
                        if (value !== 0) {
                          lastWord = i;
                        }
                      }
                      if (lastWord === -1) {
                        this.data = EMPTY_DATA;
                      } else if (dest.length === lastWord + 1) {
                        this.data = dest;
                      } else {
                        this.data = dest.slice(0, lastWord);
                      }
                    }
                    /**
                     * Returns the index of the nearest bit that is set to `false` that occurs on or before the specified starting
                     * index. If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
                     *
                     * @param fromIndex the index to start checking from (inclusive)
                     *
                     * @throws RangeError if the specified index is less than `-1`
                     */
                    previousClearBit(fromIndex) {
                      if (fromIndex < 0) {
                        throw new RangeError("fromIndex cannot be negative");
                      }
                      const data = this.data;
                      const length = data.length;
                      let word = getIndex(fromIndex);
                      if (word >= length) {
                        word = length - 1;
                      }
                      let ignore = 65535 ^ bitsFor(0, fromIndex);
                      if ((data[word] | ignore) === 65535) {
                        ignore = 0;
                        word--;
                        for (; word >= 0; word--) {
                          if (data[word] !== 65535) {
                            break;
                          }
                        }
                        if (word < 0) {
                          return -1;
                        }
                      }
                      return unIndex(word) + findMSBSet((data[word] | ignore) ^ 65535);
                    }
                    /**
                     * Returns the index of the nearest bit that is set to `true` that occurs on or before the specified starting index.
                     * If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
                     *
                     * To iterate over the `true` bits in a `BitSet`, use the following loop:
                     *
                     * ```
                     * for (let i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {
                     *   // operate on index i here
                     * }
                     * ```
                     *
                     * @param fromIndex the index to start checking from (inclusive)
                     *
                     * @throws RangeError if the specified index is less than `-1`
                     */
                    previousSetBit(fromIndex) {
                      if (fromIndex < 0) {
                        throw new RangeError("fromIndex cannot be negative");
                      }
                      const data = this.data;
                      const length = data.length;
                      let word = getIndex(fromIndex);
                      if (word >= length) {
                        word = length - 1;
                      }
                      let mask = bitsFor(0, fromIndex);
                      if ((data[word] & mask) === 0) {
                        word--;
                        mask = 65535;
                        for (; word >= 0; word--) {
                          if (data[word] !== 0) {
                            break;
                          }
                        }
                        if (word < 0) {
                          return -1;
                        }
                      }
                      return unIndex(word) + findMSBSet(data[word] & mask);
                    }
                    set(fromIndex, toIndex, value) {
                      if (toIndex === void 0) {
                        toIndex = fromIndex;
                        value = true;
                      } else if (typeof toIndex === "boolean") {
                        value = toIndex;
                        toIndex = fromIndex;
                      }
                      if (value === void 0) {
                        value = true;
                      }
                      if (fromIndex < 0 || fromIndex > toIndex) {
                        throw new RangeError();
                      }
                      let word = getIndex(fromIndex);
                      let lastWord = getIndex(toIndex);
                      if (value && lastWord >= this.data.length) {
                        let temp2 = new Uint16Array(lastWord + 1);
                        this.data.forEach((value2, index) => temp2[index] = value2);
                        this.data = temp2;
                      } else if (!value) {
                        if (word >= this.data.length) {
                          return;
                        }
                        if (lastWord >= this.data.length) {
                          lastWord = this.data.length - 1;
                          toIndex = this.data.length * 16 - 1;
                        }
                      }
                      if (word === lastWord) {
                        this._setBits(word, value, bitsFor(fromIndex, toIndex));
                      } else {
                        this._setBits(word++, value, bitsFor(fromIndex, 15));
                        while (word < lastWord) {
                          this.data[word++] = value ? 65535 : 0;
                        }
                        this._setBits(word, value, bitsFor(0, toIndex));
                      }
                    }
                    _setBits(word, value, mask) {
                      if (value) {
                        this.data[word] |= mask;
                      } else {
                        this.data[word] &= 65535 ^ mask;
                      }
                    }
                    /**
                     * Returns the number of bits of space actually in use by this `BitSet` to represent bit values. The maximum element
                     * in the set is the size - 1st element.
                     */
                    get size() {
                      return this.data.byteLength * 8;
                    }
                    /**
                     * Returns a new byte array containing all the bits in this bit set.
                     *
                     * More precisely, if
                     * `let bytes = s.toByteArray();`
                     * then `bytes.length === (s.length()+7)/8` and `s.get(n) === ((bytes[n/8] & (1<<(n%8))) != 0)` for all
                     * `n < 8 * bytes.length`.
                     */
                    // toByteArray(): Int8Array {
                    // 	throw new Error("NOT IMPLEMENTED");
                    // }
                    /**
                     * Returns a new integer array containing all the bits in this bit set.
                     *
                     * More precisely, if
                     * `let integers = s.toIntegerArray();`
                     * then `integers.length === (s.length()+31)/32` and `s.get(n) === ((integers[n/32] & (1<<(n%32))) != 0)` for all
                     * `n < 32 * integers.length`.
                     */
                    // toIntegerArray(): Int32Array {
                    // 	throw new Error("NOT IMPLEMENTED");
                    // }
                    hashCode() {
                      return MurmurHash_1.MurmurHash.hashCode(this.data, 22);
                    }
                    /**
                     * Compares this object against the specified object. The result is `true` if and only if the argument is not
                     * `undefined` and is a `Bitset` object that has exactly the same set of bits set to `true` as this bit set. That
                     * is, for every nonnegative index `k`,
                     *
                     * ```
                     * ((BitSet)obj).get(k) == this.get(k)
                     * ```
                     *
                     * must be true. The current sizes of the two bit sets are not compared.
                     */
                    equals(obj) {
                      if (obj === this) {
                        return true;
                      } else if (!(obj instanceof BitSet)) {
                        return false;
                      }
                      const len = this.length();
                      if (len !== obj.length()) {
                        return false;
                      }
                      if (len === 0) {
                        return true;
                      }
                      let bound = getIndex(len - 1);
                      for (let i = 0; i <= bound; i++) {
                        if (this.data[i] !== obj.data[i]) {
                          return false;
                        }
                      }
                      return true;
                    }
                    /**
                     * Returns a string representation of this bit set. For every index for which this `BitSet` contains a bit in the
                     * set state, the decimal representation of that index is included in the result. Such indices are listed in order
                     * from lowest to highest, separated by ", " (a comma and a space) and surrounded by braces, resulting in the usual
                     * mathematical notation for a set of integers.
                     *
                     * Example:
                     *
                     *     BitSet drPepper = new BitSet();
                     *
                     * Now `drPepper.toString()` returns `"{}"`.
                     *
                     *     drPepper.set(2);
                     *
                     * Now `drPepper.toString()` returns `"{2}"`.
                     *
                     *     drPepper.set(4);
                     *     drPepper.set(10);
                     *
                     * Now `drPepper.toString()` returns `"{2, 4, 10}"`.
                     */
                    toString() {
                      let result = "{";
                      let first = true;
                      for (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {
                        if (first) {
                          first = false;
                        } else {
                          result += ", ";
                        }
                        result += i;
                      }
                      result += "}";
                      return result;
                    }
                    // static valueOf(bytes: Int8Array): BitSet;
                    // static valueOf(buffer: ArrayBuffer): BitSet;
                    // static valueOf(integers: Int32Array): BitSet;
                    // static valueOf(data: Int8Array | Int32Array | ArrayBuffer): BitSet {
                    // 	throw new Error("NOT IMPLEMENTED");
                    // }
                    /**
                     * Performs a logical **XOR** of this bit set with the bit set argument. This bit set is modified so that a bit in
                     * it has the value `true` if and only if one of the following statements holds:
                     *
                     * * The bit initially has the value `true`, and the corresponding bit in the argument has the value `false`.
                     * * The bit initially has the value `false`, and the corresponding bit in the argument has the value `true`.
                     */
                    xor(set2) {
                      const data = this.data;
                      const other = set2.data;
                      const minWords = Math.min(data.length, other.length);
                      const words = Math.max(data.length, other.length);
                      const dest = data.length === words ? data : new Uint16Array(words);
                      let lastWord = -1;
                      for (let i = 0; i < minWords; i++) {
                        let value = dest[i] = data[i] ^ other[i];
                        if (value !== 0) {
                          lastWord = i;
                        }
                      }
                      const longer = data.length > other.length ? data : other;
                      for (let i = minWords; i < words; i++) {
                        let value = dest[i] = longer[i];
                        if (value !== 0) {
                          lastWord = i;
                        }
                      }
                      if (lastWord === -1) {
                        this.data = EMPTY_DATA;
                      } else if (dest.length === lastWord + 1) {
                        this.data = dest;
                      } else {
                        this.data = dest.slice(0, lastWord + 1);
                      }
                    }
                    clone() {
                      return new BitSet(this);
                    }
                    [Symbol.iterator]() {
                      return new BitSetIterator(this.data);
                    }
                    // Overrides formatting for nodejs assert etc.
                    [util.inspect.custom]() {
                      return "BitSet " + this.toString();
                    }
                  }
                  exports2.BitSet = BitSet;
                  class BitSetIterator {
                    constructor(data) {
                      this.data = data;
                      this.index = 0;
                      this.mask = 65535;
                    }
                    next() {
                      while (this.index < this.data.length) {
                        const bits = this.data[this.index] & this.mask;
                        if (bits !== 0) {
                          const bitNumber = unIndex(this.index) + findLSBSet(bits);
                          this.mask = bitsFor(bitNumber + 1, 15);
                          return { done: false, value: bitNumber };
                        }
                        this.index++;
                        this.mask = 65535;
                      }
                      return { done: true, value: -1 };
                    }
                    [Symbol.iterator]() {
                      return this;
                    }
                  }
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/Character.js": (
                /*!*************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/Character.js ***!
                  \*************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.isSupplementaryCodePoint = exports2.isLowSurrogate = exports2.isHighSurrogate = void 0;
                  function isHighSurrogate(ch) {
                    return ch >= 55296 && ch <= 56319;
                  }
                  exports2.isHighSurrogate = isHighSurrogate;
                  function isLowSurrogate(ch) {
                    return ch >= 56320 && ch <= 57343;
                  }
                  exports2.isLowSurrogate = isLowSurrogate;
                  function isSupplementaryCodePoint(ch) {
                    return ch >= 65536;
                  }
                  exports2.isSupplementaryCodePoint = isSupplementaryCodePoint;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/DefaultEqualityComparator.js": (
                /*!*****************************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/DefaultEqualityComparator.js ***!
                  \*****************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.DefaultEqualityComparator = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ./MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const ObjectEqualityComparator_1 = __webpack_require__2(
                    /*! ./ObjectEqualityComparator */
                    "./node_modules/antlr4ts/misc/ObjectEqualityComparator.js"
                  );
                  class DefaultEqualityComparator {
                    /**
                     * {@inheritDoc}
                     *
                     * This implementation returns
                     * `obj.`{@link Object#hashCode hashCode()}.
                     */
                    hashCode(obj) {
                      if (obj == null) {
                        return 0;
                      } else if (typeof obj === "string" || typeof obj === "number") {
                        return MurmurHash_1.MurmurHash.hashCode([obj]);
                      } else {
                        return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.hashCode(obj);
                      }
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This implementation relies on object equality. If both objects are
                     * `undefined` or `null`, this method returns `true`. Otherwise if only
                     * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
                     * this method returns the result of
                     * `a.`{@link Object#equals equals}`(b)`.
                     */
                    equals(a, b) {
                      if (a == null) {
                        return b == null;
                      } else if (typeof a === "string" || typeof a === "number") {
                        return a === b;
                      } else {
                        return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a, b);
                      }
                    }
                  }
                  DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator();
                  __decorate([
                    Decorators_1.Override
                  ], DefaultEqualityComparator.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], DefaultEqualityComparator.prototype, "equals", null);
                  exports2.DefaultEqualityComparator = DefaultEqualityComparator;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/IntegerList.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/IntegerList.js ***!
                  \***************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.IntegerList = void 0;
                  const Arrays_1 = __webpack_require__2(
                    /*! ./Arrays */
                    "./node_modules/antlr4ts/misc/Arrays.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const EMPTY_DATA = new Int32Array(0);
                  const INITIAL_SIZE = 4;
                  const MAX_ARRAY_SIZE = (1 << 31 >>> 0) - 1 - 8;
                  class IntegerList {
                    constructor(arg) {
                      if (!arg) {
                        this._data = EMPTY_DATA;
                        this._size = 0;
                      } else if (arg instanceof IntegerList) {
                        this._data = arg._data.slice(0);
                        this._size = arg._size;
                      } else if (typeof arg === "number") {
                        if (arg === 0) {
                          this._data = EMPTY_DATA;
                          this._size = 0;
                        } else {
                          this._data = new Int32Array(arg);
                          this._size = 0;
                        }
                      } else {
                        this._data = EMPTY_DATA;
                        this._size = 0;
                        for (let value of arg) {
                          this.add(value);
                        }
                      }
                    }
                    add(value) {
                      if (this._data.length === this._size) {
                        this.ensureCapacity(this._size + 1);
                      }
                      this._data[this._size] = value;
                      this._size++;
                    }
                    addAll(list) {
                      if (Array.isArray(list)) {
                        this.ensureCapacity(this._size + list.length);
                        this._data.subarray(this._size, this._size + list.length).set(list);
                        this._size += list.length;
                      } else if (list instanceof IntegerList) {
                        this.ensureCapacity(this._size + list._size);
                        this._data.subarray(this._size, this._size + list.size).set(list._data);
                        this._size += list._size;
                      } else {
                        this.ensureCapacity(this._size + list.size);
                        let current = 0;
                        for (let xi of list) {
                          this._data[this._size + current] = xi;
                          current++;
                        }
                        this._size += list.size;
                      }
                    }
                    get(index) {
                      if (index < 0 || index >= this._size) {
                        throw RangeError();
                      }
                      return this._data[index];
                    }
                    contains(value) {
                      for (let i = 0; i < this._size; i++) {
                        if (this._data[i] === value) {
                          return true;
                        }
                      }
                      return false;
                    }
                    set(index, value) {
                      if (index < 0 || index >= this._size) {
                        throw RangeError();
                      }
                      let previous = this._data[index];
                      this._data[index] = value;
                      return previous;
                    }
                    removeAt(index) {
                      let value = this.get(index);
                      this._data.copyWithin(index, index + 1, this._size);
                      this._data[this._size - 1] = 0;
                      this._size--;
                      return value;
                    }
                    removeRange(fromIndex, toIndex) {
                      if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
                        throw RangeError();
                      }
                      if (fromIndex > toIndex) {
                        throw RangeError();
                      }
                      this._data.copyWithin(toIndex, fromIndex, this._size);
                      this._data.fill(0, this._size - (toIndex - fromIndex), this._size);
                      this._size -= toIndex - fromIndex;
                    }
                    get isEmpty() {
                      return this._size === 0;
                    }
                    get size() {
                      return this._size;
                    }
                    trimToSize() {
                      if (this._data.length === this._size) {
                        return;
                      }
                      this._data = this._data.slice(0, this._size);
                    }
                    clear() {
                      this._data.fill(0, 0, this._size);
                      this._size = 0;
                    }
                    toArray() {
                      if (this._size === 0) {
                        return [];
                      }
                      return Array.from(this._data.subarray(0, this._size));
                    }
                    sort() {
                      this._data.subarray(0, this._size).sort();
                    }
                    /**
                     * Compares the specified object with this list for equality.  Returns
                     * `true` if and only if the specified object is also an {@link IntegerList},
                     * both lists have the same size, and all corresponding pairs of elements in
                     * the two lists are equal.  In other words, two lists are defined to be
                     * equal if they contain the same elements in the same order.
                     *
                     * This implementation first checks if the specified object is this
                     * list. If so, it returns `true`; if not, it checks if the
                     * specified object is an {@link IntegerList}. If not, it returns `false`;
                     * if so, it checks the size of both lists. If the lists are not the same size,
                     * it returns `false`; otherwise it iterates over both lists, comparing
                     * corresponding pairs of elements.  If any comparison returns `false`,
                     * this method returns `false`.
                     *
                     * @param o the object to be compared for equality with this list
                     * @returns `true` if the specified object is equal to this list
                     */
                    equals(o) {
                      if (o === this) {
                        return true;
                      }
                      if (!(o instanceof IntegerList)) {
                        return false;
                      }
                      if (this._size !== o._size) {
                        return false;
                      }
                      for (let i = 0; i < this._size; i++) {
                        if (this._data[i] !== o._data[i]) {
                          return false;
                        }
                      }
                      return true;
                    }
                    /**
                     * Returns the hash code value for this list.
                     *
                     * This implementation uses exactly the code that is used to define the
                     * list hash function in the documentation for the {@link List#hashCode}
                     * method.
                     *
                     * @returns the hash code value for this list
                     */
                    hashCode() {
                      let hashCode = 1;
                      for (let i = 0; i < this._size; i++) {
                        hashCode = 31 * hashCode + this._data[i];
                      }
                      return hashCode;
                    }
                    /**
                     * Returns a string representation of this list.
                     */
                    toString() {
                      return this._data.toString();
                    }
                    binarySearch(key, fromIndex, toIndex) {
                      if (fromIndex === void 0) {
                        fromIndex = 0;
                      }
                      if (toIndex === void 0) {
                        toIndex = this._size;
                      }
                      if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
                        throw new RangeError();
                      }
                      if (fromIndex > toIndex) {
                        throw new RangeError();
                      }
                      return Arrays_1.Arrays.binarySearch(this._data, key, fromIndex, toIndex);
                    }
                    ensureCapacity(capacity) {
                      if (capacity < 0 || capacity > MAX_ARRAY_SIZE) {
                        throw new RangeError();
                      }
                      let newLength;
                      if (this._data.length === 0) {
                        newLength = INITIAL_SIZE;
                      } else {
                        newLength = this._data.length;
                      }
                      while (newLength < capacity) {
                        newLength = newLength * 2;
                        if (newLength < 0 || newLength > MAX_ARRAY_SIZE) {
                          newLength = MAX_ARRAY_SIZE;
                        }
                      }
                      let tmp = new Int32Array(newLength);
                      tmp.set(this._data);
                      this._data = tmp;
                    }
                    /** Convert the list to a UTF-16 encoded char array. If all values are less
                     *  than the 0xFFFF 16-bit code point limit then this is just a char array
                     *  of 16-bit char as usual. For values in the supplementary range, encode
                     * them as two UTF-16 code units.
                     */
                    toCharArray() {
                      let resultArray = new Uint16Array(this._size);
                      let resultIdx = 0;
                      let calculatedPreciseResultSize = false;
                      for (let i = 0; i < this._size; i++) {
                        let codePoint = this._data[i];
                        if (codePoint >= 0 && codePoint < 65536) {
                          resultArray[resultIdx] = codePoint;
                          resultIdx++;
                          continue;
                        }
                        if (!calculatedPreciseResultSize) {
                          let newResultArray = new Uint16Array(this.charArraySize());
                          newResultArray.set(resultArray, 0);
                          resultArray = newResultArray;
                          calculatedPreciseResultSize = true;
                        }
                        let pair = String.fromCodePoint(codePoint);
                        resultArray[resultIdx] = pair.charCodeAt(0);
                        resultArray[resultIdx + 1] = pair.charCodeAt(1);
                        resultIdx += 2;
                      }
                      return resultArray;
                    }
                    charArraySize() {
                      let result = 0;
                      for (let i = 0; i < this._size; i++) {
                        result += this._data[i] >= 65536 ? 2 : 1;
                      }
                      return result;
                    }
                  }
                  __decorate([
                    Decorators_1.NotNull
                  ], IntegerList.prototype, "_data", void 0);
                  __decorate([
                    Decorators_1.Override
                  ], IntegerList.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntegerList.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntegerList.prototype, "toString", null);
                  exports2.IntegerList = IntegerList;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/IntegerStack.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/IntegerStack.js ***!
                  \****************************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.IntegerStack = void 0;
                  const IntegerList_1 = __webpack_require__2(
                    /*! ./IntegerList */
                    "./node_modules/antlr4ts/misc/IntegerList.js"
                  );
                  class IntegerStack extends IntegerList_1.IntegerList {
                    constructor(arg) {
                      super(arg);
                    }
                    push(value) {
                      this.add(value);
                    }
                    pop() {
                      return this.removeAt(this.size - 1);
                    }
                    peek() {
                      return this.get(this.size - 1);
                    }
                  }
                  exports2.IntegerStack = IntegerStack;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/Interval.js": (
                /*!************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/Interval.js ***!
                  \************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Interval = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const INTERVAL_POOL_MAX_VALUE = 1e3;
                  class Interval {
                    /**
                     * @param a The start of the interval
                     * @param b The end of the interval (inclusive)
                     */
                    constructor(a, b) {
                      this.a = a;
                      this.b = b;
                    }
                    static get INVALID() {
                      return Interval._INVALID;
                    }
                    /** Interval objects are used readonly so share all with the
                     *  same single value a==b up to some max size.  Use an array as a perfect hash.
                     *  Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
                     *  Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
                     *  have a..a (set with 1 element).
                     */
                    static of(a, b) {
                      if (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {
                        return new Interval(a, b);
                      }
                      if (Interval.cache[a] == null) {
                        Interval.cache[a] = new Interval(a, a);
                      }
                      return Interval.cache[a];
                    }
                    /** return number of elements between a and b inclusively. x..x is length 1.
                     *  if b &lt; a, then length is 0.  9..10 has length 2.
                     */
                    get length() {
                      if (this.b < this.a) {
                        return 0;
                      }
                      return this.b - this.a + 1;
                    }
                    equals(o) {
                      if (o === this) {
                        return true;
                      } else if (!(o instanceof Interval)) {
                        return false;
                      }
                      return this.a === o.a && this.b === o.b;
                    }
                    hashCode() {
                      let hash = 23;
                      hash = hash * 31 + this.a;
                      hash = hash * 31 + this.b;
                      return hash;
                    }
                    /** Does this start completely before other? Disjoint */
                    startsBeforeDisjoint(other) {
                      return this.a < other.a && this.b < other.a;
                    }
                    /** Does this start at or before other? Nondisjoint */
                    startsBeforeNonDisjoint(other) {
                      return this.a <= other.a && this.b >= other.a;
                    }
                    /** Does this.a start after other.b? May or may not be disjoint */
                    startsAfter(other) {
                      return this.a > other.a;
                    }
                    /** Does this start completely after other? Disjoint */
                    startsAfterDisjoint(other) {
                      return this.a > other.b;
                    }
                    /** Does this start after other? NonDisjoint */
                    startsAfterNonDisjoint(other) {
                      return this.a > other.a && this.a <= other.b;
                    }
                    /** Are both ranges disjoint? I.e., no overlap? */
                    disjoint(other) {
                      return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
                    }
                    /** Are two intervals adjacent such as 0..41 and 42..42? */
                    adjacent(other) {
                      return this.a === other.b + 1 || this.b === other.a - 1;
                    }
                    properlyContains(other) {
                      return other.a >= this.a && other.b <= this.b;
                    }
                    /** Return the interval computed from combining this and other */
                    union(other) {
                      return Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));
                    }
                    /** Return the interval in common between this and o */
                    intersection(other) {
                      return Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));
                    }
                    /** Return the interval with elements from `this` not in `other`;
                     *  `other` must not be totally enclosed (properly contained)
                     *  within `this`, which would result in two disjoint intervals
                     *  instead of the single one returned by this method.
                     */
                    differenceNotProperlyContained(other) {
                      let diff;
                      if (other.startsBeforeNonDisjoint(this)) {
                        diff = Interval.of(Math.max(this.a, other.b + 1), this.b);
                      } else if (other.startsAfterNonDisjoint(this)) {
                        diff = Interval.of(this.a, other.a - 1);
                      }
                      return diff;
                    }
                    toString() {
                      return this.a + ".." + this.b;
                    }
                  }
                  Interval._INVALID = new Interval(-1, -2);
                  Interval.cache = new Array(INTERVAL_POOL_MAX_VALUE + 1);
                  __decorate([
                    Decorators_1.Override
                  ], Interval.prototype, "equals", null);
                  __decorate([
                    Decorators_1.Override
                  ], Interval.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], Interval.prototype, "toString", null);
                  exports2.Interval = Interval;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/IntervalSet.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/IntervalSet.js ***!
                  \***************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.IntervalSet = void 0;
                  const ArrayEqualityComparator_1 = __webpack_require__2(
                    /*! ./ArrayEqualityComparator */
                    "./node_modules/antlr4ts/misc/ArrayEqualityComparator.js"
                  );
                  const IntegerList_1 = __webpack_require__2(
                    /*! ./IntegerList */
                    "./node_modules/antlr4ts/misc/IntegerList.js"
                  );
                  const Interval_1 = __webpack_require__2(
                    /*! ./Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const Lexer_1 = __webpack_require__2(
                    /*! ../Lexer */
                    "./node_modules/antlr4ts/Lexer.js"
                  );
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ./MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  class IntervalSet {
                    constructor(intervals) {
                      this.readonly = false;
                      if (intervals != null) {
                        this._intervals = intervals.slice(0);
                      } else {
                        this._intervals = [];
                      }
                    }
                    static get COMPLETE_CHAR_SET() {
                      if (IntervalSet._COMPLETE_CHAR_SET === void 0) {
                        IntervalSet._COMPLETE_CHAR_SET = IntervalSet.of(Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE);
                        IntervalSet._COMPLETE_CHAR_SET.setReadonly(true);
                      }
                      return IntervalSet._COMPLETE_CHAR_SET;
                    }
                    static get EMPTY_SET() {
                      if (IntervalSet._EMPTY_SET == null) {
                        IntervalSet._EMPTY_SET = new IntervalSet();
                        IntervalSet._EMPTY_SET.setReadonly(true);
                      }
                      return IntervalSet._EMPTY_SET;
                    }
                    /**
                     * Create a set with all ints within range [a..b] (inclusive). If b is omitted, the set contains the single element
                     * a.
                     */
                    static of(a, b = a) {
                      let s = new IntervalSet();
                      s.add(a, b);
                      return s;
                    }
                    clear() {
                      if (this.readonly) {
                        throw new Error("can't alter readonly IntervalSet");
                      }
                      this._intervals.length = 0;
                    }
                    /** Add interval; i.e., add all integers from a to b to set.
                     *  If b&lt;a, do nothing.
                     *  Keep list in sorted order (by left range value).
                     *  If overlap, combine ranges.  For example,
                     *  If this is {1..5, 10..20}, adding 6..7 yields
                     *  {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.
                     */
                    add(a, b = a) {
                      this.addRange(Interval_1.Interval.of(a, b));
                    }
                    // copy on write so we can cache a..a intervals and sets of that
                    addRange(addition) {
                      if (this.readonly) {
                        throw new Error("can't alter readonly IntervalSet");
                      }
                      if (addition.b < addition.a) {
                        return;
                      }
                      for (let i = 0; i < this._intervals.length; i++) {
                        let r = this._intervals[i];
                        if (addition.equals(r)) {
                          return;
                        }
                        if (addition.adjacent(r) || !addition.disjoint(r)) {
                          let bigger = addition.union(r);
                          this._intervals[i] = bigger;
                          while (i < this._intervals.length - 1) {
                            i++;
                            let next = this._intervals[i];
                            if (!bigger.adjacent(next) && bigger.disjoint(next)) {
                              break;
                            }
                            this._intervals.splice(i, 1);
                            i--;
                            this._intervals[i] = bigger.union(next);
                          }
                          return;
                        }
                        if (addition.startsBeforeDisjoint(r)) {
                          this._intervals.splice(i, 0, addition);
                          return;
                        }
                      }
                      this._intervals.push(addition);
                    }
                    /** combine all sets in the array returned the or'd value */
                    static or(sets) {
                      let r = new IntervalSet();
                      for (let s of sets) {
                        r.addAll(s);
                      }
                      return r;
                    }
                    addAll(set2) {
                      if (set2 == null) {
                        return this;
                      }
                      if (set2 instanceof IntervalSet) {
                        let other = set2;
                        let n = other._intervals.length;
                        for (let i = 0; i < n; i++) {
                          let I = other._intervals[i];
                          this.add(I.a, I.b);
                        }
                      } else {
                        for (let value of set2.toArray()) {
                          this.add(value);
                        }
                      }
                      return this;
                    }
                    complementRange(minElement, maxElement) {
                      return this.complement(IntervalSet.of(minElement, maxElement));
                    }
                    /** {@inheritDoc} */
                    complement(vocabulary) {
                      if (vocabulary.isNil) {
                        return IntervalSet.EMPTY_SET;
                      }
                      let vocabularyIS;
                      if (vocabulary instanceof IntervalSet) {
                        vocabularyIS = vocabulary;
                      } else {
                        vocabularyIS = new IntervalSet();
                        vocabularyIS.addAll(vocabulary);
                      }
                      return vocabularyIS.subtract(this);
                    }
                    subtract(a) {
                      if (a == null || a.isNil) {
                        return new IntervalSet(this._intervals);
                      }
                      if (a instanceof IntervalSet) {
                        return IntervalSet.subtract(this, a);
                      }
                      let other = new IntervalSet();
                      other.addAll(a);
                      return IntervalSet.subtract(this, other);
                    }
                    /**
                     * Compute the set difference between two interval sets. The specific
                     * operation is `left - right`.
                     */
                    static subtract(left, right) {
                      if (left.isNil) {
                        return new IntervalSet();
                      }
                      let result = new IntervalSet(left._intervals);
                      if (right.isNil) {
                        return result;
                      }
                      let resultI = 0;
                      let rightI = 0;
                      while (resultI < result._intervals.length && rightI < right._intervals.length) {
                        let resultInterval = result._intervals[resultI];
                        let rightInterval = right._intervals[rightI];
                        if (rightInterval.b < resultInterval.a) {
                          rightI++;
                          continue;
                        }
                        if (rightInterval.a > resultInterval.b) {
                          resultI++;
                          continue;
                        }
                        let beforeCurrent;
                        let afterCurrent;
                        if (rightInterval.a > resultInterval.a) {
                          beforeCurrent = new Interval_1.Interval(resultInterval.a, rightInterval.a - 1);
                        }
                        if (rightInterval.b < resultInterval.b) {
                          afterCurrent = new Interval_1.Interval(rightInterval.b + 1, resultInterval.b);
                        }
                        if (beforeCurrent) {
                          if (afterCurrent) {
                            result._intervals[resultI] = beforeCurrent;
                            result._intervals.splice(resultI + 1, 0, afterCurrent);
                            resultI++;
                            rightI++;
                            continue;
                          } else {
                            result._intervals[resultI] = beforeCurrent;
                            resultI++;
                            continue;
                          }
                        } else {
                          if (afterCurrent) {
                            result._intervals[resultI] = afterCurrent;
                            rightI++;
                            continue;
                          } else {
                            result._intervals.splice(resultI, 1);
                            continue;
                          }
                        }
                      }
                      return result;
                    }
                    or(a) {
                      let o = new IntervalSet();
                      o.addAll(this);
                      o.addAll(a);
                      return o;
                    }
                    /** {@inheritDoc} */
                    and(other) {
                      if (other.isNil) {
                        return new IntervalSet();
                      }
                      let myIntervals = this._intervals;
                      let theirIntervals = other._intervals;
                      let intersection;
                      let mySize = myIntervals.length;
                      let theirSize = theirIntervals.length;
                      let i = 0;
                      let j = 0;
                      while (i < mySize && j < theirSize) {
                        let mine = myIntervals[i];
                        let theirs = theirIntervals[j];
                        if (mine.startsBeforeDisjoint(theirs)) {
                          i++;
                        } else if (theirs.startsBeforeDisjoint(mine)) {
                          j++;
                        } else if (mine.properlyContains(theirs)) {
                          if (!intersection) {
                            intersection = new IntervalSet();
                          }
                          intersection.addRange(mine.intersection(theirs));
                          j++;
                        } else if (theirs.properlyContains(mine)) {
                          if (!intersection) {
                            intersection = new IntervalSet();
                          }
                          intersection.addRange(mine.intersection(theirs));
                          i++;
                        } else if (!mine.disjoint(theirs)) {
                          if (!intersection) {
                            intersection = new IntervalSet();
                          }
                          intersection.addRange(mine.intersection(theirs));
                          if (mine.startsAfterNonDisjoint(theirs)) {
                            j++;
                          } else if (theirs.startsAfterNonDisjoint(mine)) {
                            i++;
                          }
                        }
                      }
                      if (!intersection) {
                        return new IntervalSet();
                      }
                      return intersection;
                    }
                    /** {@inheritDoc} */
                    contains(el) {
                      let n = this._intervals.length;
                      let l = 0;
                      let r = n - 1;
                      while (l <= r) {
                        let m = l + r >> 1;
                        let I = this._intervals[m];
                        let a = I.a;
                        let b = I.b;
                        if (b < el) {
                          l = m + 1;
                        } else if (a > el) {
                          r = m - 1;
                        } else {
                          return true;
                        }
                      }
                      return false;
                    }
                    /** {@inheritDoc} */
                    get isNil() {
                      return this._intervals == null || this._intervals.length === 0;
                    }
                    /**
                     * Returns the maximum value contained in the set if not isNil.
                     *
                     * @return the maximum value contained in the set.
                     * @throws RangeError if set is empty
                     */
                    get maxElement() {
                      if (this.isNil) {
                        throw new RangeError("set is empty");
                      }
                      let last = this._intervals[this._intervals.length - 1];
                      return last.b;
                    }
                    /**
                     * Returns the minimum value contained in the set if not isNil.
                     *
                     * @return the minimum value contained in the set.
                     * @throws RangeError if set is empty
                     */
                    get minElement() {
                      if (this.isNil) {
                        throw new RangeError("set is empty");
                      }
                      return this._intervals[0].a;
                    }
                    /** Return a list of Interval objects. */
                    get intervals() {
                      return this._intervals;
                    }
                    hashCode() {
                      let hash = MurmurHash_1.MurmurHash.initialize();
                      for (let I of this._intervals) {
                        hash = MurmurHash_1.MurmurHash.update(hash, I.a);
                        hash = MurmurHash_1.MurmurHash.update(hash, I.b);
                      }
                      hash = MurmurHash_1.MurmurHash.finish(hash, this._intervals.length * 2);
                      return hash;
                    }
                    /** Are two IntervalSets equal?  Because all intervals are sorted
                     *  and disjoint, equals is a simple linear walk over both lists
                     *  to make sure they are the same.  Interval.equals() is used
                     *  by the List.equals() method to check the ranges.
                     */
                    equals(o) {
                      if (o == null || !(o instanceof IntervalSet)) {
                        return false;
                      }
                      return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);
                    }
                    toString(elemAreChar = false) {
                      let buf = "";
                      if (this._intervals == null || this._intervals.length === 0) {
                        return "{}";
                      }
                      if (this.size > 1) {
                        buf += "{";
                      }
                      let first = true;
                      for (let I of this._intervals) {
                        if (first) {
                          first = false;
                        } else {
                          buf += ", ";
                        }
                        let a = I.a;
                        let b = I.b;
                        if (a === b) {
                          if (a === Token_1.Token.EOF) {
                            buf += "<EOF>";
                          } else if (elemAreChar) {
                            buf += "'" + String.fromCodePoint(a) + "'";
                          } else {
                            buf += a;
                          }
                        } else {
                          if (elemAreChar) {
                            buf += "'" + String.fromCodePoint(a) + "'..'" + String.fromCodePoint(b) + "'";
                          } else {
                            buf += a + ".." + b;
                          }
                        }
                      }
                      if (this.size > 1) {
                        buf += "}";
                      }
                      return buf;
                    }
                    toStringVocabulary(vocabulary) {
                      if (this._intervals == null || this._intervals.length === 0) {
                        return "{}";
                      }
                      let buf = "";
                      if (this.size > 1) {
                        buf += "{";
                      }
                      let first = true;
                      for (let I of this._intervals) {
                        if (first) {
                          first = false;
                        } else {
                          buf += ", ";
                        }
                        let a = I.a;
                        let b = I.b;
                        if (a === b) {
                          buf += this.elementName(vocabulary, a);
                        } else {
                          for (let i = a; i <= b; i++) {
                            if (i > a) {
                              buf += ", ";
                            }
                            buf += this.elementName(vocabulary, i);
                          }
                        }
                      }
                      if (this.size > 1) {
                        buf += "}";
                      }
                      return buf;
                    }
                    elementName(vocabulary, a) {
                      if (a === Token_1.Token.EOF) {
                        return "<EOF>";
                      } else if (a === Token_1.Token.EPSILON) {
                        return "<EPSILON>";
                      } else {
                        return vocabulary.getDisplayName(a);
                      }
                    }
                    get size() {
                      let n = 0;
                      let numIntervals = this._intervals.length;
                      if (numIntervals === 1) {
                        let firstInterval = this._intervals[0];
                        return firstInterval.b - firstInterval.a + 1;
                      }
                      for (let i = 0; i < numIntervals; i++) {
                        let I = this._intervals[i];
                        n += I.b - I.a + 1;
                      }
                      return n;
                    }
                    toIntegerList() {
                      let values = new IntegerList_1.IntegerList(this.size);
                      let n = this._intervals.length;
                      for (let i = 0; i < n; i++) {
                        let I = this._intervals[i];
                        let a = I.a;
                        let b = I.b;
                        for (let v = a; v <= b; v++) {
                          values.add(v);
                        }
                      }
                      return values;
                    }
                    toSet() {
                      let s = /* @__PURE__ */ new Set();
                      for (let I of this._intervals) {
                        let a = I.a;
                        let b = I.b;
                        for (let v = a; v <= b; v++) {
                          s.add(v);
                        }
                      }
                      return s;
                    }
                    toArray() {
                      let values = new Array();
                      let n = this._intervals.length;
                      for (let i = 0; i < n; i++) {
                        let I = this._intervals[i];
                        let a = I.a;
                        let b = I.b;
                        for (let v = a; v <= b; v++) {
                          values.push(v);
                        }
                      }
                      return values;
                    }
                    remove(el) {
                      if (this.readonly) {
                        throw new Error("can't alter readonly IntervalSet");
                      }
                      let n = this._intervals.length;
                      for (let i = 0; i < n; i++) {
                        let I = this._intervals[i];
                        let a = I.a;
                        let b = I.b;
                        if (el < a) {
                          break;
                        }
                        if (el === a && el === b) {
                          this._intervals.splice(i, 1);
                          break;
                        }
                        if (el === a) {
                          this._intervals[i] = Interval_1.Interval.of(I.a + 1, I.b);
                          break;
                        }
                        if (el === b) {
                          this._intervals[i] = Interval_1.Interval.of(I.a, I.b - 1);
                          break;
                        }
                        if (el > a && el < b) {
                          let oldb = I.b;
                          this._intervals[i] = Interval_1.Interval.of(I.a, el - 1);
                          this.add(el + 1, oldb);
                        }
                      }
                    }
                    get isReadonly() {
                      return this.readonly;
                    }
                    setReadonly(readonly) {
                      if (this.readonly && !readonly) {
                        throw new Error("can't alter readonly IntervalSet");
                      }
                      this.readonly = readonly;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], IntervalSet.prototype, "addAll", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntervalSet.prototype, "complement", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntervalSet.prototype, "subtract", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntervalSet.prototype, "or", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntervalSet.prototype, "and", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntervalSet.prototype, "contains", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntervalSet.prototype, "isNil", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntervalSet.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntervalSet.prototype, "equals", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], IntervalSet.prototype, "toStringVocabulary", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], IntervalSet.prototype, "elementName", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntervalSet.prototype, "size", null);
                  __decorate([
                    Decorators_1.Override
                  ], IntervalSet.prototype, "remove", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], IntervalSet, "of", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], IntervalSet, "subtract", null);
                  exports2.IntervalSet = IntervalSet;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/MultiMap.js": (
                /*!************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/MultiMap.js ***!
                  \************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.MultiMap = void 0;
                  class MultiMap extends Map {
                    constructor() {
                      super();
                    }
                    map(key, value) {
                      let elementsForKey = super.get(key);
                      if (!elementsForKey) {
                        elementsForKey = [];
                        super.set(key, elementsForKey);
                      }
                      elementsForKey.push(value);
                    }
                    getPairs() {
                      let pairs2 = [];
                      this.forEach((values, key) => {
                        values.forEach((v) => {
                          pairs2.push([key, v]);
                        });
                      });
                      return pairs2;
                    }
                  }
                  exports2.MultiMap = MultiMap;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/MurmurHash.js": (
                /*!**************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/MurmurHash.js ***!
                  \**************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.MurmurHash = void 0;
                  var MurmurHash;
                  (function(MurmurHash2) {
                    const DEFAULT_SEED = 0;
                    function initialize(seed = DEFAULT_SEED) {
                      return seed;
                    }
                    MurmurHash2.initialize = initialize;
                    function update(hash, value) {
                      const c1 = 3432918353;
                      const c2 = 461845907;
                      const r1 = 15;
                      const r2 = 13;
                      const m = 5;
                      const n = 3864292196;
                      if (value == null) {
                        value = 0;
                      } else if (typeof value === "string") {
                        value = hashString(value);
                      } else if (typeof value === "object") {
                        value = value.hashCode();
                      }
                      let k = value;
                      k = Math.imul(k, c1);
                      k = k << r1 | k >>> 32 - r1;
                      k = Math.imul(k, c2);
                      hash = hash ^ k;
                      hash = hash << r2 | hash >>> 32 - r2;
                      hash = Math.imul(hash, m) + n;
                      return hash & 4294967295;
                    }
                    MurmurHash2.update = update;
                    function finish(hash, numberOfWords) {
                      hash = hash ^ numberOfWords * 4;
                      hash = hash ^ hash >>> 16;
                      hash = Math.imul(hash, 2246822507);
                      hash = hash ^ hash >>> 13;
                      hash = Math.imul(hash, 3266489909);
                      hash = hash ^ hash >>> 16;
                      return hash;
                    }
                    MurmurHash2.finish = finish;
                    function hashCode(data, seed = DEFAULT_SEED) {
                      let hash = initialize(seed);
                      let length = 0;
                      for (let value of data) {
                        hash = update(hash, value);
                        length++;
                      }
                      hash = finish(hash, length);
                      return hash;
                    }
                    MurmurHash2.hashCode = hashCode;
                    function hashString(str2) {
                      let len = str2.length;
                      if (len === 0) {
                        return 0;
                      }
                      let hash = 0;
                      for (let i = 0; i < len; i++) {
                        let c = str2.charCodeAt(i);
                        hash = (hash << 5 >>> 0) - hash + c;
                        hash |= 0;
                      }
                      return hash;
                    }
                  })(MurmurHash = exports2.MurmurHash || (exports2.MurmurHash = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/ObjectEqualityComparator.js": (
                /*!****************************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/ObjectEqualityComparator.js ***!
                  \****************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ObjectEqualityComparator = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class ObjectEqualityComparator {
                    /**
                     * {@inheritDoc}
                     *
                     * This implementation returns
                     * `obj.`{@link Object#hashCode hashCode()}.
                     */
                    hashCode(obj) {
                      if (obj == null) {
                        return 0;
                      }
                      return obj.hashCode();
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This implementation relies on object equality. If both objects are
                     * `undefined` or `null`, this method returns `true`. Otherwise if only
                     * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
                     * this method returns the result of
                     * `a.`{@link Object#equals equals}`(b)`.
                     */
                    equals(a, b) {
                      if (a == null) {
                        return b == null;
                      }
                      return a.equals(b);
                    }
                  }
                  ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator();
                  __decorate([
                    Decorators_1.Override
                  ], ObjectEqualityComparator.prototype, "hashCode", null);
                  __decorate([
                    Decorators_1.Override
                  ], ObjectEqualityComparator.prototype, "equals", null);
                  exports2.ObjectEqualityComparator = ObjectEqualityComparator;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/ParseCancellationException.js": (
                /*!******************************************************************!*\
                  !*** ./node_modules/antlr4ts/misc/ParseCancellationException.js ***!
                  \******************************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ParseCancellationException = void 0;
                  class ParseCancellationException extends Error {
                    constructor(cause) {
                      super(cause.message);
                      this.cause = cause;
                      this.stack = cause.stack;
                    }
                    getCause() {
                      return this.cause;
                    }
                  }
                  exports2.ParseCancellationException = ParseCancellationException;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/UUID.js": (
                /*!********************************************!*\
                  !*** ./node_modules/antlr4ts/misc/UUID.js ***!
                  \********************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.UUID = void 0;
                  const MurmurHash_1 = __webpack_require__2(
                    /*! ./MurmurHash */
                    "./node_modules/antlr4ts/misc/MurmurHash.js"
                  );
                  class UUID {
                    constructor(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {
                      this.data = new Uint32Array(4);
                      this.data[0] = mostSigBits;
                      this.data[1] = moreSigBits;
                      this.data[2] = lessSigBits;
                      this.data[3] = leastSigBits;
                    }
                    static fromString(data) {
                      if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {
                        throw new Error("Incorrectly formatted UUID");
                      }
                      let segments = data.split("-");
                      let mostSigBits = parseInt(segments[0], 16);
                      let moreSigBits = (parseInt(segments[1], 16) << 16 >>> 0) + parseInt(segments[2], 16);
                      let lessSigBits = (parseInt(segments[3], 16) << 16 >>> 0) + parseInt(segments[4].substr(0, 4), 16);
                      let leastSigBits = parseInt(segments[4].substr(-8), 16);
                      return new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
                    }
                    hashCode() {
                      return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);
                    }
                    equals(obj) {
                      if (obj === this) {
                        return true;
                      } else if (!(obj instanceof UUID)) {
                        return false;
                      }
                      return this.data[0] === obj.data[0] && this.data[1] === obj.data[1] && this.data[2] === obj.data[2] && this.data[3] === obj.data[3];
                    }
                    toString() {
                      return ("00000000" + this.data[0].toString(16)).substr(-8) + "-" + ("0000" + (this.data[1] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[1].toString(16)).substr(-4) + "-" + ("0000" + (this.data[2] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[2].toString(16)).substr(-4) + ("00000000" + this.data[3].toString(16)).substr(-8);
                    }
                  }
                  exports2.UUID = UUID;
                }
              ),
              /***/
              "./node_modules/antlr4ts/misc/Utils.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/antlr4ts/misc/Utils.js ***!
                  \*********************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.toCharArray = exports2.toMap = exports2.equals = exports2.join = exports2.escapeWhitespace = void 0;
                  function escapeWhitespace(s, escapeSpaces) {
                    return escapeSpaces ? s.replace(/ /, "\xB7") : s.replace(/\t/, "\\t").replace(/\n/, "\\n").replace(/\r/, "\\r");
                  }
                  exports2.escapeWhitespace = escapeWhitespace;
                  function join(collection, separator) {
                    let buf = "";
                    let first = true;
                    for (let current of collection) {
                      if (first) {
                        first = false;
                      } else {
                        buf += separator;
                      }
                      buf += current;
                    }
                    return buf;
                  }
                  exports2.join = join;
                  function equals(x, y) {
                    if (x === y) {
                      return true;
                    }
                    if (x === void 0 || y === void 0) {
                      return false;
                    }
                    return x.equals(y);
                  }
                  exports2.equals = equals;
                  function toMap(keys) {
                    let m = /* @__PURE__ */ new Map();
                    for (let i = 0; i < keys.length; i++) {
                      m.set(keys[i], i);
                    }
                    return m;
                  }
                  exports2.toMap = toMap;
                  function toCharArray(str2) {
                    if (typeof str2 === "string") {
                      let result = new Uint16Array(str2.length);
                      for (let i = 0; i < str2.length; i++) {
                        result[i] = str2.charCodeAt(i);
                      }
                      return result;
                    } else {
                      return str2.toCharArray();
                    }
                  }
                  exports2.toCharArray = toCharArray;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js": (
                /*!****************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js ***!
                  \****************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.AbstractParseTreeVisitor = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class AbstractParseTreeVisitor {
                    /**
                     * {@inheritDoc}
                     *
                     * The default implementation calls {@link ParseTree#accept} on the
                     * specified tree.
                     */
                    visit(tree) {
                      return tree.accept(this);
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The default implementation initializes the aggregate result to
                     * {@link #defaultResult defaultResult()}. Before visiting each child, it
                     * calls {@link #shouldVisitNextChild shouldVisitNextChild}; if the result
                     * is `false` no more children are visited and the current aggregate
                     * result is returned. After visiting a child, the aggregate result is
                     * updated by calling {@link #aggregateResult aggregateResult} with the
                     * previous aggregate result and the result of visiting the child.
                     *
                     * The default implementation is not safe for use in visitors that modify
                     * the tree structure. Visitors that modify the tree should override this
                     * method to behave properly in respect to the specific algorithm in use.
                     */
                    visitChildren(node) {
                      let result = this.defaultResult();
                      let n = node.childCount;
                      for (let i = 0; i < n; i++) {
                        if (!this.shouldVisitNextChild(node, result)) {
                          break;
                        }
                        let c = node.getChild(i);
                        let childResult = c.accept(this);
                        result = this.aggregateResult(result, childResult);
                      }
                      return result;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The default implementation returns the result of
                     * {@link #defaultResult defaultResult}.
                     */
                    visitTerminal(node) {
                      return this.defaultResult();
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The default implementation returns the result of
                     * {@link #defaultResult defaultResult}.
                     */
                    visitErrorNode(node) {
                      return this.defaultResult();
                    }
                    /**
                     * Aggregates the results of visiting multiple children of a node. After
                     * either all children are visited or {@link #shouldVisitNextChild} returns
                     * `false`, the aggregate value is returned as the result of
                     * {@link #visitChildren}.
                     *
                     * The default implementation returns `nextResult`, meaning
                     * {@link #visitChildren} will return the result of the last child visited
                     * (or return the initial value if the node has no children).
                     *
                     * @param aggregate The previous aggregate value. In the default
                     * implementation, the aggregate value is initialized to
                     * {@link #defaultResult}, which is passed as the `aggregate` argument
                     * to this method after the first child node is visited.
                     * @param nextResult The result of the immediately preceeding call to visit
                     * a child node.
                     *
                     * @returns The updated aggregate result.
                     */
                    aggregateResult(aggregate, nextResult) {
                      return nextResult;
                    }
                    /**
                     * This method is called after visiting each child in
                     * {@link #visitChildren}. This method is first called before the first
                     * child is visited; at that point `currentResult` will be the initial
                     * value (in the default implementation, the initial value is returned by a
                     * call to {@link #defaultResult}. This method is not called after the last
                     * child is visited.
                     *
                     * The default implementation always returns `true`, indicating that
                     * `visitChildren` should only return after all children are visited.
                     * One reason to override this method is to provide a "short circuit"
                     * evaluation option for situations where the result of visiting a single
                     * child has the potential to determine the result of the visit operation as
                     * a whole.
                     *
                     * @param node The {@link RuleNode} whose children are currently being
                     * visited.
                     * @param currentResult The current aggregate result of the children visited
                     * to the current point.
                     *
                     * @returns `true` to continue visiting children. Otherwise return
                     * `false` to stop visiting children and immediately return the
                     * current aggregate result from {@link #visitChildren}.
                     */
                    shouldVisitNextChild(node, currentResult) {
                      return true;
                    }
                  }
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], AbstractParseTreeVisitor.prototype, "visit", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], AbstractParseTreeVisitor.prototype, "visitChildren", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], AbstractParseTreeVisitor.prototype, "visitTerminal", null);
                  __decorate([
                    Decorators_1.Override,
                    __param(0, Decorators_1.NotNull)
                  ], AbstractParseTreeVisitor.prototype, "visitErrorNode", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], AbstractParseTreeVisitor.prototype, "shouldVisitNextChild", null);
                  exports2.AbstractParseTreeVisitor = AbstractParseTreeVisitor;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/ErrorNode.js": (
                /*!*************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/ErrorNode.js ***!
                  \*************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ErrorNode = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const TerminalNode_1 = __webpack_require__2(
                    /*! ./TerminalNode */
                    "./node_modules/antlr4ts/tree/TerminalNode.js"
                  );
                  class ErrorNode extends TerminalNode_1.TerminalNode {
                    constructor(token) {
                      super(token);
                    }
                    accept(visitor) {
                      return visitor.visitErrorNode(this);
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], ErrorNode.prototype, "accept", null);
                  exports2.ErrorNode = ErrorNode;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/ParseTreeWalker.js": (
                /*!*******************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/ParseTreeWalker.js ***!
                  \*******************************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ParseTreeWalker = void 0;
                  const ErrorNode_1 = __webpack_require__2(
                    /*! ./ErrorNode */
                    "./node_modules/antlr4ts/tree/ErrorNode.js"
                  );
                  const TerminalNode_1 = __webpack_require__2(
                    /*! ./TerminalNode */
                    "./node_modules/antlr4ts/tree/TerminalNode.js"
                  );
                  const RuleNode_1 = __webpack_require__2(
                    /*! ./RuleNode */
                    "./node_modules/antlr4ts/tree/RuleNode.js"
                  );
                  class ParseTreeWalker {
                    /**
                     * Performs a walk on the given parse tree starting at the root and going down recursively
                     * with depth-first search. On each node, {@link ParseTreeWalker#enterRule} is called before
                     * recursively walking down into child nodes, then
                     * {@link ParseTreeWalker#exitRule} is called after the recursive call to wind up.
                     * @param listener The listener used by the walker to process grammar rules
                     * @param t The parse tree to be walked on
                     */
                    walk(listener, t) {
                      let nodeStack = [];
                      let indexStack = [];
                      let currentNode = t;
                      let currentIndex = 0;
                      while (currentNode) {
                        if (currentNode instanceof ErrorNode_1.ErrorNode) {
                          if (listener.visitErrorNode) {
                            listener.visitErrorNode(currentNode);
                          }
                        } else if (currentNode instanceof TerminalNode_1.TerminalNode) {
                          if (listener.visitTerminal) {
                            listener.visitTerminal(currentNode);
                          }
                        } else {
                          this.enterRule(listener, currentNode);
                        }
                        if (currentNode.childCount > 0) {
                          nodeStack.push(currentNode);
                          indexStack.push(currentIndex);
                          currentIndex = 0;
                          currentNode = currentNode.getChild(0);
                          continue;
                        }
                        do {
                          if (currentNode instanceof RuleNode_1.RuleNode) {
                            this.exitRule(listener, currentNode);
                          }
                          if (nodeStack.length === 0) {
                            currentNode = void 0;
                            currentIndex = 0;
                            break;
                          }
                          let last = nodeStack[nodeStack.length - 1];
                          currentIndex++;
                          currentNode = currentIndex < last.childCount ? last.getChild(currentIndex) : void 0;
                          if (currentNode) {
                            break;
                          }
                          currentNode = nodeStack.pop();
                          currentIndex = indexStack.pop();
                        } while (currentNode);
                      }
                    }
                    /**
                     * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener#enterEveryRule}
                     * then by triggering the event specific to the given parse tree node
                     * @param listener The listener responding to the trigger events
                     * @param r The grammar rule containing the rule context
                     */
                    enterRule(listener, r) {
                      let ctx = r.ruleContext;
                      if (listener.enterEveryRule) {
                        listener.enterEveryRule(ctx);
                      }
                      ctx.enterRule(listener);
                    }
                    /**
                     * Exits a grammar rule by first triggering the event specific to the given parse tree node
                     * then by triggering the generic event {@link ParseTreeListener#exitEveryRule}
                     * @param listener The listener responding to the trigger events
                     * @param r The grammar rule containing the rule context
                     */
                    exitRule(listener, r) {
                      let ctx = r.ruleContext;
                      ctx.exitRule(listener);
                      if (listener.exitEveryRule) {
                        listener.exitEveryRule(ctx);
                      }
                    }
                  }
                  exports2.ParseTreeWalker = ParseTreeWalker;
                  (function(ParseTreeWalker2) {
                    ParseTreeWalker2.DEFAULT = new ParseTreeWalker2();
                  })(ParseTreeWalker = exports2.ParseTreeWalker || (exports2.ParseTreeWalker = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/RuleNode.js": (
                /*!************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/RuleNode.js ***!
                  \************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RuleNode = void 0;
                  class RuleNode {
                  }
                  exports2.RuleNode = RuleNode;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/TerminalNode.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/TerminalNode.js ***!
                  \****************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.TerminalNode = void 0;
                  const Interval_1 = __webpack_require__2(
                    /*! ../misc/Interval */
                    "./node_modules/antlr4ts/misc/Interval.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  class TerminalNode {
                    constructor(symbol) {
                      this._symbol = symbol;
                    }
                    getChild(i) {
                      throw new RangeError("Terminal Node has no children.");
                    }
                    get symbol() {
                      return this._symbol;
                    }
                    get parent() {
                      return this._parent;
                    }
                    setParent(parent) {
                      this._parent = parent;
                    }
                    get payload() {
                      return this._symbol;
                    }
                    get sourceInterval() {
                      let tokenIndex = this._symbol.tokenIndex;
                      return new Interval_1.Interval(tokenIndex, tokenIndex);
                    }
                    get childCount() {
                      return 0;
                    }
                    accept(visitor) {
                      return visitor.visitTerminal(this);
                    }
                    get text() {
                      return this._symbol.text || "";
                    }
                    toStringTree(parser) {
                      return this.toString();
                    }
                    toString() {
                      if (this._symbol.type === Token_1.Token.EOF) {
                        return "<EOF>";
                      }
                      return this._symbol.text || "";
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], TerminalNode.prototype, "getChild", null);
                  __decorate([
                    Decorators_1.Override
                  ], TerminalNode.prototype, "parent", null);
                  __decorate([
                    Decorators_1.Override
                  ], TerminalNode.prototype, "setParent", null);
                  __decorate([
                    Decorators_1.Override
                  ], TerminalNode.prototype, "payload", null);
                  __decorate([
                    Decorators_1.Override
                  ], TerminalNode.prototype, "sourceInterval", null);
                  __decorate([
                    Decorators_1.Override
                  ], TerminalNode.prototype, "childCount", null);
                  __decorate([
                    Decorators_1.Override
                  ], TerminalNode.prototype, "accept", null);
                  __decorate([
                    Decorators_1.Override
                  ], TerminalNode.prototype, "text", null);
                  __decorate([
                    Decorators_1.Override
                  ], TerminalNode.prototype, "toStringTree", null);
                  __decorate([
                    Decorators_1.Override
                  ], TerminalNode.prototype, "toString", null);
                  exports2.TerminalNode = TerminalNode;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/Trees.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/antlr4ts/tree/Trees.js ***!
                  \*********************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Trees = void 0;
                  const ATN_1 = __webpack_require__2(
                    /*! ../atn/ATN */
                    "./node_modules/antlr4ts/atn/ATN.js"
                  );
                  const CommonToken_1 = __webpack_require__2(
                    /*! ../CommonToken */
                    "./node_modules/antlr4ts/CommonToken.js"
                  );
                  const ErrorNode_1 = __webpack_require__2(
                    /*! ./ErrorNode */
                    "./node_modules/antlr4ts/tree/ErrorNode.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Parser_1 = __webpack_require__2(
                    /*! ../Parser */
                    "./node_modules/antlr4ts/Parser.js"
                  );
                  const ParserRuleContext_1 = __webpack_require__2(
                    /*! ../ParserRuleContext */
                    "./node_modules/antlr4ts/ParserRuleContext.js"
                  );
                  const RuleNode_1 = __webpack_require__2(
                    /*! ./RuleNode */
                    "./node_modules/antlr4ts/tree/RuleNode.js"
                  );
                  const TerminalNode_1 = __webpack_require__2(
                    /*! ./TerminalNode */
                    "./node_modules/antlr4ts/tree/TerminalNode.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const Utils = __webpack_require__2(
                    /*! ../misc/Utils */
                    "./node_modules/antlr4ts/misc/Utils.js"
                  );
                  class Trees {
                    static toStringTree(t, arg2) {
                      let ruleNames;
                      if (arg2 instanceof Parser_1.Parser) {
                        ruleNames = arg2.ruleNames;
                      } else {
                        ruleNames = arg2;
                      }
                      let s = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);
                      if (t.childCount === 0) {
                        return s;
                      }
                      let buf = "";
                      buf += "(";
                      s = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);
                      buf += s;
                      buf += " ";
                      for (let i = 0; i < t.childCount; i++) {
                        if (i > 0) {
                          buf += " ";
                        }
                        buf += this.toStringTree(t.getChild(i), ruleNames);
                      }
                      buf += ")";
                      return buf;
                    }
                    static getNodeText(t, arg2) {
                      let ruleNames;
                      if (arg2 instanceof Parser_1.Parser) {
                        ruleNames = arg2.ruleNames;
                      } else if (arg2) {
                        ruleNames = arg2;
                      } else {
                        let payload = t.payload;
                        if (typeof payload.text === "string") {
                          return payload.text;
                        }
                        return t.payload.toString();
                      }
                      if (t instanceof RuleNode_1.RuleNode) {
                        let ruleContext = t.ruleContext;
                        let ruleIndex = ruleContext.ruleIndex;
                        let ruleName = ruleNames[ruleIndex];
                        let altNumber = ruleContext.altNumber;
                        if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                          return ruleName + ":" + altNumber;
                        }
                        return ruleName;
                      } else if (t instanceof ErrorNode_1.ErrorNode) {
                        return t.toString();
                      } else if (t instanceof TerminalNode_1.TerminalNode) {
                        let symbol = t.symbol;
                        return symbol.text || "";
                      }
                      throw new TypeError("Unexpected node type");
                    }
                    static getChildren(t) {
                      let kids = [];
                      for (let i = 0; i < t.childCount; i++) {
                        kids.push(t.getChild(i));
                      }
                      return kids;
                    }
                    static getAncestors(t) {
                      let ancestors = [];
                      let p = t.parent;
                      while (p) {
                        ancestors.unshift(p);
                        p = p.parent;
                      }
                      return ancestors;
                    }
                    /** Return true if t is u's parent or a node on path to root from u.
                     *  Use === not equals().
                     *
                     *  @since 4.5.1
                     */
                    static isAncestorOf(t, u) {
                      if (!t || !u || !t.parent) {
                        return false;
                      }
                      let p = u.parent;
                      while (p) {
                        if (t === p) {
                          return true;
                        }
                        p = p.parent;
                      }
                      return false;
                    }
                    static findAllTokenNodes(t, ttype) {
                      return Trees.findAllNodes(t, ttype, true);
                    }
                    static findAllRuleNodes(t, ruleIndex) {
                      return Trees.findAllNodes(t, ruleIndex, false);
                    }
                    static findAllNodes(t, index, findTokens) {
                      let nodes = [];
                      Trees._findAllNodes(t, index, findTokens, nodes);
                      return nodes;
                    }
                    static _findAllNodes(t, index, findTokens, nodes) {
                      if (findTokens && t instanceof TerminalNode_1.TerminalNode) {
                        if (t.symbol.type === index) {
                          nodes.push(t);
                        }
                      } else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {
                        if (t.ruleIndex === index) {
                          nodes.push(t);
                        }
                      }
                      for (let i = 0; i < t.childCount; i++) {
                        Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
                      }
                    }
                    /** Get all descendents; includes t itself.
                     *
                     * @since 4.5.1
                     */
                    static getDescendants(t) {
                      let nodes = [];
                      function recurse(e) {
                        nodes.push(e);
                        const n = e.childCount;
                        for (let i = 0; i < n; i++) {
                          recurse(e.getChild(i));
                        }
                      }
                      recurse(t);
                      return nodes;
                    }
                    /** Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex
                     *  inclusively using postorder traversal.  Recursive depth-first-search.
                     *
                     *  @since 4.5
                     */
                    static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
                      let n = t.childCount;
                      for (let i = 0; i < n; i++) {
                        let child = t.getChild(i);
                        let r = Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
                        if (r) {
                          return r;
                        }
                      }
                      if (t instanceof ParserRuleContext_1.ParserRuleContext) {
                        let stopToken = t.stop;
                        if (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?
                        (stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {
                          return t;
                        }
                      }
                      return void 0;
                    }
                    /** Replace any subtree siblings of root that are completely to left
                     *  or right of lookahead range with a CommonToken(Token.INVALID_TYPE,"...")
                     *  node. The source interval for t is not altered to suit smaller range!
                     *
                     *  WARNING: destructive to t.
                     *
                     *  @since 4.5.1
                     */
                    static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
                      if (!t) {
                        return;
                      }
                      let count = t.childCount;
                      for (let i = 0; i < count; i++) {
                        let child = t.getChild(i);
                        let range = child.sourceInterval;
                        if (child instanceof ParserRuleContext_1.ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {
                          if (Trees.isAncestorOf(child, root)) {
                            let abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, "...");
                            t.children[i] = new TerminalNode_1.TerminalNode(abbrev);
                          }
                        }
                      }
                    }
                    static findNodeSuchThat(t, pred) {
                      if (pred(t)) {
                        return t;
                      }
                      let n = t.childCount;
                      for (let i = 0; i < n; i++) {
                        let u = Trees.findNodeSuchThat(t.getChild(i), pred);
                        if (u !== void 0) {
                          return u;
                        }
                      }
                      return void 0;
                    }
                  }
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], Trees, "toStringTree", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], Trees, "getAncestors", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], Trees, "getRootOfSubtreeEnclosingRegion", null);
                  exports2.Trees = Trees;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/pattern/Chunk.js": (
                /*!*****************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/pattern/Chunk.js ***!
                  \*****************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Chunk = void 0;
                  class Chunk {
                  }
                  exports2.Chunk = Chunk;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js": (
                /*!**************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js ***!
                  \**************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ParseTreeMatch = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let ParseTreeMatch = class ParseTreeMatch {
                    /**
                     * Constructs a new instance of {@link ParseTreeMatch} from the specified
                     * parse tree and pattern.
                     *
                     * @param tree The parse tree to match against the pattern.
                     * @param pattern The parse tree pattern.
                     * @param labels A mapping from label names to collections of
                     * {@link ParseTree} objects located by the tree pattern matching process.
                     * @param mismatchedNode The first node which failed to match the tree
                     * pattern during the matching process.
                     *
                     * @throws {@link Error} if `tree` is not defined
                     * @throws {@link Error} if `pattern` is not defined
                     * @throws {@link Error} if `labels` is not defined
                     */
                    constructor(tree, pattern, labels, mismatchedNode) {
                      if (!tree) {
                        throw new Error("tree cannot be null");
                      }
                      if (!pattern) {
                        throw new Error("pattern cannot be null");
                      }
                      if (!labels) {
                        throw new Error("labels cannot be null");
                      }
                      this._tree = tree;
                      this._pattern = pattern;
                      this._labels = labels;
                      this._mismatchedNode = mismatchedNode;
                    }
                    /**
                     * Get the last node associated with a specific `label`.
                     *
                     * For example, for pattern `<id:ID>`, `get("id")` returns the
                     * node matched for that `ID`. If more than one node
                     * matched the specified label, only the last is returned. If there is
                     * no node associated with the label, this returns `undefined`.
                     *
                     * Pattern tags like `<ID>` and `<expr>` without labels are
                     * considered to be labeled with `ID` and `expr`, respectively.
                     *
                     * @param label The label to check.
                     *
                     * @returns The last {@link ParseTree} to match a tag with the specified
                     * label, or `undefined` if no parse tree matched a tag with the label.
                     */
                    get(label) {
                      let parseTrees = this._labels.get(label);
                      if (!parseTrees || parseTrees.length === 0) {
                        return void 0;
                      }
                      return parseTrees[parseTrees.length - 1];
                    }
                    /**
                     * Return all nodes matching a rule or token tag with the specified label.
                     *
                     * If the `label` is the name of a parser rule or token in the
                     * grammar, the resulting list will contain both the parse trees matching
                     * rule or tags explicitly labeled with the label and the complete set of
                     * parse trees matching the labeled and unlabeled tags in the pattern for
                     * the parser rule or token. For example, if `label` is `"foo"`,
                     * the result will contain *all* of the following.
                     *
                     * * Parse tree nodes matching tags of the form `<foo:anyRuleName>` and
                     *   `<foo:AnyTokenName>`.
                     * * Parse tree nodes matching tags of the form `<anyLabel:foo>`.
                     * * Parse tree nodes matching tags of the form `<foo>`.
                     *
                     * @param label The label.
                     *
                     * @returns A collection of all {@link ParseTree} nodes matching tags with
                     * the specified `label`. If no nodes matched the label, an empty list
                     * is returned.
                     */
                    getAll(label) {
                      const nodes = this._labels.get(label);
                      if (!nodes) {
                        return [];
                      }
                      return nodes;
                    }
                    /**
                     * Return a mapping from label &rarr; [list of nodes].
                     *
                     * The map includes special entries corresponding to the names of rules and
                     * tokens referenced in tags in the original pattern. For additional
                     * information, see the description of {@link #getAll(String)}.
                     *
                     * @returns A mapping from labels to parse tree nodes. If the parse tree
                     * pattern did not contain any rule or token tags, this map will be empty.
                     */
                    get labels() {
                      return this._labels;
                    }
                    /**
                     * Get the node at which we first detected a mismatch.
                     *
                     * @returns the node at which we first detected a mismatch, or `undefined`
                     * if the match was successful.
                     */
                    get mismatchedNode() {
                      return this._mismatchedNode;
                    }
                    /**
                     * Gets a value indicating whether the match operation succeeded.
                     *
                     * @returns `true` if the match operation succeeded; otherwise,
                     * `false`.
                     */
                    get succeeded() {
                      return !this._mismatchedNode;
                    }
                    /**
                     * Get the tree pattern we are matching against.
                     *
                     * @returns The tree pattern we are matching against.
                     */
                    get pattern() {
                      return this._pattern;
                    }
                    /**
                     * Get the parse tree we are trying to match to a pattern.
                     *
                     * @returns The {@link ParseTree} we are trying to match to a pattern.
                     */
                    get tree() {
                      return this._tree;
                    }
                    /**
                     * {@inheritDoc}
                     */
                    toString() {
                      return `Match ${this.succeeded ? "succeeded" : "failed"}; found ${this.labels.size} labels`;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], ParseTreeMatch.prototype, "getAll", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseTreeMatch.prototype, "labels", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseTreeMatch.prototype, "pattern", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseTreeMatch.prototype, "tree", null);
                  __decorate([
                    Decorators_1.Override
                  ], ParseTreeMatch.prototype, "toString", null);
                  ParseTreeMatch = __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ParseTreeMatch);
                  exports2.ParseTreeMatch = ParseTreeMatch;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/pattern/ParseTreePattern.js": (
                /*!****************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/pattern/ParseTreePattern.js ***!
                  \****************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ParseTreePattern = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const XPath_1 = __webpack_require__2(
                    /*! ../xpath/XPath */
                    "./node_modules/antlr4ts/tree/xpath/XPath.js"
                  );
                  let ParseTreePattern = class ParseTreePattern {
                    /**
                     * Construct a new instance of the {@link ParseTreePattern} class.
                     *
                     * @param matcher The {@link ParseTreePatternMatcher} which created this
                     * tree pattern.
                     * @param pattern The tree pattern in concrete syntax form.
                     * @param patternRuleIndex The parser rule which serves as the root of the
                     * tree pattern.
                     * @param patternTree The tree pattern in {@link ParseTree} form.
                     */
                    constructor(matcher, pattern, patternRuleIndex, patternTree) {
                      this._matcher = matcher;
                      this._patternRuleIndex = patternRuleIndex;
                      this._pattern = pattern;
                      this._patternTree = patternTree;
                    }
                    /**
                     * Match a specific parse tree against this tree pattern.
                     *
                     * @param tree The parse tree to match against this tree pattern.
                     * @returns A {@link ParseTreeMatch} object describing the result of the
                     * match operation. The `ParseTreeMatch.succeeded` method can be
                     * used to determine whether or not the match was successful.
                     */
                    match(tree) {
                      return this._matcher.match(tree, this);
                    }
                    /**
                     * Determine whether or not a parse tree matches this tree pattern.
                     *
                     * @param tree The parse tree to match against this tree pattern.
                     * @returns `true` if `tree` is a match for the current tree
                     * pattern; otherwise, `false`.
                     */
                    matches(tree) {
                      return this._matcher.match(tree, this).succeeded;
                    }
                    /**
                     * Find all nodes using XPath and then try to match those subtrees against
                     * this tree pattern.
                     *
                     * @param tree The {@link ParseTree} to match against this pattern.
                     * @param xpath An expression matching the nodes
                     *
                     * @returns A collection of {@link ParseTreeMatch} objects describing the
                     * successful matches. Unsuccessful matches are omitted from the result,
                     * regardless of the reason for the failure.
                     */
                    findAll(tree, xpath) {
                      let subtrees = XPath_1.XPath.findAll(tree, xpath, this._matcher.parser);
                      let matches = [];
                      for (let t of subtrees) {
                        let match = this.match(t);
                        if (match.succeeded) {
                          matches.push(match);
                        }
                      }
                      return matches;
                    }
                    /**
                     * Get the {@link ParseTreePatternMatcher} which created this tree pattern.
                     *
                     * @returns The {@link ParseTreePatternMatcher} which created this tree
                     * pattern.
                     */
                    get matcher() {
                      return this._matcher;
                    }
                    /**
                     * Get the tree pattern in concrete syntax form.
                     *
                     * @returns The tree pattern in concrete syntax form.
                     */
                    get pattern() {
                      return this._pattern;
                    }
                    /**
                     * Get the parser rule which serves as the outermost rule for the tree
                     * pattern.
                     *
                     * @returns The parser rule which serves as the outermost rule for the tree
                     * pattern.
                     */
                    get patternRuleIndex() {
                      return this._patternRuleIndex;
                    }
                    /**
                     * Get the tree pattern as a {@link ParseTree}. The rule and token tags from
                     * the pattern are present in the parse tree as terminal nodes with a symbol
                     * of type {@link RuleTagToken} or {@link TokenTagToken}.
                     *
                     * @returns The tree pattern as a {@link ParseTree}.
                     */
                    get patternTree() {
                      return this._patternTree;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseTreePattern.prototype, "_pattern", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseTreePattern.prototype, "_patternTree", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseTreePattern.prototype, "_matcher", void 0);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull)
                  ], ParseTreePattern.prototype, "match", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], ParseTreePattern.prototype, "matches", null);
                  __decorate([
                    Decorators_1.NotNull,
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull)
                  ], ParseTreePattern.prototype, "findAll", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseTreePattern.prototype, "matcher", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseTreePattern.prototype, "pattern", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseTreePattern.prototype, "patternTree", null);
                  ParseTreePattern = __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(3, Decorators_1.NotNull)
                  ], ParseTreePattern);
                  exports2.ParseTreePattern = ParseTreePattern;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js": (
                /*!***********************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js ***!
                  \***********************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ParseTreePatternMatcher = void 0;
                  const BailErrorStrategy_1 = __webpack_require__2(
                    /*! ../../BailErrorStrategy */
                    "./node_modules/antlr4ts/BailErrorStrategy.js"
                  );
                  const CharStreams_1 = __webpack_require__2(
                    /*! ../../CharStreams */
                    "./node_modules/antlr4ts/CharStreams.js"
                  );
                  const CommonTokenStream_1 = __webpack_require__2(
                    /*! ../../CommonTokenStream */
                    "./node_modules/antlr4ts/CommonTokenStream.js"
                  );
                  const ListTokenSource_1 = __webpack_require__2(
                    /*! ../../ListTokenSource */
                    "./node_modules/antlr4ts/ListTokenSource.js"
                  );
                  const MultiMap_1 = __webpack_require__2(
                    /*! ../../misc/MultiMap */
                    "./node_modules/antlr4ts/misc/MultiMap.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const ParseCancellationException_1 = __webpack_require__2(
                    /*! ../../misc/ParseCancellationException */
                    "./node_modules/antlr4ts/misc/ParseCancellationException.js"
                  );
                  const ParserInterpreter_1 = __webpack_require__2(
                    /*! ../../ParserInterpreter */
                    "./node_modules/antlr4ts/ParserInterpreter.js"
                  );
                  const ParserRuleContext_1 = __webpack_require__2(
                    /*! ../../ParserRuleContext */
                    "./node_modules/antlr4ts/ParserRuleContext.js"
                  );
                  const ParseTreeMatch_1 = __webpack_require__2(
                    /*! ./ParseTreeMatch */
                    "./node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js"
                  );
                  const ParseTreePattern_1 = __webpack_require__2(
                    /*! ./ParseTreePattern */
                    "./node_modules/antlr4ts/tree/pattern/ParseTreePattern.js"
                  );
                  const RecognitionException_1 = __webpack_require__2(
                    /*! ../../RecognitionException */
                    "./node_modules/antlr4ts/RecognitionException.js"
                  );
                  const RuleNode_1 = __webpack_require__2(
                    /*! ../RuleNode */
                    "./node_modules/antlr4ts/tree/RuleNode.js"
                  );
                  const RuleTagToken_1 = __webpack_require__2(
                    /*! ./RuleTagToken */
                    "./node_modules/antlr4ts/tree/pattern/RuleTagToken.js"
                  );
                  const TagChunk_1 = __webpack_require__2(
                    /*! ./TagChunk */
                    "./node_modules/antlr4ts/tree/pattern/TagChunk.js"
                  );
                  const TerminalNode_1 = __webpack_require__2(
                    /*! ../TerminalNode */
                    "./node_modules/antlr4ts/tree/TerminalNode.js"
                  );
                  const TextChunk_1 = __webpack_require__2(
                    /*! ./TextChunk */
                    "./node_modules/antlr4ts/tree/pattern/TextChunk.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const TokenTagToken_1 = __webpack_require__2(
                    /*! ./TokenTagToken */
                    "./node_modules/antlr4ts/tree/pattern/TokenTagToken.js"
                  );
                  class ParseTreePatternMatcher {
                    /**
                     * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and
                     * {@link Parser} object. The lexer input stream is altered for tokenizing
                     * the tree patterns. The parser is used as a convenient mechanism to get
                     * the grammar name, plus token, rule names.
                     */
                    constructor(lexer, parser) {
                      this.start = "<";
                      this.stop = ">";
                      this.escape = "\\";
                      this.escapeRE = /\\/g;
                      this._lexer = lexer;
                      this._parser = parser;
                    }
                    /**
                     * Set the delimiters used for marking rule and token tags within concrete
                     * syntax used by the tree pattern parser.
                     *
                     * @param start The start delimiter.
                     * @param stop The stop delimiter.
                     * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.
                     *
                     * @throws {@link Error} if `start` is not defined or empty.
                     * @throws {@link Error} if `stop` is not defined or empty.
                     */
                    setDelimiters(start, stop, escapeLeft) {
                      if (!start) {
                        throw new Error("start cannot be null or empty");
                      }
                      if (!stop) {
                        throw new Error("stop cannot be null or empty");
                      }
                      this.start = start;
                      this.stop = stop;
                      this.escape = escapeLeft;
                      this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
                    }
                    matches(tree, pattern, patternRuleIndex = 0) {
                      if (typeof pattern === "string") {
                        let p = this.compile(pattern, patternRuleIndex);
                        return this.matches(tree, p);
                      } else {
                        let labels = new MultiMap_1.MultiMap();
                        let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
                        return !mismatchedNode;
                      }
                    }
                    // Implementation of match
                    match(tree, pattern, patternRuleIndex = 0) {
                      if (typeof pattern === "string") {
                        let p = this.compile(pattern, patternRuleIndex);
                        return this.match(tree, p);
                      } else {
                        let labels = new MultiMap_1.MultiMap();
                        let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
                        return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);
                      }
                    }
                    /**
                     * For repeated use of a tree pattern, compile it to a
                     * {@link ParseTreePattern} using this method.
                     */
                    compile(pattern, patternRuleIndex) {
                      let tokenList = this.tokenize(pattern);
                      let tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);
                      let tokens = new CommonTokenStream_1.CommonTokenStream(tokenSrc);
                      const parser = this._parser;
                      let parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens);
                      let tree;
                      try {
                        parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();
                        tree = parserInterp.parse(patternRuleIndex);
                      } catch (e) {
                        if (e instanceof ParseCancellationException_1.ParseCancellationException) {
                          throw e.getCause();
                        } else if (e instanceof RecognitionException_1.RecognitionException) {
                          throw e;
                        } else if (e instanceof Error) {
                          throw new ParseTreePatternMatcher.CannotInvokeStartRule(e);
                        } else {
                          throw e;
                        }
                      }
                      if (tokens.LA(1) !== Token_1.Token.EOF) {
                        throw new ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();
                      }
                      return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);
                    }
                    /**
                     * Used to convert the tree pattern string into a series of tokens. The
                     * input stream is reset.
                     */
                    get lexer() {
                      return this._lexer;
                    }
                    /**
                     * Used to collect to the grammar file name, token names, rule names for
                     * used to parse the pattern into a parse tree.
                     */
                    get parser() {
                      return this._parser;
                    }
                    // ---- SUPPORT CODE ----
                    /**
                     * Recursively walk `tree` against `patternTree`, filling
                     * `match.`{@link ParseTreeMatch#labels labels}.
                     *
                     * @returns the first node encountered in `tree` which does not match
                     * a corresponding node in `patternTree`, or `undefined` if the match
                     * was successful. The specific node returned depends on the matching
                     * algorithm used by the implementation, and may be overridden.
                     */
                    matchImpl(tree, patternTree, labels) {
                      if (!tree) {
                        throw new TypeError("tree cannot be null");
                      }
                      if (!patternTree) {
                        throw new TypeError("patternTree cannot be null");
                      }
                      if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {
                        let mismatchedNode;
                        if (tree.symbol.type === patternTree.symbol.type) {
                          if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) {
                            let tokenTagToken = patternTree.symbol;
                            labels.map(tokenTagToken.tokenName, tree);
                            const l = tokenTagToken.label;
                            if (l) {
                              labels.map(l, tree);
                            }
                          } else if (tree.text === patternTree.text) {
                          } else {
                            if (!mismatchedNode) {
                              mismatchedNode = tree;
                            }
                          }
                        } else {
                          if (!mismatchedNode) {
                            mismatchedNode = tree;
                          }
                        }
                        return mismatchedNode;
                      }
                      if (tree instanceof ParserRuleContext_1.ParserRuleContext && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {
                        let mismatchedNode;
                        let ruleTagToken = this.getRuleTagToken(patternTree);
                        if (ruleTagToken) {
                          let m;
                          if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {
                            labels.map(ruleTagToken.ruleName, tree);
                            const l = ruleTagToken.label;
                            if (l) {
                              labels.map(l, tree);
                            }
                          } else {
                            if (!mismatchedNode) {
                              mismatchedNode = tree;
                            }
                          }
                          return mismatchedNode;
                        }
                        if (tree.childCount !== patternTree.childCount) {
                          if (!mismatchedNode) {
                            mismatchedNode = tree;
                          }
                          return mismatchedNode;
                        }
                        let n = tree.childCount;
                        for (let i = 0; i < n; i++) {
                          let childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
                          if (childMatch) {
                            return childMatch;
                          }
                        }
                        return mismatchedNode;
                      }
                      return tree;
                    }
                    /** Is `t` `(expr <expr>)` subtree? */
                    getRuleTagToken(t) {
                      if (t instanceof RuleNode_1.RuleNode) {
                        if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {
                          let c = t.getChild(0);
                          if (c.symbol instanceof RuleTagToken_1.RuleTagToken) {
                            return c.symbol;
                          }
                        }
                      }
                      return void 0;
                    }
                    tokenize(pattern) {
                      let chunks = this.split(pattern);
                      let tokens = [];
                      for (let chunk of chunks) {
                        if (chunk instanceof TagChunk_1.TagChunk) {
                          let tagChunk = chunk;
                          const firstChar = tagChunk.tag.substr(0, 1);
                          if (firstChar === firstChar.toUpperCase()) {
                            let ttype = this._parser.getTokenType(tagChunk.tag);
                            if (ttype === Token_1.Token.INVALID_TYPE) {
                              throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
                            }
                            let t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
                            tokens.push(t);
                          } else if (firstChar === firstChar.toLowerCase()) {
                            let ruleIndex = this._parser.getRuleIndex(tagChunk.tag);
                            if (ruleIndex === -1) {
                              throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
                            }
                            let ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
                            tokens.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
                          } else {
                            throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
                          }
                        } else {
                          let textChunk = chunk;
                          this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);
                          let t = this._lexer.nextToken();
                          while (t.type !== Token_1.Token.EOF) {
                            tokens.push(t);
                            t = this._lexer.nextToken();
                          }
                        }
                      }
                      return tokens;
                    }
                    /** Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}. */
                    split(pattern) {
                      let p = 0;
                      let n = pattern.length;
                      let chunks = [];
                      let buf;
                      let starts = [];
                      let stops = [];
                      while (p < n) {
                        if (p === pattern.indexOf(this.escape + this.start, p)) {
                          p += this.escape.length + this.start.length;
                        } else if (p === pattern.indexOf(this.escape + this.stop, p)) {
                          p += this.escape.length + this.stop.length;
                        } else if (p === pattern.indexOf(this.start, p)) {
                          starts.push(p);
                          p += this.start.length;
                        } else if (p === pattern.indexOf(this.stop, p)) {
                          stops.push(p);
                          p += this.stop.length;
                        } else {
                          p++;
                        }
                      }
                      if (starts.length > stops.length) {
                        throw new Error("unterminated tag in pattern: " + pattern);
                      }
                      if (starts.length < stops.length) {
                        throw new Error("missing start tag in pattern: " + pattern);
                      }
                      let ntags = starts.length;
                      for (let i = 0; i < ntags; i++) {
                        if (starts[i] >= stops[i]) {
                          throw new Error("tag delimiters out of order in pattern: " + pattern);
                        }
                      }
                      if (ntags === 0) {
                        let text = pattern.substring(0, n);
                        chunks.push(new TextChunk_1.TextChunk(text));
                      }
                      if (ntags > 0 && starts[0] > 0) {
                        let text = pattern.substring(0, starts[0]);
                        chunks.push(new TextChunk_1.TextChunk(text));
                      }
                      for (let i = 0; i < ntags; i++) {
                        let tag = pattern.substring(starts[i] + this.start.length, stops[i]);
                        let ruleOrToken = tag;
                        let label;
                        let colon = tag.indexOf(":");
                        if (colon >= 0) {
                          label = tag.substring(0, colon);
                          ruleOrToken = tag.substring(colon + 1, tag.length);
                        }
                        chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));
                        if (i + 1 < ntags) {
                          let text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);
                          chunks.push(new TextChunk_1.TextChunk(text));
                        }
                      }
                      if (ntags > 0) {
                        let afterLastTag = stops[ntags - 1] + this.stop.length;
                        if (afterLastTag < n) {
                          let text = pattern.substring(afterLastTag, n);
                          chunks.push(new TextChunk_1.TextChunk(text));
                        }
                      }
                      for (let i = 0; i < chunks.length; i++) {
                        let c = chunks[i];
                        if (c instanceof TextChunk_1.TextChunk) {
                          let unescaped = c.text.replace(this.escapeRE, "");
                          if (unescaped.length < c.text.length) {
                            chunks[i] = new TextChunk_1.TextChunk(unescaped);
                          }
                        }
                      }
                      return chunks;
                    }
                  }
                  __decorate([
                    Decorators_1.NotNull,
                    __param(1, Decorators_1.NotNull)
                  ], ParseTreePatternMatcher.prototype, "match", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseTreePatternMatcher.prototype, "lexer", null);
                  __decorate([
                    Decorators_1.NotNull
                  ], ParseTreePatternMatcher.prototype, "parser", null);
                  __decorate([
                    __param(0, Decorators_1.NotNull),
                    __param(1, Decorators_1.NotNull),
                    __param(2, Decorators_1.NotNull)
                  ], ParseTreePatternMatcher.prototype, "matchImpl", null);
                  exports2.ParseTreePatternMatcher = ParseTreePatternMatcher;
                  (function(ParseTreePatternMatcher2) {
                    class CannotInvokeStartRule extends Error {
                      constructor(error) {
                        super(`CannotInvokeStartRule: ${error}`);
                        this.error = error;
                      }
                    }
                    ParseTreePatternMatcher2.CannotInvokeStartRule = CannotInvokeStartRule;
                    class StartRuleDoesNotConsumeFullPattern extends Error {
                      constructor() {
                        super("StartRuleDoesNotConsumeFullPattern");
                      }
                    }
                    ParseTreePatternMatcher2.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;
                  })(ParseTreePatternMatcher = exports2.ParseTreePatternMatcher || (exports2.ParseTreePatternMatcher = {}));
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/pattern/RuleTagToken.js": (
                /*!************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/pattern/RuleTagToken.js ***!
                  \************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.RuleTagToken = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  let RuleTagToken = class RuleTagToken {
                    /**
                     * Constructs a new instance of {@link RuleTagToken} with the specified rule
                     * name, bypass token type, and label.
                     *
                     * @param ruleName The name of the parser rule this rule tag matches.
                     * @param bypassTokenType The bypass token type assigned to the parser rule.
                     * @param label The label associated with the rule tag, or `undefined` if
                     * the rule tag is unlabeled.
                     *
                     * @exception IllegalArgumentException if `ruleName` is not defined
                     * or empty.
                     */
                    constructor(ruleName, bypassTokenType, label) {
                      if (ruleName == null || ruleName.length === 0) {
                        throw new Error("ruleName cannot be null or empty.");
                      }
                      this._ruleName = ruleName;
                      this.bypassTokenType = bypassTokenType;
                      this._label = label;
                    }
                    /**
                     * Gets the name of the rule associated with this rule tag.
                     *
                     * @returns The name of the parser rule associated with this rule tag.
                     */
                    get ruleName() {
                      return this._ruleName;
                    }
                    /**
                     * Gets the label associated with the rule tag.
                     *
                     * @returns The name of the label associated with the rule tag, or
                     * `undefined` if this is an unlabeled rule tag.
                     */
                    get label() {
                      return this._label;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.
                     */
                    get channel() {
                      return Token_1.Token.DEFAULT_CHANNEL;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * This method returns the rule tag formatted with `<` and `>`
                     * delimiters.
                     */
                    get text() {
                      if (this._label != null) {
                        return "<" + this._label + ":" + this._ruleName + ">";
                      }
                      return "<" + this._ruleName + ">";
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * Rule tag tokens have types assigned according to the rule bypass
                     * transitions created during ATN deserialization.
                     */
                    get type() {
                      return this.bypassTokenType;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The implementation for {@link RuleTagToken} always returns 0.
                     */
                    get line() {
                      return 0;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The implementation for {@link RuleTagToken} always returns -1.
                     */
                    get charPositionInLine() {
                      return -1;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The implementation for {@link RuleTagToken} always returns -1.
                     */
                    get tokenIndex() {
                      return -1;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The implementation for {@link RuleTagToken} always returns -1.
                     */
                    get startIndex() {
                      return -1;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The implementation for {@link RuleTagToken} always returns -1.
                     */
                    get stopIndex() {
                      return -1;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The implementation for {@link RuleTagToken} always returns `undefined`.
                     */
                    get tokenSource() {
                      return void 0;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The implementation for {@link RuleTagToken} always returns `undefined`.
                     */
                    get inputStream() {
                      return void 0;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The implementation for {@link RuleTagToken} returns a string of the form
                     * `ruleName:bypassTokenType`.
                     */
                    toString() {
                      return this._ruleName + ":" + this.bypassTokenType;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], RuleTagToken.prototype, "ruleName", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTagToken.prototype, "channel", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTagToken.prototype, "text", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTagToken.prototype, "type", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTagToken.prototype, "line", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTagToken.prototype, "charPositionInLine", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTagToken.prototype, "tokenIndex", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTagToken.prototype, "startIndex", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTagToken.prototype, "stopIndex", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTagToken.prototype, "tokenSource", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTagToken.prototype, "inputStream", null);
                  __decorate([
                    Decorators_1.Override
                  ], RuleTagToken.prototype, "toString", null);
                  RuleTagToken = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], RuleTagToken);
                  exports2.RuleTagToken = RuleTagToken;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/pattern/TagChunk.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/pattern/TagChunk.js ***!
                  \********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.TagChunk = void 0;
                  const Chunk_1 = __webpack_require__2(
                    /*! ./Chunk */
                    "./node_modules/antlr4ts/tree/pattern/Chunk.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class TagChunk extends Chunk_1.Chunk {
                    /**
                     * Construct a new instance of {@link TagChunk} using the specified label
                     * and tag.
                     *
                     * @param label The label for the tag. If this is `undefined`, the
                     * {@link TagChunk} represents an unlabeled tag.
                     * @param tag The tag, which should be the name of a parser rule or token
                     * type.
                     *
                     * @exception IllegalArgumentException if `tag` is not defined or
                     * empty.
                     */
                    constructor(tag, label) {
                      super();
                      if (tag == null || tag.length === 0) {
                        throw new Error("tag cannot be null or empty");
                      }
                      this._tag = tag;
                      this._label = label;
                    }
                    /**
                     * Get the tag for this chunk.
                     *
                     * @returns The tag for the chunk.
                     */
                    get tag() {
                      return this._tag;
                    }
                    /**
                     * Get the label, if any, assigned to this chunk.
                     *
                     * @returns The label assigned to this chunk, or `undefined` if no label is
                     * assigned to the chunk.
                     */
                    get label() {
                      return this._label;
                    }
                    /**
                     * This method returns a text representation of the tag chunk. Labeled tags
                     * are returned in the form `label:tag`, and unlabeled tags are
                     * returned as just the tag name.
                     */
                    toString() {
                      if (this._label != null) {
                        return this._label + ":" + this._tag;
                      }
                      return this._tag;
                    }
                  }
                  __decorate([
                    Decorators_1.NotNull
                  ], TagChunk.prototype, "tag", null);
                  __decorate([
                    Decorators_1.Override
                  ], TagChunk.prototype, "toString", null);
                  exports2.TagChunk = TagChunk;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/pattern/TextChunk.js": (
                /*!*********************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/pattern/TextChunk.js ***!
                  \*********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.TextChunk = void 0;
                  const Chunk_1 = __webpack_require__2(
                    /*! ./Chunk */
                    "./node_modules/antlr4ts/tree/pattern/Chunk.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let TextChunk = class TextChunk extends Chunk_1.Chunk {
                    /**
                     * Constructs a new instance of {@link TextChunk} with the specified text.
                     *
                     * @param text The text of this chunk.
                     * @exception IllegalArgumentException if `text` is not defined.
                     */
                    constructor(text) {
                      super();
                      if (text == null) {
                        throw new Error("text cannot be null");
                      }
                      this._text = text;
                    }
                    /**
                     * Gets the raw text of this chunk.
                     *
                     * @returns The text of the chunk.
                     */
                    get text() {
                      return this._text;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The implementation for {@link TextChunk} returns the result of
                     * `text` in single quotes.
                     */
                    toString() {
                      return "'" + this._text + "'";
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], TextChunk.prototype, "_text", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], TextChunk.prototype, "text", null);
                  __decorate([
                    Decorators_1.Override
                  ], TextChunk.prototype, "toString", null);
                  TextChunk = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], TextChunk);
                  exports2.TextChunk = TextChunk;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/pattern/TokenTagToken.js": (
                /*!*************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/pattern/TokenTagToken.js ***!
                  \*************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  var __param = this && this.__param || function(paramIndex, decorator) {
                    return function(target, key) {
                      decorator(target, key, paramIndex);
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.TokenTagToken = void 0;
                  const CommonToken_1 = __webpack_require__2(
                    /*! ../../CommonToken */
                    "./node_modules/antlr4ts/CommonToken.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  let TokenTagToken = class TokenTagToken extends CommonToken_1.CommonToken {
                    /**
                     * Constructs a new instance of {@link TokenTagToken} with the specified
                     * token name, type, and label.
                     *
                     * @param tokenName The token name.
                     * @param type The token type.
                     * @param label The label associated with the token tag, or `undefined` if
                     * the token tag is unlabeled.
                     */
                    constructor(tokenName, type2, label) {
                      super(type2);
                      this._tokenName = tokenName;
                      this._label = label;
                    }
                    /**
                     * Gets the token name.
                     * @returns The token name.
                     */
                    get tokenName() {
                      return this._tokenName;
                    }
                    /**
                     * Gets the label associated with the rule tag.
                     *
                     * @returns The name of the label associated with the rule tag, or
                     * `undefined` if this is an unlabeled rule tag.
                     */
                    get label() {
                      return this._label;
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The implementation for {@link TokenTagToken} returns the token tag
                     * formatted with `<` and `>` delimiters.
                     */
                    get text() {
                      if (this._label != null) {
                        return "<" + this._label + ":" + this._tokenName + ">";
                      }
                      return "<" + this._tokenName + ">";
                    }
                    /**
                     * {@inheritDoc}
                     *
                     * The implementation for {@link TokenTagToken} returns a string of the form
                     * `tokenName:type`.
                     */
                    toString() {
                      return this._tokenName + ":" + this.type;
                    }
                  };
                  __decorate([
                    Decorators_1.NotNull
                  ], TokenTagToken.prototype, "_tokenName", void 0);
                  __decorate([
                    Decorators_1.NotNull
                  ], TokenTagToken.prototype, "tokenName", null);
                  __decorate([
                    Decorators_1.Override
                  ], TokenTagToken.prototype, "text", null);
                  __decorate([
                    Decorators_1.Override
                  ], TokenTagToken.prototype, "toString", null);
                  TokenTagToken = __decorate([
                    __param(0, Decorators_1.NotNull)
                  ], TokenTagToken);
                  exports2.TokenTagToken = TokenTagToken;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/xpath/XPath.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/xpath/XPath.js ***!
                  \***************************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.XPath = void 0;
                  const CharStreams_1 = __webpack_require__2(
                    /*! ../../CharStreams */
                    "./node_modules/antlr4ts/CharStreams.js"
                  );
                  const CommonTokenStream_1 = __webpack_require__2(
                    /*! ../../CommonTokenStream */
                    "./node_modules/antlr4ts/CommonTokenStream.js"
                  );
                  const LexerNoViableAltException_1 = __webpack_require__2(
                    /*! ../../LexerNoViableAltException */
                    "./node_modules/antlr4ts/LexerNoViableAltException.js"
                  );
                  const ParserRuleContext_1 = __webpack_require__2(
                    /*! ../../ParserRuleContext */
                    "./node_modules/antlr4ts/ParserRuleContext.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! ../../Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const XPathLexer_1 = __webpack_require__2(
                    /*! ./XPathLexer */
                    "./node_modules/antlr4ts/tree/xpath/XPathLexer.js"
                  );
                  const XPathLexerErrorListener_1 = __webpack_require__2(
                    /*! ./XPathLexerErrorListener */
                    "./node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js"
                  );
                  const XPathRuleAnywhereElement_1 = __webpack_require__2(
                    /*! ./XPathRuleAnywhereElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js"
                  );
                  const XPathRuleElement_1 = __webpack_require__2(
                    /*! ./XPathRuleElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathRuleElement.js"
                  );
                  const XPathTokenAnywhereElement_1 = __webpack_require__2(
                    /*! ./XPathTokenAnywhereElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js"
                  );
                  const XPathTokenElement_1 = __webpack_require__2(
                    /*! ./XPathTokenElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathTokenElement.js"
                  );
                  const XPathWildcardAnywhereElement_1 = __webpack_require__2(
                    /*! ./XPathWildcardAnywhereElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js"
                  );
                  const XPathWildcardElement_1 = __webpack_require__2(
                    /*! ./XPathWildcardElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js"
                  );
                  class XPath {
                    constructor(parser, path) {
                      this.parser = parser;
                      this.path = path;
                      this.elements = this.split(path);
                    }
                    // TODO: check for invalid token/rule names, bad syntax
                    split(path) {
                      let lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path));
                      lexer.recover = (e) => {
                        throw e;
                      };
                      lexer.removeErrorListeners();
                      lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());
                      let tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);
                      try {
                        tokenStream.fill();
                      } catch (e) {
                        if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
                          let pos = lexer.charPositionInLine;
                          let msg = "Invalid tokens or characters at index " + pos + " in path '" + path + "' -- " + e.message;
                          throw new RangeError(msg);
                        }
                        throw e;
                      }
                      let tokens = tokenStream.getTokens();
                      let elements = [];
                      let n = tokens.length;
                      let i = 0;
                      loop: while (i < n) {
                        let el = tokens[i];
                        let next;
                        switch (el.type) {
                          case XPathLexer_1.XPathLexer.ROOT:
                          case XPathLexer_1.XPathLexer.ANYWHERE:
                            let anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;
                            i++;
                            next = tokens[i];
                            let invert = next.type === XPathLexer_1.XPathLexer.BANG;
                            if (invert) {
                              i++;
                              next = tokens[i];
                            }
                            let pathElement = this.getXPathElement(next, anywhere);
                            pathElement.invert = invert;
                            elements.push(pathElement);
                            i++;
                            break;
                          case XPathLexer_1.XPathLexer.TOKEN_REF:
                          case XPathLexer_1.XPathLexer.RULE_REF:
                          case XPathLexer_1.XPathLexer.WILDCARD:
                            elements.push(this.getXPathElement(el, false));
                            i++;
                            break;
                          case Token_1.Token.EOF:
                            break loop;
                          default:
                            throw new Error("Unknowth path element " + el);
                        }
                      }
                      return elements;
                    }
                    /**
                     * Convert word like `*` or `ID` or `expr` to a path
                     * element. `anywhere` is `true` if `//` precedes the
                     * word.
                     */
                    getXPathElement(wordToken, anywhere) {
                      if (wordToken.type === Token_1.Token.EOF) {
                        throw new Error("Missing path element at end of path");
                      }
                      let word = wordToken.text;
                      if (word == null) {
                        throw new Error("Expected wordToken to have text content.");
                      }
                      let ttype = this.parser.getTokenType(word);
                      let ruleIndex = this.parser.getRuleIndex(word);
                      switch (wordToken.type) {
                        case XPathLexer_1.XPathLexer.WILDCARD:
                          return anywhere ? new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() : new XPathWildcardElement_1.XPathWildcardElement();
                        case XPathLexer_1.XPathLexer.TOKEN_REF:
                        case XPathLexer_1.XPathLexer.STRING:
                          if (ttype === Token_1.Token.INVALID_TYPE) {
                            throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid token name");
                          }
                          return anywhere ? new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement_1.XPathTokenElement(word, ttype);
                        default:
                          if (ruleIndex === -1) {
                            throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid rule name");
                          }
                          return anywhere ? new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);
                      }
                    }
                    static findAll(tree, xpath, parser) {
                      let p = new XPath(parser, xpath);
                      return p.evaluate(tree);
                    }
                    /**
                     * Return a list of all nodes starting at `t` as root that satisfy the
                     * path. The root `/` is relative to the node passed to {@link evaluate}.
                     */
                    evaluate(t) {
                      let dummyRoot = new ParserRuleContext_1.ParserRuleContext();
                      dummyRoot.addChild(t);
                      let work = /* @__PURE__ */ new Set([dummyRoot]);
                      let i = 0;
                      while (i < this.elements.length) {
                        let next = /* @__PURE__ */ new Set();
                        for (let node of work) {
                          if (node.childCount > 0) {
                            let matching = this.elements[i].evaluate(node);
                            matching.forEach(next.add, next);
                          }
                        }
                        i++;
                        work = next;
                      }
                      return work;
                    }
                  }
                  exports2.XPath = XPath;
                  XPath.WILDCARD = "*";
                  XPath.NOT = "!";
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/xpath/XPathElement.js": (
                /*!**********************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/xpath/XPathElement.js ***!
                  \**********************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.XPathElement = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class XPathElement {
                    /** Construct element like `/ID` or `ID` or `/*` etc...
                     *  op is null if just node
                     */
                    constructor(nodeName) {
                      this.nodeName = nodeName;
                      this.invert = false;
                    }
                    toString() {
                      let inv = this.invert ? "!" : "";
                      let className = Object.constructor.name;
                      return className + "[" + inv + this.nodeName + "]";
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], XPathElement.prototype, "toString", null);
                  exports2.XPathElement = XPathElement;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/xpath/XPathLexer.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/xpath/XPathLexer.js ***!
                  \********************************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.XPathLexer = void 0;
                  const ATNDeserializer_1 = __webpack_require__2(
                    /*! ../../atn/ATNDeserializer */
                    "./node_modules/antlr4ts/atn/ATNDeserializer.js"
                  );
                  const Lexer_1 = __webpack_require__2(
                    /*! ../../Lexer */
                    "./node_modules/antlr4ts/Lexer.js"
                  );
                  const LexerATNSimulator_1 = __webpack_require__2(
                    /*! ../../atn/LexerATNSimulator */
                    "./node_modules/antlr4ts/atn/LexerATNSimulator.js"
                  );
                  const VocabularyImpl_1 = __webpack_require__2(
                    /*! ../../VocabularyImpl */
                    "./node_modules/antlr4ts/VocabularyImpl.js"
                  );
                  const Utils = __webpack_require__2(
                    /*! ../../misc/Utils */
                    "./node_modules/antlr4ts/misc/Utils.js"
                  );
                  class XPathLexer extends Lexer_1.Lexer {
                    // tslint:enable:no-trailing-whitespace
                    constructor(input) {
                      super(input);
                      this._interp = new LexerATNSimulator_1.LexerATNSimulator(XPathLexer._ATN, this);
                    }
                    // @Override
                    // @NotNull
                    get vocabulary() {
                      return XPathLexer.VOCABULARY;
                    }
                    // @Override
                    get grammarFileName() {
                      return "XPathLexer.g4";
                    }
                    // @Override
                    get ruleNames() {
                      return XPathLexer.ruleNames;
                    }
                    // @Override
                    get serializedATN() {
                      return XPathLexer._serializedATN;
                    }
                    // @Override
                    get channelNames() {
                      return XPathLexer.channelNames;
                    }
                    // @Override
                    get modeNames() {
                      return XPathLexer.modeNames;
                    }
                    // @Override
                    action(_localctx, ruleIndex, actionIndex) {
                      switch (ruleIndex) {
                        case 4:
                          this.ID_action(_localctx, actionIndex);
                          break;
                      }
                    }
                    ID_action(_localctx, actionIndex) {
                      switch (actionIndex) {
                        case 0:
                          let text = this.text;
                          if (text.charAt(0) === text.charAt(0).toUpperCase()) {
                            this.type = XPathLexer.TOKEN_REF;
                          } else {
                            this.type = XPathLexer.RULE_REF;
                          }
                          break;
                      }
                    }
                    static get _ATN() {
                      if (!XPathLexer.__ATN) {
                        XPathLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(XPathLexer._serializedATN));
                      }
                      return XPathLexer.__ATN;
                    }
                  }
                  exports2.XPathLexer = XPathLexer;
                  XPathLexer.TOKEN_REF = 1;
                  XPathLexer.RULE_REF = 2;
                  XPathLexer.ANYWHERE = 3;
                  XPathLexer.ROOT = 4;
                  XPathLexer.WILDCARD = 5;
                  XPathLexer.BANG = 6;
                  XPathLexer.ID = 7;
                  XPathLexer.STRING = 8;
                  XPathLexer.channelNames = [
                    "DEFAULT_TOKEN_CHANNEL",
                    "HIDDEN"
                  ];
                  XPathLexer.modeNames = [
                    "DEFAULT_MODE"
                  ];
                  XPathLexer.ruleNames = [
                    "ANYWHERE",
                    "ROOT",
                    "WILDCARD",
                    "BANG",
                    "ID",
                    "NameChar",
                    "NameStartChar",
                    "STRING"
                  ];
                  XPathLexer._LITERAL_NAMES = [
                    void 0,
                    void 0,
                    void 0,
                    "'//'",
                    "'/'",
                    "'*'",
                    "'!'"
                  ];
                  XPathLexer._SYMBOLIC_NAMES = [
                    void 0,
                    "TOKEN_REF",
                    "RULE_REF",
                    "ANYWHERE",
                    "ROOT",
                    "WILDCARD",
                    "BANG",
                    "ID",
                    "STRING"
                  ];
                  XPathLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);
                  XPathLexer._serializedATNSegments = 2;
                  XPathLexer._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\n2\b					\x07	\x07\b	\b			\x07\n\f"\v\x07\x07\b\b		\x07	,\n	\f		/\v			-\n\x07\x07	\b\v	\r\n\u02B6\n2;C\\aac|\x81\xA1\xAC\xAC\xAF\xAF\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0302\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u0485\u0489\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u0593\u05BF\u05C1\u05C1\u05C3\u05C4\u05C6\u05C7\u05C9\u05C9\u05D2\u05EC\u05F2\u05F4\u0602\u0607\u0612\u061C\u061E\u061E\u0622\u066B\u0670\u06D5\u06D7\u06DF\u06E1\u06EA\u06EC\u06FE\u0701\u0701\u0711\u074C\u074F\u07B3\u07C2\u07F7\u07FC\u07FC\u0802\u082F\u0842\u085D\u08A2\u08B6\u08B8\u08BF\u08D6\u0965\u0968\u0971\u0973\u0985\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BE\u09C6\u09C9\u09CA\u09CD\u09D0\u09D9\u09D9\u09DE\u09DF\u09E1\u09E5\u09E8\u09F3\u0A03\u0A05\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A3E\u0A3E\u0A40\u0A44\u0A49\u0A4A\u0A4D\u0A4F\u0A53\u0A53\u0A5B\u0A5E\u0A60\u0A60\u0A68\u0A77\u0A83\u0A85\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABE\u0AC7\u0AC9\u0ACB\u0ACD\u0ACF\u0AD2\u0AD2\u0AE2\u0AE5\u0AE8\u0AF1\u0AFB\u0AFB\u0B03\u0B05\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3E\u0B46\u0B49\u0B4A\u0B4D\u0B4F\u0B58\u0B59\u0B5E\u0B5F\u0B61\u0B65\u0B68\u0B71\u0B73\u0B73\u0B84\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BC0\u0BC4\u0BC8\u0BCA\u0BCC\u0BCF\u0BD2\u0BD2\u0BD9\u0BD9\u0BE8\u0BF1\u0C02\u0C05\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C46\u0C48\u0C4A\u0C4C\u0C4F\u0C57\u0C58\u0C5A\u0C5C\u0C62\u0C65\u0C68\u0C71\u0C82\u0C85\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBE\u0CC6\u0CC8\u0CCA\u0CCC\u0CCF\u0CD7\u0CD8\u0CE0\u0CE0\u0CE2\u0CE5\u0CE8\u0CF1\u0CF3\u0CF4\u0D03\u0D05\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D46\u0D48\u0D4A\u0D4C\u0D50\u0D56\u0D59\u0D61\u0D65\u0D68\u0D71\u0D7C\u0D81\u0D84\u0D85\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0DCC\u0DCC\u0DD1\u0DD6\u0DD8\u0DD8\u0DDA\u0DE1\u0DE8\u0DF1\u0DF4\u0DF5\u0E03\u0E3C\u0E42\u0E50\u0E52\u0E5B\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EBB\u0EBD\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0ECA\u0ECF\u0ED2\u0EDB\u0EDE\u0EE1\u0F02\u0F02\u0F1A\u0F1B\u0F22\u0F2B\u0F37\u0F37\u0F39\u0F39\u0F3B\u0F3B\u0F40\u0F49\u0F4B\u0F6E\u0F73\u0F86\u0F88\u0F99\u0F9B\u0FBE\u0FC8\u0FC8\u1002\u104B\u1052\u109F\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u135F\u1361\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1716\u1722\u1736\u1742\u1755\u1762\u176E\u1770\u1772\u1774\u1775\u1782\u17D5\u17D9\u17D9\u17DE\u17DF\u17E2\u17EB\u180D\u1810\u1812\u181B\u1822\u1879\u1882\u18AC\u18B2\u18F7\u1902\u1920\u1922\u192D\u1932\u193D\u1948\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u19D2\u19DB\u1A02\u1A1D\u1A22\u1A60\u1A62\u1A7E\u1A81\u1A8B\u1A92\u1A9B\u1AA9\u1AA9\u1AB2\u1ABF\u1B02\u1B4D\u1B52\u1B5B\u1B6D\u1B75\u1B82\u1BF5\u1C02\u1C39\u1C42\u1C4B\u1C4F\u1C7F\u1C82\u1C8A\u1CD2\u1CD4\u1CD6\u1CF8\u1CFA\u1CFB\u1D02\u1DF7\u1DFD\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u200D\u2011\u202C\u2030\u2041\u2042\u2056\u2056\u2062\u2066\u2068\u2071\u2073\u2073\u2081\u2081\u2092\u209E\u20D2\u20DE\u20E3\u20E3\u20E7\u20F2\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D81\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2DE2\u2E01\u2E31\u2E31\u3007\u3009\u3023\u3031\u3033\u3037\u303A\u303E\u3043\u3098\u309B\u309C\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA62D\uA642\uA671\uA676\uA67F\uA681\uA6F3\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA829\uA842\uA875\uA882\uA8C7\uA8D2\uA8DB\uA8E2\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA902\uA92F\uA932\uA955\uA962\uA97E\uA982\uA9C2\uA9D1\uA9DB\uA9E2\uAA00\uAA02\uAA38\uAA42\uAA4F\uAA52\uAA5B\uAA62\uAA78\uAA7C\uAAC4\uAADD\uAADF\uAAE2\uAAF1\uAAF4\uAAF8\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABEC\uABEE\uABEF\uABF2\uABFB\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE02\uFE11\uFE22\uFE31\uFE35\uFE36\uFE4F\uFE51\uFE72\uFE76\uFE78\uFEFE\uFF01\uFF01\uFF12\uFF1B\uFF23\uFF3C\uFF41\uFF41\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\uFFFB\uFFFD\r(*<>?AOR_\x82\xFC\u0142\u0176\u01FF\u01FF\u0282\u029E\u02A2\u02D2\u02E2\u02E2\u0302\u0321\u0332\u034C\u0352\u037C\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04A2\u04AB\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A05\u0A07\u0A08\u0A0E\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A3A\u0A3C\u0A41\u0A41\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE8\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1002\u1048\u1068\u1071\u1081\u10BC\u10BF\u10BF\u10D2\u10EA\u10F2\u10FB\u1102\u1136\u1138\u1141\u1152\u1175\u1178\u1178\u1182\u11C6\u11CC\u11CE\u11D2\u11DC\u11DE\u11DE\u1202\u1213\u1215\u1239\u1240\u1240\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12EC\u12F2\u12FB\u1302\u1305\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133E\u1346\u1349\u134A\u134D\u134F\u1352\u1352\u1359\u1359\u135F\u1365\u1368\u136E\u1372\u1376\u1402\u144C\u1452\u145B\u1482\u14C7\u14C9\u14C9\u14D2\u14DB\u1582\u15B7\u15BA\u15C2\u15DA\u15DF\u1602\u1642\u1646\u1646\u1652\u165B\u1682\u16B9\u16C2\u16CB\u1702\u171B\u171F\u172D\u1732\u173B\u18A2\u18EB\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C38\u1C3A\u1C42\u1C52\u1C5B\u1C74\u1C91\u1C94\u1CA9\u1CAB\u1CB8\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6A62\u6A6B\u6AD2\u6AEF\u6AF2\u6AF6\u6B02\u6B38\u6B42\u6B45\u6B52\u6B5B\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F80\u6F91\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uBC9F\uBCA0\uBCA2\uBCA5\uD167\uD16B\uD16F\uD184\uD187\uD18D\uD1AC\uD1AF\uD244\uD246\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uD7D0\uD801\uDA02\uDA38\uDA3D\uDA6E\uDA77\uDA77\uDA86\uDA86\uDA9D\uDAA1\uDAA3\uDAB1\uE002\uE008\uE00A\uE01A\uE01D\uE023\uE025\uE026\uE028\uE02C\uE802\uE8C6\uE8D2\uE8D8\uE902\uE94C\uE952\uE95B\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F"\x81\u0102\u01F1\u0240C\\c|\xAC\xAC\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0372\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u05D2\u05EC\u05F2\u05F4\u0622\u064C\u0670\u0671\u0673\u06D5\u06D7\u06D7\u06E7\u06E8\u06F0\u06F1\u06FC\u06FE\u0701\u0701\u0712\u0712\u0714\u0731\u074F\u07A7\u07B3\u07B3\u07CC\u07EC\u07F6\u07F7\u07FC\u07FC\u0802\u0817\u081C\u081C\u0826\u0826\u082A\u082A\u0842\u085A\u08A2\u08B6\u08B8\u08BF\u0906\u093B\u093F\u093F\u0952\u0952\u095A\u0963\u0973\u0982\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BF\u09BF\u09D0\u09D0\u09DE\u09DF\u09E1\u09E3\u09F2\u09F3\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A5B\u0A5E\u0A60\u0A60\u0A74\u0A76\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABF\u0ABF\u0AD2\u0AD2\u0AE2\u0AE3\u0AFB\u0AFB\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3F\u0B3F\u0B5E\u0B5F\u0B61\u0B63\u0B73\u0B73\u0B85\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BD2\u0BD2\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C3F\u0C5A\u0C5C\u0C62\u0C63\u0C82\u0C82\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBF\u0CBF\u0CE0\u0CE0\u0CE2\u0CE3\u0CF3\u0CF4\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D3F\u0D50\u0D50\u0D56\u0D58\u0D61\u0D63\u0D7C\u0D81\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0E03\u0E32\u0E34\u0E35\u0E42\u0E48\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EB2\u0EB4\u0EB5\u0EBF\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0EDE\u0EE1\u0F02\u0F02\u0F42\u0F49\u0F4B\u0F6E\u0F8A\u0F8E\u1002\u102C\u1041\u1041\u1052\u1057\u105C\u105F\u1063\u1063\u1067\u1068\u1070\u1072\u1077\u1083\u1090\u1090\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1713\u1722\u1733\u1742\u1753\u1762\u176E\u1770\u1772\u1782\u17B5\u17D9\u17D9\u17DE\u17DE\u1822\u1879\u1882\u1886\u1889\u18AA\u18AC\u18AC\u18B2\u18F7\u1902\u1920\u1952\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u1A02\u1A18\u1A22\u1A56\u1AA9\u1AA9\u1B07\u1B35\u1B47\u1B4D\u1B85\u1BA2\u1BB0\u1BB1\u1BBC\u1BE7\u1C02\u1C25\u1C4F\u1C51\u1C5C\u1C7F\u1C82\u1C8A\u1CEB\u1CEE\u1CF0\u1CF3\u1CF7\u1CF8\u1D02\u1DC1\u1E02\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u2073\u2073\u2081\u2081\u2092\u209E\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF0\u2CF4\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D82\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2E31\u2E31\u3007\u3009\u3023\u302B\u3033\u3037\u303A\u303E\u3043\u3098\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA621\uA62C\uA62D\uA642\uA670\uA681\uA69F\uA6A2\uA6F1\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA803\uA805\uA807\uA809\uA80C\uA80E\uA824\uA842\uA875\uA884\uA8B5\uA8F4\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA90C\uA927\uA932\uA948\uA962\uA97E\uA986\uA9B4\uA9D1\uA9D1\uA9E2\uA9E6\uA9E8\uA9F1\uA9FC\uAA00\uAA02\uAA2A\uAA42\uAA44\uAA46\uAA4D\uAA62\uAA78\uAA7C\uAA7C\uAA80\uAAB1\uAAB3\uAAB3\uAAB7\uAAB8\uAABB\uAABF\uAAC2\uAAC2\uAAC4\uAAC4\uAADD\uAADF\uAAE2\uAAEC\uAAF4\uAAF6\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABE4\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB1F\uFB21\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE72\uFE76\uFE78\uFEFE\uFF23\uFF3C\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\r(*<>?AOR_\x82\xFC\u0142\u0176\u0282\u029E\u02A2\u02D2\u0302\u0321\u0332\u034C\u0352\u0377\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A02\u0A12\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE6\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1005\u1039\u1085\u10B1\u10D2\u10EA\u1105\u1128\u1152\u1174\u1178\u1178\u1185\u11B4\u11C3\u11C6\u11DC\u11DC\u11DE\u11DE\u1202\u1213\u1215\u122D\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12E0\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133F\u133F\u1352\u1352\u135F\u1363\u1402\u1436\u1449\u144C\u1482\u14B1\u14C6\u14C7\u14C9\u14C9\u1582\u15B0\u15DA\u15DD\u1602\u1631\u1646\u1646\u1682\u16AC\u1702\u171B\u18A2\u18E1\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C30\u1C42\u1C42\u1C74\u1C91\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6AD2\u6AEF\u6B02\u6B31\u6B42\u6B45\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F52\u6F95\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548';
                  XPathLexer._serializedATNSegment1 = `\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uE802\uE8C6\uE902\uE945\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F1\x07	\v\x07	\v\r%')\x071\x071\x071\x07,\b\x1B\x07#\x1B
 \b\r\x07"  !!#" #$\b$\f%&	&'(	()-\x07)*,\v+*,/-.-+.0/-01\x07)1 -`;
                  XPathLexer._serializedATN = Utils.join([
                    XPathLexer._serializedATNSegment0,
                    XPathLexer._serializedATNSegment1
                  ], "");
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js": (
                /*!*********************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js ***!
                  \*********************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.XPathLexerErrorListener = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  class XPathLexerErrorListener {
                    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], XPathLexerErrorListener.prototype, "syntaxError", null);
                  exports2.XPathLexerErrorListener = XPathLexerErrorListener;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js": (
                /*!**********************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js ***!
                  \**********************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.XPathRuleAnywhereElement = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Trees_1 = __webpack_require__2(
                    /*! ../Trees */
                    "./node_modules/antlr4ts/tree/Trees.js"
                  );
                  const XPathElement_1 = __webpack_require__2(
                    /*! ./XPathElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathElement.js"
                  );
                  class XPathRuleAnywhereElement extends XPathElement_1.XPathElement {
                    constructor(ruleName, ruleIndex) {
                      super(ruleName);
                      this.ruleIndex = ruleIndex;
                    }
                    evaluate(t) {
                      return Trees_1.Trees.findAllRuleNodes(t, this.ruleIndex);
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], XPathRuleAnywhereElement.prototype, "evaluate", null);
                  exports2.XPathRuleAnywhereElement = XPathRuleAnywhereElement;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/xpath/XPathRuleElement.js": (
                /*!**************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/xpath/XPathRuleElement.js ***!
                  \**************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.XPathRuleElement = void 0;
                  const ParserRuleContext_1 = __webpack_require__2(
                    /*! ../../ParserRuleContext */
                    "./node_modules/antlr4ts/ParserRuleContext.js"
                  );
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Trees_1 = __webpack_require__2(
                    /*! ../Trees */
                    "./node_modules/antlr4ts/tree/Trees.js"
                  );
                  const XPathElement_1 = __webpack_require__2(
                    /*! ./XPathElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathElement.js"
                  );
                  class XPathRuleElement extends XPathElement_1.XPathElement {
                    constructor(ruleName, ruleIndex) {
                      super(ruleName);
                      this.ruleIndex = ruleIndex;
                    }
                    evaluate(t) {
                      let nodes = [];
                      for (let c of Trees_1.Trees.getChildren(t)) {
                        if (c instanceof ParserRuleContext_1.ParserRuleContext) {
                          if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
                            nodes.push(c);
                          }
                        }
                      }
                      return nodes;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], XPathRuleElement.prototype, "evaluate", null);
                  exports2.XPathRuleElement = XPathRuleElement;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js": (
                /*!***********************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js ***!
                  \***********************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.XPathTokenAnywhereElement = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Trees_1 = __webpack_require__2(
                    /*! ../Trees */
                    "./node_modules/antlr4ts/tree/Trees.js"
                  );
                  const XPathElement_1 = __webpack_require__2(
                    /*! ./XPathElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathElement.js"
                  );
                  class XPathTokenAnywhereElement extends XPathElement_1.XPathElement {
                    constructor(tokenName, tokenType) {
                      super(tokenName);
                      this.tokenType = tokenType;
                    }
                    evaluate(t) {
                      return Trees_1.Trees.findAllTokenNodes(t, this.tokenType);
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], XPathTokenAnywhereElement.prototype, "evaluate", null);
                  exports2.XPathTokenAnywhereElement = XPathTokenAnywhereElement;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/xpath/XPathTokenElement.js": (
                /*!***************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/xpath/XPathTokenElement.js ***!
                  \***************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.XPathTokenElement = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const TerminalNode_1 = __webpack_require__2(
                    /*! ../TerminalNode */
                    "./node_modules/antlr4ts/tree/TerminalNode.js"
                  );
                  const Trees_1 = __webpack_require__2(
                    /*! ../Trees */
                    "./node_modules/antlr4ts/tree/Trees.js"
                  );
                  const XPathElement_1 = __webpack_require__2(
                    /*! ./XPathElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathElement.js"
                  );
                  class XPathTokenElement extends XPathElement_1.XPathElement {
                    constructor(tokenName, tokenType) {
                      super(tokenName);
                      this.tokenType = tokenType;
                    }
                    evaluate(t) {
                      let nodes = [];
                      for (let c of Trees_1.Trees.getChildren(t)) {
                        if (c instanceof TerminalNode_1.TerminalNode) {
                          if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
                            nodes.push(c);
                          }
                        }
                      }
                      return nodes;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], XPathTokenElement.prototype, "evaluate", null);
                  exports2.XPathTokenElement = XPathTokenElement;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js": (
                /*!**************************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js ***!
                  \**************************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.XPathWildcardAnywhereElement = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Trees_1 = __webpack_require__2(
                    /*! ../Trees */
                    "./node_modules/antlr4ts/tree/Trees.js"
                  );
                  const XPath_1 = __webpack_require__2(
                    /*! ./XPath */
                    "./node_modules/antlr4ts/tree/xpath/XPath.js"
                  );
                  const XPathElement_1 = __webpack_require__2(
                    /*! ./XPathElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathElement.js"
                  );
                  class XPathWildcardAnywhereElement extends XPathElement_1.XPathElement {
                    constructor() {
                      super(XPath_1.XPath.WILDCARD);
                    }
                    evaluate(t) {
                      if (this.invert) {
                        return [];
                      }
                      return Trees_1.Trees.getDescendants(t);
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], XPathWildcardAnywhereElement.prototype, "evaluate", null);
                  exports2.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement;
                }
              ),
              /***/
              "./node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js": (
                /*!******************************************************************!*\
                  !*** ./node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js ***!
                  \******************************************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
                    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                  };
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.XPathWildcardElement = void 0;
                  const Decorators_1 = __webpack_require__2(
                    /*! ../../Decorators */
                    "./node_modules/antlr4ts/Decorators.js"
                  );
                  const Trees_1 = __webpack_require__2(
                    /*! ../Trees */
                    "./node_modules/antlr4ts/tree/Trees.js"
                  );
                  const XPath_1 = __webpack_require__2(
                    /*! ./XPath */
                    "./node_modules/antlr4ts/tree/xpath/XPath.js"
                  );
                  const XPathElement_1 = __webpack_require__2(
                    /*! ./XPathElement */
                    "./node_modules/antlr4ts/tree/xpath/XPathElement.js"
                  );
                  class XPathWildcardElement extends XPathElement_1.XPathElement {
                    constructor() {
                      super(XPath_1.XPath.WILDCARD);
                    }
                    evaluate(t) {
                      let kids = [];
                      if (this.invert) {
                        return kids;
                      }
                      for (let c of Trees_1.Trees.getChildren(t)) {
                        kids.push(c);
                      }
                      return kids;
                    }
                  }
                  __decorate([
                    Decorators_1.Override
                  ], XPathWildcardElement.prototype, "evaluate", null);
                  exports2.XPathWildcardElement = XPathWildcardElement;
                }
              ),
              /***/
              "./node_modules/assert/build/assert.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/assert/build/assert.js ***!
                  \*********************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var process2 = __webpack_require__2(
                    /*! process/browser */
                    "./node_modules/process/browser.js"
                  );
                  function _typeof(o) {
                    "@babel/helpers - typeof";
                    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                      return typeof o2;
                    } : function(o2) {
                      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                    }, _typeof(o);
                  }
                  function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                    }
                  }
                  function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                  }
                  function _toPropertyKey(arg) {
                    var key = _toPrimitive(arg, "string");
                    return _typeof(key) === "symbol" ? key : String(key);
                  }
                  function _toPrimitive(input, hint) {
                    if (_typeof(input) !== "object" || input === null) return input;
                    var prim = input[Symbol.toPrimitive];
                    if (prim !== void 0) {
                      var res = prim.call(input, hint || "default");
                      if (_typeof(res) !== "object") return res;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return (hint === "string" ? String : Number)(input);
                  }
                  function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                      throw new TypeError("Cannot call a class as a function");
                    }
                  }
                  var _require = __webpack_require__2(
                    /*! ./internal/errors */
                    "./node_modules/assert/build/internal/errors.js"
                  ), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                  var AssertionError = __webpack_require__2(
                    /*! ./internal/assert/assertion_error */
                    "./node_modules/assert/build/internal/assert/assertion_error.js"
                  );
                  var _require2 = __webpack_require__2(
                    /*! util/ */
                    "./node_modules/util/util.js"
                  ), inspect = _require2.inspect;
                  var _require$types = __webpack_require__2(
                    /*! util/ */
                    "./node_modules/util/util.js"
                  ).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                  var objectAssign = __webpack_require__2(
                    /*! object.assign/polyfill */
                    "./node_modules/object.assign/polyfill.js"
                  )();
                  var objectIs = __webpack_require__2(
                    /*! object-is/polyfill */
                    "./node_modules/object-is/polyfill.js"
                  )();
                  var RegExpPrototypeTest = __webpack_require__2(
                    /*! call-bind/callBound */
                    "./node_modules/call-bind/callBound.js"
                  )("RegExp.prototype.test");
                  var errorCache = /* @__PURE__ */ new Map();
                  var isDeepEqual;
                  var isDeepStrictEqual;
                  var parseExpressionAt;
                  var findNodeAround;
                  var decoder;
                  function lazyLoadComparison() {
                    var comparison = __webpack_require__2(
                      /*! ./internal/util/comparisons */
                      "./node_modules/assert/build/internal/util/comparisons.js"
                    );
                    isDeepEqual = comparison.isDeepEqual;
                    isDeepStrictEqual = comparison.isDeepStrictEqual;
                  }
                  var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                  var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", "\\b", "", "", "\\u000b", "\\f", "", "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];
                  var escapeFn = function escapeFn2(str2) {
                    return meta[str2.charCodeAt(0)];
                  };
                  var warned = false;
                  var assert = module2.exports = ok;
                  var NO_EXCEPTION_SENTINEL = {};
                  function innerFail(obj) {
                    if (obj.message instanceof Error) throw obj.message;
                    throw new AssertionError(obj);
                  }
                  function fail(actual, expected, message, operator, stackStartFn) {
                    var argsLen = arguments.length;
                    var internalMessage;
                    if (argsLen === 0) {
                      internalMessage = "Failed";
                    } else if (argsLen === 1) {
                      message = actual;
                      actual = void 0;
                    } else {
                      if (warned === false) {
                        warned = true;
                        var warn = process2.emitWarning ? process2.emitWarning : console.warn.bind(console);
                        warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
                      }
                      if (argsLen === 2) operator = "!=";
                    }
                    if (message instanceof Error) throw message;
                    var errArgs = {
                      actual,
                      expected,
                      operator: operator === void 0 ? "fail" : operator,
                      stackStartFn: stackStartFn || fail
                    };
                    if (message !== void 0) {
                      errArgs.message = message;
                    }
                    var err = new AssertionError(errArgs);
                    if (internalMessage) {
                      err.message = internalMessage;
                      err.generatedMessage = true;
                    }
                    throw err;
                  }
                  assert.fail = fail;
                  assert.AssertionError = AssertionError;
                  function innerOk(fn, argLen, value, message) {
                    if (!value) {
                      var generatedMessage = false;
                      if (argLen === 0) {
                        generatedMessage = true;
                        message = "No value argument passed to `assert.ok()`";
                      } else if (message instanceof Error) {
                        throw message;
                      }
                      var err = new AssertionError({
                        actual: value,
                        expected: true,
                        message,
                        operator: "==",
                        stackStartFn: fn
                      });
                      err.generatedMessage = generatedMessage;
                      throw err;
                    }
                  }
                  function ok() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    innerOk.apply(void 0, [ok, args.length].concat(args));
                  }
                  assert.ok = ok;
                  assert.equal = function equal(actual, expected, message) {
                    if (arguments.length < 2) {
                      throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (actual != expected) {
                      innerFail({
                        actual,
                        expected,
                        message,
                        operator: "==",
                        stackStartFn: equal
                      });
                    }
                  };
                  assert.notEqual = function notEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                      throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (actual == expected) {
                      innerFail({
                        actual,
                        expected,
                        message,
                        operator: "!=",
                        stackStartFn: notEqual
                      });
                    }
                  };
                  assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                      throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (isDeepEqual === void 0) lazyLoadComparison();
                    if (!isDeepEqual(actual, expected)) {
                      innerFail({
                        actual,
                        expected,
                        message,
                        operator: "deepEqual",
                        stackStartFn: deepEqual
                      });
                    }
                  };
                  assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                      throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (isDeepEqual === void 0) lazyLoadComparison();
                    if (isDeepEqual(actual, expected)) {
                      innerFail({
                        actual,
                        expected,
                        message,
                        operator: "notDeepEqual",
                        stackStartFn: notDeepEqual
                      });
                    }
                  };
                  assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                      throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (isDeepEqual === void 0) lazyLoadComparison();
                    if (!isDeepStrictEqual(actual, expected)) {
                      innerFail({
                        actual,
                        expected,
                        message,
                        operator: "deepStrictEqual",
                        stackStartFn: deepStrictEqual
                      });
                    }
                  };
                  assert.notDeepStrictEqual = notDeepStrictEqual;
                  function notDeepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                      throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (isDeepEqual === void 0) lazyLoadComparison();
                    if (isDeepStrictEqual(actual, expected)) {
                      innerFail({
                        actual,
                        expected,
                        message,
                        operator: "notDeepStrictEqual",
                        stackStartFn: notDeepStrictEqual
                      });
                    }
                  }
                  assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                      throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (!objectIs(actual, expected)) {
                      innerFail({
                        actual,
                        expected,
                        message,
                        operator: "strictEqual",
                        stackStartFn: strictEqual
                      });
                    }
                  };
                  assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                      throw new ERR_MISSING_ARGS("actual", "expected");
                    }
                    if (objectIs(actual, expected)) {
                      innerFail({
                        actual,
                        expected,
                        message,
                        operator: "notStrictEqual",
                        stackStartFn: notStrictEqual
                      });
                    }
                  };
                  var Comparison = /* @__PURE__ */ _createClass(function Comparison2(obj, keys, actual) {
                    var _this = this;
                    _classCallCheck(this, Comparison2);
                    keys.forEach(function(key) {
                      if (key in obj) {
                        if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
                          _this[key] = actual[key];
                        } else {
                          _this[key] = obj[key];
                        }
                      }
                    });
                  });
                  function compareExceptionKey(actual, expected, key, message, keys, fn) {
                    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                      if (!message) {
                        var a = new Comparison(actual, keys);
                        var b = new Comparison(expected, keys, actual);
                        var err = new AssertionError({
                          actual: a,
                          expected: b,
                          operator: "deepStrictEqual",
                          stackStartFn: fn
                        });
                        err.actual = actual;
                        err.expected = expected;
                        err.operator = fn.name;
                        throw err;
                      }
                      innerFail({
                        actual,
                        expected,
                        message,
                        operator: fn.name,
                        stackStartFn: fn
                      });
                    }
                  }
                  function expectedException(actual, expected, msg, fn) {
                    if (typeof expected !== "function") {
                      if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
                      if (arguments.length === 2) {
                        throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
                      }
                      if (_typeof(actual) !== "object" || actual === null) {
                        var err = new AssertionError({
                          actual,
                          expected,
                          message: msg,
                          operator: "deepStrictEqual",
                          stackStartFn: fn
                        });
                        err.operator = fn.name;
                        throw err;
                      }
                      var keys = Object.keys(expected);
                      if (expected instanceof Error) {
                        keys.push("name", "message");
                      } else if (keys.length === 0) {
                        throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
                      }
                      if (isDeepEqual === void 0) lazyLoadComparison();
                      keys.forEach(function(key) {
                        if (typeof actual[key] === "string" && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
                          return;
                        }
                        compareExceptionKey(actual, expected, key, msg, keys, fn);
                      });
                      return true;
                    }
                    if (expected.prototype !== void 0 && actual instanceof expected) {
                      return true;
                    }
                    if (Error.isPrototypeOf(expected)) {
                      return false;
                    }
                    return expected.call({}, actual) === true;
                  }
                  function getActual(fn) {
                    if (typeof fn !== "function") {
                      throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
                    }
                    try {
                      fn();
                    } catch (e) {
                      return e;
                    }
                    return NO_EXCEPTION_SENTINEL;
                  }
                  function checkIsPromise(obj) {
                    return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
                  }
                  function waitForActual(promiseFn) {
                    return Promise.resolve().then(function() {
                      var resultPromise;
                      if (typeof promiseFn === "function") {
                        resultPromise = promiseFn();
                        if (!checkIsPromise(resultPromise)) {
                          throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
                        }
                      } else if (checkIsPromise(promiseFn)) {
                        resultPromise = promiseFn;
                      } else {
                        throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
                      }
                      return Promise.resolve().then(function() {
                        return resultPromise;
                      }).then(function() {
                        return NO_EXCEPTION_SENTINEL;
                      }).catch(function(e) {
                        return e;
                      });
                    });
                  }
                  function expectsError(stackStartFn, actual, error, message) {
                    if (typeof error === "string") {
                      if (arguments.length === 4) {
                        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
                      }
                      if (_typeof(actual) === "object" && actual !== null) {
                        if (actual.message === error) {
                          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
                        }
                      } else if (actual === error) {
                        throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
                      }
                      message = error;
                      error = void 0;
                    } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
                      throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
                    }
                    if (actual === NO_EXCEPTION_SENTINEL) {
                      var details = "";
                      if (error && error.name) {
                        details += " (".concat(error.name, ")");
                      }
                      details += message ? ": ".concat(message) : ".";
                      var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
                      innerFail({
                        actual: void 0,
                        expected: error,
                        operator: stackStartFn.name,
                        message: "Missing expected ".concat(fnType).concat(details),
                        stackStartFn
                      });
                    }
                    if (error && !expectedException(actual, error, message, stackStartFn)) {
                      throw actual;
                    }
                  }
                  function expectsNoError(stackStartFn, actual, error, message) {
                    if (actual === NO_EXCEPTION_SENTINEL) return;
                    if (typeof error === "string") {
                      message = error;
                      error = void 0;
                    }
                    if (!error || expectedException(actual, error)) {
                      var details = message ? ": ".concat(message) : ".";
                      var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
                      innerFail({
                        actual,
                        expected: error,
                        operator: stackStartFn.name,
                        message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
                        stackStartFn
                      });
                    }
                    throw actual;
                  }
                  assert.throws = function throws(promiseFn) {
                    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                      args[_key2 - 1] = arguments[_key2];
                    }
                    expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
                  };
                  assert.rejects = function rejects(promiseFn) {
                    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                      args[_key3 - 1] = arguments[_key3];
                    }
                    return waitForActual(promiseFn).then(function(result) {
                      return expectsError.apply(void 0, [rejects, result].concat(args));
                    });
                  };
                  assert.doesNotThrow = function doesNotThrow(fn) {
                    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                      args[_key4 - 1] = arguments[_key4];
                    }
                    expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
                  };
                  assert.doesNotReject = function doesNotReject(fn) {
                    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
                      args[_key5 - 1] = arguments[_key5];
                    }
                    return waitForActual(fn).then(function(result) {
                      return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
                    });
                  };
                  assert.ifError = function ifError(err) {
                    if (err !== null && err !== void 0) {
                      var message = "ifError got unwanted exception: ";
                      if (_typeof(err) === "object" && typeof err.message === "string") {
                        if (err.message.length === 0 && err.constructor) {
                          message += err.constructor.name;
                        } else {
                          message += err.message;
                        }
                      } else {
                        message += inspect(err);
                      }
                      var newErr = new AssertionError({
                        actual: err,
                        expected: null,
                        operator: "ifError",
                        message,
                        stackStartFn: ifError
                      });
                      var origStack = err.stack;
                      if (typeof origStack === "string") {
                        var tmp2 = origStack.split("\n");
                        tmp2.shift();
                        var tmp1 = newErr.stack.split("\n");
                        for (var i = 0; i < tmp2.length; i++) {
                          var pos = tmp1.indexOf(tmp2[i]);
                          if (pos !== -1) {
                            tmp1 = tmp1.slice(0, pos);
                            break;
                          }
                        }
                        newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
                      }
                      throw newErr;
                    }
                  };
                  function internalMatch(string, regexp, message, fn, fnName) {
                    if (!isRegExp(regexp)) {
                      throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
                    }
                    var match = fnName === "match";
                    if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match) {
                      if (message instanceof Error) {
                        throw message;
                      }
                      var generatedMessage = !message;
                      message = message || (typeof string !== "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
                      var err = new AssertionError({
                        actual: string,
                        expected: regexp,
                        message,
                        operator: fnName,
                        stackStartFn: fn
                      });
                      err.generatedMessage = generatedMessage;
                      throw err;
                    }
                  }
                  assert.match = function match(string, regexp, message) {
                    internalMatch(string, regexp, message, match, "match");
                  };
                  assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
                    internalMatch(string, regexp, message, doesNotMatch, "doesNotMatch");
                  };
                  function strict() {
                    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                      args[_key6] = arguments[_key6];
                    }
                    innerOk.apply(void 0, [strict, args.length].concat(args));
                  }
                  assert.strict = objectAssign(strict, assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                  });
                  assert.strict.strict = assert.strict;
                }
              ),
              /***/
              "./node_modules/assert/build/internal/assert/assertion_error.js": (
                /*!**********************************************************************!*\
                  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
                  \**********************************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var process2 = __webpack_require__2(
                    /*! process/browser */
                    "./node_modules/process/browser.js"
                  );
                  function ownKeys(e, r) {
                    var t = Object.keys(e);
                    if (Object.getOwnPropertySymbols) {
                      var o = Object.getOwnPropertySymbols(e);
                      r && (o = o.filter(function(r2) {
                        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                      })), t.push.apply(t, o);
                    }
                    return t;
                  }
                  function _objectSpread(e) {
                    for (var r = 1; r < arguments.length; r++) {
                      var t = null != arguments[r] ? arguments[r] : {};
                      r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
                        _defineProperty(e, r2, t[r2]);
                      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
                        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                      });
                    }
                    return e;
                  }
                  function _defineProperty(obj, key, value) {
                    key = _toPropertyKey(key);
                    if (key in obj) {
                      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                    } else {
                      obj[key] = value;
                    }
                    return obj;
                  }
                  function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                      throw new TypeError("Cannot call a class as a function");
                    }
                  }
                  function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                    }
                  }
                  function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                  }
                  function _toPropertyKey(arg) {
                    var key = _toPrimitive(arg, "string");
                    return _typeof(key) === "symbol" ? key : String(key);
                  }
                  function _toPrimitive(input, hint) {
                    if (_typeof(input) !== "object" || input === null) return input;
                    var prim = input[Symbol.toPrimitive];
                    if (prim !== void 0) {
                      var res = prim.call(input, hint || "default");
                      if (_typeof(res) !== "object") return res;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return (hint === "string" ? String : Number)(input);
                  }
                  function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                      throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                    Object.defineProperty(subClass, "prototype", { writable: false });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                  }
                  function _createSuper(Derived) {
                    var hasNativeReflectConstruct = _isNativeReflectConstruct();
                    return function _createSuperInternal() {
                      var Super = _getPrototypeOf(Derived), result;
                      if (hasNativeReflectConstruct) {
                        var NewTarget = _getPrototypeOf(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                      } else {
                        result = Super.apply(this, arguments);
                      }
                      return _possibleConstructorReturn(this, result);
                    };
                  }
                  function _possibleConstructorReturn(self2, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                      return call;
                    } else if (call !== void 0) {
                      throw new TypeError("Derived constructors may only return object or undefined");
                    }
                    return _assertThisInitialized(self2);
                  }
                  function _assertThisInitialized(self2) {
                    if (self2 === void 0) {
                      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self2;
                  }
                  function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
                    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
                      if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
                      if (typeof Class2 !== "function") {
                        throw new TypeError("Super expression must either be null or a function");
                      }
                      if (typeof _cache !== "undefined") {
                        if (_cache.has(Class2)) return _cache.get(Class2);
                        _cache.set(Class2, Wrapper);
                      }
                      function Wrapper() {
                        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
                      }
                      Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
                      return _setPrototypeOf(Wrapper, Class2);
                    };
                    return _wrapNativeSuper(Class);
                  }
                  function _construct(Parent, args, Class) {
                    if (_isNativeReflectConstruct()) {
                      _construct = Reflect.construct.bind();
                    } else {
                      _construct = function _construct2(Parent2, args2, Class2) {
                        var a = [null];
                        a.push.apply(a, args2);
                        var Constructor = Function.bind.apply(Parent2, a);
                        var instance = new Constructor();
                        if (Class2) _setPrototypeOf(instance, Class2.prototype);
                        return instance;
                      };
                    }
                    return _construct.apply(null, arguments);
                  }
                  function _isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                      }));
                      return true;
                    } catch (e) {
                      return false;
                    }
                  }
                  function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                  }
                  function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                      o2.__proto__ = p2;
                      return o2;
                    };
                    return _setPrototypeOf(o, p);
                  }
                  function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
                      return o2.__proto__ || Object.getPrototypeOf(o2);
                    };
                    return _getPrototypeOf(o);
                  }
                  function _typeof(o) {
                    "@babel/helpers - typeof";
                    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                      return typeof o2;
                    } : function(o2) {
                      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                    }, _typeof(o);
                  }
                  var _require = __webpack_require__2(
                    /*! util/ */
                    "./node_modules/util/util.js"
                  ), inspect = _require.inspect;
                  var _require2 = __webpack_require__2(
                    /*! ../errors */
                    "./node_modules/assert/build/internal/errors.js"
                  ), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
                  function endsWith(str2, search, this_len) {
                    if (this_len === void 0 || this_len > str2.length) {
                      this_len = str2.length;
                    }
                    return str2.substring(this_len - search.length, this_len) === search;
                  }
                  function repeat2(str2, count) {
                    count = Math.floor(count);
                    if (str2.length == 0 || count == 0) return "";
                    var maxCount = str2.length * count;
                    count = Math.floor(Math.log(count) / Math.log(2));
                    while (count) {
                      str2 += str2;
                      count--;
                    }
                    str2 += str2.substring(0, maxCount - str2.length);
                    return str2;
                  }
                  var blue = "";
                  var green = "";
                  var red = "";
                  var white = "";
                  var kReadableOperator = {
                    deepStrictEqual: "Expected values to be strictly deep-equal:",
                    strictEqual: "Expected values to be strictly equal:",
                    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                    deepEqual: "Expected values to be loosely deep-equal:",
                    equal: "Expected values to be loosely equal:",
                    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                    notEqual: 'Expected "actual" to be loosely unequal to:',
                    notIdentical: "Values identical but not reference-equal:"
                  };
                  var kMaxShortLength = 10;
                  function copyError(source) {
                    var keys = Object.keys(source);
                    var target = Object.create(Object.getPrototypeOf(source));
                    keys.forEach(function(key) {
                      target[key] = source[key];
                    });
                    Object.defineProperty(target, "message", {
                      value: source.message
                    });
                    return target;
                  }
                  function inspectValue(val) {
                    return inspect(val, {
                      compact: false,
                      customInspect: false,
                      depth: 1e3,
                      maxArrayLength: Infinity,
                      // Assert compares only enumerable properties (with a few exceptions).
                      showHidden: false,
                      // Having a long line as error is better than wrapping the line for
                      // comparison for now.
                      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                      // have meta information about the inspected properties (i.e., know where
                      // in what line the property starts and ends).
                      breakLength: Infinity,
                      // Assert does not detect proxies currently.
                      showProxy: false,
                      sorted: true,
                      // Inspect getters as we also check them when comparing entries.
                      getters: true
                    });
                  }
                  function createErrDiff(actual, expected, operator) {
                    var other = "";
                    var res = "";
                    var lastPos = 0;
                    var end = "";
                    var skipped = false;
                    var actualInspected = inspectValue(actual);
                    var actualLines = actualInspected.split("\n");
                    var expectedLines = inspectValue(expected).split("\n");
                    var i = 0;
                    var indicator = "";
                    if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
                      operator = "strictEqualObject";
                    }
                    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                      var inputLength = actualLines[0].length + expectedLines[0].length;
                      if (inputLength <= kMaxShortLength) {
                        if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
                          return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                        }
                      } else if (operator !== "strictEqualObject") {
                        var maxLength = process2.stderr && process2.stderr.isTTY ? process2.stderr.columns : 80;
                        if (inputLength < maxLength) {
                          while (actualLines[0][i] === expectedLines[0][i]) {
                            i++;
                          }
                          if (i > 2) {
                            indicator = "\n  ".concat(repeat2(" ", i), "^");
                            i = 0;
                          }
                        }
                      }
                    }
                    var a = actualLines[actualLines.length - 1];
                    var b = expectedLines[expectedLines.length - 1];
                    while (a === b) {
                      if (i++ < 2) {
                        end = "\n  ".concat(a).concat(end);
                      } else {
                        other = a;
                      }
                      actualLines.pop();
                      expectedLines.pop();
                      if (actualLines.length === 0 || expectedLines.length === 0) break;
                      a = actualLines[actualLines.length - 1];
                      b = expectedLines[expectedLines.length - 1];
                    }
                    var maxLines = Math.max(actualLines.length, expectedLines.length);
                    if (maxLines === 0) {
                      var _actualLines = actualInspected.split("\n");
                      if (_actualLines.length > 30) {
                        _actualLines[26] = "".concat(blue, "...").concat(white);
                        while (_actualLines.length > 27) {
                          _actualLines.pop();
                        }
                      }
                      return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
                    }
                    if (i > 3) {
                      end = "\n".concat(blue, "...").concat(white).concat(end);
                      skipped = true;
                    }
                    if (other !== "") {
                      end = "\n  ".concat(other).concat(end);
                      other = "";
                    }
                    var printedLines = 0;
                    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                    for (i = 0; i < maxLines; i++) {
                      var cur = i - lastPos;
                      if (actualLines.length < i + 1) {
                        if (cur > 1 && i > 2) {
                          if (cur > 4) {
                            res += "\n".concat(blue, "...").concat(white);
                            skipped = true;
                          } else if (cur > 3) {
                            res += "\n  ".concat(expectedLines[i - 2]);
                            printedLines++;
                          }
                          res += "\n  ".concat(expectedLines[i - 1]);
                          printedLines++;
                        }
                        lastPos = i;
                        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                        printedLines++;
                      } else if (expectedLines.length < i + 1) {
                        if (cur > 1 && i > 2) {
                          if (cur > 4) {
                            res += "\n".concat(blue, "...").concat(white);
                            skipped = true;
                          } else if (cur > 3) {
                            res += "\n  ".concat(actualLines[i - 2]);
                            printedLines++;
                          }
                          res += "\n  ".concat(actualLines[i - 1]);
                          printedLines++;
                        }
                        lastPos = i;
                        res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                        printedLines++;
                      } else {
                        var expectedLine = expectedLines[i];
                        var actualLine = actualLines[i];
                        var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
                        if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
                          divergingLines = false;
                          actualLine += ",";
                        }
                        if (divergingLines) {
                          if (cur > 1 && i > 2) {
                            if (cur > 4) {
                              res += "\n".concat(blue, "...").concat(white);
                              skipped = true;
                            } else if (cur > 3) {
                              res += "\n  ".concat(actualLines[i - 2]);
                              printedLines++;
                            }
                            res += "\n  ".concat(actualLines[i - 1]);
                            printedLines++;
                          }
                          lastPos = i;
                          res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                          other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                          printedLines += 2;
                        } else {
                          res += other;
                          other = "";
                          if (cur === 1 || i === 0) {
                            res += "\n  ".concat(actualLine);
                            printedLines++;
                          }
                        }
                      }
                      if (printedLines > 20 && i < maxLines - 2) {
                        return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                      }
                    }
                    return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
                  }
                  var AssertionError = /* @__PURE__ */ function(_Error, _inspect$custom) {
                    _inherits(AssertionError2, _Error);
                    var _super = _createSuper(AssertionError2);
                    function AssertionError2(options) {
                      var _this;
                      _classCallCheck(this, AssertionError2);
                      if (_typeof(options) !== "object" || options === null) {
                        throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
                      }
                      var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                      var actual = options.actual, expected = options.expected;
                      var limit = Error.stackTraceLimit;
                      Error.stackTraceLimit = 0;
                      if (message != null) {
                        _this = _super.call(this, String(message));
                      } else {
                        if (process2.stderr && process2.stderr.isTTY) {
                          if (process2.stderr && process2.stderr.getColorDepth && process2.stderr.getColorDepth() !== 1) {
                            blue = "\x1B[34m";
                            green = "\x1B[32m";
                            white = "\x1B[39m";
                            red = "\x1B[31m";
                          } else {
                            blue = "";
                            green = "";
                            white = "";
                            red = "";
                          }
                        }
                        if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
                          actual = copyError(actual);
                          expected = copyError(expected);
                        }
                        if (operator === "deepStrictEqual" || operator === "strictEqual") {
                          _this = _super.call(this, createErrDiff(actual, expected, operator));
                        } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
                          var base = kReadableOperator[operator];
                          var res = inspectValue(actual).split("\n");
                          if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
                            base = kReadableOperator.notStrictEqualObject;
                          }
                          if (res.length > 30) {
                            res[26] = "".concat(blue, "...").concat(white);
                            while (res.length > 27) {
                              res.pop();
                            }
                          }
                          if (res.length === 1) {
                            _this = _super.call(this, "".concat(base, " ").concat(res[0]));
                          } else {
                            _this = _super.call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n"));
                          }
                        } else {
                          var _res = inspectValue(actual);
                          var other = "";
                          var knownOperators = kReadableOperator[operator];
                          if (operator === "notDeepEqual" || operator === "notEqual") {
                            _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                            if (_res.length > 1024) {
                              _res = "".concat(_res.slice(0, 1021), "...");
                            }
                          } else {
                            other = "".concat(inspectValue(expected));
                            if (_res.length > 512) {
                              _res = "".concat(_res.slice(0, 509), "...");
                            }
                            if (other.length > 512) {
                              other = "".concat(other.slice(0, 509), "...");
                            }
                            if (operator === "deepEqual" || operator === "equal") {
                              _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                            } else {
                              other = " ".concat(operator, " ").concat(other);
                            }
                          }
                          _this = _super.call(this, "".concat(_res).concat(other));
                        }
                      }
                      Error.stackTraceLimit = limit;
                      _this.generatedMessage = !message;
                      Object.defineProperty(_assertThisInitialized(_this), "name", {
                        value: "AssertionError [ERR_ASSERTION]",
                        enumerable: false,
                        writable: true,
                        configurable: true
                      });
                      _this.code = "ERR_ASSERTION";
                      _this.actual = actual;
                      _this.expected = expected;
                      _this.operator = operator;
                      if (Error.captureStackTrace) {
                        Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                      }
                      _this.stack;
                      _this.name = "AssertionError";
                      return _possibleConstructorReturn(_this);
                    }
                    _createClass(AssertionError2, [{
                      key: "toString",
                      value: function toString2() {
                        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                      }
                    }, {
                      key: _inspect$custom,
                      value: function value(recurseTimes, ctx) {
                        return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
                          customInspect: false,
                          depth: 0
                        }));
                      }
                    }]);
                    return AssertionError2;
                  }(/* @__PURE__ */ _wrapNativeSuper(Error), inspect.custom);
                  module2.exports = AssertionError;
                }
              ),
              /***/
              "./node_modules/assert/build/internal/errors.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/assert/build/internal/errors.js ***!
                  \******************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  function _typeof(o) {
                    "@babel/helpers - typeof";
                    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                      return typeof o2;
                    } : function(o2) {
                      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                    }, _typeof(o);
                  }
                  function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                    }
                  }
                  function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                  }
                  function _toPropertyKey(arg) {
                    var key = _toPrimitive(arg, "string");
                    return _typeof(key) === "symbol" ? key : String(key);
                  }
                  function _toPrimitive(input, hint) {
                    if (_typeof(input) !== "object" || input === null) return input;
                    var prim = input[Symbol.toPrimitive];
                    if (prim !== void 0) {
                      var res = prim.call(input, hint || "default");
                      if (_typeof(res) !== "object") return res;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return (hint === "string" ? String : Number)(input);
                  }
                  function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                      throw new TypeError("Cannot call a class as a function");
                    }
                  }
                  function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                      throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                    Object.defineProperty(subClass, "prototype", { writable: false });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                  }
                  function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                      o2.__proto__ = p2;
                      return o2;
                    };
                    return _setPrototypeOf(o, p);
                  }
                  function _createSuper(Derived) {
                    var hasNativeReflectConstruct = _isNativeReflectConstruct();
                    return function _createSuperInternal() {
                      var Super = _getPrototypeOf(Derived), result;
                      if (hasNativeReflectConstruct) {
                        var NewTarget = _getPrototypeOf(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                      } else {
                        result = Super.apply(this, arguments);
                      }
                      return _possibleConstructorReturn(this, result);
                    };
                  }
                  function _possibleConstructorReturn(self2, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                      return call;
                    } else if (call !== void 0) {
                      throw new TypeError("Derived constructors may only return object or undefined");
                    }
                    return _assertThisInitialized(self2);
                  }
                  function _assertThisInitialized(self2) {
                    if (self2 === void 0) {
                      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self2;
                  }
                  function _isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                      }));
                      return true;
                    } catch (e) {
                      return false;
                    }
                  }
                  function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
                      return o2.__proto__ || Object.getPrototypeOf(o2);
                    };
                    return _getPrototypeOf(o);
                  }
                  var codes = {};
                  var assert;
                  var util;
                  function createErrorType(code, message, Base) {
                    if (!Base) {
                      Base = Error;
                    }
                    function getMessage(arg1, arg2, arg3) {
                      if (typeof message === "string") {
                        return message;
                      } else {
                        return message(arg1, arg2, arg3);
                      }
                    }
                    var NodeError = /* @__PURE__ */ function(_Base) {
                      _inherits(NodeError2, _Base);
                      var _super = _createSuper(NodeError2);
                      function NodeError2(arg1, arg2, arg3) {
                        var _this;
                        _classCallCheck(this, NodeError2);
                        _this = _super.call(this, getMessage(arg1, arg2, arg3));
                        _this.code = code;
                        return _this;
                      }
                      return _createClass(NodeError2);
                    }(Base);
                    codes[code] = NodeError;
                  }
                  function oneOf(expected, thing) {
                    if (Array.isArray(expected)) {
                      var len = expected.length;
                      expected = expected.map(function(i) {
                        return String(i);
                      });
                      if (len > 2) {
                        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
                      } else if (len === 2) {
                        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                      } else {
                        return "of ".concat(thing, " ").concat(expected[0]);
                      }
                    } else {
                      return "of ".concat(thing, " ").concat(String(expected));
                    }
                  }
                  function startsWith(str2, search, pos) {
                    return str2.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                  }
                  function endsWith(str2, search, this_len) {
                    if (this_len === void 0 || this_len > str2.length) {
                      this_len = str2.length;
                    }
                    return str2.substring(this_len - search.length, this_len) === search;
                  }
                  function includes(str2, search, start) {
                    if (typeof start !== "number") {
                      start = 0;
                    }
                    if (start + search.length > str2.length) {
                      return false;
                    } else {
                      return str2.indexOf(search, start) !== -1;
                    }
                  }
                  createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
                  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
                    if (assert === void 0) assert = __webpack_require__2(
                      /*! ../assert */
                      "./node_modules/assert/build/assert.js"
                    );
                    assert(typeof name === "string", "'name' must be a string");
                    var determiner;
                    if (typeof expected === "string" && startsWith(expected, "not ")) {
                      determiner = "must not be";
                      expected = expected.replace(/^not /, "");
                    } else {
                      determiner = "must be";
                    }
                    var msg;
                    if (endsWith(name, " argument")) {
                      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                    } else {
                      var type2 = includes(name, ".") ? "property" : "argument";
                      msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                    }
                    msg += ". Received type ".concat(_typeof(actual));
                    return msg;
                  }, TypeError);
                  createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
                    var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
                    if (util === void 0) util = __webpack_require__2(
                      /*! util/ */
                      "./node_modules/util/util.js"
                    );
                    var inspected = util.inspect(value);
                    if (inspected.length > 128) {
                      inspected = "".concat(inspected.slice(0, 128), "...");
                    }
                    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                  }, TypeError, RangeError);
                  createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
                    var type2;
                    if (value && value.constructor && value.constructor.name) {
                      type2 = "instance of ".concat(value.constructor.name);
                    } else {
                      type2 = "type ".concat(_typeof(value));
                    }
                    return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type2, ".");
                  }, TypeError);
                  createErrorType("ERR_MISSING_ARGS", function() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    if (assert === void 0) assert = __webpack_require__2(
                      /*! ../assert */
                      "./node_modules/assert/build/assert.js"
                    );
                    assert(args.length > 0, "At least one arg needs to be specified");
                    var msg = "The ";
                    var len = args.length;
                    args = args.map(function(a) {
                      return '"'.concat(a, '"');
                    });
                    switch (len) {
                      case 1:
                        msg += "".concat(args[0], " argument");
                        break;
                      case 2:
                        msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                        break;
                      default:
                        msg += args.slice(0, len - 1).join(", ");
                        msg += ", and ".concat(args[len - 1], " arguments");
                        break;
                    }
                    return "".concat(msg, " must be specified");
                  }, TypeError);
                  module2.exports.codes = codes;
                }
              ),
              /***/
              "./node_modules/assert/build/internal/util/comparisons.js": (
                /*!****************************************************************!*\
                  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
                  \****************************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  function _slicedToArray(arr, i) {
                    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
                  }
                  function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                  }
                  function _unsupportedIterableToArray(o, minLen) {
                    if (!o) return;
                    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
                    var n = Object.prototype.toString.call(o).slice(8, -1);
                    if (n === "Object" && o.constructor) n = o.constructor.name;
                    if (n === "Map" || n === "Set") return Array.from(o);
                    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
                  }
                  function _arrayLikeToArray(arr, len) {
                    if (len == null || len > arr.length) len = arr.length;
                    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
                    return arr2;
                  }
                  function _iterableToArrayLimit(r, l) {
                    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
                    if (null != t) {
                      var e, n, i, u, a = [], f = true, o = false;
                      try {
                        if (i = (t = t.call(r)).next, 0 === l) {
                          if (Object(t) !== t) return;
                          f = false;
                        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
                      } catch (r2) {
                        o = true, n = r2;
                      } finally {
                        try {
                          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
                        } finally {
                          if (o) throw n;
                        }
                      }
                      return a;
                    }
                  }
                  function _arrayWithHoles(arr) {
                    if (Array.isArray(arr)) return arr;
                  }
                  function _typeof(o) {
                    "@babel/helpers - typeof";
                    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                      return typeof o2;
                    } : function(o2) {
                      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                    }, _typeof(o);
                  }
                  var regexFlagsSupported = /a/g.flags !== void 0;
                  var arrayFromSet = function arrayFromSet2(set2) {
                    var array = [];
                    set2.forEach(function(value) {
                      return array.push(value);
                    });
                    return array;
                  };
                  var arrayFromMap = function arrayFromMap2(map2) {
                    var array = [];
                    map2.forEach(function(value, key) {
                      return array.push([key, value]);
                    });
                    return array;
                  };
                  var objectIs = Object.is ? Object.is : __webpack_require__2(
                    /*! object-is */
                    "./node_modules/object-is/index.js"
                  );
                  var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                    return [];
                  };
                  var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__2(
                    /*! is-nan */
                    "./node_modules/is-nan/index.js"
                  );
                  function uncurryThis(f) {
                    return f.call.bind(f);
                  }
                  var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                  var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                  var objectToString = uncurryThis(Object.prototype.toString);
                  var _require$types = __webpack_require__2(
                    /*! util/ */
                    "./node_modules/util/util.js"
                  ).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                  function isNonIndex(key) {
                    if (key.length === 0 || key.length > 10) return true;
                    for (var i = 0; i < key.length; i++) {
                      var code = key.charCodeAt(i);
                      if (code < 48 || code > 57) return true;
                    }
                    return key.length === 10 && key >= Math.pow(2, 32);
                  }
                  function getOwnNonIndexProperties(value) {
                    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                  }
                  function compare(a, b) {
                    if (a === b) {
                      return 0;
                    }
                    var x = a.length;
                    var y = b.length;
                    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                      if (a[i] !== b[i]) {
                        x = a[i];
                        y = b[i];
                        break;
                      }
                    }
                    if (x < y) {
                      return -1;
                    }
                    if (y < x) {
                      return 1;
                    }
                    return 0;
                  }
                  var ONLY_ENUMERABLE = void 0;
                  var kStrict = true;
                  var kLoose = false;
                  var kNoIterator = 0;
                  var kIsArray = 1;
                  var kIsSet = 2;
                  var kIsMap = 3;
                  function areSimilarRegExps(a, b) {
                    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                  }
                  function areSimilarFloatArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                      return false;
                    }
                    for (var offset = 0; offset < a.byteLength; offset++) {
                      if (a[offset] !== b[offset]) {
                        return false;
                      }
                    }
                    return true;
                  }
                  function areSimilarTypedArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                      return false;
                    }
                    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                  }
                  function areEqualArrayBuffers(buf1, buf2) {
                    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                  }
                  function isEqualBoxedPrimitive(val1, val2) {
                    if (isNumberObject(val1)) {
                      return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                    }
                    if (isStringObject(val1)) {
                      return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                    }
                    if (isBooleanObject(val1)) {
                      return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                    }
                    if (isBigIntObject(val1)) {
                      return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                    }
                    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                  }
                  function innerDeepEqual(val1, val2, strict, memos) {
                    if (val1 === val2) {
                      if (val1 !== 0) return true;
                      return strict ? objectIs(val1, val2) : true;
                    }
                    if (strict) {
                      if (_typeof(val1) !== "object") {
                        return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
                      }
                      if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
                        return false;
                      }
                      if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                        return false;
                      }
                    } else {
                      if (val1 === null || _typeof(val1) !== "object") {
                        if (val2 === null || _typeof(val2) !== "object") {
                          return val1 == val2;
                        }
                        return false;
                      }
                      if (val2 === null || _typeof(val2) !== "object") {
                        return false;
                      }
                    }
                    var val1Tag = objectToString(val1);
                    var val2Tag = objectToString(val2);
                    if (val1Tag !== val2Tag) {
                      return false;
                    }
                    if (Array.isArray(val1)) {
                      if (val1.length !== val2.length) {
                        return false;
                      }
                      var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                      var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                      if (keys1.length !== keys2.length) {
                        return false;
                      }
                      return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                    }
                    if (val1Tag === "[object Object]") {
                      if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                        return false;
                      }
                    }
                    if (isDate(val1)) {
                      if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                        return false;
                      }
                    } else if (isRegExp(val1)) {
                      if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                        return false;
                      }
                    } else if (isNativeError(val1) || val1 instanceof Error) {
                      if (val1.message !== val2.message || val1.name !== val2.name) {
                        return false;
                      }
                    } else if (isArrayBufferView(val1)) {
                      if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                        if (!areSimilarFloatArrays(val1, val2)) {
                          return false;
                        }
                      } else if (!areSimilarTypedArrays(val1, val2)) {
                        return false;
                      }
                      var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                      var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                      if (_keys.length !== _keys2.length) {
                        return false;
                      }
                      return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                    } else if (isSet(val1)) {
                      if (!isSet(val2) || val1.size !== val2.size) {
                        return false;
                      }
                      return keyCheck(val1, val2, strict, memos, kIsSet);
                    } else if (isMap(val1)) {
                      if (!isMap(val2) || val1.size !== val2.size) {
                        return false;
                      }
                      return keyCheck(val1, val2, strict, memos, kIsMap);
                    } else if (isAnyArrayBuffer(val1)) {
                      if (!areEqualArrayBuffers(val1, val2)) {
                        return false;
                      }
                    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                      return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator);
                  }
                  function getEnumerables(val, keys) {
                    return keys.filter(function(k) {
                      return propertyIsEnumerable(val, k);
                    });
                  }
                  function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                    if (arguments.length === 5) {
                      aKeys = Object.keys(val1);
                      var bKeys = Object.keys(val2);
                      if (aKeys.length !== bKeys.length) {
                        return false;
                      }
                    }
                    var i = 0;
                    for (; i < aKeys.length; i++) {
                      if (!hasOwnProperty(val2, aKeys[i])) {
                        return false;
                      }
                    }
                    if (strict && arguments.length === 5) {
                      var symbolKeysA = objectGetOwnPropertySymbols(val1);
                      if (symbolKeysA.length !== 0) {
                        var count = 0;
                        for (i = 0; i < symbolKeysA.length; i++) {
                          var key = symbolKeysA[i];
                          if (propertyIsEnumerable(val1, key)) {
                            if (!propertyIsEnumerable(val2, key)) {
                              return false;
                            }
                            aKeys.push(key);
                            count++;
                          } else if (propertyIsEnumerable(val2, key)) {
                            return false;
                          }
                        }
                        var symbolKeysB = objectGetOwnPropertySymbols(val2);
                        if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                          return false;
                        }
                      } else {
                        var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                        if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                          return false;
                        }
                      }
                    }
                    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                      return true;
                    }
                    if (memos === void 0) {
                      memos = {
                        val1: /* @__PURE__ */ new Map(),
                        val2: /* @__PURE__ */ new Map(),
                        position: 0
                      };
                    } else {
                      var val2MemoA = memos.val1.get(val1);
                      if (val2MemoA !== void 0) {
                        var val2MemoB = memos.val2.get(val2);
                        if (val2MemoB !== void 0) {
                          return val2MemoA === val2MemoB;
                        }
                      }
                      memos.position++;
                    }
                    memos.val1.set(val1, memos.position);
                    memos.val2.set(val2, memos.position);
                    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                    memos.val1.delete(val1);
                    memos.val2.delete(val2);
                    return areEq;
                  }
                  function setHasEqualElement(set2, val1, strict, memo) {
                    var setValues = arrayFromSet(set2);
                    for (var i = 0; i < setValues.length; i++) {
                      var val2 = setValues[i];
                      if (innerDeepEqual(val1, val2, strict, memo)) {
                        set2.delete(val2);
                        return true;
                      }
                    }
                    return false;
                  }
                  function findLooseMatchingPrimitives(prim) {
                    switch (_typeof(prim)) {
                      case "undefined":
                        return null;
                      case "object":
                        return void 0;
                      case "symbol":
                        return false;
                      case "string":
                        prim = +prim;
                      // Loose equal entries exist only if the string is possible to convert to
                      // a regular number and not NaN.
                      // Fall through
                      case "number":
                        if (numberIsNaN(prim)) {
                          return false;
                        }
                    }
                    return true;
                  }
                  function setMightHaveLoosePrim(a, b, prim) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) return altValue;
                    return b.has(altValue) && !a.has(altValue);
                  }
                  function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) {
                      return altValue;
                    }
                    var curB = b.get(altValue);
                    if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                      return false;
                    }
                    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                  }
                  function setEquiv(a, b, strict, memo) {
                    var set2 = null;
                    var aValues = arrayFromSet(a);
                    for (var i = 0; i < aValues.length; i++) {
                      var val = aValues[i];
                      if (_typeof(val) === "object" && val !== null) {
                        if (set2 === null) {
                          set2 = /* @__PURE__ */ new Set();
                        }
                        set2.add(val);
                      } else if (!b.has(val)) {
                        if (strict) return false;
                        if (!setMightHaveLoosePrim(a, b, val)) {
                          return false;
                        }
                        if (set2 === null) {
                          set2 = /* @__PURE__ */ new Set();
                        }
                        set2.add(val);
                      }
                    }
                    if (set2 !== null) {
                      var bValues = arrayFromSet(b);
                      for (var _i = 0; _i < bValues.length; _i++) {
                        var _val = bValues[_i];
                        if (_typeof(_val) === "object" && _val !== null) {
                          if (!setHasEqualElement(set2, _val, strict, memo)) return false;
                        } else if (!strict && !a.has(_val) && !setHasEqualElement(set2, _val, strict, memo)) {
                          return false;
                        }
                      }
                      return set2.size === 0;
                    }
                    return true;
                  }
                  function mapHasEqualEntry(set2, map2, key1, item1, strict, memo) {
                    var setValues = arrayFromSet(set2);
                    for (var i = 0; i < setValues.length; i++) {
                      var key2 = setValues[i];
                      if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map2.get(key2), strict, memo)) {
                        set2.delete(key2);
                        return true;
                      }
                    }
                    return false;
                  }
                  function mapEquiv(a, b, strict, memo) {
                    var set2 = null;
                    var aEntries = arrayFromMap(a);
                    for (var i = 0; i < aEntries.length; i++) {
                      var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                      if (_typeof(key) === "object" && key !== null) {
                        if (set2 === null) {
                          set2 = /* @__PURE__ */ new Set();
                        }
                        set2.add(key);
                      } else {
                        var item2 = b.get(key);
                        if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                          if (strict) return false;
                          if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                          if (set2 === null) {
                            set2 = /* @__PURE__ */ new Set();
                          }
                          set2.add(key);
                        }
                      }
                    }
                    if (set2 !== null) {
                      var bEntries = arrayFromMap(b);
                      for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
                        var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
                        if (_typeof(_key) === "object" && _key !== null) {
                          if (!mapHasEqualEntry(set2, a, _key, item, strict, memo)) return false;
                        } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set2, a, _key, item, false, memo)) {
                          return false;
                        }
                      }
                      return set2.size === 0;
                    }
                    return true;
                  }
                  function objEquiv(a, b, strict, keys, memos, iterationType) {
                    var i = 0;
                    if (iterationType === kIsSet) {
                      if (!setEquiv(a, b, strict, memos)) {
                        return false;
                      }
                    } else if (iterationType === kIsMap) {
                      if (!mapEquiv(a, b, strict, memos)) {
                        return false;
                      }
                    } else if (iterationType === kIsArray) {
                      for (; i < a.length; i++) {
                        if (hasOwnProperty(a, i)) {
                          if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                            return false;
                          }
                        } else if (hasOwnProperty(b, i)) {
                          return false;
                        } else {
                          var keysA = Object.keys(a);
                          for (; i < keysA.length; i++) {
                            var key = keysA[i];
                            if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                              return false;
                            }
                          }
                          if (keysA.length !== Object.keys(b).length) {
                            return false;
                          }
                          return true;
                        }
                      }
                    }
                    for (i = 0; i < keys.length; i++) {
                      var _key2 = keys[i];
                      if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
                        return false;
                      }
                    }
                    return true;
                  }
                  function isDeepEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kLoose);
                  }
                  function isDeepStrictEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kStrict);
                  }
                  module2.exports = {
                    isDeepEqual,
                    isDeepStrictEqual
                  };
                }
              ),
              /***/
              "./node_modules/available-typed-arrays/index.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/available-typed-arrays/index.js ***!
                  \******************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var possibleNames = __webpack_require__2(
                    /*! possible-typed-array-names */
                    "./node_modules/possible-typed-array-names/index.js"
                  );
                  var g = typeof globalThis === "undefined" ? __webpack_require__2.g : globalThis;
                  module2.exports = function availableTypedArrays() {
                    var out = [];
                    for (var i = 0; i < possibleNames.length; i++) {
                      if (typeof g[possibleNames[i]] === "function") {
                        out[out.length] = possibleNames[i];
                      }
                    }
                    return out;
                  };
                }
              ),
              /***/
              "./node_modules/call-bind-apply-helpers/actualApply.js": (
                /*!*************************************************************!*\
                  !*** ./node_modules/call-bind-apply-helpers/actualApply.js ***!
                  \*************************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var bind = __webpack_require__2(
                    /*! function-bind */
                    "./node_modules/function-bind/index.js"
                  );
                  var $apply = __webpack_require__2(
                    /*! ./functionApply */
                    "./node_modules/call-bind-apply-helpers/functionApply.js"
                  );
                  var $call = __webpack_require__2(
                    /*! ./functionCall */
                    "./node_modules/call-bind-apply-helpers/functionCall.js"
                  );
                  var $reflectApply = __webpack_require__2(
                    /*! ./reflectApply */
                    "./node_modules/call-bind-apply-helpers/reflectApply.js"
                  );
                  module2.exports = $reflectApply || bind.call($call, $apply);
                }
              ),
              /***/
              "./node_modules/call-bind-apply-helpers/applyBind.js": (
                /*!***********************************************************!*\
                  !*** ./node_modules/call-bind-apply-helpers/applyBind.js ***!
                  \***********************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var bind = __webpack_require__2(
                    /*! function-bind */
                    "./node_modules/function-bind/index.js"
                  );
                  var $apply = __webpack_require__2(
                    /*! ./functionApply */
                    "./node_modules/call-bind-apply-helpers/functionApply.js"
                  );
                  var actualApply = __webpack_require__2(
                    /*! ./actualApply */
                    "./node_modules/call-bind-apply-helpers/actualApply.js"
                  );
                  module2.exports = function applyBind() {
                    return actualApply(bind, $apply, arguments);
                  };
                }
              ),
              /***/
              "./node_modules/call-bind-apply-helpers/functionApply.js": (
                /*!***************************************************************!*\
                  !*** ./node_modules/call-bind-apply-helpers/functionApply.js ***!
                  \***************************************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Function.prototype.apply;
                }
              ),
              /***/
              "./node_modules/call-bind-apply-helpers/functionCall.js": (
                /*!**************************************************************!*\
                  !*** ./node_modules/call-bind-apply-helpers/functionCall.js ***!
                  \**************************************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Function.prototype.call;
                }
              ),
              /***/
              "./node_modules/call-bind-apply-helpers/index.js": (
                /*!*******************************************************!*\
                  !*** ./node_modules/call-bind-apply-helpers/index.js ***!
                  \*******************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var bind = __webpack_require__2(
                    /*! function-bind */
                    "./node_modules/function-bind/index.js"
                  );
                  var $TypeError = __webpack_require__2(
                    /*! es-errors/type */
                    "./node_modules/es-errors/type.js"
                  );
                  var $call = __webpack_require__2(
                    /*! ./functionCall */
                    "./node_modules/call-bind-apply-helpers/functionCall.js"
                  );
                  var $actualApply = __webpack_require__2(
                    /*! ./actualApply */
                    "./node_modules/call-bind-apply-helpers/actualApply.js"
                  );
                  module2.exports = function callBindBasic(args) {
                    if (args.length < 1 || typeof args[0] !== "function") {
                      throw new $TypeError("a function is required");
                    }
                    return $actualApply(bind, $call, args);
                  };
                }
              ),
              /***/
              "./node_modules/call-bind-apply-helpers/reflectApply.js": (
                /*!**************************************************************!*\
                  !*** ./node_modules/call-bind-apply-helpers/reflectApply.js ***!
                  \**************************************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
                }
              ),
              /***/
              "./node_modules/call-bind/callBound.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/call-bind/callBound.js ***!
                  \*********************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var GetIntrinsic = __webpack_require__2(
                    /*! get-intrinsic */
                    "./node_modules/get-intrinsic/index.js"
                  );
                  var callBind = __webpack_require__2(
                    /*! ./ */
                    "./node_modules/call-bind/index.js"
                  );
                  var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
                  module2.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = GetIntrinsic(name, !!allowMissing);
                    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
                      return callBind(intrinsic);
                    }
                    return intrinsic;
                  };
                }
              ),
              /***/
              "./node_modules/call-bind/index.js": (
                /*!*****************************************!*\
                  !*** ./node_modules/call-bind/index.js ***!
                  \*****************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var setFunctionLength = __webpack_require__2(
                    /*! set-function-length */
                    "./node_modules/set-function-length/index.js"
                  );
                  var $defineProperty = __webpack_require__2(
                    /*! es-define-property */
                    "./node_modules/es-define-property/index.js"
                  );
                  var callBindBasic = __webpack_require__2(
                    /*! call-bind-apply-helpers */
                    "./node_modules/call-bind-apply-helpers/index.js"
                  );
                  var applyBind = __webpack_require__2(
                    /*! call-bind-apply-helpers/applyBind */
                    "./node_modules/call-bind-apply-helpers/applyBind.js"
                  );
                  module2.exports = function callBind(originalFunction) {
                    var func = callBindBasic(arguments);
                    var adjustedLength = originalFunction.length - (arguments.length - 1);
                    return setFunctionLength(
                      func,
                      1 + (adjustedLength > 0 ? adjustedLength : 0),
                      true
                    );
                  };
                  if ($defineProperty) {
                    $defineProperty(module2.exports, "apply", { value: applyBind });
                  } else {
                    module2.exports.apply = applyBind;
                  }
                }
              ),
              /***/
              "./node_modules/call-bound/index.js": (
                /*!******************************************!*\
                  !*** ./node_modules/call-bound/index.js ***!
                  \******************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var GetIntrinsic = __webpack_require__2(
                    /*! get-intrinsic */
                    "./node_modules/get-intrinsic/index.js"
                  );
                  var callBindBasic = __webpack_require__2(
                    /*! call-bind-apply-helpers */
                    "./node_modules/call-bind-apply-helpers/index.js"
                  );
                  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
                  module2.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = (
                      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
                      GetIntrinsic(name, !!allowMissing)
                    );
                    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
                      return callBindBasic(
                        /** @type {const} */
                        [intrinsic]
                      );
                    }
                    return intrinsic;
                  };
                }
              ),
              /***/
              "./node_modules/define-data-property/index.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/define-data-property/index.js ***!
                  \****************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var $defineProperty = __webpack_require__2(
                    /*! es-define-property */
                    "./node_modules/es-define-property/index.js"
                  );
                  var $SyntaxError = __webpack_require__2(
                    /*! es-errors/syntax */
                    "./node_modules/es-errors/syntax.js"
                  );
                  var $TypeError = __webpack_require__2(
                    /*! es-errors/type */
                    "./node_modules/es-errors/type.js"
                  );
                  var gopd = __webpack_require__2(
                    /*! gopd */
                    "./node_modules/gopd/index.js"
                  );
                  module2.exports = function defineDataProperty(obj, property, value) {
                    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
                      throw new $TypeError("`obj` must be an object or a function`");
                    }
                    if (typeof property !== "string" && typeof property !== "symbol") {
                      throw new $TypeError("`property` must be a string or a symbol`");
                    }
                    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
                      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
                    }
                    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
                      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
                    }
                    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
                      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
                    }
                    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
                      throw new $TypeError("`loose`, if provided, must be a boolean");
                    }
                    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
                    var nonWritable = arguments.length > 4 ? arguments[4] : null;
                    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
                    var loose = arguments.length > 6 ? arguments[6] : false;
                    var desc = !!gopd && gopd(obj, property);
                    if ($defineProperty) {
                      $defineProperty(obj, property, {
                        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
                        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
                        value,
                        writable: nonWritable === null && desc ? desc.writable : !nonWritable
                      });
                    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
                      obj[property] = value;
                    } else {
                      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
                    }
                  };
                }
              ),
              /***/
              "./node_modules/define-properties/index.js": (
                /*!*************************************************!*\
                  !*** ./node_modules/define-properties/index.js ***!
                  \*************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var keys = __webpack_require__2(
                    /*! object-keys */
                    "./node_modules/object-keys/index.js"
                  );
                  var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
                  var toStr = Object.prototype.toString;
                  var concat = Array.prototype.concat;
                  var defineDataProperty = __webpack_require__2(
                    /*! define-data-property */
                    "./node_modules/define-data-property/index.js"
                  );
                  var isFunction = function(fn) {
                    return typeof fn === "function" && toStr.call(fn) === "[object Function]";
                  };
                  var supportsDescriptors = __webpack_require__2(
                    /*! has-property-descriptors */
                    "./node_modules/has-property-descriptors/index.js"
                  )();
                  var defineProperty = function(object, name, value, predicate) {
                    if (name in object) {
                      if (predicate === true) {
                        if (object[name] === value) {
                          return;
                        }
                      } else if (!isFunction(predicate) || !predicate()) {
                        return;
                      }
                    }
                    if (supportsDescriptors) {
                      defineDataProperty(object, name, value, true);
                    } else {
                      defineDataProperty(object, name, value);
                    }
                  };
                  var defineProperties = function(object, map2) {
                    var predicates = arguments.length > 2 ? arguments[2] : {};
                    var props = keys(map2);
                    if (hasSymbols) {
                      props = concat.call(props, Object.getOwnPropertySymbols(map2));
                    }
                    for (var i = 0; i < props.length; i += 1) {
                      defineProperty(object, props[i], map2[props[i]], predicates[props[i]]);
                    }
                  };
                  defineProperties.supportsDescriptors = !!supportsDescriptors;
                  module2.exports = defineProperties;
                }
              ),
              /***/
              "./node_modules/dunder-proto/get.js": (
                /*!******************************************!*\
                  !*** ./node_modules/dunder-proto/get.js ***!
                  \******************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var callBind = __webpack_require__2(
                    /*! call-bind-apply-helpers */
                    "./node_modules/call-bind-apply-helpers/index.js"
                  );
                  var gOPD = __webpack_require__2(
                    /*! gopd */
                    "./node_modules/gopd/index.js"
                  );
                  var hasProtoAccessor;
                  try {
                    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
                    [].__proto__ === Array.prototype;
                  } catch (e) {
                    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
                      throw e;
                    }
                  }
                  var desc = !!hasProtoAccessor && gOPD && gOPD(
                    Object.prototype,
                    /** @type {keyof typeof Object.prototype} */
                    "__proto__"
                  );
                  var $Object = Object;
                  var $getPrototypeOf = $Object.getPrototypeOf;
                  module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
                    /** @type {import('./get')} */
                    function getDunder(value) {
                      return $getPrototypeOf(value == null ? value : $Object(value));
                    }
                  ) : false;
                }
              ),
              /***/
              "./node_modules/es-define-property/index.js": (
                /*!**************************************************!*\
                  !*** ./node_modules/es-define-property/index.js ***!
                  \**************************************************/
                /***/
                (module2) => {
                  "use strict";
                  var $defineProperty = Object.defineProperty || false;
                  if ($defineProperty) {
                    try {
                      $defineProperty({}, "a", { value: 1 });
                    } catch (e) {
                      $defineProperty = false;
                    }
                  }
                  module2.exports = $defineProperty;
                }
              ),
              /***/
              "./node_modules/es-errors/eval.js": (
                /*!****************************************!*\
                  !*** ./node_modules/es-errors/eval.js ***!
                  \****************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = EvalError;
                }
              ),
              /***/
              "./node_modules/es-errors/index.js": (
                /*!*****************************************!*\
                  !*** ./node_modules/es-errors/index.js ***!
                  \*****************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Error;
                }
              ),
              /***/
              "./node_modules/es-errors/range.js": (
                /*!*****************************************!*\
                  !*** ./node_modules/es-errors/range.js ***!
                  \*****************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = RangeError;
                }
              ),
              /***/
              "./node_modules/es-errors/ref.js": (
                /*!***************************************!*\
                  !*** ./node_modules/es-errors/ref.js ***!
                  \***************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = ReferenceError;
                }
              ),
              /***/
              "./node_modules/es-errors/syntax.js": (
                /*!******************************************!*\
                  !*** ./node_modules/es-errors/syntax.js ***!
                  \******************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = SyntaxError;
                }
              ),
              /***/
              "./node_modules/es-errors/type.js": (
                /*!****************************************!*\
                  !*** ./node_modules/es-errors/type.js ***!
                  \****************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = TypeError;
                }
              ),
              /***/
              "./node_modules/es-errors/uri.js": (
                /*!***************************************!*\
                  !*** ./node_modules/es-errors/uri.js ***!
                  \***************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = URIError;
                }
              ),
              /***/
              "./node_modules/es-object-atoms/index.js": (
                /*!***********************************************!*\
                  !*** ./node_modules/es-object-atoms/index.js ***!
                  \***********************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Object;
                }
              ),
              /***/
              "./node_modules/for-each/index.js": (
                /*!****************************************!*\
                  !*** ./node_modules/for-each/index.js ***!
                  \****************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var isCallable = __webpack_require__2(
                    /*! is-callable */
                    "./node_modules/is-callable/index.js"
                  );
                  var toStr = Object.prototype.toString;
                  var hasOwnProperty = Object.prototype.hasOwnProperty;
                  var forEachArray = function forEachArray2(array, iterator, receiver) {
                    for (var i = 0, len = array.length; i < len; i++) {
                      if (hasOwnProperty.call(array, i)) {
                        if (receiver == null) {
                          iterator(array[i], i, array);
                        } else {
                          iterator.call(receiver, array[i], i, array);
                        }
                      }
                    }
                  };
                  var forEachString = function forEachString2(string, iterator, receiver) {
                    for (var i = 0, len = string.length; i < len; i++) {
                      if (receiver == null) {
                        iterator(string.charAt(i), i, string);
                      } else {
                        iterator.call(receiver, string.charAt(i), i, string);
                      }
                    }
                  };
                  var forEachObject = function forEachObject2(object, iterator, receiver) {
                    for (var k in object) {
                      if (hasOwnProperty.call(object, k)) {
                        if (receiver == null) {
                          iterator(object[k], k, object);
                        } else {
                          iterator.call(receiver, object[k], k, object);
                        }
                      }
                    }
                  };
                  function isArray(x) {
                    return toStr.call(x) === "[object Array]";
                  }
                  module2.exports = function forEach(list, iterator, thisArg) {
                    if (!isCallable(iterator)) {
                      throw new TypeError("iterator must be a function");
                    }
                    var receiver;
                    if (arguments.length >= 3) {
                      receiver = thisArg;
                    }
                    if (isArray(list)) {
                      forEachArray(list, iterator, receiver);
                    } else if (typeof list === "string") {
                      forEachString(list, iterator, receiver);
                    } else {
                      forEachObject(list, iterator, receiver);
                    }
                  };
                }
              ),
              /***/
              "./node_modules/function-bind/implementation.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/function-bind/implementation.js ***!
                  \******************************************************/
                /***/
                (module2) => {
                  "use strict";
                  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
                  var toStr = Object.prototype.toString;
                  var max6 = Math.max;
                  var funcType = "[object Function]";
                  var concatty = function concatty2(a, b) {
                    var arr = [];
                    for (var i = 0; i < a.length; i += 1) {
                      arr[i] = a[i];
                    }
                    for (var j = 0; j < b.length; j += 1) {
                      arr[j + a.length] = b[j];
                    }
                    return arr;
                  };
                  var slicy = function slicy2(arrLike, offset) {
                    var arr = [];
                    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
                      arr[j] = arrLike[i];
                    }
                    return arr;
                  };
                  var joiny = function(arr, joiner) {
                    var str2 = "";
                    for (var i = 0; i < arr.length; i += 1) {
                      str2 += arr[i];
                      if (i + 1 < arr.length) {
                        str2 += joiner;
                      }
                    }
                    return str2;
                  };
                  module2.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
                      throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slicy(arguments, 1);
                    var bound;
                    var binder = function() {
                      if (this instanceof bound) {
                        var result = target.apply(
                          this,
                          concatty(args, arguments)
                        );
                        if (Object(result) === result) {
                          return result;
                        }
                        return this;
                      }
                      return target.apply(
                        that,
                        concatty(args, arguments)
                      );
                    };
                    var boundLength = max6(0, target.length - args.length);
                    var boundArgs = [];
                    for (var i = 0; i < boundLength; i++) {
                      boundArgs[i] = "$" + i;
                    }
                    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
                    if (target.prototype) {
                      var Empty = function Empty2() {
                      };
                      Empty.prototype = target.prototype;
                      bound.prototype = new Empty();
                      Empty.prototype = null;
                    }
                    return bound;
                  };
                }
              ),
              /***/
              "./node_modules/function-bind/index.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/function-bind/index.js ***!
                  \*********************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var implementation = __webpack_require__2(
                    /*! ./implementation */
                    "./node_modules/function-bind/implementation.js"
                  );
                  module2.exports = Function.prototype.bind || implementation;
                }
              ),
              /***/
              "./node_modules/get-intrinsic/index.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/get-intrinsic/index.js ***!
                  \*********************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var undefined2;
                  var $Object = __webpack_require__2(
                    /*! es-object-atoms */
                    "./node_modules/es-object-atoms/index.js"
                  );
                  var $Error = __webpack_require__2(
                    /*! es-errors */
                    "./node_modules/es-errors/index.js"
                  );
                  var $EvalError = __webpack_require__2(
                    /*! es-errors/eval */
                    "./node_modules/es-errors/eval.js"
                  );
                  var $RangeError = __webpack_require__2(
                    /*! es-errors/range */
                    "./node_modules/es-errors/range.js"
                  );
                  var $ReferenceError = __webpack_require__2(
                    /*! es-errors/ref */
                    "./node_modules/es-errors/ref.js"
                  );
                  var $SyntaxError = __webpack_require__2(
                    /*! es-errors/syntax */
                    "./node_modules/es-errors/syntax.js"
                  );
                  var $TypeError = __webpack_require__2(
                    /*! es-errors/type */
                    "./node_modules/es-errors/type.js"
                  );
                  var $URIError = __webpack_require__2(
                    /*! es-errors/uri */
                    "./node_modules/es-errors/uri.js"
                  );
                  var abs3 = __webpack_require__2(
                    /*! math-intrinsics/abs */
                    "./node_modules/math-intrinsics/abs.js"
                  );
                  var floor5 = __webpack_require__2(
                    /*! math-intrinsics/floor */
                    "./node_modules/math-intrinsics/floor.js"
                  );
                  var max6 = __webpack_require__2(
                    /*! math-intrinsics/max */
                    "./node_modules/math-intrinsics/max.js"
                  );
                  var min6 = __webpack_require__2(
                    /*! math-intrinsics/min */
                    "./node_modules/math-intrinsics/min.js"
                  );
                  var pow8 = __webpack_require__2(
                    /*! math-intrinsics/pow */
                    "./node_modules/math-intrinsics/pow.js"
                  );
                  var round7 = __webpack_require__2(
                    /*! math-intrinsics/round */
                    "./node_modules/math-intrinsics/round.js"
                  );
                  var sign = __webpack_require__2(
                    /*! math-intrinsics/sign */
                    "./node_modules/math-intrinsics/sign.js"
                  );
                  var $Function = Function;
                  var getEvalledConstructor = function(expressionSyntax) {
                    try {
                      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
                    } catch (e) {
                    }
                  };
                  var $gOPD = __webpack_require__2(
                    /*! gopd */
                    "./node_modules/gopd/index.js"
                  );
                  var $defineProperty = __webpack_require__2(
                    /*! es-define-property */
                    "./node_modules/es-define-property/index.js"
                  );
                  var throwTypeError = function() {
                    throw new $TypeError();
                  };
                  var ThrowTypeError = $gOPD ? function() {
                    try {
                      arguments.callee;
                      return throwTypeError;
                    } catch (calleeThrows) {
                      try {
                        return $gOPD(arguments, "callee").get;
                      } catch (gOPDthrows) {
                        return throwTypeError;
                      }
                    }
                  }() : throwTypeError;
                  var hasSymbols = __webpack_require__2(
                    /*! has-symbols */
                    "./node_modules/has-symbols/index.js"
                  )();
                  var getProto = __webpack_require__2(
                    /*! get-proto */
                    "./node_modules/get-proto/index.js"
                  );
                  var $ObjectGPO = __webpack_require__2(
                    /*! get-proto/Object.getPrototypeOf */
                    "./node_modules/get-proto/Object.getPrototypeOf.js"
                  );
                  var $ReflectGPO = __webpack_require__2(
                    /*! get-proto/Reflect.getPrototypeOf */
                    "./node_modules/get-proto/Reflect.getPrototypeOf.js"
                  );
                  var $apply = __webpack_require__2(
                    /*! call-bind-apply-helpers/functionApply */
                    "./node_modules/call-bind-apply-helpers/functionApply.js"
                  );
                  var $call = __webpack_require__2(
                    /*! call-bind-apply-helpers/functionCall */
                    "./node_modules/call-bind-apply-helpers/functionCall.js"
                  );
                  var needsEval = {};
                  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
                  var INTRINSICS = {
                    __proto__: null,
                    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
                    "%Array%": Array,
                    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
                    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
                    "%AsyncFromSyncIteratorPrototype%": undefined2,
                    "%AsyncFunction%": needsEval,
                    "%AsyncGenerator%": needsEval,
                    "%AsyncGeneratorFunction%": needsEval,
                    "%AsyncIteratorPrototype%": needsEval,
                    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
                    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
                    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
                    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
                    "%Boolean%": Boolean,
                    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
                    "%Date%": Date,
                    "%decodeURI%": decodeURI,
                    "%decodeURIComponent%": decodeURIComponent,
                    "%encodeURI%": encodeURI,
                    "%encodeURIComponent%": encodeURIComponent,
                    "%Error%": $Error,
                    "%eval%": eval,
                    // eslint-disable-line no-eval
                    "%EvalError%": $EvalError,
                    "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
                    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
                    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
                    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
                    "%Function%": $Function,
                    "%GeneratorFunction%": needsEval,
                    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
                    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
                    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
                    "%isFinite%": isFinite,
                    "%isNaN%": isNaN,
                    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
                    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
                    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
                    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
                    "%Math%": Math,
                    "%Number%": Number,
                    "%Object%": $Object,
                    "%Object.getOwnPropertyDescriptor%": $gOPD,
                    "%parseFloat%": parseFloat,
                    "%parseInt%": parseInt,
                    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
                    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
                    "%RangeError%": $RangeError,
                    "%ReferenceError%": $ReferenceError,
                    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
                    "%RegExp%": RegExp,
                    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
                    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
                    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
                    "%String%": String,
                    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
                    "%Symbol%": hasSymbols ? Symbol : undefined2,
                    "%SyntaxError%": $SyntaxError,
                    "%ThrowTypeError%": ThrowTypeError,
                    "%TypedArray%": TypedArray,
                    "%TypeError%": $TypeError,
                    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
                    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
                    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
                    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
                    "%URIError%": $URIError,
                    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
                    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
                    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
                    "%Function.prototype.call%": $call,
                    "%Function.prototype.apply%": $apply,
                    "%Object.defineProperty%": $defineProperty,
                    "%Object.getPrototypeOf%": $ObjectGPO,
                    "%Math.abs%": abs3,
                    "%Math.floor%": floor5,
                    "%Math.max%": max6,
                    "%Math.min%": min6,
                    "%Math.pow%": pow8,
                    "%Math.round%": round7,
                    "%Math.sign%": sign,
                    "%Reflect.getPrototypeOf%": $ReflectGPO
                  };
                  if (getProto) {
                    try {
                      null.error;
                    } catch (e) {
                      var errorProto = getProto(getProto(e));
                      INTRINSICS["%Error.prototype%"] = errorProto;
                    }
                  }
                  var doEval = function doEval2(name) {
                    var value;
                    if (name === "%AsyncFunction%") {
                      value = getEvalledConstructor("async function () {}");
                    } else if (name === "%GeneratorFunction%") {
                      value = getEvalledConstructor("function* () {}");
                    } else if (name === "%AsyncGeneratorFunction%") {
                      value = getEvalledConstructor("async function* () {}");
                    } else if (name === "%AsyncGenerator%") {
                      var fn = doEval2("%AsyncGeneratorFunction%");
                      if (fn) {
                        value = fn.prototype;
                      }
                    } else if (name === "%AsyncIteratorPrototype%") {
                      var gen = doEval2("%AsyncGenerator%");
                      if (gen && getProto) {
                        value = getProto(gen.prototype);
                      }
                    }
                    INTRINSICS[name] = value;
                    return value;
                  };
                  var LEGACY_ALIASES = {
                    __proto__: null,
                    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
                    "%ArrayPrototype%": ["Array", "prototype"],
                    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
                    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
                    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
                    "%ArrayProto_values%": ["Array", "prototype", "values"],
                    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
                    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
                    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
                    "%BooleanPrototype%": ["Boolean", "prototype"],
                    "%DataViewPrototype%": ["DataView", "prototype"],
                    "%DatePrototype%": ["Date", "prototype"],
                    "%ErrorPrototype%": ["Error", "prototype"],
                    "%EvalErrorPrototype%": ["EvalError", "prototype"],
                    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
                    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
                    "%FunctionPrototype%": ["Function", "prototype"],
                    "%Generator%": ["GeneratorFunction", "prototype"],
                    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
                    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
                    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
                    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
                    "%JSONParse%": ["JSON", "parse"],
                    "%JSONStringify%": ["JSON", "stringify"],
                    "%MapPrototype%": ["Map", "prototype"],
                    "%NumberPrototype%": ["Number", "prototype"],
                    "%ObjectPrototype%": ["Object", "prototype"],
                    "%ObjProto_toString%": ["Object", "prototype", "toString"],
                    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
                    "%PromisePrototype%": ["Promise", "prototype"],
                    "%PromiseProto_then%": ["Promise", "prototype", "then"],
                    "%Promise_all%": ["Promise", "all"],
                    "%Promise_reject%": ["Promise", "reject"],
                    "%Promise_resolve%": ["Promise", "resolve"],
                    "%RangeErrorPrototype%": ["RangeError", "prototype"],
                    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
                    "%RegExpPrototype%": ["RegExp", "prototype"],
                    "%SetPrototype%": ["Set", "prototype"],
                    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
                    "%StringPrototype%": ["String", "prototype"],
                    "%SymbolPrototype%": ["Symbol", "prototype"],
                    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
                    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
                    "%TypeErrorPrototype%": ["TypeError", "prototype"],
                    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
                    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
                    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
                    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
                    "%URIErrorPrototype%": ["URIError", "prototype"],
                    "%WeakMapPrototype%": ["WeakMap", "prototype"],
                    "%WeakSetPrototype%": ["WeakSet", "prototype"]
                  };
                  var bind = __webpack_require__2(
                    /*! function-bind */
                    "./node_modules/function-bind/index.js"
                  );
                  var hasOwn = __webpack_require__2(
                    /*! hasown */
                    "./node_modules/hasown/index.js"
                  );
                  var $concat = bind.call($call, Array.prototype.concat);
                  var $spliceApply = bind.call($apply, Array.prototype.splice);
                  var $replace = bind.call($call, String.prototype.replace);
                  var $strSlice = bind.call($call, String.prototype.slice);
                  var $exec = bind.call($call, RegExp.prototype.exec);
                  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                  var reEscapeChar = /\\(\\)?/g;
                  var stringToPath = function stringToPath2(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === "%" && last !== "%") {
                      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
                    } else if (last === "%" && first !== "%") {
                      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
                    });
                    return result;
                  };
                  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                      alias = LEGACY_ALIASES[intrinsicName];
                      intrinsicName = "%" + alias[0] + "%";
                    }
                    if (hasOwn(INTRINSICS, intrinsicName)) {
                      var value = INTRINSICS[intrinsicName];
                      if (value === needsEval) {
                        value = doEval(intrinsicName);
                      }
                      if (typeof value === "undefined" && !allowMissing) {
                        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
                      }
                      return {
                        alias,
                        name: intrinsicName,
                        value
                      };
                    }
                    throw new $SyntaxError("intrinsic " + name + " does not exist!");
                  };
                  module2.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== "string" || name.length === 0) {
                      throw new $TypeError("intrinsic name must be a non-empty string");
                    }
                    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
                      throw new $TypeError('"allowMissing" argument must be a boolean');
                    }
                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
                    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;
                    var alias = intrinsic.alias;
                    if (alias) {
                      intrinsicBaseName = alias[0];
                      $spliceApply(parts, $concat([0, 1], alias));
                    }
                    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
                      var part = parts[i];
                      var first = $strSlice(part, 0, 1);
                      var last = $strSlice(part, -1);
                      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
                        throw new $SyntaxError("property names with quotes must have matching quotes");
                      }
                      if (part === "constructor" || !isOwn) {
                        skipFurtherCaching = true;
                      }
                      intrinsicBaseName += "." + part;
                      intrinsicRealName = "%" + intrinsicBaseName + "%";
                      if (hasOwn(INTRINSICS, intrinsicRealName)) {
                        value = INTRINSICS[intrinsicRealName];
                      } else if (value != null) {
                        if (!(part in value)) {
                          if (!allowMissing) {
                            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                          }
                          return void undefined2;
                        }
                        if ($gOPD && i + 1 >= parts.length) {
                          var desc = $gOPD(value, part);
                          isOwn = !!desc;
                          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                            value = desc.get;
                          } else {
                            value = value[part];
                          }
                        } else {
                          isOwn = hasOwn(value, part);
                          value = value[part];
                        }
                        if (isOwn && !skipFurtherCaching) {
                          INTRINSICS[intrinsicRealName] = value;
                        }
                      }
                    }
                    return value;
                  };
                }
              ),
              /***/
              "./node_modules/get-proto/Object.getPrototypeOf.js": (
                /*!*********************************************************!*\
                  !*** ./node_modules/get-proto/Object.getPrototypeOf.js ***!
                  \*********************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var $Object = __webpack_require__2(
                    /*! es-object-atoms */
                    "./node_modules/es-object-atoms/index.js"
                  );
                  module2.exports = $Object.getPrototypeOf || null;
                }
              ),
              /***/
              "./node_modules/get-proto/Reflect.getPrototypeOf.js": (
                /*!**********************************************************!*\
                  !*** ./node_modules/get-proto/Reflect.getPrototypeOf.js ***!
                  \**********************************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
                }
              ),
              /***/
              "./node_modules/get-proto/index.js": (
                /*!*****************************************!*\
                  !*** ./node_modules/get-proto/index.js ***!
                  \*****************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var reflectGetProto = __webpack_require__2(
                    /*! ./Reflect.getPrototypeOf */
                    "./node_modules/get-proto/Reflect.getPrototypeOf.js"
                  );
                  var originalGetProto = __webpack_require__2(
                    /*! ./Object.getPrototypeOf */
                    "./node_modules/get-proto/Object.getPrototypeOf.js"
                  );
                  var getDunderProto = __webpack_require__2(
                    /*! dunder-proto/get */
                    "./node_modules/dunder-proto/get.js"
                  );
                  module2.exports = reflectGetProto ? function getProto(O) {
                    return reflectGetProto(O);
                  } : originalGetProto ? function getProto(O) {
                    if (!O || typeof O !== "object" && typeof O !== "function") {
                      throw new TypeError("getProto: not an object");
                    }
                    return originalGetProto(O);
                  } : getDunderProto ? function getProto(O) {
                    return getDunderProto(O);
                  } : null;
                }
              ),
              /***/
              "./node_modules/gopd/gOPD.js": (
                /*!***********************************!*\
                  !*** ./node_modules/gopd/gOPD.js ***!
                  \***********************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Object.getOwnPropertyDescriptor;
                }
              ),
              /***/
              "./node_modules/gopd/index.js": (
                /*!************************************!*\
                  !*** ./node_modules/gopd/index.js ***!
                  \************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var $gOPD = __webpack_require__2(
                    /*! ./gOPD */
                    "./node_modules/gopd/gOPD.js"
                  );
                  if ($gOPD) {
                    try {
                      $gOPD([], "length");
                    } catch (e) {
                      $gOPD = null;
                    }
                  }
                  module2.exports = $gOPD;
                }
              ),
              /***/
              "./node_modules/has-property-descriptors/index.js": (
                /*!********************************************************!*\
                  !*** ./node_modules/has-property-descriptors/index.js ***!
                  \********************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var $defineProperty = __webpack_require__2(
                    /*! es-define-property */
                    "./node_modules/es-define-property/index.js"
                  );
                  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
                    return !!$defineProperty;
                  };
                  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                    if (!$defineProperty) {
                      return null;
                    }
                    try {
                      return $defineProperty([], "length", { value: 1 }).length !== 1;
                    } catch (e) {
                      return true;
                    }
                  };
                  module2.exports = hasPropertyDescriptors;
                }
              ),
              /***/
              "./node_modules/has-symbols/index.js": (
                /*!*******************************************!*\
                  !*** ./node_modules/has-symbols/index.js ***!
                  \*******************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var origSymbol = typeof Symbol !== "undefined" && Symbol;
                  var hasSymbolSham = __webpack_require__2(
                    /*! ./shams */
                    "./node_modules/has-symbols/shams.js"
                  );
                  module2.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== "function") {
                      return false;
                    }
                    if (typeof Symbol !== "function") {
                      return false;
                    }
                    if (typeof origSymbol("foo") !== "symbol") {
                      return false;
                    }
                    if (typeof Symbol("bar") !== "symbol") {
                      return false;
                    }
                    return hasSymbolSham();
                  };
                }
              ),
              /***/
              "./node_modules/has-symbols/shams.js": (
                /*!*******************************************!*\
                  !*** ./node_modules/has-symbols/shams.js ***!
                  \*******************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = function hasSymbols() {
                    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
                      return false;
                    }
                    if (typeof Symbol.iterator === "symbol") {
                      return true;
                    }
                    var obj = {};
                    var sym = Symbol("test");
                    var symObj = Object(sym);
                    if (typeof sym === "string") {
                      return false;
                    }
                    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
                      return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
                      return false;
                    }
                    var symVal = 42;
                    obj[sym] = symVal;
                    for (var _ in obj) {
                      return false;
                    }
                    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
                      return false;
                    }
                    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
                      return false;
                    }
                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                      return false;
                    }
                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                      return false;
                    }
                    if (typeof Object.getOwnPropertyDescriptor === "function") {
                      var descriptor = (
                        /** @type {PropertyDescriptor} */
                        Object.getOwnPropertyDescriptor(obj, sym)
                      );
                      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                        return false;
                      }
                    }
                    return true;
                  };
                }
              ),
              /***/
              "./node_modules/has-tostringtag/shams.js": (
                /*!***********************************************!*\
                  !*** ./node_modules/has-tostringtag/shams.js ***!
                  \***********************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var hasSymbols = __webpack_require__2(
                    /*! has-symbols/shams */
                    "./node_modules/has-symbols/shams.js"
                  );
                  module2.exports = function hasToStringTagShams() {
                    return hasSymbols() && !!Symbol.toStringTag;
                  };
                }
              ),
              /***/
              "./node_modules/hasown/index.js": (
                /*!**************************************!*\
                  !*** ./node_modules/hasown/index.js ***!
                  \**************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var call = Function.prototype.call;
                  var $hasOwn = Object.prototype.hasOwnProperty;
                  var bind = __webpack_require__2(
                    /*! function-bind */
                    "./node_modules/function-bind/index.js"
                  );
                  module2.exports = bind.call(call, $hasOwn);
                }
              ),
              /***/
              "./node_modules/inherits/inherits_browser.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/inherits/inherits_browser.js ***!
                  \***************************************************/
                /***/
                (module2) => {
                  if (typeof Object.create === "function") {
                    module2.exports = function inherits(ctor, superCtor) {
                      if (superCtor) {
                        ctor.super_ = superCtor;
                        ctor.prototype = Object.create(superCtor.prototype, {
                          constructor: {
                            value: ctor,
                            enumerable: false,
                            writable: true,
                            configurable: true
                          }
                        });
                      }
                    };
                  } else {
                    module2.exports = function inherits(ctor, superCtor) {
                      if (superCtor) {
                        ctor.super_ = superCtor;
                        var TempCtor = function() {
                        };
                        TempCtor.prototype = superCtor.prototype;
                        ctor.prototype = new TempCtor();
                        ctor.prototype.constructor = ctor;
                      }
                    };
                  }
                }
              ),
              /***/
              "./node_modules/is-arguments/index.js": (
                /*!********************************************!*\
                  !*** ./node_modules/is-arguments/index.js ***!
                  \********************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var hasToStringTag = __webpack_require__2(
                    /*! has-tostringtag/shams */
                    "./node_modules/has-tostringtag/shams.js"
                  )();
                  var callBound = __webpack_require__2(
                    /*! call-bound */
                    "./node_modules/call-bound/index.js"
                  );
                  var $toString = callBound("Object.prototype.toString");
                  var isStandardArguments = function isArguments(value) {
                    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
                      return false;
                    }
                    return $toString(value) === "[object Arguments]";
                  };
                  var isLegacyArguments = function isArguments(value) {
                    if (isStandardArguments(value)) {
                      return true;
                    }
                    return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
                  };
                  var supportsStandardArguments = function() {
                    return isStandardArguments(arguments);
                  }();
                  isStandardArguments.isLegacyArguments = isLegacyArguments;
                  module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
                }
              ),
              /***/
              "./node_modules/is-callable/index.js": (
                /*!*******************************************!*\
                  !*** ./node_modules/is-callable/index.js ***!
                  \*******************************************/
                /***/
                (module2) => {
                  "use strict";
                  var fnToStr = Function.prototype.toString;
                  var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
                  var badArrayLike;
                  var isCallableMarker;
                  if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
                    try {
                      badArrayLike = Object.defineProperty({}, "length", {
                        get: function() {
                          throw isCallableMarker;
                        }
                      });
                      isCallableMarker = {};
                      reflectApply(function() {
                        throw 42;
                      }, null, badArrayLike);
                    } catch (_) {
                      if (_ !== isCallableMarker) {
                        reflectApply = null;
                      }
                    }
                  } else {
                    reflectApply = null;
                  }
                  var constructorRegex = /^\s*class\b/;
                  var isES6ClassFn = function isES6ClassFunction(value) {
                    try {
                      var fnStr = fnToStr.call(value);
                      return constructorRegex.test(fnStr);
                    } catch (e) {
                      return false;
                    }
                  };
                  var tryFunctionObject = function tryFunctionToStr(value) {
                    try {
                      if (isES6ClassFn(value)) {
                        return false;
                      }
                      fnToStr.call(value);
                      return true;
                    } catch (e) {
                      return false;
                    }
                  };
                  var toStr = Object.prototype.toString;
                  var objectClass = "[object Object]";
                  var fnClass = "[object Function]";
                  var genClass = "[object GeneratorFunction]";
                  var ddaClass = "[object HTMLAllCollection]";
                  var ddaClass2 = "[object HTML document.all class]";
                  var ddaClass3 = "[object HTMLCollection]";
                  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
                  var isIE68 = !(0 in [,]);
                  var isDDA = function isDocumentDotAll() {
                    return false;
                  };
                  if (typeof document === "object") {
                    var all = document.all;
                    if (toStr.call(all) === toStr.call(document.all)) {
                      isDDA = function isDocumentDotAll(value) {
                        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
                          try {
                            var str2 = toStr.call(value);
                            return (str2 === ddaClass || str2 === ddaClass2 || str2 === ddaClass3 || str2 === objectClass) && value("") == null;
                          } catch (e) {
                          }
                        }
                        return false;
                      };
                    }
                  }
                  module2.exports = reflectApply ? function isCallable(value) {
                    if (isDDA(value)) {
                      return true;
                    }
                    if (!value) {
                      return false;
                    }
                    if (typeof value !== "function" && typeof value !== "object") {
                      return false;
                    }
                    try {
                      reflectApply(value, null, badArrayLike);
                    } catch (e) {
                      if (e !== isCallableMarker) {
                        return false;
                      }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                  } : function isCallable(value) {
                    if (isDDA(value)) {
                      return true;
                    }
                    if (!value) {
                      return false;
                    }
                    if (typeof value !== "function" && typeof value !== "object") {
                      return false;
                    }
                    if (hasToStringTag) {
                      return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                      return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                      return false;
                    }
                    return tryFunctionObject(value);
                  };
                }
              ),
              /***/
              "./node_modules/is-generator-function/index.js": (
                /*!*****************************************************!*\
                  !*** ./node_modules/is-generator-function/index.js ***!
                  \*****************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var callBound = __webpack_require__2(
                    /*! call-bound */
                    "./node_modules/call-bound/index.js"
                  );
                  var safeRegexTest = __webpack_require__2(
                    /*! safe-regex-test */
                    "./node_modules/safe-regex-test/index.js"
                  );
                  var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
                  var hasToStringTag = __webpack_require__2(
                    /*! has-tostringtag/shams */
                    "./node_modules/has-tostringtag/shams.js"
                  )();
                  var getProto = __webpack_require__2(
                    /*! get-proto */
                    "./node_modules/get-proto/index.js"
                  );
                  var toStr = callBound("Object.prototype.toString");
                  var fnToStr = callBound("Function.prototype.toString");
                  var getGeneratorFunc = function() {
                    if (!hasToStringTag) {
                      return false;
                    }
                    try {
                      return Function("return function*() {}")();
                    } catch (e) {
                    }
                  };
                  var GeneratorFunction;
                  module2.exports = function isGeneratorFunction(fn) {
                    if (typeof fn !== "function") {
                      return false;
                    }
                    if (isFnRegex(fnToStr(fn))) {
                      return true;
                    }
                    if (!hasToStringTag) {
                      var str2 = toStr(fn);
                      return str2 === "[object GeneratorFunction]";
                    }
                    if (!getProto) {
                      return false;
                    }
                    if (typeof GeneratorFunction === "undefined") {
                      var generatorFunc = getGeneratorFunc();
                      GeneratorFunction = generatorFunc ? (
                        /** @type {GeneratorFunctionConstructor} */
                        getProto(generatorFunc)
                      ) : false;
                    }
                    return getProto(fn) === GeneratorFunction;
                  };
                }
              ),
              /***/
              "./node_modules/is-nan/implementation.js": (
                /*!***********************************************!*\
                  !*** ./node_modules/is-nan/implementation.js ***!
                  \***********************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = function isNaN2(value) {
                    return value !== value;
                  };
                }
              ),
              /***/
              "./node_modules/is-nan/index.js": (
                /*!**************************************!*\
                  !*** ./node_modules/is-nan/index.js ***!
                  \**************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var callBind = __webpack_require__2(
                    /*! call-bind */
                    "./node_modules/call-bind/index.js"
                  );
                  var define2 = __webpack_require__2(
                    /*! define-properties */
                    "./node_modules/define-properties/index.js"
                  );
                  var implementation = __webpack_require__2(
                    /*! ./implementation */
                    "./node_modules/is-nan/implementation.js"
                  );
                  var getPolyfill = __webpack_require__2(
                    /*! ./polyfill */
                    "./node_modules/is-nan/polyfill.js"
                  );
                  var shim = __webpack_require__2(
                    /*! ./shim */
                    "./node_modules/is-nan/shim.js"
                  );
                  var polyfill = callBind(getPolyfill(), Number);
                  define2(polyfill, {
                    getPolyfill,
                    implementation,
                    shim
                  });
                  module2.exports = polyfill;
                }
              ),
              /***/
              "./node_modules/is-nan/polyfill.js": (
                /*!*****************************************!*\
                  !*** ./node_modules/is-nan/polyfill.js ***!
                  \*****************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var implementation = __webpack_require__2(
                    /*! ./implementation */
                    "./node_modules/is-nan/implementation.js"
                  );
                  module2.exports = function getPolyfill() {
                    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
                      return Number.isNaN;
                    }
                    return implementation;
                  };
                }
              ),
              /***/
              "./node_modules/is-nan/shim.js": (
                /*!*************************************!*\
                  !*** ./node_modules/is-nan/shim.js ***!
                  \*************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var define2 = __webpack_require__2(
                    /*! define-properties */
                    "./node_modules/define-properties/index.js"
                  );
                  var getPolyfill = __webpack_require__2(
                    /*! ./polyfill */
                    "./node_modules/is-nan/polyfill.js"
                  );
                  module2.exports = function shimNumberIsNaN() {
                    var polyfill = getPolyfill();
                    define2(Number, { isNaN: polyfill }, {
                      isNaN: function testIsNaN() {
                        return Number.isNaN !== polyfill;
                      }
                    });
                    return polyfill;
                  };
                }
              ),
              /***/
              "./node_modules/is-regex/index.js": (
                /*!****************************************!*\
                  !*** ./node_modules/is-regex/index.js ***!
                  \****************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var callBound = __webpack_require__2(
                    /*! call-bound */
                    "./node_modules/call-bound/index.js"
                  );
                  var hasToStringTag = __webpack_require__2(
                    /*! has-tostringtag/shams */
                    "./node_modules/has-tostringtag/shams.js"
                  )();
                  var hasOwn = __webpack_require__2(
                    /*! hasown */
                    "./node_modules/hasown/index.js"
                  );
                  var gOPD = __webpack_require__2(
                    /*! gopd */
                    "./node_modules/gopd/index.js"
                  );
                  var fn;
                  if (hasToStringTag) {
                    var $exec = callBound("RegExp.prototype.exec");
                    var isRegexMarker = {};
                    var throwRegexMarker = function() {
                      throw isRegexMarker;
                    };
                    var badStringifier = {
                      toString: throwRegexMarker,
                      valueOf: throwRegexMarker
                    };
                    if (typeof Symbol.toPrimitive === "symbol") {
                      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
                    }
                    fn = function isRegex(value) {
                      if (!value || typeof value !== "object") {
                        return false;
                      }
                      var descriptor = (
                        /** @type {NonNullable<typeof gOPD>} */
                        gOPD(
                          /** @type {{ lastIndex?: unknown }} */
                          value,
                          "lastIndex"
                        )
                      );
                      var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
                      if (!hasLastIndexDataProperty) {
                        return false;
                      }
                      try {
                        $exec(
                          value,
                          /** @type {string} */
                          /** @type {unknown} */
                          badStringifier
                        );
                      } catch (e) {
                        return e === isRegexMarker;
                      }
                    };
                  } else {
                    var $toString = callBound("Object.prototype.toString");
                    var regexClass = "[object RegExp]";
                    fn = function isRegex(value) {
                      if (!value || typeof value !== "object" && typeof value !== "function") {
                        return false;
                      }
                      return $toString(value) === regexClass;
                    };
                  }
                  module2.exports = fn;
                }
              ),
              /***/
              "./node_modules/is-typed-array/index.js": (
                /*!**********************************************!*\
                  !*** ./node_modules/is-typed-array/index.js ***!
                  \**********************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var whichTypedArray = __webpack_require__2(
                    /*! which-typed-array */
                    "./node_modules/which-typed-array/index.js"
                  );
                  module2.exports = function isTypedArray(value) {
                    return !!whichTypedArray(value);
                  };
                }
              ),
              /***/
              "./node_modules/lodash/lodash.js": (
                /*!***************************************!*\
                  !*** ./node_modules/lodash/lodash.js ***!
                  \***************************************/
                /***/
                function(module2, exports2, __webpack_require__2) {
                  module2 = __webpack_require__2.nmd(module2);
                  var __WEBPACK_AMD_DEFINE_RESULT__;
                  ;
                  (function() {
                    var undefined2;
                    var VERSION = "4.17.21";
                    var LARGE_ARRAY_SIZE = 200;
                    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
                    var HASH_UNDEFINED = "__lodash_hash_undefined__";
                    var MAX_MEMOIZE_SIZE = 500;
                    var PLACEHOLDER = "__lodash_placeholder__";
                    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
                    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
                    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
                    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
                    var HOT_COUNT = 800, HOT_SPAN = 16;
                    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
                    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
                    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
                    var wrapFlags = [
                      ["ary", WRAP_ARY_FLAG],
                      ["bind", WRAP_BIND_FLAG],
                      ["bindKey", WRAP_BIND_KEY_FLAG],
                      ["curry", WRAP_CURRY_FLAG],
                      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
                      ["flip", WRAP_FLIP_FLAG],
                      ["partial", WRAP_PARTIAL_FLAG],
                      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
                      ["rearg", WRAP_REARG_FLAG]
                    ];
                    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
                    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
                    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
                    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
                    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
                    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
                    var reTrimStart = /^\s+/;
                    var reWhitespace = /\s/;
                    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
                    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
                    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
                    var reEscapeChar = /\\(\\)?/g;
                    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                    var reFlags = /\w*$/;
                    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
                    var reIsBinary = /^0b[01]+$/i;
                    var reIsHostCtor = /^\[object .+?Constructor\]$/;
                    var reIsOctal = /^0o[0-7]+$/i;
                    var reIsUint = /^(?:0|[1-9]\d*)$/;
                    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
                    var reNoMatch = /($^)/;
                    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
                    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
                    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
                    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
                    var reApos = RegExp(rsApos, "g");
                    var reComboMark = RegExp(rsCombo, "g");
                    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
                    var reUnicodeWord = RegExp([
                      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
                      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
                      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
                      rsUpper + "+" + rsOptContrUpper,
                      rsOrdUpper,
                      rsOrdLower,
                      rsDigits,
                      rsEmoji
                    ].join("|"), "g");
                    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
                    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
                    var contextProps = [
                      "Array",
                      "Buffer",
                      "DataView",
                      "Date",
                      "Error",
                      "Float32Array",
                      "Float64Array",
                      "Function",
                      "Int8Array",
                      "Int16Array",
                      "Int32Array",
                      "Map",
                      "Math",
                      "Object",
                      "Promise",
                      "RegExp",
                      "Set",
                      "String",
                      "Symbol",
                      "TypeError",
                      "Uint8Array",
                      "Uint8ClampedArray",
                      "Uint16Array",
                      "Uint32Array",
                      "WeakMap",
                      "_",
                      "clearTimeout",
                      "isFinite",
                      "parseInt",
                      "setTimeout"
                    ];
                    var templateCounter = -1;
                    var typedArrayTags = {};
                    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
                    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
                    var cloneableTags = {};
                    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
                    var deburredLetters = {
                      // Latin-1 Supplement block.
                      "\xC0": "A",
                      "\xC1": "A",
                      "\xC2": "A",
                      "\xC3": "A",
                      "\xC4": "A",
                      "\xC5": "A",
                      "\xE0": "a",
                      "\xE1": "a",
                      "\xE2": "a",
                      "\xE3": "a",
                      "\xE4": "a",
                      "\xE5": "a",
                      "\xC7": "C",
                      "\xE7": "c",
                      "\xD0": "D",
                      "\xF0": "d",
                      "\xC8": "E",
                      "\xC9": "E",
                      "\xCA": "E",
                      "\xCB": "E",
                      "\xE8": "e",
                      "\xE9": "e",
                      "\xEA": "e",
                      "\xEB": "e",
                      "\xCC": "I",
                      "\xCD": "I",
                      "\xCE": "I",
                      "\xCF": "I",
                      "\xEC": "i",
                      "\xED": "i",
                      "\xEE": "i",
                      "\xEF": "i",
                      "\xD1": "N",
                      "\xF1": "n",
                      "\xD2": "O",
                      "\xD3": "O",
                      "\xD4": "O",
                      "\xD5": "O",
                      "\xD6": "O",
                      "\xD8": "O",
                      "\xF2": "o",
                      "\xF3": "o",
                      "\xF4": "o",
                      "\xF5": "o",
                      "\xF6": "o",
                      "\xF8": "o",
                      "\xD9": "U",
                      "\xDA": "U",
                      "\xDB": "U",
                      "\xDC": "U",
                      "\xF9": "u",
                      "\xFA": "u",
                      "\xFB": "u",
                      "\xFC": "u",
                      "\xDD": "Y",
                      "\xFD": "y",
                      "\xFF": "y",
                      "\xC6": "Ae",
                      "\xE6": "ae",
                      "\xDE": "Th",
                      "\xFE": "th",
                      "\xDF": "ss",
                      // Latin Extended-A block.
                      "\u0100": "A",
                      "\u0102": "A",
                      "\u0104": "A",
                      "\u0101": "a",
                      "\u0103": "a",
                      "\u0105": "a",
                      "\u0106": "C",
                      "\u0108": "C",
                      "\u010A": "C",
                      "\u010C": "C",
                      "\u0107": "c",
                      "\u0109": "c",
                      "\u010B": "c",
                      "\u010D": "c",
                      "\u010E": "D",
                      "\u0110": "D",
                      "\u010F": "d",
                      "\u0111": "d",
                      "\u0112": "E",
                      "\u0114": "E",
                      "\u0116": "E",
                      "\u0118": "E",
                      "\u011A": "E",
                      "\u0113": "e",
                      "\u0115": "e",
                      "\u0117": "e",
                      "\u0119": "e",
                      "\u011B": "e",
                      "\u011C": "G",
                      "\u011E": "G",
                      "\u0120": "G",
                      "\u0122": "G",
                      "\u011D": "g",
                      "\u011F": "g",
                      "\u0121": "g",
                      "\u0123": "g",
                      "\u0124": "H",
                      "\u0126": "H",
                      "\u0125": "h",
                      "\u0127": "h",
                      "\u0128": "I",
                      "\u012A": "I",
                      "\u012C": "I",
                      "\u012E": "I",
                      "\u0130": "I",
                      "\u0129": "i",
                      "\u012B": "i",
                      "\u012D": "i",
                      "\u012F": "i",
                      "\u0131": "i",
                      "\u0134": "J",
                      "\u0135": "j",
                      "\u0136": "K",
                      "\u0137": "k",
                      "\u0138": "k",
                      "\u0139": "L",
                      "\u013B": "L",
                      "\u013D": "L",
                      "\u013F": "L",
                      "\u0141": "L",
                      "\u013A": "l",
                      "\u013C": "l",
                      "\u013E": "l",
                      "\u0140": "l",
                      "\u0142": "l",
                      "\u0143": "N",
                      "\u0145": "N",
                      "\u0147": "N",
                      "\u014A": "N",
                      "\u0144": "n",
                      "\u0146": "n",
                      "\u0148": "n",
                      "\u014B": "n",
                      "\u014C": "O",
                      "\u014E": "O",
                      "\u0150": "O",
                      "\u014D": "o",
                      "\u014F": "o",
                      "\u0151": "o",
                      "\u0154": "R",
                      "\u0156": "R",
                      "\u0158": "R",
                      "\u0155": "r",
                      "\u0157": "r",
                      "\u0159": "r",
                      "\u015A": "S",
                      "\u015C": "S",
                      "\u015E": "S",
                      "\u0160": "S",
                      "\u015B": "s",
                      "\u015D": "s",
                      "\u015F": "s",
                      "\u0161": "s",
                      "\u0162": "T",
                      "\u0164": "T",
                      "\u0166": "T",
                      "\u0163": "t",
                      "\u0165": "t",
                      "\u0167": "t",
                      "\u0168": "U",
                      "\u016A": "U",
                      "\u016C": "U",
                      "\u016E": "U",
                      "\u0170": "U",
                      "\u0172": "U",
                      "\u0169": "u",
                      "\u016B": "u",
                      "\u016D": "u",
                      "\u016F": "u",
                      "\u0171": "u",
                      "\u0173": "u",
                      "\u0174": "W",
                      "\u0175": "w",
                      "\u0176": "Y",
                      "\u0177": "y",
                      "\u0178": "Y",
                      "\u0179": "Z",
                      "\u017B": "Z",
                      "\u017D": "Z",
                      "\u017A": "z",
                      "\u017C": "z",
                      "\u017E": "z",
                      "\u0132": "IJ",
                      "\u0133": "ij",
                      "\u0152": "Oe",
                      "\u0153": "oe",
                      "\u0149": "'n",
                      "\u017F": "s"
                    };
                    var htmlEscapes = {
                      "&": "&amp;",
                      "<": "&lt;",
                      ">": "&gt;",
                      '"': "&quot;",
                      "'": "&#39;"
                    };
                    var htmlUnescapes = {
                      "&amp;": "&",
                      "&lt;": "<",
                      "&gt;": ">",
                      "&quot;": '"',
                      "&#39;": "'"
                    };
                    var stringEscapes = {
                      "\\": "\\",
                      "'": "'",
                      "\n": "n",
                      "\r": "r",
                      "\u2028": "u2028",
                      "\u2029": "u2029"
                    };
                    var freeParseFloat = parseFloat, freeParseInt = parseInt;
                    var freeGlobal = typeof __webpack_require__2.g == "object" && __webpack_require__2.g && __webpack_require__2.g.Object === Object && __webpack_require__2.g;
                    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
                    var root = freeGlobal || freeSelf || Function("return this")();
                    var freeExports = exports2 && !exports2.nodeType && exports2;
                    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
                    var moduleExports = freeModule && freeModule.exports === freeExports;
                    var freeProcess = moduleExports && freeGlobal.process;
                    var nodeUtil = function() {
                      try {
                        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
                        if (types2) {
                          return types2;
                        }
                        return freeProcess && freeProcess.binding && freeProcess.binding("util");
                      } catch (e) {
                      }
                    }();
                    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
                    function apply(func, thisArg, args) {
                      switch (args.length) {
                        case 0:
                          return func.call(thisArg);
                        case 1:
                          return func.call(thisArg, args[0]);
                        case 2:
                          return func.call(thisArg, args[0], args[1]);
                        case 3:
                          return func.call(thisArg, args[0], args[1], args[2]);
                      }
                      return func.apply(thisArg, args);
                    }
                    function arrayAggregator(array, setter, iteratee, accumulator) {
                      var index = -1, length = array == null ? 0 : array.length;
                      while (++index < length) {
                        var value = array[index];
                        setter(accumulator, value, iteratee(value), array);
                      }
                      return accumulator;
                    }
                    function arrayEach(array, iteratee) {
                      var index = -1, length = array == null ? 0 : array.length;
                      while (++index < length) {
                        if (iteratee(array[index], index, array) === false) {
                          break;
                        }
                      }
                      return array;
                    }
                    function arrayEachRight(array, iteratee) {
                      var length = array == null ? 0 : array.length;
                      while (length--) {
                        if (iteratee(array[length], length, array) === false) {
                          break;
                        }
                      }
                      return array;
                    }
                    function arrayEvery(array, predicate) {
                      var index = -1, length = array == null ? 0 : array.length;
                      while (++index < length) {
                        if (!predicate(array[index], index, array)) {
                          return false;
                        }
                      }
                      return true;
                    }
                    function arrayFilter(array, predicate) {
                      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                      while (++index < length) {
                        var value = array[index];
                        if (predicate(value, index, array)) {
                          result[resIndex++] = value;
                        }
                      }
                      return result;
                    }
                    function arrayIncludes(array, value) {
                      var length = array == null ? 0 : array.length;
                      return !!length && baseIndexOf(array, value, 0) > -1;
                    }
                    function arrayIncludesWith(array, value, comparator) {
                      var index = -1, length = array == null ? 0 : array.length;
                      while (++index < length) {
                        if (comparator(value, array[index])) {
                          return true;
                        }
                      }
                      return false;
                    }
                    function arrayMap(array, iteratee) {
                      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                      while (++index < length) {
                        result[index] = iteratee(array[index], index, array);
                      }
                      return result;
                    }
                    function arrayPush(array, values) {
                      var index = -1, length = values.length, offset = array.length;
                      while (++index < length) {
                        array[offset + index] = values[index];
                      }
                      return array;
                    }
                    function arrayReduce(array, iteratee, accumulator, initAccum) {
                      var index = -1, length = array == null ? 0 : array.length;
                      if (initAccum && length) {
                        accumulator = array[++index];
                      }
                      while (++index < length) {
                        accumulator = iteratee(accumulator, array[index], index, array);
                      }
                      return accumulator;
                    }
                    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                      var length = array == null ? 0 : array.length;
                      if (initAccum && length) {
                        accumulator = array[--length];
                      }
                      while (length--) {
                        accumulator = iteratee(accumulator, array[length], length, array);
                      }
                      return accumulator;
                    }
                    function arraySome(array, predicate) {
                      var index = -1, length = array == null ? 0 : array.length;
                      while (++index < length) {
                        if (predicate(array[index], index, array)) {
                          return true;
                        }
                      }
                      return false;
                    }
                    var asciiSize = baseProperty("length");
                    function asciiToArray(string) {
                      return string.split("");
                    }
                    function asciiWords(string) {
                      return string.match(reAsciiWord) || [];
                    }
                    function baseFindKey(collection, predicate, eachFunc) {
                      var result;
                      eachFunc(collection, function(value, key, collection2) {
                        if (predicate(value, key, collection2)) {
                          result = key;
                          return false;
                        }
                      });
                      return result;
                    }
                    function baseFindIndex(array, predicate, fromIndex, fromRight) {
                      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
                      while (fromRight ? index-- : ++index < length) {
                        if (predicate(array[index], index, array)) {
                          return index;
                        }
                      }
                      return -1;
                    }
                    function baseIndexOf(array, value, fromIndex) {
                      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
                    }
                    function baseIndexOfWith(array, value, fromIndex, comparator) {
                      var index = fromIndex - 1, length = array.length;
                      while (++index < length) {
                        if (comparator(array[index], value)) {
                          return index;
                        }
                      }
                      return -1;
                    }
                    function baseIsNaN(value) {
                      return value !== value;
                    }
                    function baseMean(array, iteratee) {
                      var length = array == null ? 0 : array.length;
                      return length ? baseSum(array, iteratee) / length : NAN;
                    }
                    function baseProperty(key) {
                      return function(object) {
                        return object == null ? undefined2 : object[key];
                      };
                    }
                    function basePropertyOf(object) {
                      return function(key) {
                        return object == null ? undefined2 : object[key];
                      };
                    }
                    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                      eachFunc(collection, function(value, index, collection2) {
                        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
                      });
                      return accumulator;
                    }
                    function baseSortBy(array, comparer) {
                      var length = array.length;
                      array.sort(comparer);
                      while (length--) {
                        array[length] = array[length].value;
                      }
                      return array;
                    }
                    function baseSum(array, iteratee) {
                      var result, index = -1, length = array.length;
                      while (++index < length) {
                        var current = iteratee(array[index]);
                        if (current !== undefined2) {
                          result = result === undefined2 ? current : result + current;
                        }
                      }
                      return result;
                    }
                    function baseTimes(n, iteratee) {
                      var index = -1, result = Array(n);
                      while (++index < n) {
                        result[index] = iteratee(index);
                      }
                      return result;
                    }
                    function baseToPairs(object, props) {
                      return arrayMap(props, function(key) {
                        return [key, object[key]];
                      });
                    }
                    function baseTrim(string) {
                      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
                    }
                    function baseUnary(func) {
                      return function(value) {
                        return func(value);
                      };
                    }
                    function baseValues(object, props) {
                      return arrayMap(props, function(key) {
                        return object[key];
                      });
                    }
                    function cacheHas(cache, key) {
                      return cache.has(key);
                    }
                    function charsStartIndex(strSymbols, chrSymbols) {
                      var index = -1, length = strSymbols.length;
                      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                      }
                      return index;
                    }
                    function charsEndIndex(strSymbols, chrSymbols) {
                      var index = strSymbols.length;
                      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                      }
                      return index;
                    }
                    function countHolders(array, placeholder) {
                      var length = array.length, result = 0;
                      while (length--) {
                        if (array[length] === placeholder) {
                          ++result;
                        }
                      }
                      return result;
                    }
                    var deburrLetter = basePropertyOf(deburredLetters);
                    var escapeHtmlChar = basePropertyOf(htmlEscapes);
                    function escapeStringChar(chr) {
                      return "\\" + stringEscapes[chr];
                    }
                    function getValue(object, key) {
                      return object == null ? undefined2 : object[key];
                    }
                    function hasUnicode(string) {
                      return reHasUnicode.test(string);
                    }
                    function hasUnicodeWord(string) {
                      return reHasUnicodeWord.test(string);
                    }
                    function iteratorToArray(iterator) {
                      var data, result = [];
                      while (!(data = iterator.next()).done) {
                        result.push(data.value);
                      }
                      return result;
                    }
                    function mapToArray(map2) {
                      var index = -1, result = Array(map2.size);
                      map2.forEach(function(value, key) {
                        result[++index] = [key, value];
                      });
                      return result;
                    }
                    function overArg(func, transform) {
                      return function(arg) {
                        return func(transform(arg));
                      };
                    }
                    function replaceHolders(array, placeholder) {
                      var index = -1, length = array.length, resIndex = 0, result = [];
                      while (++index < length) {
                        var value = array[index];
                        if (value === placeholder || value === PLACEHOLDER) {
                          array[index] = PLACEHOLDER;
                          result[resIndex++] = index;
                        }
                      }
                      return result;
                    }
                    function setToArray(set2) {
                      var index = -1, result = Array(set2.size);
                      set2.forEach(function(value) {
                        result[++index] = value;
                      });
                      return result;
                    }
                    function setToPairs(set2) {
                      var index = -1, result = Array(set2.size);
                      set2.forEach(function(value) {
                        result[++index] = [value, value];
                      });
                      return result;
                    }
                    function strictIndexOf(array, value, fromIndex) {
                      var index = fromIndex - 1, length = array.length;
                      while (++index < length) {
                        if (array[index] === value) {
                          return index;
                        }
                      }
                      return -1;
                    }
                    function strictLastIndexOf(array, value, fromIndex) {
                      var index = fromIndex + 1;
                      while (index--) {
                        if (array[index] === value) {
                          return index;
                        }
                      }
                      return index;
                    }
                    function stringSize(string) {
                      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
                    }
                    function stringToArray(string) {
                      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
                    }
                    function trimmedEndIndex(string) {
                      var index = string.length;
                      while (index-- && reWhitespace.test(string.charAt(index))) {
                      }
                      return index;
                    }
                    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
                    function unicodeSize(string) {
                      var result = reUnicode.lastIndex = 0;
                      while (reUnicode.test(string)) {
                        ++result;
                      }
                      return result;
                    }
                    function unicodeToArray(string) {
                      return string.match(reUnicode) || [];
                    }
                    function unicodeWords(string) {
                      return string.match(reUnicodeWord) || [];
                    }
                    var runInContext = function runInContext2(context) {
                      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
                      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
                      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
                      var coreJsData = context["__core-js_shared__"];
                      var funcToString = funcProto.toString;
                      var hasOwnProperty = objectProto.hasOwnProperty;
                      var idCounter = 0;
                      var maskSrcKey = function() {
                        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                        return uid ? "Symbol(src)_1." + uid : "";
                      }();
                      var nativeObjectToString = objectProto.toString;
                      var objectCtorString = funcToString.call(Object2);
                      var oldDash = root._;
                      var reIsNative = RegExp2(
                        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
                      );
                      var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol3 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : undefined2, symIterator = Symbol3 ? Symbol3.iterator : undefined2, symToStringTag = Symbol3 ? Symbol3.toStringTag : undefined2;
                      var defineProperty = function() {
                        try {
                          var func = getNative(Object2, "defineProperty");
                          func({}, "", {});
                          return func;
                        } catch (e) {
                        }
                      }();
                      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
                      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
                      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
                      var metaMap = WeakMap2 && new WeakMap2();
                      var realNames = {};
                      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
                      var symbolProto = Symbol3 ? Symbol3.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
                      function lodash(value) {
                        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                          if (value instanceof LodashWrapper) {
                            return value;
                          }
                          if (hasOwnProperty.call(value, "__wrapped__")) {
                            return wrapperClone(value);
                          }
                        }
                        return new LodashWrapper(value);
                      }
                      var baseCreate = /* @__PURE__ */ function() {
                        function object() {
                        }
                        return function(proto) {
                          if (!isObject2(proto)) {
                            return {};
                          }
                          if (objectCreate) {
                            return objectCreate(proto);
                          }
                          object.prototype = proto;
                          var result2 = new object();
                          object.prototype = undefined2;
                          return result2;
                        };
                      }();
                      function baseLodash() {
                      }
                      function LodashWrapper(value, chainAll) {
                        this.__wrapped__ = value;
                        this.__actions__ = [];
                        this.__chain__ = !!chainAll;
                        this.__index__ = 0;
                        this.__values__ = undefined2;
                      }
                      lodash.templateSettings = {
                        /**
                         * Used to detect `data` property values to be HTML-escaped.
                         *
                         * @memberOf _.templateSettings
                         * @type {RegExp}
                         */
                        "escape": reEscape,
                        /**
                         * Used to detect code to be evaluated.
                         *
                         * @memberOf _.templateSettings
                         * @type {RegExp}
                         */
                        "evaluate": reEvaluate,
                        /**
                         * Used to detect `data` property values to inject.
                         *
                         * @memberOf _.templateSettings
                         * @type {RegExp}
                         */
                        "interpolate": reInterpolate,
                        /**
                         * Used to reference the data object in the template text.
                         *
                         * @memberOf _.templateSettings
                         * @type {string}
                         */
                        "variable": "",
                        /**
                         * Used to import variables into the compiled template.
                         *
                         * @memberOf _.templateSettings
                         * @type {Object}
                         */
                        "imports": {
                          /**
                           * A reference to the `lodash` function.
                           *
                           * @memberOf _.templateSettings.imports
                           * @type {Function}
                           */
                          "_": lodash
                        }
                      };
                      lodash.prototype = baseLodash.prototype;
                      lodash.prototype.constructor = lodash;
                      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                      LodashWrapper.prototype.constructor = LodashWrapper;
                      function LazyWrapper(value) {
                        this.__wrapped__ = value;
                        this.__actions__ = [];
                        this.__dir__ = 1;
                        this.__filtered__ = false;
                        this.__iteratees__ = [];
                        this.__takeCount__ = MAX_ARRAY_LENGTH;
                        this.__views__ = [];
                      }
                      function lazyClone() {
                        var result2 = new LazyWrapper(this.__wrapped__);
                        result2.__actions__ = copyArray(this.__actions__);
                        result2.__dir__ = this.__dir__;
                        result2.__filtered__ = this.__filtered__;
                        result2.__iteratees__ = copyArray(this.__iteratees__);
                        result2.__takeCount__ = this.__takeCount__;
                        result2.__views__ = copyArray(this.__views__);
                        return result2;
                      }
                      function lazyReverse() {
                        if (this.__filtered__) {
                          var result2 = new LazyWrapper(this);
                          result2.__dir__ = -1;
                          result2.__filtered__ = true;
                        } else {
                          result2 = this.clone();
                          result2.__dir__ *= -1;
                        }
                        return result2;
                      }
                      function lazyValue() {
                        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                        if (!isArr || !isRight && arrLength == length && takeCount == length) {
                          return baseWrapperValue(array, this.__actions__);
                        }
                        var result2 = [];
                        outer:
                          while (length-- && resIndex < takeCount) {
                            index += dir;
                            var iterIndex = -1, value = array[index];
                            while (++iterIndex < iterLength) {
                              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
                              if (type2 == LAZY_MAP_FLAG) {
                                value = computed;
                              } else if (!computed) {
                                if (type2 == LAZY_FILTER_FLAG) {
                                  continue outer;
                                } else {
                                  break outer;
                                }
                              }
                            }
                            result2[resIndex++] = value;
                          }
                        return result2;
                      }
                      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                      LazyWrapper.prototype.constructor = LazyWrapper;
                      function Hash(entries) {
                        var index = -1, length = entries == null ? 0 : entries.length;
                        this.clear();
                        while (++index < length) {
                          var entry = entries[index];
                          this.set(entry[0], entry[1]);
                        }
                      }
                      function hashClear() {
                        this.__data__ = nativeCreate ? nativeCreate(null) : {};
                        this.size = 0;
                      }
                      function hashDelete(key) {
                        var result2 = this.has(key) && delete this.__data__[key];
                        this.size -= result2 ? 1 : 0;
                        return result2;
                      }
                      function hashGet(key) {
                        var data = this.__data__;
                        if (nativeCreate) {
                          var result2 = data[key];
                          return result2 === HASH_UNDEFINED ? undefined2 : result2;
                        }
                        return hasOwnProperty.call(data, key) ? data[key] : undefined2;
                      }
                      function hashHas(key) {
                        var data = this.__data__;
                        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
                      }
                      function hashSet(key, value) {
                        var data = this.__data__;
                        this.size += this.has(key) ? 0 : 1;
                        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
                        return this;
                      }
                      Hash.prototype.clear = hashClear;
                      Hash.prototype["delete"] = hashDelete;
                      Hash.prototype.get = hashGet;
                      Hash.prototype.has = hashHas;
                      Hash.prototype.set = hashSet;
                      function ListCache(entries) {
                        var index = -1, length = entries == null ? 0 : entries.length;
                        this.clear();
                        while (++index < length) {
                          var entry = entries[index];
                          this.set(entry[0], entry[1]);
                        }
                      }
                      function listCacheClear() {
                        this.__data__ = [];
                        this.size = 0;
                      }
                      function listCacheDelete(key) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        if (index < 0) {
                          return false;
                        }
                        var lastIndex = data.length - 1;
                        if (index == lastIndex) {
                          data.pop();
                        } else {
                          splice.call(data, index, 1);
                        }
                        --this.size;
                        return true;
                      }
                      function listCacheGet(key) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        return index < 0 ? undefined2 : data[index][1];
                      }
                      function listCacheHas(key) {
                        return assocIndexOf(this.__data__, key) > -1;
                      }
                      function listCacheSet(key, value) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        if (index < 0) {
                          ++this.size;
                          data.push([key, value]);
                        } else {
                          data[index][1] = value;
                        }
                        return this;
                      }
                      ListCache.prototype.clear = listCacheClear;
                      ListCache.prototype["delete"] = listCacheDelete;
                      ListCache.prototype.get = listCacheGet;
                      ListCache.prototype.has = listCacheHas;
                      ListCache.prototype.set = listCacheSet;
                      function MapCache(entries) {
                        var index = -1, length = entries == null ? 0 : entries.length;
                        this.clear();
                        while (++index < length) {
                          var entry = entries[index];
                          this.set(entry[0], entry[1]);
                        }
                      }
                      function mapCacheClear() {
                        this.size = 0;
                        this.__data__ = {
                          "hash": new Hash(),
                          "map": new (Map2 || ListCache)(),
                          "string": new Hash()
                        };
                      }
                      function mapCacheDelete(key) {
                        var result2 = getMapData(this, key)["delete"](key);
                        this.size -= result2 ? 1 : 0;
                        return result2;
                      }
                      function mapCacheGet(key) {
                        return getMapData(this, key).get(key);
                      }
                      function mapCacheHas(key) {
                        return getMapData(this, key).has(key);
                      }
                      function mapCacheSet(key, value) {
                        var data = getMapData(this, key), size2 = data.size;
                        data.set(key, value);
                        this.size += data.size == size2 ? 0 : 1;
                        return this;
                      }
                      MapCache.prototype.clear = mapCacheClear;
                      MapCache.prototype["delete"] = mapCacheDelete;
                      MapCache.prototype.get = mapCacheGet;
                      MapCache.prototype.has = mapCacheHas;
                      MapCache.prototype.set = mapCacheSet;
                      function SetCache(values2) {
                        var index = -1, length = values2 == null ? 0 : values2.length;
                        this.__data__ = new MapCache();
                        while (++index < length) {
                          this.add(values2[index]);
                        }
                      }
                      function setCacheAdd(value) {
                        this.__data__.set(value, HASH_UNDEFINED);
                        return this;
                      }
                      function setCacheHas(value) {
                        return this.__data__.has(value);
                      }
                      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                      SetCache.prototype.has = setCacheHas;
                      function Stack(entries) {
                        var data = this.__data__ = new ListCache(entries);
                        this.size = data.size;
                      }
                      function stackClear() {
                        this.__data__ = new ListCache();
                        this.size = 0;
                      }
                      function stackDelete(key) {
                        var data = this.__data__, result2 = data["delete"](key);
                        this.size = data.size;
                        return result2;
                      }
                      function stackGet(key) {
                        return this.__data__.get(key);
                      }
                      function stackHas(key) {
                        return this.__data__.has(key);
                      }
                      function stackSet(key, value) {
                        var data = this.__data__;
                        if (data instanceof ListCache) {
                          var pairs2 = data.__data__;
                          if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
                            pairs2.push([key, value]);
                            this.size = ++data.size;
                            return this;
                          }
                          data = this.__data__ = new MapCache(pairs2);
                        }
                        data.set(key, value);
                        this.size = data.size;
                        return this;
                      }
                      Stack.prototype.clear = stackClear;
                      Stack.prototype["delete"] = stackDelete;
                      Stack.prototype.get = stackGet;
                      Stack.prototype.has = stackHas;
                      Stack.prototype.set = stackSet;
                      function arrayLikeKeys(value, inherited) {
                        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
                        for (var key in value) {
                          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                          isIndex(key, length)))) {
                            result2.push(key);
                          }
                        }
                        return result2;
                      }
                      function arraySample(array) {
                        var length = array.length;
                        return length ? array[baseRandom(0, length - 1)] : undefined2;
                      }
                      function arraySampleSize(array, n) {
                        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
                      }
                      function arrayShuffle(array) {
                        return shuffleSelf(copyArray(array));
                      }
                      function assignMergeValue(object, key, value) {
                        if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
                          baseAssignValue(object, key, value);
                        }
                      }
                      function assignValue(object, key, value) {
                        var objValue = object[key];
                        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
                          baseAssignValue(object, key, value);
                        }
                      }
                      function assocIndexOf(array, key) {
                        var length = array.length;
                        while (length--) {
                          if (eq(array[length][0], key)) {
                            return length;
                          }
                        }
                        return -1;
                      }
                      function baseAggregator(collection, setter, iteratee2, accumulator) {
                        baseEach(collection, function(value, key, collection2) {
                          setter(accumulator, value, iteratee2(value), collection2);
                        });
                        return accumulator;
                      }
                      function baseAssign(object, source) {
                        return object && copyObject(source, keys(source), object);
                      }
                      function baseAssignIn(object, source) {
                        return object && copyObject(source, keysIn(source), object);
                      }
                      function baseAssignValue(object, key, value) {
                        if (key == "__proto__" && defineProperty) {
                          defineProperty(object, key, {
                            "configurable": true,
                            "enumerable": true,
                            "value": value,
                            "writable": true
                          });
                        } else {
                          object[key] = value;
                        }
                      }
                      function baseAt(object, paths) {
                        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
                        while (++index < length) {
                          result2[index] = skip ? undefined2 : get(object, paths[index]);
                        }
                        return result2;
                      }
                      function baseClamp(number, lower, upper) {
                        if (number === number) {
                          if (upper !== undefined2) {
                            number = number <= upper ? number : upper;
                          }
                          if (lower !== undefined2) {
                            number = number >= lower ? number : lower;
                          }
                        }
                        return number;
                      }
                      function baseClone(value, bitmask, customizer, key, object, stack) {
                        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                        if (customizer) {
                          result2 = object ? customizer(value, key, object, stack) : customizer(value);
                        }
                        if (result2 !== undefined2) {
                          return result2;
                        }
                        if (!isObject2(value)) {
                          return value;
                        }
                        var isArr = isArray(value);
                        if (isArr) {
                          result2 = initCloneArray(value);
                          if (!isDeep) {
                            return copyArray(value, result2);
                          }
                        } else {
                          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                          if (isBuffer(value)) {
                            return cloneBuffer(value, isDeep);
                          }
                          if (tag == objectTag || tag == argsTag || isFunc && !object) {
                            result2 = isFlat || isFunc ? {} : initCloneObject(value);
                            if (!isDeep) {
                              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                            }
                          } else {
                            if (!cloneableTags[tag]) {
                              return object ? value : {};
                            }
                            result2 = initCloneByTag(value, tag, isDeep);
                          }
                        }
                        stack || (stack = new Stack());
                        var stacked = stack.get(value);
                        if (stacked) {
                          return stacked;
                        }
                        stack.set(value, result2);
                        if (isSet(value)) {
                          value.forEach(function(subValue) {
                            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                          });
                        } else if (isMap(value)) {
                          value.forEach(function(subValue, key2) {
                            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                          });
                        }
                        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                        var props = isArr ? undefined2 : keysFunc(value);
                        arrayEach(props || value, function(subValue, key2) {
                          if (props) {
                            key2 = subValue;
                            subValue = value[key2];
                          }
                          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                        });
                        return result2;
                      }
                      function baseConforms(source) {
                        var props = keys(source);
                        return function(object) {
                          return baseConformsTo(object, source, props);
                        };
                      }
                      function baseConformsTo(object, source, props) {
                        var length = props.length;
                        if (object == null) {
                          return !length;
                        }
                        object = Object2(object);
                        while (length--) {
                          var key = props[length], predicate = source[key], value = object[key];
                          if (value === undefined2 && !(key in object) || !predicate(value)) {
                            return false;
                          }
                        }
                        return true;
                      }
                      function baseDelay(func, wait, args) {
                        if (typeof func != "function") {
                          throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        return setTimeout2(function() {
                          func.apply(undefined2, args);
                        }, wait);
                      }
                      function baseDifference(array, values2, iteratee2, comparator) {
                        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
                        if (!length) {
                          return result2;
                        }
                        if (iteratee2) {
                          values2 = arrayMap(values2, baseUnary(iteratee2));
                        }
                        if (comparator) {
                          includes2 = arrayIncludesWith;
                          isCommon = false;
                        } else if (values2.length >= LARGE_ARRAY_SIZE) {
                          includes2 = cacheHas;
                          isCommon = false;
                          values2 = new SetCache(values2);
                        }
                        outer:
                          while (++index < length) {
                            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                            value = comparator || value !== 0 ? value : 0;
                            if (isCommon && computed === computed) {
                              var valuesIndex = valuesLength;
                              while (valuesIndex--) {
                                if (values2[valuesIndex] === computed) {
                                  continue outer;
                                }
                              }
                              result2.push(value);
                            } else if (!includes2(values2, computed, comparator)) {
                              result2.push(value);
                            }
                          }
                        return result2;
                      }
                      var baseEach = createBaseEach(baseForOwn);
                      var baseEachRight = createBaseEach(baseForOwnRight, true);
                      function baseEvery(collection, predicate) {
                        var result2 = true;
                        baseEach(collection, function(value, index, collection2) {
                          result2 = !!predicate(value, index, collection2);
                          return result2;
                        });
                        return result2;
                      }
                      function baseExtremum(array, iteratee2, comparator) {
                        var index = -1, length = array.length;
                        while (++index < length) {
                          var value = array[index], current = iteratee2(value);
                          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                            var computed = current, result2 = value;
                          }
                        }
                        return result2;
                      }
                      function baseFill(array, value, start, end) {
                        var length = array.length;
                        start = toInteger(start);
                        if (start < 0) {
                          start = -start > length ? 0 : length + start;
                        }
                        end = end === undefined2 || end > length ? length : toInteger(end);
                        if (end < 0) {
                          end += length;
                        }
                        end = start > end ? 0 : toLength(end);
                        while (start < end) {
                          array[start++] = value;
                        }
                        return array;
                      }
                      function baseFilter(collection, predicate) {
                        var result2 = [];
                        baseEach(collection, function(value, index, collection2) {
                          if (predicate(value, index, collection2)) {
                            result2.push(value);
                          }
                        });
                        return result2;
                      }
                      function baseFlatten(array, depth, predicate, isStrict, result2) {
                        var index = -1, length = array.length;
                        predicate || (predicate = isFlattenable);
                        result2 || (result2 = []);
                        while (++index < length) {
                          var value = array[index];
                          if (depth > 0 && predicate(value)) {
                            if (depth > 1) {
                              baseFlatten(value, depth - 1, predicate, isStrict, result2);
                            } else {
                              arrayPush(result2, value);
                            }
                          } else if (!isStrict) {
                            result2[result2.length] = value;
                          }
                        }
                        return result2;
                      }
                      var baseFor = createBaseFor();
                      var baseForRight = createBaseFor(true);
                      function baseForOwn(object, iteratee2) {
                        return object && baseFor(object, iteratee2, keys);
                      }
                      function baseForOwnRight(object, iteratee2) {
                        return object && baseForRight(object, iteratee2, keys);
                      }
                      function baseFunctions(object, props) {
                        return arrayFilter(props, function(key) {
                          return isFunction(object[key]);
                        });
                      }
                      function baseGet(object, path) {
                        path = castPath(path, object);
                        var index = 0, length = path.length;
                        while (object != null && index < length) {
                          object = object[toKey(path[index++])];
                        }
                        return index && index == length ? object : undefined2;
                      }
                      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                        var result2 = keysFunc(object);
                        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
                      }
                      function baseGetTag(value) {
                        if (value == null) {
                          return value === undefined2 ? undefinedTag : nullTag;
                        }
                        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
                      }
                      function baseGt(value, other) {
                        return value > other;
                      }
                      function baseHas(object, key) {
                        return object != null && hasOwnProperty.call(object, key);
                      }
                      function baseHasIn(object, key) {
                        return object != null && key in Object2(object);
                      }
                      function baseInRange(number, start, end) {
                        return number >= nativeMin(start, end) && number < nativeMax(start, end);
                      }
                      function baseIntersection(arrays, iteratee2, comparator) {
                        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
                        while (othIndex--) {
                          var array = arrays[othIndex];
                          if (othIndex && iteratee2) {
                            array = arrayMap(array, baseUnary(iteratee2));
                          }
                          maxLength = nativeMin(array.length, maxLength);
                          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
                        }
                        array = arrays[0];
                        var index = -1, seen = caches[0];
                        outer:
                          while (++index < length && result2.length < maxLength) {
                            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                            value = comparator || value !== 0 ? value : 0;
                            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                              othIndex = othLength;
                              while (--othIndex) {
                                var cache = caches[othIndex];
                                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                                  continue outer;
                                }
                              }
                              if (seen) {
                                seen.push(computed);
                              }
                              result2.push(value);
                            }
                          }
                        return result2;
                      }
                      function baseInverter(object, setter, iteratee2, accumulator) {
                        baseForOwn(object, function(value, key, object2) {
                          setter(accumulator, iteratee2(value), key, object2);
                        });
                        return accumulator;
                      }
                      function baseInvoke(object, path, args) {
                        path = castPath(path, object);
                        object = parent(object, path);
                        var func = object == null ? object : object[toKey(last(path))];
                        return func == null ? undefined2 : apply(func, object, args);
                      }
                      function baseIsArguments(value) {
                        return isObjectLike(value) && baseGetTag(value) == argsTag;
                      }
                      function baseIsArrayBuffer(value) {
                        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
                      }
                      function baseIsDate(value) {
                        return isObjectLike(value) && baseGetTag(value) == dateTag;
                      }
                      function baseIsEqual(value, other, bitmask, customizer, stack) {
                        if (value === other) {
                          return true;
                        }
                        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                          return value !== value && other !== other;
                        }
                        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
                      }
                      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                        objTag = objTag == argsTag ? objectTag : objTag;
                        othTag = othTag == argsTag ? objectTag : othTag;
                        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                        if (isSameTag && isBuffer(object)) {
                          if (!isBuffer(other)) {
                            return false;
                          }
                          objIsArr = true;
                          objIsObj = false;
                        }
                        if (isSameTag && !objIsObj) {
                          stack || (stack = new Stack());
                          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                        }
                        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                          if (objIsWrapped || othIsWrapped) {
                            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                            stack || (stack = new Stack());
                            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                          }
                        }
                        if (!isSameTag) {
                          return false;
                        }
                        stack || (stack = new Stack());
                        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
                      }
                      function baseIsMap(value) {
                        return isObjectLike(value) && getTag(value) == mapTag;
                      }
                      function baseIsMatch(object, source, matchData, customizer) {
                        var index = matchData.length, length = index, noCustomizer = !customizer;
                        if (object == null) {
                          return !length;
                        }
                        object = Object2(object);
                        while (index--) {
                          var data = matchData[index];
                          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                            return false;
                          }
                        }
                        while (++index < length) {
                          data = matchData[index];
                          var key = data[0], objValue = object[key], srcValue = data[1];
                          if (noCustomizer && data[2]) {
                            if (objValue === undefined2 && !(key in object)) {
                              return false;
                            }
                          } else {
                            var stack = new Stack();
                            if (customizer) {
                              var result2 = customizer(objValue, srcValue, key, object, source, stack);
                            }
                            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                              return false;
                            }
                          }
                        }
                        return true;
                      }
                      function baseIsNative(value) {
                        if (!isObject2(value) || isMasked(value)) {
                          return false;
                        }
                        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                        return pattern.test(toSource(value));
                      }
                      function baseIsRegExp(value) {
                        return isObjectLike(value) && baseGetTag(value) == regexpTag;
                      }
                      function baseIsSet(value) {
                        return isObjectLike(value) && getTag(value) == setTag;
                      }
                      function baseIsTypedArray(value) {
                        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                      }
                      function baseIteratee(value) {
                        if (typeof value == "function") {
                          return value;
                        }
                        if (value == null) {
                          return identity;
                        }
                        if (typeof value == "object") {
                          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                        }
                        return property(value);
                      }
                      function baseKeys(object) {
                        if (!isPrototype(object)) {
                          return nativeKeys(object);
                        }
                        var result2 = [];
                        for (var key in Object2(object)) {
                          if (hasOwnProperty.call(object, key) && key != "constructor") {
                            result2.push(key);
                          }
                        }
                        return result2;
                      }
                      function baseKeysIn(object) {
                        if (!isObject2(object)) {
                          return nativeKeysIn(object);
                        }
                        var isProto = isPrototype(object), result2 = [];
                        for (var key in object) {
                          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                            result2.push(key);
                          }
                        }
                        return result2;
                      }
                      function baseLt(value, other) {
                        return value < other;
                      }
                      function baseMap(collection, iteratee2) {
                        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                        baseEach(collection, function(value, key, collection2) {
                          result2[++index] = iteratee2(value, key, collection2);
                        });
                        return result2;
                      }
                      function baseMatches(source) {
                        var matchData = getMatchData(source);
                        if (matchData.length == 1 && matchData[0][2]) {
                          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                        }
                        return function(object) {
                          return object === source || baseIsMatch(object, source, matchData);
                        };
                      }
                      function baseMatchesProperty(path, srcValue) {
                        if (isKey(path) && isStrictComparable(srcValue)) {
                          return matchesStrictComparable(toKey(path), srcValue);
                        }
                        return function(object) {
                          var objValue = get(object, path);
                          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                        };
                      }
                      function baseMerge(object, source, srcIndex, customizer, stack) {
                        if (object === source) {
                          return;
                        }
                        baseFor(source, function(srcValue, key) {
                          stack || (stack = new Stack());
                          if (isObject2(srcValue)) {
                            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                          } else {
                            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                            if (newValue === undefined2) {
                              newValue = srcValue;
                            }
                            assignMergeValue(object, key, newValue);
                          }
                        }, keysIn);
                      }
                      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
                        if (stacked) {
                          assignMergeValue(object, key, stacked);
                          return;
                        }
                        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
                        var isCommon = newValue === undefined2;
                        if (isCommon) {
                          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                          newValue = srcValue;
                          if (isArr || isBuff || isTyped) {
                            if (isArray(objValue)) {
                              newValue = objValue;
                            } else if (isArrayLikeObject(objValue)) {
                              newValue = copyArray(objValue);
                            } else if (isBuff) {
                              isCommon = false;
                              newValue = cloneBuffer(srcValue, true);
                            } else if (isTyped) {
                              isCommon = false;
                              newValue = cloneTypedArray(srcValue, true);
                            } else {
                              newValue = [];
                            }
                          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                            newValue = objValue;
                            if (isArguments(objValue)) {
                              newValue = toPlainObject(objValue);
                            } else if (!isObject2(objValue) || isFunction(objValue)) {
                              newValue = initCloneObject(srcValue);
                            }
                          } else {
                            isCommon = false;
                          }
                        }
                        if (isCommon) {
                          stack.set(srcValue, newValue);
                          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                          stack["delete"](srcValue);
                        }
                        assignMergeValue(object, key, newValue);
                      }
                      function baseNth(array, n) {
                        var length = array.length;
                        if (!length) {
                          return;
                        }
                        n += n < 0 ? length : 0;
                        return isIndex(n, length) ? array[n] : undefined2;
                      }
                      function baseOrderBy(collection, iteratees, orders) {
                        if (iteratees.length) {
                          iteratees = arrayMap(iteratees, function(iteratee2) {
                            if (isArray(iteratee2)) {
                              return function(value) {
                                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                              };
                            }
                            return iteratee2;
                          });
                        } else {
                          iteratees = [identity];
                        }
                        var index = -1;
                        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                        var result2 = baseMap(collection, function(value, key, collection2) {
                          var criteria = arrayMap(iteratees, function(iteratee2) {
                            return iteratee2(value);
                          });
                          return { "criteria": criteria, "index": ++index, "value": value };
                        });
                        return baseSortBy(result2, function(object, other) {
                          return compareMultiple(object, other, orders);
                        });
                      }
                      function basePick(object, paths) {
                        return basePickBy(object, paths, function(value, path) {
                          return hasIn(object, path);
                        });
                      }
                      function basePickBy(object, paths, predicate) {
                        var index = -1, length = paths.length, result2 = {};
                        while (++index < length) {
                          var path = paths[index], value = baseGet(object, path);
                          if (predicate(value, path)) {
                            baseSet(result2, castPath(path, object), value);
                          }
                        }
                        return result2;
                      }
                      function basePropertyDeep(path) {
                        return function(object) {
                          return baseGet(object, path);
                        };
                      }
                      function basePullAll(array, values2, iteratee2, comparator) {
                        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
                        if (array === values2) {
                          values2 = copyArray(values2);
                        }
                        if (iteratee2) {
                          seen = arrayMap(array, baseUnary(iteratee2));
                        }
                        while (++index < length) {
                          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
                          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                            if (seen !== array) {
                              splice.call(seen, fromIndex, 1);
                            }
                            splice.call(array, fromIndex, 1);
                          }
                        }
                        return array;
                      }
                      function basePullAt(array, indexes) {
                        var length = array ? indexes.length : 0, lastIndex = length - 1;
                        while (length--) {
                          var index = indexes[length];
                          if (length == lastIndex || index !== previous) {
                            var previous = index;
                            if (isIndex(index)) {
                              splice.call(array, index, 1);
                            } else {
                              baseUnset(array, index);
                            }
                          }
                        }
                        return array;
                      }
                      function baseRandom(lower, upper) {
                        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                      }
                      function baseRange(start, end, step, fromRight) {
                        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
                        while (length--) {
                          result2[fromRight ? length : ++index] = start;
                          start += step;
                        }
                        return result2;
                      }
                      function baseRepeat(string, n) {
                        var result2 = "";
                        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                          return result2;
                        }
                        do {
                          if (n % 2) {
                            result2 += string;
                          }
                          n = nativeFloor(n / 2);
                          if (n) {
                            string += string;
                          }
                        } while (n);
                        return result2;
                      }
                      function baseRest(func, start) {
                        return setToString(overRest(func, start, identity), func + "");
                      }
                      function baseSample(collection) {
                        return arraySample(values(collection));
                      }
                      function baseSampleSize(collection, n) {
                        var array = values(collection);
                        return shuffleSelf(array, baseClamp(n, 0, array.length));
                      }
                      function baseSet(object, path, value, customizer) {
                        if (!isObject2(object)) {
                          return object;
                        }
                        path = castPath(path, object);
                        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                        while (nested != null && ++index < length) {
                          var key = toKey(path[index]), newValue = value;
                          if (key === "__proto__" || key === "constructor" || key === "prototype") {
                            return object;
                          }
                          if (index != lastIndex) {
                            var objValue = nested[key];
                            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                            if (newValue === undefined2) {
                              newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                            }
                          }
                          assignValue(nested, key, newValue);
                          nested = nested[key];
                        }
                        return object;
                      }
                      var baseSetData = !metaMap ? identity : function(func, data) {
                        metaMap.set(func, data);
                        return func;
                      };
                      var baseSetToString = !defineProperty ? identity : function(func, string) {
                        return defineProperty(func, "toString", {
                          "configurable": true,
                          "enumerable": false,
                          "value": constant(string),
                          "writable": true
                        });
                      };
                      function baseShuffle(collection) {
                        return shuffleSelf(values(collection));
                      }
                      function baseSlice(array, start, end) {
                        var index = -1, length = array.length;
                        if (start < 0) {
                          start = -start > length ? 0 : length + start;
                        }
                        end = end > length ? length : end;
                        if (end < 0) {
                          end += length;
                        }
                        length = start > end ? 0 : end - start >>> 0;
                        start >>>= 0;
                        var result2 = Array2(length);
                        while (++index < length) {
                          result2[index] = array[index + start];
                        }
                        return result2;
                      }
                      function baseSome(collection, predicate) {
                        var result2;
                        baseEach(collection, function(value, index, collection2) {
                          result2 = predicate(value, index, collection2);
                          return !result2;
                        });
                        return !!result2;
                      }
                      function baseSortedIndex(array, value, retHighest) {
                        var low = 0, high = array == null ? low : array.length;
                        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                          while (low < high) {
                            var mid = low + high >>> 1, computed = array[mid];
                            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                              low = mid + 1;
                            } else {
                              high = mid;
                            }
                          }
                          return high;
                        }
                        return baseSortedIndexBy(array, value, identity, retHighest);
                      }
                      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
                        var low = 0, high = array == null ? 0 : array.length;
                        if (high === 0) {
                          return 0;
                        }
                        value = iteratee2(value);
                        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
                        while (low < high) {
                          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                          if (valIsNaN) {
                            var setLow = retHighest || othIsReflexive;
                          } else if (valIsUndefined) {
                            setLow = othIsReflexive && (retHighest || othIsDefined);
                          } else if (valIsNull) {
                            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                          } else if (valIsSymbol) {
                            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                          } else if (othIsNull || othIsSymbol) {
                            setLow = false;
                          } else {
                            setLow = retHighest ? computed <= value : computed < value;
                          }
                          if (setLow) {
                            low = mid + 1;
                          } else {
                            high = mid;
                          }
                        }
                        return nativeMin(high, MAX_ARRAY_INDEX);
                      }
                      function baseSortedUniq(array, iteratee2) {
                        var index = -1, length = array.length, resIndex = 0, result2 = [];
                        while (++index < length) {
                          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                          if (!index || !eq(computed, seen)) {
                            var seen = computed;
                            result2[resIndex++] = value === 0 ? 0 : value;
                          }
                        }
                        return result2;
                      }
                      function baseToNumber(value) {
                        if (typeof value == "number") {
                          return value;
                        }
                        if (isSymbol(value)) {
                          return NAN;
                        }
                        return +value;
                      }
                      function baseToString(value) {
                        if (typeof value == "string") {
                          return value;
                        }
                        if (isArray(value)) {
                          return arrayMap(value, baseToString) + "";
                        }
                        if (isSymbol(value)) {
                          return symbolToString ? symbolToString.call(value) : "";
                        }
                        var result2 = value + "";
                        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
                      }
                      function baseUniq(array, iteratee2, comparator) {
                        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
                        if (comparator) {
                          isCommon = false;
                          includes2 = arrayIncludesWith;
                        } else if (length >= LARGE_ARRAY_SIZE) {
                          var set3 = iteratee2 ? null : createSet(array);
                          if (set3) {
                            return setToArray(set3);
                          }
                          isCommon = false;
                          includes2 = cacheHas;
                          seen = new SetCache();
                        } else {
                          seen = iteratee2 ? [] : result2;
                        }
                        outer:
                          while (++index < length) {
                            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                            value = comparator || value !== 0 ? value : 0;
                            if (isCommon && computed === computed) {
                              var seenIndex = seen.length;
                              while (seenIndex--) {
                                if (seen[seenIndex] === computed) {
                                  continue outer;
                                }
                              }
                              if (iteratee2) {
                                seen.push(computed);
                              }
                              result2.push(value);
                            } else if (!includes2(seen, computed, comparator)) {
                              if (seen !== result2) {
                                seen.push(computed);
                              }
                              result2.push(value);
                            }
                          }
                        return result2;
                      }
                      function baseUnset(object, path) {
                        path = castPath(path, object);
                        object = parent(object, path);
                        return object == null || delete object[toKey(last(path))];
                      }
                      function baseUpdate(object, path, updater, customizer) {
                        return baseSet(object, path, updater(baseGet(object, path)), customizer);
                      }
                      function baseWhile(array, predicate, isDrop, fromRight) {
                        var length = array.length, index = fromRight ? length : -1;
                        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
                        }
                        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
                      }
                      function baseWrapperValue(value, actions) {
                        var result2 = value;
                        if (result2 instanceof LazyWrapper) {
                          result2 = result2.value();
                        }
                        return arrayReduce(actions, function(result3, action) {
                          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
                        }, result2);
                      }
                      function baseXor(arrays, iteratee2, comparator) {
                        var length = arrays.length;
                        if (length < 2) {
                          return length ? baseUniq(arrays[0]) : [];
                        }
                        var index = -1, result2 = Array2(length);
                        while (++index < length) {
                          var array = arrays[index], othIndex = -1;
                          while (++othIndex < length) {
                            if (othIndex != index) {
                              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                            }
                          }
                        }
                        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
                      }
                      function baseZipObject(props, values2, assignFunc) {
                        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
                        while (++index < length) {
                          var value = index < valsLength ? values2[index] : undefined2;
                          assignFunc(result2, props[index], value);
                        }
                        return result2;
                      }
                      function castArrayLikeObject(value) {
                        return isArrayLikeObject(value) ? value : [];
                      }
                      function castFunction(value) {
                        return typeof value == "function" ? value : identity;
                      }
                      function castPath(value, object) {
                        if (isArray(value)) {
                          return value;
                        }
                        return isKey(value, object) ? [value] : stringToPath(toString2(value));
                      }
                      var castRest = baseRest;
                      function castSlice(array, start, end) {
                        var length = array.length;
                        end = end === undefined2 ? length : end;
                        return !start && end >= length ? array : baseSlice(array, start, end);
                      }
                      var clearTimeout2 = ctxClearTimeout || function(id) {
                        return root.clearTimeout(id);
                      };
                      function cloneBuffer(buffer, isDeep) {
                        if (isDeep) {
                          return buffer.slice();
                        }
                        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                        buffer.copy(result2);
                        return result2;
                      }
                      function cloneArrayBuffer(arrayBuffer) {
                        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
                        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
                        return result2;
                      }
                      function cloneDataView(dataView, isDeep) {
                        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                      }
                      function cloneRegExp(regexp) {
                        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                        result2.lastIndex = regexp.lastIndex;
                        return result2;
                      }
                      function cloneSymbol(symbol) {
                        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
                      }
                      function cloneTypedArray(typedArray, isDeep) {
                        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                      }
                      function compareAscending(value, other) {
                        if (value !== other) {
                          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                            return 1;
                          }
                          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                            return -1;
                          }
                        }
                        return 0;
                      }
                      function compareMultiple(object, other, orders) {
                        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                        while (++index < length) {
                          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
                          if (result2) {
                            if (index >= ordersLength) {
                              return result2;
                            }
                            var order = orders[index];
                            return result2 * (order == "desc" ? -1 : 1);
                          }
                        }
                        return object.index - other.index;
                      }
                      function composeArgs(args, partials, holders, isCurried) {
                        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
                        while (++leftIndex < leftLength) {
                          result2[leftIndex] = partials[leftIndex];
                        }
                        while (++argsIndex < holdersLength) {
                          if (isUncurried || argsIndex < argsLength) {
                            result2[holders[argsIndex]] = args[argsIndex];
                          }
                        }
                        while (rangeLength--) {
                          result2[leftIndex++] = args[argsIndex++];
                        }
                        return result2;
                      }
                      function composeArgsRight(args, partials, holders, isCurried) {
                        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
                        while (++argsIndex < rangeLength) {
                          result2[argsIndex] = args[argsIndex];
                        }
                        var offset = argsIndex;
                        while (++rightIndex < rightLength) {
                          result2[offset + rightIndex] = partials[rightIndex];
                        }
                        while (++holdersIndex < holdersLength) {
                          if (isUncurried || argsIndex < argsLength) {
                            result2[offset + holders[holdersIndex]] = args[argsIndex++];
                          }
                        }
                        return result2;
                      }
                      function copyArray(source, array) {
                        var index = -1, length = source.length;
                        array || (array = Array2(length));
                        while (++index < length) {
                          array[index] = source[index];
                        }
                        return array;
                      }
                      function copyObject(source, props, object, customizer) {
                        var isNew = !object;
                        object || (object = {});
                        var index = -1, length = props.length;
                        while (++index < length) {
                          var key = props[index];
                          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
                          if (newValue === undefined2) {
                            newValue = source[key];
                          }
                          if (isNew) {
                            baseAssignValue(object, key, newValue);
                          } else {
                            assignValue(object, key, newValue);
                          }
                        }
                        return object;
                      }
                      function copySymbols(source, object) {
                        return copyObject(source, getSymbols(source), object);
                      }
                      function copySymbolsIn(source, object) {
                        return copyObject(source, getSymbolsIn(source), object);
                      }
                      function createAggregator(setter, initializer) {
                        return function(collection, iteratee2) {
                          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
                        };
                      }
                      function createAssigner(assigner) {
                        return baseRest(function(object, sources) {
                          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
                          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
                          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                            customizer = length < 3 ? undefined2 : customizer;
                            length = 1;
                          }
                          object = Object2(object);
                          while (++index < length) {
                            var source = sources[index];
                            if (source) {
                              assigner(object, source, index, customizer);
                            }
                          }
                          return object;
                        });
                      }
                      function createBaseEach(eachFunc, fromRight) {
                        return function(collection, iteratee2) {
                          if (collection == null) {
                            return collection;
                          }
                          if (!isArrayLike(collection)) {
                            return eachFunc(collection, iteratee2);
                          }
                          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
                          while (fromRight ? index-- : ++index < length) {
                            if (iteratee2(iterable[index], index, iterable) === false) {
                              break;
                            }
                          }
                          return collection;
                        };
                      }
                      function createBaseFor(fromRight) {
                        return function(object, iteratee2, keysFunc) {
                          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
                          while (length--) {
                            var key = props[fromRight ? length : ++index];
                            if (iteratee2(iterable[key], key, iterable) === false) {
                              break;
                            }
                          }
                          return object;
                        };
                      }
                      function createBind(func, bitmask, thisArg) {
                        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                        function wrapper() {
                          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                          return fn.apply(isBind ? thisArg : this, arguments);
                        }
                        return wrapper;
                      }
                      function createCaseFirst(methodName) {
                        return function(string) {
                          string = toString2(string);
                          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
                          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                          return chr[methodName]() + trailing;
                        };
                      }
                      function createCompounder(callback) {
                        return function(string) {
                          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
                        };
                      }
                      function createCtor(Ctor) {
                        return function() {
                          var args = arguments;
                          switch (args.length) {
                            case 0:
                              return new Ctor();
                            case 1:
                              return new Ctor(args[0]);
                            case 2:
                              return new Ctor(args[0], args[1]);
                            case 3:
                              return new Ctor(args[0], args[1], args[2]);
                            case 4:
                              return new Ctor(args[0], args[1], args[2], args[3]);
                            case 5:
                              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                            case 6:
                              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                            case 7:
                              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                          }
                          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
                          return isObject2(result2) ? result2 : thisBinding;
                        };
                      }
                      function createCurry(func, bitmask, arity) {
                        var Ctor = createCtor(func);
                        function wrapper() {
                          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
                          while (index--) {
                            args[index] = arguments[index];
                          }
                          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                          length -= holders.length;
                          if (length < arity) {
                            return createRecurry(
                              func,
                              bitmask,
                              createHybrid,
                              wrapper.placeholder,
                              undefined2,
                              args,
                              holders,
                              undefined2,
                              undefined2,
                              arity - length
                            );
                          }
                          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                          return apply(fn, this, args);
                        }
                        return wrapper;
                      }
                      function createFind(findIndexFunc) {
                        return function(collection, predicate, fromIndex) {
                          var iterable = Object2(collection);
                          if (!isArrayLike(collection)) {
                            var iteratee2 = getIteratee(predicate, 3);
                            collection = keys(collection);
                            predicate = function(key) {
                              return iteratee2(iterable[key], key, iterable);
                            };
                          }
                          var index = findIndexFunc(collection, predicate, fromIndex);
                          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
                        };
                      }
                      function createFlow(fromRight) {
                        return flatRest(function(funcs) {
                          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                          if (fromRight) {
                            funcs.reverse();
                          }
                          while (index--) {
                            var func = funcs[index];
                            if (typeof func != "function") {
                              throw new TypeError2(FUNC_ERROR_TEXT);
                            }
                            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                              var wrapper = new LodashWrapper([], true);
                            }
                          }
                          index = wrapper ? index : length;
                          while (++index < length) {
                            func = funcs[index];
                            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                            } else {
                              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                            }
                          }
                          return function() {
                            var args = arguments, value = args[0];
                            if (wrapper && args.length == 1 && isArray(value)) {
                              return wrapper.plant(value).value();
                            }
                            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                            while (++index2 < length) {
                              result2 = funcs[index2].call(this, result2);
                            }
                            return result2;
                          };
                        });
                      }
                      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
                        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
                        function wrapper() {
                          var length = arguments.length, args = Array2(length), index = length;
                          while (index--) {
                            args[index] = arguments[index];
                          }
                          if (isCurried) {
                            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                          }
                          if (partials) {
                            args = composeArgs(args, partials, holders, isCurried);
                          }
                          if (partialsRight) {
                            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                          }
                          length -= holdersCount;
                          if (isCurried && length < arity) {
                            var newHolders = replaceHolders(args, placeholder);
                            return createRecurry(
                              func,
                              bitmask,
                              createHybrid,
                              wrapper.placeholder,
                              thisArg,
                              args,
                              newHolders,
                              argPos,
                              ary2,
                              arity - length
                            );
                          }
                          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                          length = args.length;
                          if (argPos) {
                            args = reorder(args, argPos);
                          } else if (isFlip && length > 1) {
                            args.reverse();
                          }
                          if (isAry && ary2 < length) {
                            args.length = ary2;
                          }
                          if (this && this !== root && this instanceof wrapper) {
                            fn = Ctor || createCtor(fn);
                          }
                          return fn.apply(thisBinding, args);
                        }
                        return wrapper;
                      }
                      function createInverter(setter, toIteratee) {
                        return function(object, iteratee2) {
                          return baseInverter(object, setter, toIteratee(iteratee2), {});
                        };
                      }
                      function createMathOperation(operator, defaultValue) {
                        return function(value, other) {
                          var result2;
                          if (value === undefined2 && other === undefined2) {
                            return defaultValue;
                          }
                          if (value !== undefined2) {
                            result2 = value;
                          }
                          if (other !== undefined2) {
                            if (result2 === undefined2) {
                              return other;
                            }
                            if (typeof value == "string" || typeof other == "string") {
                              value = baseToString(value);
                              other = baseToString(other);
                            } else {
                              value = baseToNumber(value);
                              other = baseToNumber(other);
                            }
                            result2 = operator(value, other);
                          }
                          return result2;
                        };
                      }
                      function createOver(arrayFunc) {
                        return flatRest(function(iteratees) {
                          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                          return baseRest(function(args) {
                            var thisArg = this;
                            return arrayFunc(iteratees, function(iteratee2) {
                              return apply(iteratee2, thisArg, args);
                            });
                          });
                        });
                      }
                      function createPadding(length, chars) {
                        chars = chars === undefined2 ? " " : baseToString(chars);
                        var charsLength = chars.length;
                        if (charsLength < 2) {
                          return charsLength ? baseRepeat(chars, length) : chars;
                        }
                        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
                      }
                      function createPartial(func, bitmask, thisArg, partials) {
                        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                        function wrapper() {
                          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                          while (++leftIndex < leftLength) {
                            args[leftIndex] = partials[leftIndex];
                          }
                          while (argsLength--) {
                            args[leftIndex++] = arguments[++argsIndex];
                          }
                          return apply(fn, isBind ? thisArg : this, args);
                        }
                        return wrapper;
                      }
                      function createRange(fromRight) {
                        return function(start, end, step) {
                          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                            end = step = undefined2;
                          }
                          start = toFinite(start);
                          if (end === undefined2) {
                            end = start;
                            start = 0;
                          } else {
                            end = toFinite(end);
                          }
                          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
                          return baseRange(start, end, step, fromRight);
                        };
                      }
                      function createRelationalOperation(operator) {
                        return function(value, other) {
                          if (!(typeof value == "string" && typeof other == "string")) {
                            value = toNumber(value);
                            other = toNumber(other);
                          }
                          return operator(value, other);
                        };
                      }
                      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
                        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
                        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                        }
                        var newData = [
                          func,
                          bitmask,
                          thisArg,
                          newPartials,
                          newHolders,
                          newPartialsRight,
                          newHoldersRight,
                          argPos,
                          ary2,
                          arity
                        ];
                        var result2 = wrapFunc.apply(undefined2, newData);
                        if (isLaziable(func)) {
                          setData(result2, newData);
                        }
                        result2.placeholder = placeholder;
                        return setWrapToString(result2, func, bitmask);
                      }
                      function createRound(methodName) {
                        var func = Math2[methodName];
                        return function(number, precision) {
                          number = toNumber(number);
                          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                          if (precision && nativeIsFinite(number)) {
                            var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                            pair = (toString2(value) + "e").split("e");
                            return +(pair[0] + "e" + (+pair[1] - precision));
                          }
                          return func(number);
                        };
                      }
                      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
                        return new Set2(values2);
                      };
                      function createToPairs(keysFunc) {
                        return function(object) {
                          var tag = getTag(object);
                          if (tag == mapTag) {
                            return mapToArray(object);
                          }
                          if (tag == setTag) {
                            return setToPairs(object);
                          }
                          return baseToPairs(object, keysFunc(object));
                        };
                      }
                      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
                        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                        if (!isBindKey && typeof func != "function") {
                          throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        var length = partials ? partials.length : 0;
                        if (!length) {
                          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                          partials = holders = undefined2;
                        }
                        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
                        arity = arity === undefined2 ? arity : toInteger(arity);
                        length -= holders ? holders.length : 0;
                        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                          var partialsRight = partials, holdersRight = holders;
                          partials = holders = undefined2;
                        }
                        var data = isBindKey ? undefined2 : getData(func);
                        var newData = [
                          func,
                          bitmask,
                          thisArg,
                          partials,
                          holders,
                          partialsRight,
                          holdersRight,
                          argPos,
                          ary2,
                          arity
                        ];
                        if (data) {
                          mergeData(newData, data);
                        }
                        func = newData[0];
                        bitmask = newData[1];
                        thisArg = newData[2];
                        partials = newData[3];
                        holders = newData[4];
                        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                        }
                        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                          var result2 = createBind(func, bitmask, thisArg);
                        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                          result2 = createCurry(func, bitmask, arity);
                        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                          result2 = createPartial(func, bitmask, thisArg, partials);
                        } else {
                          result2 = createHybrid.apply(undefined2, newData);
                        }
                        var setter = data ? baseSetData : setData;
                        return setWrapToString(setter(result2, newData), func, bitmask);
                      }
                      function customDefaultsAssignIn(objValue, srcValue, key, object) {
                        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                          return srcValue;
                        }
                        return objValue;
                      }
                      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                        if (isObject2(objValue) && isObject2(srcValue)) {
                          stack.set(srcValue, objValue);
                          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
                          stack["delete"](srcValue);
                        }
                        return objValue;
                      }
                      function customOmitClone(value) {
                        return isPlainObject(value) ? undefined2 : value;
                      }
                      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                          return false;
                        }
                        var arrStacked = stack.get(array);
                        var othStacked = stack.get(other);
                        if (arrStacked && othStacked) {
                          return arrStacked == other && othStacked == array;
                        }
                        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
                        stack.set(array, other);
                        stack.set(other, array);
                        while (++index < arrLength) {
                          var arrValue = array[index], othValue = other[index];
                          if (customizer) {
                            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                          }
                          if (compared !== undefined2) {
                            if (compared) {
                              continue;
                            }
                            result2 = false;
                            break;
                          }
                          if (seen) {
                            if (!arraySome(other, function(othValue2, othIndex) {
                              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                                return seen.push(othIndex);
                              }
                            })) {
                              result2 = false;
                              break;
                            }
                          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                            result2 = false;
                            break;
                          }
                        }
                        stack["delete"](array);
                        stack["delete"](other);
                        return result2;
                      }
                      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                        switch (tag) {
                          case dataViewTag:
                            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                              return false;
                            }
                            object = object.buffer;
                            other = other.buffer;
                          case arrayBufferTag:
                            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                              return false;
                            }
                            return true;
                          case boolTag:
                          case dateTag:
                          case numberTag:
                            return eq(+object, +other);
                          case errorTag:
                            return object.name == other.name && object.message == other.message;
                          case regexpTag:
                          case stringTag:
                            return object == other + "";
                          case mapTag:
                            var convert = mapToArray;
                          case setTag:
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                            convert || (convert = setToArray);
                            if (object.size != other.size && !isPartial) {
                              return false;
                            }
                            var stacked = stack.get(object);
                            if (stacked) {
                              return stacked == other;
                            }
                            bitmask |= COMPARE_UNORDERED_FLAG;
                            stack.set(object, other);
                            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                            stack["delete"](object);
                            return result2;
                          case symbolTag:
                            if (symbolValueOf) {
                              return symbolValueOf.call(object) == symbolValueOf.call(other);
                            }
                        }
                        return false;
                      }
                      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                        if (objLength != othLength && !isPartial) {
                          return false;
                        }
                        var index = objLength;
                        while (index--) {
                          var key = objProps[index];
                          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                            return false;
                          }
                        }
                        var objStacked = stack.get(object);
                        var othStacked = stack.get(other);
                        if (objStacked && othStacked) {
                          return objStacked == other && othStacked == object;
                        }
                        var result2 = true;
                        stack.set(object, other);
                        stack.set(other, object);
                        var skipCtor = isPartial;
                        while (++index < objLength) {
                          key = objProps[index];
                          var objValue = object[key], othValue = other[key];
                          if (customizer) {
                            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                          }
                          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                            result2 = false;
                            break;
                          }
                          skipCtor || (skipCtor = key == "constructor");
                        }
                        if (result2 && !skipCtor) {
                          var objCtor = object.constructor, othCtor = other.constructor;
                          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                            result2 = false;
                          }
                        }
                        stack["delete"](object);
                        stack["delete"](other);
                        return result2;
                      }
                      function flatRest(func) {
                        return setToString(overRest(func, undefined2, flatten), func + "");
                      }
                      function getAllKeys(object) {
                        return baseGetAllKeys(object, keys, getSymbols);
                      }
                      function getAllKeysIn(object) {
                        return baseGetAllKeys(object, keysIn, getSymbolsIn);
                      }
                      var getData = !metaMap ? noop : function(func) {
                        return metaMap.get(func);
                      };
                      function getFuncName(func) {
                        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
                        while (length--) {
                          var data = array[length], otherFunc = data.func;
                          if (otherFunc == null || otherFunc == func) {
                            return data.name;
                          }
                        }
                        return result2;
                      }
                      function getHolder(func) {
                        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
                        return object.placeholder;
                      }
                      function getIteratee() {
                        var result2 = lodash.iteratee || iteratee;
                        result2 = result2 === iteratee ? baseIteratee : result2;
                        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
                      }
                      function getMapData(map3, key) {
                        var data = map3.__data__;
                        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
                      }
                      function getMatchData(object) {
                        var result2 = keys(object), length = result2.length;
                        while (length--) {
                          var key = result2[length], value = object[key];
                          result2[length] = [key, value, isStrictComparable(value)];
                        }
                        return result2;
                      }
                      function getNative(object, key) {
                        var value = getValue(object, key);
                        return baseIsNative(value) ? value : undefined2;
                      }
                      function getRawTag(value) {
                        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                        try {
                          value[symToStringTag] = undefined2;
                          var unmasked = true;
                        } catch (e) {
                        }
                        var result2 = nativeObjectToString.call(value);
                        if (unmasked) {
                          if (isOwn) {
                            value[symToStringTag] = tag;
                          } else {
                            delete value[symToStringTag];
                          }
                        }
                        return result2;
                      }
                      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                        if (object == null) {
                          return [];
                        }
                        object = Object2(object);
                        return arrayFilter(nativeGetSymbols(object), function(symbol) {
                          return propertyIsEnumerable.call(object, symbol);
                        });
                      };
                      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                        var result2 = [];
                        while (object) {
                          arrayPush(result2, getSymbols(object));
                          object = getPrototype(object);
                        }
                        return result2;
                      };
                      var getTag = baseGetTag;
                      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
                        getTag = function(value) {
                          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
                          if (ctorString) {
                            switch (ctorString) {
                              case dataViewCtorString:
                                return dataViewTag;
                              case mapCtorString:
                                return mapTag;
                              case promiseCtorString:
                                return promiseTag;
                              case setCtorString:
                                return setTag;
                              case weakMapCtorString:
                                return weakMapTag;
                            }
                          }
                          return result2;
                        };
                      }
                      function getView(start, end, transforms) {
                        var index = -1, length = transforms.length;
                        while (++index < length) {
                          var data = transforms[index], size2 = data.size;
                          switch (data.type) {
                            case "drop":
                              start += size2;
                              break;
                            case "dropRight":
                              end -= size2;
                              break;
                            case "take":
                              end = nativeMin(end, start + size2);
                              break;
                            case "takeRight":
                              start = nativeMax(start, end - size2);
                              break;
                          }
                        }
                        return { "start": start, "end": end };
                      }
                      function getWrapDetails(source) {
                        var match = source.match(reWrapDetails);
                        return match ? match[1].split(reSplitDetails) : [];
                      }
                      function hasPath(object, path, hasFunc) {
                        path = castPath(path, object);
                        var index = -1, length = path.length, result2 = false;
                        while (++index < length) {
                          var key = toKey(path[index]);
                          if (!(result2 = object != null && hasFunc(object, key))) {
                            break;
                          }
                          object = object[key];
                        }
                        if (result2 || ++index != length) {
                          return result2;
                        }
                        length = object == null ? 0 : object.length;
                        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
                      }
                      function initCloneArray(array) {
                        var length = array.length, result2 = new array.constructor(length);
                        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                          result2.index = array.index;
                          result2.input = array.input;
                        }
                        return result2;
                      }
                      function initCloneObject(object) {
                        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
                      }
                      function initCloneByTag(object, tag, isDeep) {
                        var Ctor = object.constructor;
                        switch (tag) {
                          case arrayBufferTag:
                            return cloneArrayBuffer(object);
                          case boolTag:
                          case dateTag:
                            return new Ctor(+object);
                          case dataViewTag:
                            return cloneDataView(object, isDeep);
                          case float32Tag:
                          case float64Tag:
                          case int8Tag:
                          case int16Tag:
                          case int32Tag:
                          case uint8Tag:
                          case uint8ClampedTag:
                          case uint16Tag:
                          case uint32Tag:
                            return cloneTypedArray(object, isDeep);
                          case mapTag:
                            return new Ctor();
                          case numberTag:
                          case stringTag:
                            return new Ctor(object);
                          case regexpTag:
                            return cloneRegExp(object);
                          case setTag:
                            return new Ctor();
                          case symbolTag:
                            return cloneSymbol(object);
                        }
                      }
                      function insertWrapDetails(source, details) {
                        var length = details.length;
                        if (!length) {
                          return source;
                        }
                        var lastIndex = length - 1;
                        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
                        details = details.join(length > 2 ? ", " : " ");
                        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
                      }
                      function isFlattenable(value) {
                        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
                      }
                      function isIndex(value, length) {
                        var type2 = typeof value;
                        length = length == null ? MAX_SAFE_INTEGER : length;
                        return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
                      }
                      function isIterateeCall(value, index, object) {
                        if (!isObject2(object)) {
                          return false;
                        }
                        var type2 = typeof index;
                        if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
                          return eq(object[index], value);
                        }
                        return false;
                      }
                      function isKey(value, object) {
                        if (isArray(value)) {
                          return false;
                        }
                        var type2 = typeof value;
                        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
                          return true;
                        }
                        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
                      }
                      function isKeyable(value) {
                        var type2 = typeof value;
                        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
                      }
                      function isLaziable(func) {
                        var funcName = getFuncName(func), other = lodash[funcName];
                        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                          return false;
                        }
                        if (func === other) {
                          return true;
                        }
                        var data = getData(other);
                        return !!data && func === data[0];
                      }
                      function isMasked(func) {
                        return !!maskSrcKey && maskSrcKey in func;
                      }
                      var isMaskable = coreJsData ? isFunction : stubFalse;
                      function isPrototype(value) {
                        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                        return value === proto;
                      }
                      function isStrictComparable(value) {
                        return value === value && !isObject2(value);
                      }
                      function matchesStrictComparable(key, srcValue) {
                        return function(object) {
                          if (object == null) {
                            return false;
                          }
                          return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
                        };
                      }
                      function memoizeCapped(func) {
                        var result2 = memoize(func, function(key) {
                          if (cache.size === MAX_MEMOIZE_SIZE) {
                            cache.clear();
                          }
                          return key;
                        });
                        var cache = result2.cache;
                        return result2;
                      }
                      function mergeData(data, source) {
                        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                        if (!(isCommon || isCombo)) {
                          return data;
                        }
                        if (srcBitmask & WRAP_BIND_FLAG) {
                          data[2] = source[2];
                          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                        }
                        var value = source[3];
                        if (value) {
                          var partials = data[3];
                          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                        }
                        value = source[5];
                        if (value) {
                          partials = data[5];
                          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                        }
                        value = source[7];
                        if (value) {
                          data[7] = value;
                        }
                        if (srcBitmask & WRAP_ARY_FLAG) {
                          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                        }
                        if (data[9] == null) {
                          data[9] = source[9];
                        }
                        data[0] = source[0];
                        data[1] = newBitmask;
                        return data;
                      }
                      function nativeKeysIn(object) {
                        var result2 = [];
                        if (object != null) {
                          for (var key in Object2(object)) {
                            result2.push(key);
                          }
                        }
                        return result2;
                      }
                      function objectToString(value) {
                        return nativeObjectToString.call(value);
                      }
                      function overRest(func, start, transform2) {
                        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
                        return function() {
                          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
                          while (++index < length) {
                            array[index] = args[start + index];
                          }
                          index = -1;
                          var otherArgs = Array2(start + 1);
                          while (++index < start) {
                            otherArgs[index] = args[index];
                          }
                          otherArgs[start] = transform2(array);
                          return apply(func, this, otherArgs);
                        };
                      }
                      function parent(object, path) {
                        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
                      }
                      function reorder(array, indexes) {
                        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                        while (length--) {
                          var index = indexes[length];
                          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
                        }
                        return array;
                      }
                      function safeGet(object, key) {
                        if (key === "constructor" && typeof object[key] === "function") {
                          return;
                        }
                        if (key == "__proto__") {
                          return;
                        }
                        return object[key];
                      }
                      var setData = shortOut(baseSetData);
                      var setTimeout2 = ctxSetTimeout || function(func, wait) {
                        return root.setTimeout(func, wait);
                      };
                      var setToString = shortOut(baseSetToString);
                      function setWrapToString(wrapper, reference, bitmask) {
                        var source = reference + "";
                        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
                      }
                      function shortOut(func) {
                        var count = 0, lastCalled = 0;
                        return function() {
                          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                          lastCalled = stamp;
                          if (remaining > 0) {
                            if (++count >= HOT_COUNT) {
                              return arguments[0];
                            }
                          } else {
                            count = 0;
                          }
                          return func.apply(undefined2, arguments);
                        };
                      }
                      function shuffleSelf(array, size2) {
                        var index = -1, length = array.length, lastIndex = length - 1;
                        size2 = size2 === undefined2 ? length : size2;
                        while (++index < size2) {
                          var rand = baseRandom(index, lastIndex), value = array[rand];
                          array[rand] = array[index];
                          array[index] = value;
                        }
                        array.length = size2;
                        return array;
                      }
                      var stringToPath = memoizeCapped(function(string) {
                        var result2 = [];
                        if (string.charCodeAt(0) === 46) {
                          result2.push("");
                        }
                        string.replace(rePropName, function(match, number, quote, subString) {
                          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
                        });
                        return result2;
                      });
                      function toKey(value) {
                        if (typeof value == "string" || isSymbol(value)) {
                          return value;
                        }
                        var result2 = value + "";
                        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
                      }
                      function toSource(func) {
                        if (func != null) {
                          try {
                            return funcToString.call(func);
                          } catch (e) {
                          }
                          try {
                            return func + "";
                          } catch (e) {
                          }
                        }
                        return "";
                      }
                      function updateWrapDetails(details, bitmask) {
                        arrayEach(wrapFlags, function(pair) {
                          var value = "_." + pair[0];
                          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                            details.push(value);
                          }
                        });
                        return details.sort();
                      }
                      function wrapperClone(wrapper) {
                        if (wrapper instanceof LazyWrapper) {
                          return wrapper.clone();
                        }
                        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                        result2.__actions__ = copyArray(wrapper.__actions__);
                        result2.__index__ = wrapper.__index__;
                        result2.__values__ = wrapper.__values__;
                        return result2;
                      }
                      function chunk(array, size2, guard) {
                        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
                          size2 = 1;
                        } else {
                          size2 = nativeMax(toInteger(size2), 0);
                        }
                        var length = array == null ? 0 : array.length;
                        if (!length || size2 < 1) {
                          return [];
                        }
                        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
                        while (index < length) {
                          result2[resIndex++] = baseSlice(array, index, index += size2);
                        }
                        return result2;
                      }
                      function compact(array) {
                        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
                        while (++index < length) {
                          var value = array[index];
                          if (value) {
                            result2[resIndex++] = value;
                          }
                        }
                        return result2;
                      }
                      function concat() {
                        var length = arguments.length;
                        if (!length) {
                          return [];
                        }
                        var args = Array2(length - 1), array = arguments[0], index = length;
                        while (index--) {
                          args[index - 1] = arguments[index];
                        }
                        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
                      }
                      var difference = baseRest(function(array, values2) {
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
                      });
                      var differenceBy = baseRest(function(array, values2) {
                        var iteratee2 = last(values2);
                        if (isArrayLikeObject(iteratee2)) {
                          iteratee2 = undefined2;
                        }
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
                      });
                      var differenceWith = baseRest(function(array, values2) {
                        var comparator = last(values2);
                        if (isArrayLikeObject(comparator)) {
                          comparator = undefined2;
                        }
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
                      });
                      function drop(array, n, guard) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                          return [];
                        }
                        n = guard || n === undefined2 ? 1 : toInteger(n);
                        return baseSlice(array, n < 0 ? 0 : n, length);
                      }
                      function dropRight(array, n, guard) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                          return [];
                        }
                        n = guard || n === undefined2 ? 1 : toInteger(n);
                        n = length - n;
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                      }
                      function dropRightWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
                      }
                      function dropWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
                      }
                      function fill(array, value, start, end) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                          return [];
                        }
                        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                          start = 0;
                          end = length;
                        }
                        return baseFill(array, value, start, end);
                      }
                      function findIndex(array, predicate, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                          return -1;
                        }
                        var index = fromIndex == null ? 0 : toInteger(fromIndex);
                        if (index < 0) {
                          index = nativeMax(length + index, 0);
                        }
                        return baseFindIndex(array, getIteratee(predicate, 3), index);
                      }
                      function findLastIndex(array, predicate, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                          return -1;
                        }
                        var index = length - 1;
                        if (fromIndex !== undefined2) {
                          index = toInteger(fromIndex);
                          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                        }
                        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
                      }
                      function flatten(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseFlatten(array, 1) : [];
                      }
                      function flattenDeep(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseFlatten(array, INFINITY) : [];
                      }
                      function flattenDepth(array, depth) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                          return [];
                        }
                        depth = depth === undefined2 ? 1 : toInteger(depth);
                        return baseFlatten(array, depth);
                      }
                      function fromPairs(pairs2) {
                        var index = -1, length = pairs2 == null ? 0 : pairs2.length, result2 = {};
                        while (++index < length) {
                          var pair = pairs2[index];
                          result2[pair[0]] = pair[1];
                        }
                        return result2;
                      }
                      function head(array) {
                        return array && array.length ? array[0] : undefined2;
                      }
                      function indexOf(array, value, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                          return -1;
                        }
                        var index = fromIndex == null ? 0 : toInteger(fromIndex);
                        if (index < 0) {
                          index = nativeMax(length + index, 0);
                        }
                        return baseIndexOf(array, value, index);
                      }
                      function initial(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseSlice(array, 0, -1) : [];
                      }
                      var intersection = baseRest(function(arrays) {
                        var mapped = arrayMap(arrays, castArrayLikeObject);
                        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
                      });
                      var intersectionBy = baseRest(function(arrays) {
                        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                        if (iteratee2 === last(mapped)) {
                          iteratee2 = undefined2;
                        } else {
                          mapped.pop();
                        }
                        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
                      });
                      var intersectionWith = baseRest(function(arrays) {
                        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                        comparator = typeof comparator == "function" ? comparator : undefined2;
                        if (comparator) {
                          mapped.pop();
                        }
                        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
                      });
                      function join(array, separator) {
                        return array == null ? "" : nativeJoin.call(array, separator);
                      }
                      function last(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? array[length - 1] : undefined2;
                      }
                      function lastIndexOf(array, value, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                          return -1;
                        }
                        var index = length;
                        if (fromIndex !== undefined2) {
                          index = toInteger(fromIndex);
                          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                        }
                        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
                      }
                      function nth(array, n) {
                        return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
                      }
                      var pull = baseRest(pullAll);
                      function pullAll(array, values2) {
                        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
                      }
                      function pullAllBy(array, values2, iteratee2) {
                        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
                      }
                      function pullAllWith(array, values2, comparator) {
                        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
                      }
                      var pullAt = flatRest(function(array, indexes) {
                        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
                        basePullAt(array, arrayMap(indexes, function(index) {
                          return isIndex(index, length) ? +index : index;
                        }).sort(compareAscending));
                        return result2;
                      });
                      function remove(array, predicate) {
                        var result2 = [];
                        if (!(array && array.length)) {
                          return result2;
                        }
                        var index = -1, indexes = [], length = array.length;
                        predicate = getIteratee(predicate, 3);
                        while (++index < length) {
                          var value = array[index];
                          if (predicate(value, index, array)) {
                            result2.push(value);
                            indexes.push(index);
                          }
                        }
                        basePullAt(array, indexes);
                        return result2;
                      }
                      function reverse(array) {
                        return array == null ? array : nativeReverse.call(array);
                      }
                      function slice(array, start, end) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                          return [];
                        }
                        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                          start = 0;
                          end = length;
                        } else {
                          start = start == null ? 0 : toInteger(start);
                          end = end === undefined2 ? length : toInteger(end);
                        }
                        return baseSlice(array, start, end);
                      }
                      function sortedIndex(array, value) {
                        return baseSortedIndex(array, value);
                      }
                      function sortedIndexBy(array, value, iteratee2) {
                        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
                      }
                      function sortedIndexOf(array, value) {
                        var length = array == null ? 0 : array.length;
                        if (length) {
                          var index = baseSortedIndex(array, value);
                          if (index < length && eq(array[index], value)) {
                            return index;
                          }
                        }
                        return -1;
                      }
                      function sortedLastIndex(array, value) {
                        return baseSortedIndex(array, value, true);
                      }
                      function sortedLastIndexBy(array, value, iteratee2) {
                        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
                      }
                      function sortedLastIndexOf(array, value) {
                        var length = array == null ? 0 : array.length;
                        if (length) {
                          var index = baseSortedIndex(array, value, true) - 1;
                          if (eq(array[index], value)) {
                            return index;
                          }
                        }
                        return -1;
                      }
                      function sortedUniq(array) {
                        return array && array.length ? baseSortedUniq(array) : [];
                      }
                      function sortedUniqBy(array, iteratee2) {
                        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
                      }
                      function tail(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseSlice(array, 1, length) : [];
                      }
                      function take(array, n, guard) {
                        if (!(array && array.length)) {
                          return [];
                        }
                        n = guard || n === undefined2 ? 1 : toInteger(n);
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                      }
                      function takeRight(array, n, guard) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                          return [];
                        }
                        n = guard || n === undefined2 ? 1 : toInteger(n);
                        n = length - n;
                        return baseSlice(array, n < 0 ? 0 : n, length);
                      }
                      function takeRightWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
                      }
                      function takeWhile(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
                      }
                      var union = baseRest(function(arrays) {
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                      });
                      var unionBy = baseRest(function(arrays) {
                        var iteratee2 = last(arrays);
                        if (isArrayLikeObject(iteratee2)) {
                          iteratee2 = undefined2;
                        }
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
                      });
                      var unionWith = baseRest(function(arrays) {
                        var comparator = last(arrays);
                        comparator = typeof comparator == "function" ? comparator : undefined2;
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
                      });
                      function uniq(array) {
                        return array && array.length ? baseUniq(array) : [];
                      }
                      function uniqBy(array, iteratee2) {
                        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
                      }
                      function uniqWith(array, comparator) {
                        comparator = typeof comparator == "function" ? comparator : undefined2;
                        return array && array.length ? baseUniq(array, undefined2, comparator) : [];
                      }
                      function unzip(array) {
                        if (!(array && array.length)) {
                          return [];
                        }
                        var length = 0;
                        array = arrayFilter(array, function(group) {
                          if (isArrayLikeObject(group)) {
                            length = nativeMax(group.length, length);
                            return true;
                          }
                        });
                        return baseTimes(length, function(index) {
                          return arrayMap(array, baseProperty(index));
                        });
                      }
                      function unzipWith(array, iteratee2) {
                        if (!(array && array.length)) {
                          return [];
                        }
                        var result2 = unzip(array);
                        if (iteratee2 == null) {
                          return result2;
                        }
                        return arrayMap(result2, function(group) {
                          return apply(iteratee2, undefined2, group);
                        });
                      }
                      var without = baseRest(function(array, values2) {
                        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
                      });
                      var xor = baseRest(function(arrays) {
                        return baseXor(arrayFilter(arrays, isArrayLikeObject));
                      });
                      var xorBy = baseRest(function(arrays) {
                        var iteratee2 = last(arrays);
                        if (isArrayLikeObject(iteratee2)) {
                          iteratee2 = undefined2;
                        }
                        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
                      });
                      var xorWith = baseRest(function(arrays) {
                        var comparator = last(arrays);
                        comparator = typeof comparator == "function" ? comparator : undefined2;
                        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
                      });
                      var zip = baseRest(unzip);
                      function zipObject(props, values2) {
                        return baseZipObject(props || [], values2 || [], assignValue);
                      }
                      function zipObjectDeep(props, values2) {
                        return baseZipObject(props || [], values2 || [], baseSet);
                      }
                      var zipWith = baseRest(function(arrays) {
                        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
                        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
                        return unzipWith(arrays, iteratee2);
                      });
                      function chain(value) {
                        var result2 = lodash(value);
                        result2.__chain__ = true;
                        return result2;
                      }
                      function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                      }
                      function thru(value, interceptor) {
                        return interceptor(value);
                      }
                      var wrapperAt = flatRest(function(paths) {
                        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                          return baseAt(object, paths);
                        };
                        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                          return this.thru(interceptor);
                        }
                        value = value.slice(start, +start + (length ? 1 : 0));
                        value.__actions__.push({
                          "func": thru,
                          "args": [interceptor],
                          "thisArg": undefined2
                        });
                        return new LodashWrapper(value, this.__chain__).thru(function(array) {
                          if (length && !array.length) {
                            array.push(undefined2);
                          }
                          return array;
                        });
                      });
                      function wrapperChain() {
                        return chain(this);
                      }
                      function wrapperCommit() {
                        return new LodashWrapper(this.value(), this.__chain__);
                      }
                      function wrapperNext() {
                        if (this.__values__ === undefined2) {
                          this.__values__ = toArray2(this.value());
                        }
                        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
                        return { "done": done, "value": value };
                      }
                      function wrapperToIterator() {
                        return this;
                      }
                      function wrapperPlant(value) {
                        var result2, parent2 = this;
                        while (parent2 instanceof baseLodash) {
                          var clone2 = wrapperClone(parent2);
                          clone2.__index__ = 0;
                          clone2.__values__ = undefined2;
                          if (result2) {
                            previous.__wrapped__ = clone2;
                          } else {
                            result2 = clone2;
                          }
                          var previous = clone2;
                          parent2 = parent2.__wrapped__;
                        }
                        previous.__wrapped__ = value;
                        return result2;
                      }
                      function wrapperReverse() {
                        var value = this.__wrapped__;
                        if (value instanceof LazyWrapper) {
                          var wrapped = value;
                          if (this.__actions__.length) {
                            wrapped = new LazyWrapper(this);
                          }
                          wrapped = wrapped.reverse();
                          wrapped.__actions__.push({
                            "func": thru,
                            "args": [reverse],
                            "thisArg": undefined2
                          });
                          return new LodashWrapper(wrapped, this.__chain__);
                        }
                        return this.thru(reverse);
                      }
                      function wrapperValue() {
                        return baseWrapperValue(this.__wrapped__, this.__actions__);
                      }
                      var countBy = createAggregator(function(result2, value, key) {
                        if (hasOwnProperty.call(result2, key)) {
                          ++result2[key];
                        } else {
                          baseAssignValue(result2, key, 1);
                        }
                      });
                      function every(collection, predicate, guard) {
                        var func = isArray(collection) ? arrayEvery : baseEvery;
                        if (guard && isIterateeCall(collection, predicate, guard)) {
                          predicate = undefined2;
                        }
                        return func(collection, getIteratee(predicate, 3));
                      }
                      function filter(collection, predicate) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        return func(collection, getIteratee(predicate, 3));
                      }
                      var find = createFind(findIndex);
                      var findLast = createFind(findLastIndex);
                      function flatMap(collection, iteratee2) {
                        return baseFlatten(map2(collection, iteratee2), 1);
                      }
                      function flatMapDeep(collection, iteratee2) {
                        return baseFlatten(map2(collection, iteratee2), INFINITY);
                      }
                      function flatMapDepth(collection, iteratee2, depth) {
                        depth = depth === undefined2 ? 1 : toInteger(depth);
                        return baseFlatten(map2(collection, iteratee2), depth);
                      }
                      function forEach(collection, iteratee2) {
                        var func = isArray(collection) ? arrayEach : baseEach;
                        return func(collection, getIteratee(iteratee2, 3));
                      }
                      function forEachRight(collection, iteratee2) {
                        var func = isArray(collection) ? arrayEachRight : baseEachRight;
                        return func(collection, getIteratee(iteratee2, 3));
                      }
                      var groupBy = createAggregator(function(result2, value, key) {
                        if (hasOwnProperty.call(result2, key)) {
                          result2[key].push(value);
                        } else {
                          baseAssignValue(result2, key, [value]);
                        }
                      });
                      function includes(collection, value, fromIndex, guard) {
                        collection = isArrayLike(collection) ? collection : values(collection);
                        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                        var length = collection.length;
                        if (fromIndex < 0) {
                          fromIndex = nativeMax(length + fromIndex, 0);
                        }
                        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
                      }
                      var invokeMap = baseRest(function(collection, path, args) {
                        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                        baseEach(collection, function(value) {
                          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                        });
                        return result2;
                      });
                      var keyBy2 = createAggregator(function(result2, value, key) {
                        baseAssignValue(result2, key, value);
                      });
                      function map2(collection, iteratee2) {
                        var func = isArray(collection) ? arrayMap : baseMap;
                        return func(collection, getIteratee(iteratee2, 3));
                      }
                      function orderBy(collection, iteratees, orders, guard) {
                        if (collection == null) {
                          return [];
                        }
                        if (!isArray(iteratees)) {
                          iteratees = iteratees == null ? [] : [iteratees];
                        }
                        orders = guard ? undefined2 : orders;
                        if (!isArray(orders)) {
                          orders = orders == null ? [] : [orders];
                        }
                        return baseOrderBy(collection, iteratees, orders);
                      }
                      var partition = createAggregator(function(result2, value, key) {
                        result2[key ? 0 : 1].push(value);
                      }, function() {
                        return [[], []];
                      });
                      function reduce(collection, iteratee2, accumulator) {
                        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
                      }
                      function reduceRight(collection, iteratee2, accumulator) {
                        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
                      }
                      function reject(collection, predicate) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        return func(collection, negate(getIteratee(predicate, 3)));
                      }
                      function sample(collection) {
                        var func = isArray(collection) ? arraySample : baseSample;
                        return func(collection);
                      }
                      function sampleSize(collection, n, guard) {
                        if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
                          n = 1;
                        } else {
                          n = toInteger(n);
                        }
                        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                        return func(collection, n);
                      }
                      function shuffle(collection) {
                        var func = isArray(collection) ? arrayShuffle : baseShuffle;
                        return func(collection);
                      }
                      function size(collection) {
                        if (collection == null) {
                          return 0;
                        }
                        if (isArrayLike(collection)) {
                          return isString(collection) ? stringSize(collection) : collection.length;
                        }
                        var tag = getTag(collection);
                        if (tag == mapTag || tag == setTag) {
                          return collection.size;
                        }
                        return baseKeys(collection).length;
                      }
                      function some(collection, predicate, guard) {
                        var func = isArray(collection) ? arraySome : baseSome;
                        if (guard && isIterateeCall(collection, predicate, guard)) {
                          predicate = undefined2;
                        }
                        return func(collection, getIteratee(predicate, 3));
                      }
                      var sortBy = baseRest(function(collection, iteratees) {
                        if (collection == null) {
                          return [];
                        }
                        var length = iteratees.length;
                        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                          iteratees = [];
                        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                          iteratees = [iteratees[0]];
                        }
                        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                      });
                      var now = ctxNow || function() {
                        return root.Date.now();
                      };
                      function after(n, func) {
                        if (typeof func != "function") {
                          throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        n = toInteger(n);
                        return function() {
                          if (--n < 1) {
                            return func.apply(this, arguments);
                          }
                        };
                      }
                      function ary(func, n, guard) {
                        n = guard ? undefined2 : n;
                        n = func && n == null ? func.length : n;
                        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
                      }
                      function before(n, func) {
                        var result2;
                        if (typeof func != "function") {
                          throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        n = toInteger(n);
                        return function() {
                          if (--n > 0) {
                            result2 = func.apply(this, arguments);
                          }
                          if (n <= 1) {
                            func = undefined2;
                          }
                          return result2;
                        };
                      }
                      var bind = baseRest(function(func, thisArg, partials) {
                        var bitmask = WRAP_BIND_FLAG;
                        if (partials.length) {
                          var holders = replaceHolders(partials, getHolder(bind));
                          bitmask |= WRAP_PARTIAL_FLAG;
                        }
                        return createWrap(func, bitmask, thisArg, partials, holders);
                      });
                      var bindKey = baseRest(function(object, key, partials) {
                        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                        if (partials.length) {
                          var holders = replaceHolders(partials, getHolder(bindKey));
                          bitmask |= WRAP_PARTIAL_FLAG;
                        }
                        return createWrap(key, bitmask, object, partials, holders);
                      });
                      function curry(func, arity, guard) {
                        arity = guard ? undefined2 : arity;
                        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
                        result2.placeholder = curry.placeholder;
                        return result2;
                      }
                      function curryRight(func, arity, guard) {
                        arity = guard ? undefined2 : arity;
                        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
                        result2.placeholder = curryRight.placeholder;
                        return result2;
                      }
                      function debounce(func, wait, options) {
                        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                        if (typeof func != "function") {
                          throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        wait = toNumber(wait) || 0;
                        if (isObject2(options)) {
                          leading = !!options.leading;
                          maxing = "maxWait" in options;
                          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                          trailing = "trailing" in options ? !!options.trailing : trailing;
                        }
                        function invokeFunc(time) {
                          var args = lastArgs, thisArg = lastThis;
                          lastArgs = lastThis = undefined2;
                          lastInvokeTime = time;
                          result2 = func.apply(thisArg, args);
                          return result2;
                        }
                        function leadingEdge(time) {
                          lastInvokeTime = time;
                          timerId = setTimeout2(timerExpired, wait);
                          return leading ? invokeFunc(time) : result2;
                        }
                        function remainingWait(time) {
                          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                        }
                        function shouldInvoke(time) {
                          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                        }
                        function timerExpired() {
                          var time = now();
                          if (shouldInvoke(time)) {
                            return trailingEdge(time);
                          }
                          timerId = setTimeout2(timerExpired, remainingWait(time));
                        }
                        function trailingEdge(time) {
                          timerId = undefined2;
                          if (trailing && lastArgs) {
                            return invokeFunc(time);
                          }
                          lastArgs = lastThis = undefined2;
                          return result2;
                        }
                        function cancel() {
                          if (timerId !== undefined2) {
                            clearTimeout2(timerId);
                          }
                          lastInvokeTime = 0;
                          lastArgs = lastCallTime = lastThis = timerId = undefined2;
                        }
                        function flush() {
                          return timerId === undefined2 ? result2 : trailingEdge(now());
                        }
                        function debounced() {
                          var time = now(), isInvoking = shouldInvoke(time);
                          lastArgs = arguments;
                          lastThis = this;
                          lastCallTime = time;
                          if (isInvoking) {
                            if (timerId === undefined2) {
                              return leadingEdge(lastCallTime);
                            }
                            if (maxing) {
                              clearTimeout2(timerId);
                              timerId = setTimeout2(timerExpired, wait);
                              return invokeFunc(lastCallTime);
                            }
                          }
                          if (timerId === undefined2) {
                            timerId = setTimeout2(timerExpired, wait);
                          }
                          return result2;
                        }
                        debounced.cancel = cancel;
                        debounced.flush = flush;
                        return debounced;
                      }
                      var defer = baseRest(function(func, args) {
                        return baseDelay(func, 1, args);
                      });
                      var delay = baseRest(function(func, wait, args) {
                        return baseDelay(func, toNumber(wait) || 0, args);
                      });
                      function flip(func) {
                        return createWrap(func, WRAP_FLIP_FLAG);
                      }
                      function memoize(func, resolver) {
                        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                          throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        var memoized = function() {
                          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                          if (cache.has(key)) {
                            return cache.get(key);
                          }
                          var result2 = func.apply(this, args);
                          memoized.cache = cache.set(key, result2) || cache;
                          return result2;
                        };
                        memoized.cache = new (memoize.Cache || MapCache)();
                        return memoized;
                      }
                      memoize.Cache = MapCache;
                      function negate(predicate) {
                        if (typeof predicate != "function") {
                          throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        return function() {
                          var args = arguments;
                          switch (args.length) {
                            case 0:
                              return !predicate.call(this);
                            case 1:
                              return !predicate.call(this, args[0]);
                            case 2:
                              return !predicate.call(this, args[0], args[1]);
                            case 3:
                              return !predicate.call(this, args[0], args[1], args[2]);
                          }
                          return !predicate.apply(this, args);
                        };
                      }
                      function once(func) {
                        return before(2, func);
                      }
                      var overArgs = castRest(function(func, transforms) {
                        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                        var funcsLength = transforms.length;
                        return baseRest(function(args) {
                          var index = -1, length = nativeMin(args.length, funcsLength);
                          while (++index < length) {
                            args[index] = transforms[index].call(this, args[index]);
                          }
                          return apply(func, this, args);
                        });
                      });
                      var partial = baseRest(function(func, partials) {
                        var holders = replaceHolders(partials, getHolder(partial));
                        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
                      });
                      var partialRight = baseRest(function(func, partials) {
                        var holders = replaceHolders(partials, getHolder(partialRight));
                        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
                      });
                      var rearg = flatRest(function(func, indexes) {
                        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
                      });
                      function rest(func, start) {
                        if (typeof func != "function") {
                          throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        start = start === undefined2 ? start : toInteger(start);
                        return baseRest(func, start);
                      }
                      function spread(func, start) {
                        if (typeof func != "function") {
                          throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        start = start == null ? 0 : nativeMax(toInteger(start), 0);
                        return baseRest(function(args) {
                          var array = args[start], otherArgs = castSlice(args, 0, start);
                          if (array) {
                            arrayPush(otherArgs, array);
                          }
                          return apply(func, this, otherArgs);
                        });
                      }
                      function throttle(func, wait, options) {
                        var leading = true, trailing = true;
                        if (typeof func != "function") {
                          throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        if (isObject2(options)) {
                          leading = "leading" in options ? !!options.leading : leading;
                          trailing = "trailing" in options ? !!options.trailing : trailing;
                        }
                        return debounce(func, wait, {
                          "leading": leading,
                          "maxWait": wait,
                          "trailing": trailing
                        });
                      }
                      function unary(func) {
                        return ary(func, 1);
                      }
                      function wrap(value, wrapper) {
                        return partial(castFunction(wrapper), value);
                      }
                      function castArray() {
                        if (!arguments.length) {
                          return [];
                        }
                        var value = arguments[0];
                        return isArray(value) ? value : [value];
                      }
                      function clone(value) {
                        return baseClone(value, CLONE_SYMBOLS_FLAG);
                      }
                      function cloneWith(value, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined2;
                        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                      }
                      function cloneDeep(value) {
                        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                      }
                      function cloneDeepWith(value, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined2;
                        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
                      }
                      function conformsTo(object, source) {
                        return source == null || baseConformsTo(object, source, keys(source));
                      }
                      function eq(value, other) {
                        return value === other || value !== value && other !== other;
                      }
                      var gt = createRelationalOperation(baseGt);
                      var gte = createRelationalOperation(function(value, other) {
                        return value >= other;
                      });
                      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
                        return arguments;
                      }()) ? baseIsArguments : function(value) {
                        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
                      };
                      var isArray = Array2.isArray;
                      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
                      function isArrayLike(value) {
                        return value != null && isLength(value.length) && !isFunction(value);
                      }
                      function isArrayLikeObject(value) {
                        return isObjectLike(value) && isArrayLike(value);
                      }
                      function isBoolean2(value) {
                        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
                      }
                      var isBuffer = nativeIsBuffer || stubFalse;
                      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
                      function isElement(value) {
                        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
                      }
                      function isEmpty(value) {
                        if (value == null) {
                          return true;
                        }
                        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                          return !value.length;
                        }
                        var tag = getTag(value);
                        if (tag == mapTag || tag == setTag) {
                          return !value.size;
                        }
                        if (isPrototype(value)) {
                          return !baseKeys(value).length;
                        }
                        for (var key in value) {
                          if (hasOwnProperty.call(value, key)) {
                            return false;
                          }
                        }
                        return true;
                      }
                      function isEqual(value, other) {
                        return baseIsEqual(value, other);
                      }
                      function isEqualWith(value, other, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined2;
                        var result2 = customizer ? customizer(value, other) : undefined2;
                        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
                      }
                      function isError(value) {
                        if (!isObjectLike(value)) {
                          return false;
                        }
                        var tag = baseGetTag(value);
                        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
                      }
                      function isFinite2(value) {
                        return typeof value == "number" && nativeIsFinite(value);
                      }
                      function isFunction(value) {
                        if (!isObject2(value)) {
                          return false;
                        }
                        var tag = baseGetTag(value);
                        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                      }
                      function isInteger2(value) {
                        return typeof value == "number" && value == toInteger(value);
                      }
                      function isLength(value) {
                        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                      }
                      function isObject2(value) {
                        var type2 = typeof value;
                        return value != null && (type2 == "object" || type2 == "function");
                      }
                      function isObjectLike(value) {
                        return value != null && typeof value == "object";
                      }
                      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
                      function isMatch(object, source) {
                        return object === source || baseIsMatch(object, source, getMatchData(source));
                      }
                      function isMatchWith(object, source, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined2;
                        return baseIsMatch(object, source, getMatchData(source), customizer);
                      }
                      function isNaN2(value) {
                        return isNumber(value) && value != +value;
                      }
                      function isNative(value) {
                        if (isMaskable(value)) {
                          throw new Error2(CORE_ERROR_TEXT);
                        }
                        return baseIsNative(value);
                      }
                      function isNull2(value) {
                        return value === null;
                      }
                      function isNil(value) {
                        return value == null;
                      }
                      function isNumber(value) {
                        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
                      }
                      function isPlainObject(value) {
                        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                          return false;
                        }
                        var proto = getPrototype(value);
                        if (proto === null) {
                          return true;
                        }
                        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
                      }
                      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
                      function isSafeInteger(value) {
                        return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
                      }
                      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
                      function isString(value) {
                        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
                      }
                      function isSymbol(value) {
                        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
                      }
                      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
                      function isUndefined(value) {
                        return value === undefined2;
                      }
                      function isWeakMap(value) {
                        return isObjectLike(value) && getTag(value) == weakMapTag;
                      }
                      function isWeakSet(value) {
                        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                      }
                      var lt = createRelationalOperation(baseLt);
                      var lte = createRelationalOperation(function(value, other) {
                        return value <= other;
                      });
                      function toArray2(value) {
                        if (!value) {
                          return [];
                        }
                        if (isArrayLike(value)) {
                          return isString(value) ? stringToArray(value) : copyArray(value);
                        }
                        if (symIterator && value[symIterator]) {
                          return iteratorToArray(value[symIterator]());
                        }
                        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                        return func(value);
                      }
                      function toFinite(value) {
                        if (!value) {
                          return value === 0 ? value : 0;
                        }
                        value = toNumber(value);
                        if (value === INFINITY || value === -INFINITY) {
                          var sign = value < 0 ? -1 : 1;
                          return sign * MAX_INTEGER;
                        }
                        return value === value ? value : 0;
                      }
                      function toInteger(value) {
                        var result2 = toFinite(value), remainder = result2 % 1;
                        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
                      }
                      function toLength(value) {
                        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                      }
                      function toNumber(value) {
                        if (typeof value == "number") {
                          return value;
                        }
                        if (isSymbol(value)) {
                          return NAN;
                        }
                        if (isObject2(value)) {
                          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                          value = isObject2(other) ? other + "" : other;
                        }
                        if (typeof value != "string") {
                          return value === 0 ? value : +value;
                        }
                        value = baseTrim(value);
                        var isBinary2 = reIsBinary.test(value);
                        return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
                      }
                      function toPlainObject(value) {
                        return copyObject(value, keysIn(value));
                      }
                      function toSafeInteger(value) {
                        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
                      }
                      function toString2(value) {
                        return value == null ? "" : baseToString(value);
                      }
                      var assign = createAssigner(function(object, source) {
                        if (isPrototype(source) || isArrayLike(source)) {
                          copyObject(source, keys(source), object);
                          return;
                        }
                        for (var key in source) {
                          if (hasOwnProperty.call(source, key)) {
                            assignValue(object, key, source[key]);
                          }
                        }
                      });
                      var assignIn = createAssigner(function(object, source) {
                        copyObject(source, keysIn(source), object);
                      });
                      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                        copyObject(source, keysIn(source), object, customizer);
                      });
                      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                        copyObject(source, keys(source), object, customizer);
                      });
                      var at = flatRest(baseAt);
                      function create(prototype, properties) {
                        var result2 = baseCreate(prototype);
                        return properties == null ? result2 : baseAssign(result2, properties);
                      }
                      var defaults = baseRest(function(object, sources) {
                        object = Object2(object);
                        var index = -1;
                        var length = sources.length;
                        var guard = length > 2 ? sources[2] : undefined2;
                        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                          length = 1;
                        }
                        while (++index < length) {
                          var source = sources[index];
                          var props = keysIn(source);
                          var propsIndex = -1;
                          var propsLength = props.length;
                          while (++propsIndex < propsLength) {
                            var key = props[propsIndex];
                            var value = object[key];
                            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                              object[key] = source[key];
                            }
                          }
                        }
                        return object;
                      });
                      var defaultsDeep = baseRest(function(args) {
                        args.push(undefined2, customDefaultsMerge);
                        return apply(mergeWith, undefined2, args);
                      });
                      function findKey(object, predicate) {
                        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
                      }
                      function findLastKey(object, predicate) {
                        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
                      }
                      function forIn(object, iteratee2) {
                        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
                      }
                      function forInRight(object, iteratee2) {
                        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
                      }
                      function forOwn(object, iteratee2) {
                        return object && baseForOwn(object, getIteratee(iteratee2, 3));
                      }
                      function forOwnRight(object, iteratee2) {
                        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
                      }
                      function functions(object) {
                        return object == null ? [] : baseFunctions(object, keys(object));
                      }
                      function functionsIn(object) {
                        return object == null ? [] : baseFunctions(object, keysIn(object));
                      }
                      function get(object, path, defaultValue) {
                        var result2 = object == null ? undefined2 : baseGet(object, path);
                        return result2 === undefined2 ? defaultValue : result2;
                      }
                      function has(object, path) {
                        return object != null && hasPath(object, path, baseHas);
                      }
                      function hasIn(object, path) {
                        return object != null && hasPath(object, path, baseHasIn);
                      }
                      var invert = createInverter(function(result2, value, key) {
                        if (value != null && typeof value.toString != "function") {
                          value = nativeObjectToString.call(value);
                        }
                        result2[value] = key;
                      }, constant(identity));
                      var invertBy = createInverter(function(result2, value, key) {
                        if (value != null && typeof value.toString != "function") {
                          value = nativeObjectToString.call(value);
                        }
                        if (hasOwnProperty.call(result2, value)) {
                          result2[value].push(key);
                        } else {
                          result2[value] = [key];
                        }
                      }, getIteratee);
                      var invoke = baseRest(baseInvoke);
                      function keys(object) {
                        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                      }
                      function keysIn(object) {
                        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                      }
                      function mapKeys(object, iteratee2) {
                        var result2 = {};
                        iteratee2 = getIteratee(iteratee2, 3);
                        baseForOwn(object, function(value, key, object2) {
                          baseAssignValue(result2, iteratee2(value, key, object2), value);
                        });
                        return result2;
                      }
                      function mapValues(object, iteratee2) {
                        var result2 = {};
                        iteratee2 = getIteratee(iteratee2, 3);
                        baseForOwn(object, function(value, key, object2) {
                          baseAssignValue(result2, key, iteratee2(value, key, object2));
                        });
                        return result2;
                      }
                      var merge2 = createAssigner(function(object, source, srcIndex) {
                        baseMerge(object, source, srcIndex);
                      });
                      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                        baseMerge(object, source, srcIndex, customizer);
                      });
                      var omit = flatRest(function(object, paths) {
                        var result2 = {};
                        if (object == null) {
                          return result2;
                        }
                        var isDeep = false;
                        paths = arrayMap(paths, function(path) {
                          path = castPath(path, object);
                          isDeep || (isDeep = path.length > 1);
                          return path;
                        });
                        copyObject(object, getAllKeysIn(object), result2);
                        if (isDeep) {
                          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                        }
                        var length = paths.length;
                        while (length--) {
                          baseUnset(result2, paths[length]);
                        }
                        return result2;
                      });
                      function omitBy(object, predicate) {
                        return pickBy(object, negate(getIteratee(predicate)));
                      }
                      var pick = flatRest(function(object, paths) {
                        return object == null ? {} : basePick(object, paths);
                      });
                      function pickBy(object, predicate) {
                        if (object == null) {
                          return {};
                        }
                        var props = arrayMap(getAllKeysIn(object), function(prop) {
                          return [prop];
                        });
                        predicate = getIteratee(predicate);
                        return basePickBy(object, props, function(value, path) {
                          return predicate(value, path[0]);
                        });
                      }
                      function result(object, path, defaultValue) {
                        path = castPath(path, object);
                        var index = -1, length = path.length;
                        if (!length) {
                          length = 1;
                          object = undefined2;
                        }
                        while (++index < length) {
                          var value = object == null ? undefined2 : object[toKey(path[index])];
                          if (value === undefined2) {
                            index = length;
                            value = defaultValue;
                          }
                          object = isFunction(value) ? value.call(object) : value;
                        }
                        return object;
                      }
                      function set2(object, path, value) {
                        return object == null ? object : baseSet(object, path, value);
                      }
                      function setWith(object, path, value, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined2;
                        return object == null ? object : baseSet(object, path, value, customizer);
                      }
                      var toPairs = createToPairs(keys);
                      var toPairsIn = createToPairs(keysIn);
                      function transform(object, iteratee2, accumulator) {
                        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                        iteratee2 = getIteratee(iteratee2, 4);
                        if (accumulator == null) {
                          var Ctor = object && object.constructor;
                          if (isArrLike) {
                            accumulator = isArr ? new Ctor() : [];
                          } else if (isObject2(object)) {
                            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                          } else {
                            accumulator = {};
                          }
                        }
                        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
                          return iteratee2(accumulator, value, index, object2);
                        });
                        return accumulator;
                      }
                      function unset(object, path) {
                        return object == null ? true : baseUnset(object, path);
                      }
                      function update(object, path, updater) {
                        return object == null ? object : baseUpdate(object, path, castFunction(updater));
                      }
                      function updateWith(object, path, updater, customizer) {
                        customizer = typeof customizer == "function" ? customizer : undefined2;
                        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
                      }
                      function values(object) {
                        return object == null ? [] : baseValues(object, keys(object));
                      }
                      function valuesIn(object) {
                        return object == null ? [] : baseValues(object, keysIn(object));
                      }
                      function clamp(number, lower, upper) {
                        if (upper === undefined2) {
                          upper = lower;
                          lower = undefined2;
                        }
                        if (upper !== undefined2) {
                          upper = toNumber(upper);
                          upper = upper === upper ? upper : 0;
                        }
                        if (lower !== undefined2) {
                          lower = toNumber(lower);
                          lower = lower === lower ? lower : 0;
                        }
                        return baseClamp(toNumber(number), lower, upper);
                      }
                      function inRange(number, start, end) {
                        start = toFinite(start);
                        if (end === undefined2) {
                          end = start;
                          start = 0;
                        } else {
                          end = toFinite(end);
                        }
                        number = toNumber(number);
                        return baseInRange(number, start, end);
                      }
                      function random2(lower, upper, floating) {
                        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
                          upper = floating = undefined2;
                        }
                        if (floating === undefined2) {
                          if (typeof upper == "boolean") {
                            floating = upper;
                            upper = undefined2;
                          } else if (typeof lower == "boolean") {
                            floating = lower;
                            lower = undefined2;
                          }
                        }
                        if (lower === undefined2 && upper === undefined2) {
                          lower = 0;
                          upper = 1;
                        } else {
                          lower = toFinite(lower);
                          if (upper === undefined2) {
                            upper = lower;
                            lower = 0;
                          } else {
                            upper = toFinite(upper);
                          }
                        }
                        if (lower > upper) {
                          var temp2 = lower;
                          lower = upper;
                          upper = temp2;
                        }
                        if (floating || lower % 1 || upper % 1) {
                          var rand = nativeRandom();
                          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
                        }
                        return baseRandom(lower, upper);
                      }
                      var camelCase = createCompounder(function(result2, word, index) {
                        word = word.toLowerCase();
                        return result2 + (index ? capitalize(word) : word);
                      });
                      function capitalize(string) {
                        return upperFirst(toString2(string).toLowerCase());
                      }
                      function deburr(string) {
                        string = toString2(string);
                        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
                      }
                      function endsWith(string, target, position) {
                        string = toString2(string);
                        target = baseToString(target);
                        var length = string.length;
                        position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
                        var end = position;
                        position -= target.length;
                        return position >= 0 && string.slice(position, end) == target;
                      }
                      function escape(string) {
                        string = toString2(string);
                        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
                      }
                      function escapeRegExp(string) {
                        string = toString2(string);
                        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
                      }
                      var kebabCase = createCompounder(function(result2, word, index) {
                        return result2 + (index ? "-" : "") + word.toLowerCase();
                      });
                      var lowerCase = createCompounder(function(result2, word, index) {
                        return result2 + (index ? " " : "") + word.toLowerCase();
                      });
                      var lowerFirst = createCaseFirst("toLowerCase");
                      function pad(string, length, chars) {
                        string = toString2(string);
                        length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        if (!length || strLength >= length) {
                          return string;
                        }
                        var mid = (length - strLength) / 2;
                        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
                      }
                      function padEnd(string, length, chars) {
                        string = toString2(string);
                        length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
                      }
                      function padStart2(string, length, chars) {
                        string = toString2(string);
                        length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
                      }
                      function parseInt2(string, radix, guard) {
                        if (guard || radix == null) {
                          radix = 0;
                        } else if (radix) {
                          radix = +radix;
                        }
                        return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
                      }
                      function repeat2(string, n, guard) {
                        if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
                          n = 1;
                        } else {
                          n = toInteger(n);
                        }
                        return baseRepeat(toString2(string), n);
                      }
                      function replace() {
                        var args = arguments, string = toString2(args[0]);
                        return args.length < 3 ? string : string.replace(args[1], args[2]);
                      }
                      var snakeCase = createCompounder(function(result2, word, index) {
                        return result2 + (index ? "_" : "") + word.toLowerCase();
                      });
                      function split(string, separator, limit) {
                        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                          separator = limit = undefined2;
                        }
                        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
                        if (!limit) {
                          return [];
                        }
                        string = toString2(string);
                        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                          separator = baseToString(separator);
                          if (!separator && hasUnicode(string)) {
                            return castSlice(stringToArray(string), 0, limit);
                          }
                        }
                        return string.split(separator, limit);
                      }
                      var startCase = createCompounder(function(result2, word, index) {
                        return result2 + (index ? " " : "") + upperFirst(word);
                      });
                      function startsWith(string, target, position) {
                        string = toString2(string);
                        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                        target = baseToString(target);
                        return string.slice(position, position + target.length) == target;
                      }
                      function template(string, options, guard) {
                        var settings = lodash.templateSettings;
                        if (guard && isIterateeCall(string, options, guard)) {
                          options = undefined2;
                        }
                        string = toString2(string);
                        options = assignInWith({}, options, settings, customDefaultsAssignIn);
                        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                        var reDelimiters = RegExp2(
                          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
                          "g"
                        );
                        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                          interpolateValue || (interpolateValue = esTemplateValue);
                          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                          if (escapeValue) {
                            isEscaping = true;
                            source += "' +\n__e(" + escapeValue + ") +\n'";
                          }
                          if (evaluateValue) {
                            isEvaluating = true;
                            source += "';\n" + evaluateValue + ";\n__p += '";
                          }
                          if (interpolateValue) {
                            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                          }
                          index = offset + match.length;
                          return match;
                        });
                        source += "';\n";
                        var variable = hasOwnProperty.call(options, "variable") && options.variable;
                        if (!variable) {
                          source = "with (obj) {\n" + source + "\n}\n";
                        } else if (reForbiddenIdentifierChars.test(variable)) {
                          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
                        }
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var result2 = attempt(function() {
                          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
                        });
                        result2.source = source;
                        if (isError(result2)) {
                          throw result2;
                        }
                        return result2;
                      }
                      function toLower(value) {
                        return toString2(value).toLowerCase();
                      }
                      function toUpper(value) {
                        return toString2(value).toUpperCase();
                      }
                      function trim(string, chars, guard) {
                        string = toString2(string);
                        if (string && (guard || chars === undefined2)) {
                          return baseTrim(string);
                        }
                        if (!string || !(chars = baseToString(chars))) {
                          return string;
                        }
                        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                        return castSlice(strSymbols, start, end).join("");
                      }
                      function trimEnd(string, chars, guard) {
                        string = toString2(string);
                        if (string && (guard || chars === undefined2)) {
                          return string.slice(0, trimmedEndIndex(string) + 1);
                        }
                        if (!string || !(chars = baseToString(chars))) {
                          return string;
                        }
                        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                        return castSlice(strSymbols, 0, end).join("");
                      }
                      function trimStart(string, chars, guard) {
                        string = toString2(string);
                        if (string && (guard || chars === undefined2)) {
                          return string.replace(reTrimStart, "");
                        }
                        if (!string || !(chars = baseToString(chars))) {
                          return string;
                        }
                        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                        return castSlice(strSymbols, start).join("");
                      }
                      function truncate(string, options) {
                        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                        if (isObject2(options)) {
                          var separator = "separator" in options ? options.separator : separator;
                          length = "length" in options ? toInteger(options.length) : length;
                          omission = "omission" in options ? baseToString(options.omission) : omission;
                        }
                        string = toString2(string);
                        var strLength = string.length;
                        if (hasUnicode(string)) {
                          var strSymbols = stringToArray(string);
                          strLength = strSymbols.length;
                        }
                        if (length >= strLength) {
                          return string;
                        }
                        var end = length - stringSize(omission);
                        if (end < 1) {
                          return omission;
                        }
                        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                        if (separator === undefined2) {
                          return result2 + omission;
                        }
                        if (strSymbols) {
                          end += result2.length - end;
                        }
                        if (isRegExp(separator)) {
                          if (string.slice(end).search(separator)) {
                            var match, substring = result2;
                            if (!separator.global) {
                              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
                            }
                            separator.lastIndex = 0;
                            while (match = separator.exec(substring)) {
                              var newEnd = match.index;
                            }
                            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
                          }
                        } else if (string.indexOf(baseToString(separator), end) != end) {
                          var index = result2.lastIndexOf(separator);
                          if (index > -1) {
                            result2 = result2.slice(0, index);
                          }
                        }
                        return result2 + omission;
                      }
                      function unescape(string) {
                        string = toString2(string);
                        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
                      }
                      var upperCase = createCompounder(function(result2, word, index) {
                        return result2 + (index ? " " : "") + word.toUpperCase();
                      });
                      var upperFirst = createCaseFirst("toUpperCase");
                      function words(string, pattern, guard) {
                        string = toString2(string);
                        pattern = guard ? undefined2 : pattern;
                        if (pattern === undefined2) {
                          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                        }
                        return string.match(pattern) || [];
                      }
                      var attempt = baseRest(function(func, args) {
                        try {
                          return apply(func, undefined2, args);
                        } catch (e) {
                          return isError(e) ? e : new Error2(e);
                        }
                      });
                      var bindAll = flatRest(function(object, methodNames) {
                        arrayEach(methodNames, function(key) {
                          key = toKey(key);
                          baseAssignValue(object, key, bind(object[key], object));
                        });
                        return object;
                      });
                      function cond(pairs2) {
                        var length = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
                        pairs2 = !length ? [] : arrayMap(pairs2, function(pair) {
                          if (typeof pair[1] != "function") {
                            throw new TypeError2(FUNC_ERROR_TEXT);
                          }
                          return [toIteratee(pair[0]), pair[1]];
                        });
                        return baseRest(function(args) {
                          var index = -1;
                          while (++index < length) {
                            var pair = pairs2[index];
                            if (apply(pair[0], this, args)) {
                              return apply(pair[1], this, args);
                            }
                          }
                        });
                      }
                      function conforms(source) {
                        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                      }
                      function constant(value) {
                        return function() {
                          return value;
                        };
                      }
                      function defaultTo(value, defaultValue) {
                        return value == null || value !== value ? defaultValue : value;
                      }
                      var flow = createFlow();
                      var flowRight = createFlow(true);
                      function identity(value) {
                        return value;
                      }
                      function iteratee(func) {
                        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
                      }
                      function matches(source) {
                        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                      }
                      function matchesProperty(path, srcValue) {
                        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
                      }
                      var method = baseRest(function(path, args) {
                        return function(object) {
                          return baseInvoke(object, path, args);
                        };
                      });
                      var methodOf = baseRest(function(object, args) {
                        return function(path) {
                          return baseInvoke(object, path, args);
                        };
                      });
                      function mixin(object, source, options) {
                        var props = keys(source), methodNames = baseFunctions(source, props);
                        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
                          options = source;
                          source = object;
                          object = this;
                          methodNames = baseFunctions(source, keys(source));
                        }
                        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
                        arrayEach(methodNames, function(methodName) {
                          var func = source[methodName];
                          object[methodName] = func;
                          if (isFunc) {
                            object.prototype[methodName] = function() {
                              var chainAll = this.__chain__;
                              if (chain2 || chainAll) {
                                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                                actions.push({ "func": func, "args": arguments, "thisArg": object });
                                result2.__chain__ = chainAll;
                                return result2;
                              }
                              return func.apply(object, arrayPush([this.value()], arguments));
                            };
                          }
                        });
                        return object;
                      }
                      function noConflict() {
                        if (root._ === this) {
                          root._ = oldDash;
                        }
                        return this;
                      }
                      function noop() {
                      }
                      function nthArg(n) {
                        n = toInteger(n);
                        return baseRest(function(args) {
                          return baseNth(args, n);
                        });
                      }
                      var over = createOver(arrayMap);
                      var overEvery = createOver(arrayEvery);
                      var overSome = createOver(arraySome);
                      function property(path) {
                        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                      }
                      function propertyOf(object) {
                        return function(path) {
                          return object == null ? undefined2 : baseGet(object, path);
                        };
                      }
                      var range = createRange();
                      var rangeRight = createRange(true);
                      function stubArray() {
                        return [];
                      }
                      function stubFalse() {
                        return false;
                      }
                      function stubObject() {
                        return {};
                      }
                      function stubString() {
                        return "";
                      }
                      function stubTrue() {
                        return true;
                      }
                      function times(n, iteratee2) {
                        n = toInteger(n);
                        if (n < 1 || n > MAX_SAFE_INTEGER) {
                          return [];
                        }
                        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                        iteratee2 = getIteratee(iteratee2);
                        n -= MAX_ARRAY_LENGTH;
                        var result2 = baseTimes(length, iteratee2);
                        while (++index < n) {
                          iteratee2(index);
                        }
                        return result2;
                      }
                      function toPath(value) {
                        if (isArray(value)) {
                          return arrayMap(value, toKey);
                        }
                        return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
                      }
                      function uniqueId(prefix) {
                        var id = ++idCounter;
                        return toString2(prefix) + id;
                      }
                      var add = createMathOperation(function(augend, addend) {
                        return augend + addend;
                      }, 0);
                      var ceil = createRound("ceil");
                      var divide = createMathOperation(function(dividend, divisor) {
                        return dividend / divisor;
                      }, 1);
                      var floor5 = createRound("floor");
                      function max6(array) {
                        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
                      }
                      function maxBy(array, iteratee2) {
                        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
                      }
                      function mean(array) {
                        return baseMean(array, identity);
                      }
                      function meanBy(array, iteratee2) {
                        return baseMean(array, getIteratee(iteratee2, 2));
                      }
                      function min6(array) {
                        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
                      }
                      function minBy(array, iteratee2) {
                        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
                      }
                      var multiply2 = createMathOperation(function(multiplier, multiplicand) {
                        return multiplier * multiplicand;
                      }, 1);
                      var round7 = createRound("round");
                      var subtract = createMathOperation(function(minuend, subtrahend) {
                        return minuend - subtrahend;
                      }, 0);
                      function sum(array) {
                        return array && array.length ? baseSum(array, identity) : 0;
                      }
                      function sumBy(array, iteratee2) {
                        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
                      }
                      lodash.after = after;
                      lodash.ary = ary;
                      lodash.assign = assign;
                      lodash.assignIn = assignIn;
                      lodash.assignInWith = assignInWith;
                      lodash.assignWith = assignWith;
                      lodash.at = at;
                      lodash.before = before;
                      lodash.bind = bind;
                      lodash.bindAll = bindAll;
                      lodash.bindKey = bindKey;
                      lodash.castArray = castArray;
                      lodash.chain = chain;
                      lodash.chunk = chunk;
                      lodash.compact = compact;
                      lodash.concat = concat;
                      lodash.cond = cond;
                      lodash.conforms = conforms;
                      lodash.constant = constant;
                      lodash.countBy = countBy;
                      lodash.create = create;
                      lodash.curry = curry;
                      lodash.curryRight = curryRight;
                      lodash.debounce = debounce;
                      lodash.defaults = defaults;
                      lodash.defaultsDeep = defaultsDeep;
                      lodash.defer = defer;
                      lodash.delay = delay;
                      lodash.difference = difference;
                      lodash.differenceBy = differenceBy;
                      lodash.differenceWith = differenceWith;
                      lodash.drop = drop;
                      lodash.dropRight = dropRight;
                      lodash.dropRightWhile = dropRightWhile;
                      lodash.dropWhile = dropWhile;
                      lodash.fill = fill;
                      lodash.filter = filter;
                      lodash.flatMap = flatMap;
                      lodash.flatMapDeep = flatMapDeep;
                      lodash.flatMapDepth = flatMapDepth;
                      lodash.flatten = flatten;
                      lodash.flattenDeep = flattenDeep;
                      lodash.flattenDepth = flattenDepth;
                      lodash.flip = flip;
                      lodash.flow = flow;
                      lodash.flowRight = flowRight;
                      lodash.fromPairs = fromPairs;
                      lodash.functions = functions;
                      lodash.functionsIn = functionsIn;
                      lodash.groupBy = groupBy;
                      lodash.initial = initial;
                      lodash.intersection = intersection;
                      lodash.intersectionBy = intersectionBy;
                      lodash.intersectionWith = intersectionWith;
                      lodash.invert = invert;
                      lodash.invertBy = invertBy;
                      lodash.invokeMap = invokeMap;
                      lodash.iteratee = iteratee;
                      lodash.keyBy = keyBy2;
                      lodash.keys = keys;
                      lodash.keysIn = keysIn;
                      lodash.map = map2;
                      lodash.mapKeys = mapKeys;
                      lodash.mapValues = mapValues;
                      lodash.matches = matches;
                      lodash.matchesProperty = matchesProperty;
                      lodash.memoize = memoize;
                      lodash.merge = merge2;
                      lodash.mergeWith = mergeWith;
                      lodash.method = method;
                      lodash.methodOf = methodOf;
                      lodash.mixin = mixin;
                      lodash.negate = negate;
                      lodash.nthArg = nthArg;
                      lodash.omit = omit;
                      lodash.omitBy = omitBy;
                      lodash.once = once;
                      lodash.orderBy = orderBy;
                      lodash.over = over;
                      lodash.overArgs = overArgs;
                      lodash.overEvery = overEvery;
                      lodash.overSome = overSome;
                      lodash.partial = partial;
                      lodash.partialRight = partialRight;
                      lodash.partition = partition;
                      lodash.pick = pick;
                      lodash.pickBy = pickBy;
                      lodash.property = property;
                      lodash.propertyOf = propertyOf;
                      lodash.pull = pull;
                      lodash.pullAll = pullAll;
                      lodash.pullAllBy = pullAllBy;
                      lodash.pullAllWith = pullAllWith;
                      lodash.pullAt = pullAt;
                      lodash.range = range;
                      lodash.rangeRight = rangeRight;
                      lodash.rearg = rearg;
                      lodash.reject = reject;
                      lodash.remove = remove;
                      lodash.rest = rest;
                      lodash.reverse = reverse;
                      lodash.sampleSize = sampleSize;
                      lodash.set = set2;
                      lodash.setWith = setWith;
                      lodash.shuffle = shuffle;
                      lodash.slice = slice;
                      lodash.sortBy = sortBy;
                      lodash.sortedUniq = sortedUniq;
                      lodash.sortedUniqBy = sortedUniqBy;
                      lodash.split = split;
                      lodash.spread = spread;
                      lodash.tail = tail;
                      lodash.take = take;
                      lodash.takeRight = takeRight;
                      lodash.takeRightWhile = takeRightWhile;
                      lodash.takeWhile = takeWhile;
                      lodash.tap = tap;
                      lodash.throttle = throttle;
                      lodash.thru = thru;
                      lodash.toArray = toArray2;
                      lodash.toPairs = toPairs;
                      lodash.toPairsIn = toPairsIn;
                      lodash.toPath = toPath;
                      lodash.toPlainObject = toPlainObject;
                      lodash.transform = transform;
                      lodash.unary = unary;
                      lodash.union = union;
                      lodash.unionBy = unionBy;
                      lodash.unionWith = unionWith;
                      lodash.uniq = uniq;
                      lodash.uniqBy = uniqBy;
                      lodash.uniqWith = uniqWith;
                      lodash.unset = unset;
                      lodash.unzip = unzip;
                      lodash.unzipWith = unzipWith;
                      lodash.update = update;
                      lodash.updateWith = updateWith;
                      lodash.values = values;
                      lodash.valuesIn = valuesIn;
                      lodash.without = without;
                      lodash.words = words;
                      lodash.wrap = wrap;
                      lodash.xor = xor;
                      lodash.xorBy = xorBy;
                      lodash.xorWith = xorWith;
                      lodash.zip = zip;
                      lodash.zipObject = zipObject;
                      lodash.zipObjectDeep = zipObjectDeep;
                      lodash.zipWith = zipWith;
                      lodash.entries = toPairs;
                      lodash.entriesIn = toPairsIn;
                      lodash.extend = assignIn;
                      lodash.extendWith = assignInWith;
                      mixin(lodash, lodash);
                      lodash.add = add;
                      lodash.attempt = attempt;
                      lodash.camelCase = camelCase;
                      lodash.capitalize = capitalize;
                      lodash.ceil = ceil;
                      lodash.clamp = clamp;
                      lodash.clone = clone;
                      lodash.cloneDeep = cloneDeep;
                      lodash.cloneDeepWith = cloneDeepWith;
                      lodash.cloneWith = cloneWith;
                      lodash.conformsTo = conformsTo;
                      lodash.deburr = deburr;
                      lodash.defaultTo = defaultTo;
                      lodash.divide = divide;
                      lodash.endsWith = endsWith;
                      lodash.eq = eq;
                      lodash.escape = escape;
                      lodash.escapeRegExp = escapeRegExp;
                      lodash.every = every;
                      lodash.find = find;
                      lodash.findIndex = findIndex;
                      lodash.findKey = findKey;
                      lodash.findLast = findLast;
                      lodash.findLastIndex = findLastIndex;
                      lodash.findLastKey = findLastKey;
                      lodash.floor = floor5;
                      lodash.forEach = forEach;
                      lodash.forEachRight = forEachRight;
                      lodash.forIn = forIn;
                      lodash.forInRight = forInRight;
                      lodash.forOwn = forOwn;
                      lodash.forOwnRight = forOwnRight;
                      lodash.get = get;
                      lodash.gt = gt;
                      lodash.gte = gte;
                      lodash.has = has;
                      lodash.hasIn = hasIn;
                      lodash.head = head;
                      lodash.identity = identity;
                      lodash.includes = includes;
                      lodash.indexOf = indexOf;
                      lodash.inRange = inRange;
                      lodash.invoke = invoke;
                      lodash.isArguments = isArguments;
                      lodash.isArray = isArray;
                      lodash.isArrayBuffer = isArrayBuffer;
                      lodash.isArrayLike = isArrayLike;
                      lodash.isArrayLikeObject = isArrayLikeObject;
                      lodash.isBoolean = isBoolean2;
                      lodash.isBuffer = isBuffer;
                      lodash.isDate = isDate;
                      lodash.isElement = isElement;
                      lodash.isEmpty = isEmpty;
                      lodash.isEqual = isEqual;
                      lodash.isEqualWith = isEqualWith;
                      lodash.isError = isError;
                      lodash.isFinite = isFinite2;
                      lodash.isFunction = isFunction;
                      lodash.isInteger = isInteger2;
                      lodash.isLength = isLength;
                      lodash.isMap = isMap;
                      lodash.isMatch = isMatch;
                      lodash.isMatchWith = isMatchWith;
                      lodash.isNaN = isNaN2;
                      lodash.isNative = isNative;
                      lodash.isNil = isNil;
                      lodash.isNull = isNull2;
                      lodash.isNumber = isNumber;
                      lodash.isObject = isObject2;
                      lodash.isObjectLike = isObjectLike;
                      lodash.isPlainObject = isPlainObject;
                      lodash.isRegExp = isRegExp;
                      lodash.isSafeInteger = isSafeInteger;
                      lodash.isSet = isSet;
                      lodash.isString = isString;
                      lodash.isSymbol = isSymbol;
                      lodash.isTypedArray = isTypedArray;
                      lodash.isUndefined = isUndefined;
                      lodash.isWeakMap = isWeakMap;
                      lodash.isWeakSet = isWeakSet;
                      lodash.join = join;
                      lodash.kebabCase = kebabCase;
                      lodash.last = last;
                      lodash.lastIndexOf = lastIndexOf;
                      lodash.lowerCase = lowerCase;
                      lodash.lowerFirst = lowerFirst;
                      lodash.lt = lt;
                      lodash.lte = lte;
                      lodash.max = max6;
                      lodash.maxBy = maxBy;
                      lodash.mean = mean;
                      lodash.meanBy = meanBy;
                      lodash.min = min6;
                      lodash.minBy = minBy;
                      lodash.stubArray = stubArray;
                      lodash.stubFalse = stubFalse;
                      lodash.stubObject = stubObject;
                      lodash.stubString = stubString;
                      lodash.stubTrue = stubTrue;
                      lodash.multiply = multiply2;
                      lodash.nth = nth;
                      lodash.noConflict = noConflict;
                      lodash.noop = noop;
                      lodash.now = now;
                      lodash.pad = pad;
                      lodash.padEnd = padEnd;
                      lodash.padStart = padStart2;
                      lodash.parseInt = parseInt2;
                      lodash.random = random2;
                      lodash.reduce = reduce;
                      lodash.reduceRight = reduceRight;
                      lodash.repeat = repeat2;
                      lodash.replace = replace;
                      lodash.result = result;
                      lodash.round = round7;
                      lodash.runInContext = runInContext2;
                      lodash.sample = sample;
                      lodash.size = size;
                      lodash.snakeCase = snakeCase;
                      lodash.some = some;
                      lodash.sortedIndex = sortedIndex;
                      lodash.sortedIndexBy = sortedIndexBy;
                      lodash.sortedIndexOf = sortedIndexOf;
                      lodash.sortedLastIndex = sortedLastIndex;
                      lodash.sortedLastIndexBy = sortedLastIndexBy;
                      lodash.sortedLastIndexOf = sortedLastIndexOf;
                      lodash.startCase = startCase;
                      lodash.startsWith = startsWith;
                      lodash.subtract = subtract;
                      lodash.sum = sum;
                      lodash.sumBy = sumBy;
                      lodash.template = template;
                      lodash.times = times;
                      lodash.toFinite = toFinite;
                      lodash.toInteger = toInteger;
                      lodash.toLength = toLength;
                      lodash.toLower = toLower;
                      lodash.toNumber = toNumber;
                      lodash.toSafeInteger = toSafeInteger;
                      lodash.toString = toString2;
                      lodash.toUpper = toUpper;
                      lodash.trim = trim;
                      lodash.trimEnd = trimEnd;
                      lodash.trimStart = trimStart;
                      lodash.truncate = truncate;
                      lodash.unescape = unescape;
                      lodash.uniqueId = uniqueId;
                      lodash.upperCase = upperCase;
                      lodash.upperFirst = upperFirst;
                      lodash.each = forEach;
                      lodash.eachRight = forEachRight;
                      lodash.first = head;
                      mixin(lodash, function() {
                        var source = {};
                        baseForOwn(lodash, function(func, methodName) {
                          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                            source[methodName] = func;
                          }
                        });
                        return source;
                      }(), { "chain": false });
                      lodash.VERSION = VERSION;
                      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
                        lodash[methodName].placeholder = lodash;
                      });
                      arrayEach(["drop", "take"], function(methodName, index) {
                        LazyWrapper.prototype[methodName] = function(n) {
                          n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
                          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                          if (result2.__filtered__) {
                            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
                          } else {
                            result2.__views__.push({
                              "size": nativeMin(n, MAX_ARRAY_LENGTH),
                              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                            });
                          }
                          return result2;
                        };
                        LazyWrapper.prototype[methodName + "Right"] = function(n) {
                          return this.reverse()[methodName](n).reverse();
                        };
                      });
                      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
                        var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
                        LazyWrapper.prototype[methodName] = function(iteratee2) {
                          var result2 = this.clone();
                          result2.__iteratees__.push({
                            "iteratee": getIteratee(iteratee2, 3),
                            "type": type2
                          });
                          result2.__filtered__ = result2.__filtered__ || isFilter;
                          return result2;
                        };
                      });
                      arrayEach(["head", "last"], function(methodName, index) {
                        var takeName = "take" + (index ? "Right" : "");
                        LazyWrapper.prototype[methodName] = function() {
                          return this[takeName](1).value()[0];
                        };
                      });
                      arrayEach(["initial", "tail"], function(methodName, index) {
                        var dropName = "drop" + (index ? "" : "Right");
                        LazyWrapper.prototype[methodName] = function() {
                          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                        };
                      });
                      LazyWrapper.prototype.compact = function() {
                        return this.filter(identity);
                      };
                      LazyWrapper.prototype.find = function(predicate) {
                        return this.filter(predicate).head();
                      };
                      LazyWrapper.prototype.findLast = function(predicate) {
                        return this.reverse().find(predicate);
                      };
                      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                        if (typeof path == "function") {
                          return new LazyWrapper(this);
                        }
                        return this.map(function(value) {
                          return baseInvoke(value, path, args);
                        });
                      });
                      LazyWrapper.prototype.reject = function(predicate) {
                        return this.filter(negate(getIteratee(predicate)));
                      };
                      LazyWrapper.prototype.slice = function(start, end) {
                        start = toInteger(start);
                        var result2 = this;
                        if (result2.__filtered__ && (start > 0 || end < 0)) {
                          return new LazyWrapper(result2);
                        }
                        if (start < 0) {
                          result2 = result2.takeRight(-start);
                        } else if (start) {
                          result2 = result2.drop(start);
                        }
                        if (end !== undefined2) {
                          end = toInteger(end);
                          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
                        }
                        return result2;
                      };
                      LazyWrapper.prototype.takeRightWhile = function(predicate) {
                        return this.reverse().takeWhile(predicate).reverse();
                      };
                      LazyWrapper.prototype.toArray = function() {
                        return this.take(MAX_ARRAY_LENGTH);
                      };
                      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                        if (!lodashFunc) {
                          return;
                        }
                        lodash.prototype[methodName] = function() {
                          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
                          var interceptor = function(value2) {
                            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                            return isTaker && chainAll ? result3[0] : result3;
                          };
                          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                            isLazy = useLazy = false;
                          }
                          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                          if (!retUnwrapped && useLazy) {
                            value = onlyLazy ? value : new LazyWrapper(this);
                            var result2 = func.apply(value, args);
                            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                            return new LodashWrapper(result2, chainAll);
                          }
                          if (isUnwrapped && onlyLazy) {
                            return func.apply(this, args);
                          }
                          result2 = this.thru(interceptor);
                          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
                        };
                      });
                      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
                        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                        lodash.prototype[methodName] = function() {
                          var args = arguments;
                          if (retUnwrapped && !this.__chain__) {
                            var value = this.value();
                            return func.apply(isArray(value) ? value : [], args);
                          }
                          return this[chainName](function(value2) {
                            return func.apply(isArray(value2) ? value2 : [], args);
                          });
                        };
                      });
                      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                        var lodashFunc = lodash[methodName];
                        if (lodashFunc) {
                          var key = lodashFunc.name + "";
                          if (!hasOwnProperty.call(realNames, key)) {
                            realNames[key] = [];
                          }
                          realNames[key].push({ "name": methodName, "func": lodashFunc });
                        }
                      });
                      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
                        "name": "wrapper",
                        "func": undefined2
                      }];
                      LazyWrapper.prototype.clone = lazyClone;
                      LazyWrapper.prototype.reverse = lazyReverse;
                      LazyWrapper.prototype.value = lazyValue;
                      lodash.prototype.at = wrapperAt;
                      lodash.prototype.chain = wrapperChain;
                      lodash.prototype.commit = wrapperCommit;
                      lodash.prototype.next = wrapperNext;
                      lodash.prototype.plant = wrapperPlant;
                      lodash.prototype.reverse = wrapperReverse;
                      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
                      lodash.prototype.first = lodash.prototype.head;
                      if (symIterator) {
                        lodash.prototype[symIterator] = wrapperToIterator;
                      }
                      return lodash;
                    };
                    var _ = runInContext();
                    if (true) {
                      root._ = _;
                      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return _;
                      }.call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined2 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    } else {
                    }
                  }).call(this);
                }
              ),
              /***/
              "./node_modules/math-intrinsics/abs.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/math-intrinsics/abs.js ***!
                  \*********************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Math.abs;
                }
              ),
              /***/
              "./node_modules/math-intrinsics/floor.js": (
                /*!***********************************************!*\
                  !*** ./node_modules/math-intrinsics/floor.js ***!
                  \***********************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Math.floor;
                }
              ),
              /***/
              "./node_modules/math-intrinsics/isNaN.js": (
                /*!***********************************************!*\
                  !*** ./node_modules/math-intrinsics/isNaN.js ***!
                  \***********************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Number.isNaN || function isNaN2(a) {
                    return a !== a;
                  };
                }
              ),
              /***/
              "./node_modules/math-intrinsics/max.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/math-intrinsics/max.js ***!
                  \*********************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Math.max;
                }
              ),
              /***/
              "./node_modules/math-intrinsics/min.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/math-intrinsics/min.js ***!
                  \*********************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Math.min;
                }
              ),
              /***/
              "./node_modules/math-intrinsics/pow.js": (
                /*!*********************************************!*\
                  !*** ./node_modules/math-intrinsics/pow.js ***!
                  \*********************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Math.pow;
                }
              ),
              /***/
              "./node_modules/math-intrinsics/round.js": (
                /*!***********************************************!*\
                  !*** ./node_modules/math-intrinsics/round.js ***!
                  \***********************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = Math.round;
                }
              ),
              /***/
              "./node_modules/math-intrinsics/sign.js": (
                /*!**********************************************!*\
                  !*** ./node_modules/math-intrinsics/sign.js ***!
                  \**********************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var $isNaN = __webpack_require__2(
                    /*! ./isNaN */
                    "./node_modules/math-intrinsics/isNaN.js"
                  );
                  module2.exports = function sign(number) {
                    if ($isNaN(number) || number === 0) {
                      return number;
                    }
                    return number < 0 ? -1 : 1;
                  };
                }
              ),
              /***/
              "./node_modules/object-is/implementation.js": (
                /*!**************************************************!*\
                  !*** ./node_modules/object-is/implementation.js ***!
                  \**************************************************/
                /***/
                (module2) => {
                  "use strict";
                  var numberIsNaN = function(value) {
                    return value !== value;
                  };
                  module2.exports = function is(a, b) {
                    if (a === 0 && b === 0) {
                      return 1 / a === 1 / b;
                    }
                    if (a === b) {
                      return true;
                    }
                    if (numberIsNaN(a) && numberIsNaN(b)) {
                      return true;
                    }
                    return false;
                  };
                }
              ),
              /***/
              "./node_modules/object-is/index.js": (
                /*!*****************************************!*\
                  !*** ./node_modules/object-is/index.js ***!
                  \*****************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var define2 = __webpack_require__2(
                    /*! define-properties */
                    "./node_modules/define-properties/index.js"
                  );
                  var callBind = __webpack_require__2(
                    /*! call-bind */
                    "./node_modules/call-bind/index.js"
                  );
                  var implementation = __webpack_require__2(
                    /*! ./implementation */
                    "./node_modules/object-is/implementation.js"
                  );
                  var getPolyfill = __webpack_require__2(
                    /*! ./polyfill */
                    "./node_modules/object-is/polyfill.js"
                  );
                  var shim = __webpack_require__2(
                    /*! ./shim */
                    "./node_modules/object-is/shim.js"
                  );
                  var polyfill = callBind(getPolyfill(), Object);
                  define2(polyfill, {
                    getPolyfill,
                    implementation,
                    shim
                  });
                  module2.exports = polyfill;
                }
              ),
              /***/
              "./node_modules/object-is/polyfill.js": (
                /*!********************************************!*\
                  !*** ./node_modules/object-is/polyfill.js ***!
                  \********************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var implementation = __webpack_require__2(
                    /*! ./implementation */
                    "./node_modules/object-is/implementation.js"
                  );
                  module2.exports = function getPolyfill() {
                    return typeof Object.is === "function" ? Object.is : implementation;
                  };
                }
              ),
              /***/
              "./node_modules/object-is/shim.js": (
                /*!****************************************!*\
                  !*** ./node_modules/object-is/shim.js ***!
                  \****************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var getPolyfill = __webpack_require__2(
                    /*! ./polyfill */
                    "./node_modules/object-is/polyfill.js"
                  );
                  var define2 = __webpack_require__2(
                    /*! define-properties */
                    "./node_modules/define-properties/index.js"
                  );
                  module2.exports = function shimObjectIs() {
                    var polyfill = getPolyfill();
                    define2(Object, { is: polyfill }, {
                      is: function testObjectIs() {
                        return Object.is !== polyfill;
                      }
                    });
                    return polyfill;
                  };
                }
              ),
              /***/
              "./node_modules/object-keys/implementation.js": (
                /*!****************************************************!*\
                  !*** ./node_modules/object-keys/implementation.js ***!
                  \****************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var keysShim;
                  if (!Object.keys) {
                    var has = Object.prototype.hasOwnProperty;
                    var toStr = Object.prototype.toString;
                    var isArgs = __webpack_require__2(
                      /*! ./isArguments */
                      "./node_modules/object-keys/isArguments.js"
                    );
                    var isEnumerable = Object.prototype.propertyIsEnumerable;
                    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
                    var hasProtoEnumBug = isEnumerable.call(function() {
                    }, "prototype");
                    var dontEnums = [
                      "toString",
                      "toLocaleString",
                      "valueOf",
                      "hasOwnProperty",
                      "isPrototypeOf",
                      "propertyIsEnumerable",
                      "constructor"
                    ];
                    var equalsConstructorPrototype = function(o) {
                      var ctor = o.constructor;
                      return ctor && ctor.prototype === o;
                    };
                    var excludedKeys = {
                      $applicationCache: true,
                      $console: true,
                      $external: true,
                      $frame: true,
                      $frameElement: true,
                      $frames: true,
                      $innerHeight: true,
                      $innerWidth: true,
                      $onmozfullscreenchange: true,
                      $onmozfullscreenerror: true,
                      $outerHeight: true,
                      $outerWidth: true,
                      $pageXOffset: true,
                      $pageYOffset: true,
                      $parent: true,
                      $scrollLeft: true,
                      $scrollTop: true,
                      $scrollX: true,
                      $scrollY: true,
                      $self: true,
                      $webkitIndexedDB: true,
                      $webkitStorageInfo: true,
                      $window: true
                    };
                    var hasAutomationEqualityBug = function() {
                      if (typeof window === "undefined") {
                        return false;
                      }
                      for (var k in window) {
                        try {
                          if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                            try {
                              equalsConstructorPrototype(window[k]);
                            } catch (e) {
                              return true;
                            }
                          }
                        } catch (e) {
                          return true;
                        }
                      }
                      return false;
                    }();
                    var equalsConstructorPrototypeIfNotBuggy = function(o) {
                      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
                        return equalsConstructorPrototype(o);
                      }
                      try {
                        return equalsConstructorPrototype(o);
                      } catch (e) {
                        return false;
                      }
                    };
                    keysShim = function keys(object) {
                      var isObject2 = object !== null && typeof object === "object";
                      var isFunction = toStr.call(object) === "[object Function]";
                      var isArguments = isArgs(object);
                      var isString = isObject2 && toStr.call(object) === "[object String]";
                      var theKeys = [];
                      if (!isObject2 && !isFunction && !isArguments) {
                        throw new TypeError("Object.keys called on a non-object");
                      }
                      var skipProto = hasProtoEnumBug && isFunction;
                      if (isString && object.length > 0 && !has.call(object, 0)) {
                        for (var i = 0; i < object.length; ++i) {
                          theKeys.push(String(i));
                        }
                      }
                      if (isArguments && object.length > 0) {
                        for (var j = 0; j < object.length; ++j) {
                          theKeys.push(String(j));
                        }
                      } else {
                        for (var name in object) {
                          if (!(skipProto && name === "prototype") && has.call(object, name)) {
                            theKeys.push(String(name));
                          }
                        }
                      }
                      if (hasDontEnumBug) {
                        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                        for (var k = 0; k < dontEnums.length; ++k) {
                          if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
                            theKeys.push(dontEnums[k]);
                          }
                        }
                      }
                      return theKeys;
                    };
                  }
                  module2.exports = keysShim;
                }
              ),
              /***/
              "./node_modules/object-keys/index.js": (
                /*!*******************************************!*\
                  !*** ./node_modules/object-keys/index.js ***!
                  \*******************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var slice = Array.prototype.slice;
                  var isArgs = __webpack_require__2(
                    /*! ./isArguments */
                    "./node_modules/object-keys/isArguments.js"
                  );
                  var origKeys = Object.keys;
                  var keysShim = origKeys ? function keys(o) {
                    return origKeys(o);
                  } : __webpack_require__2(
                    /*! ./implementation */
                    "./node_modules/object-keys/implementation.js"
                  );
                  var originalKeys = Object.keys;
                  keysShim.shim = function shimObjectKeys() {
                    if (Object.keys) {
                      var keysWorksWithArguments = function() {
                        var args = Object.keys(arguments);
                        return args && args.length === arguments.length;
                      }(1, 2);
                      if (!keysWorksWithArguments) {
                        Object.keys = function keys(object) {
                          if (isArgs(object)) {
                            return originalKeys(slice.call(object));
                          }
                          return originalKeys(object);
                        };
                      }
                    } else {
                      Object.keys = keysShim;
                    }
                    return Object.keys || keysShim;
                  };
                  module2.exports = keysShim;
                }
              ),
              /***/
              "./node_modules/object-keys/isArguments.js": (
                /*!*************************************************!*\
                  !*** ./node_modules/object-keys/isArguments.js ***!
                  \*************************************************/
                /***/
                (module2) => {
                  "use strict";
                  var toStr = Object.prototype.toString;
                  module2.exports = function isArguments(value) {
                    var str2 = toStr.call(value);
                    var isArgs = str2 === "[object Arguments]";
                    if (!isArgs) {
                      isArgs = str2 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
                    }
                    return isArgs;
                  };
                }
              ),
              /***/
              "./node_modules/object.assign/implementation.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/object.assign/implementation.js ***!
                  \******************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var objectKeys = __webpack_require__2(
                    /*! object-keys */
                    "./node_modules/object-keys/index.js"
                  );
                  var hasSymbols = __webpack_require__2(
                    /*! has-symbols/shams */
                    "./node_modules/has-symbols/shams.js"
                  )();
                  var callBound = __webpack_require__2(
                    /*! call-bound */
                    "./node_modules/call-bound/index.js"
                  );
                  var $Object = __webpack_require__2(
                    /*! es-object-atoms */
                    "./node_modules/es-object-atoms/index.js"
                  );
                  var $push = callBound("Array.prototype.push");
                  var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
                  var originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null;
                  module2.exports = function assign(target, source1) {
                    if (target == null) {
                      throw new TypeError("target must be an object");
                    }
                    var to = $Object(target);
                    if (arguments.length === 1) {
                      return to;
                    }
                    for (var s = 1; s < arguments.length; ++s) {
                      var from = $Object(arguments[s]);
                      var keys = objectKeys(from);
                      var getSymbols = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);
                      if (getSymbols) {
                        var syms = getSymbols(from);
                        for (var j = 0; j < syms.length; ++j) {
                          var key = syms[j];
                          if ($propIsEnumerable(from, key)) {
                            $push(keys, key);
                          }
                        }
                      }
                      for (var i = 0; i < keys.length; ++i) {
                        var nextKey = keys[i];
                        if ($propIsEnumerable(from, nextKey)) {
                          var propValue = from[nextKey];
                          to[nextKey] = propValue;
                        }
                      }
                    }
                    return to;
                  };
                }
              ),
              /***/
              "./node_modules/object.assign/polyfill.js": (
                /*!************************************************!*\
                  !*** ./node_modules/object.assign/polyfill.js ***!
                  \************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var implementation = __webpack_require__2(
                    /*! ./implementation */
                    "./node_modules/object.assign/implementation.js"
                  );
                  var lacksProperEnumerationOrder = function() {
                    if (!Object.assign) {
                      return false;
                    }
                    var str2 = "abcdefghijklmnopqrst";
                    var letters = str2.split("");
                    var map2 = {};
                    for (var i = 0; i < letters.length; ++i) {
                      map2[letters[i]] = letters[i];
                    }
                    var obj = Object.assign({}, map2);
                    var actual = "";
                    for (var k in obj) {
                      actual += k;
                    }
                    return str2 !== actual;
                  };
                  var assignHasPendingExceptions = function() {
                    if (!Object.assign || !Object.preventExtensions) {
                      return false;
                    }
                    var thrower = Object.preventExtensions({ 1: 2 });
                    try {
                      Object.assign(thrower, "xy");
                    } catch (e) {
                      return thrower[1] === "y";
                    }
                    return false;
                  };
                  module2.exports = function getPolyfill() {
                    if (!Object.assign) {
                      return implementation;
                    }
                    if (lacksProperEnumerationOrder()) {
                      return implementation;
                    }
                    if (assignHasPendingExceptions()) {
                      return implementation;
                    }
                    return Object.assign;
                  };
                }
              ),
              /***/
              "./node_modules/possible-typed-array-names/index.js": (
                /*!**********************************************************!*\
                  !*** ./node_modules/possible-typed-array-names/index.js ***!
                  \**********************************************************/
                /***/
                (module2) => {
                  "use strict";
                  module2.exports = [
                    "Float16Array",
                    "Float32Array",
                    "Float64Array",
                    "Int8Array",
                    "Int16Array",
                    "Int32Array",
                    "Uint8Array",
                    "Uint8ClampedArray",
                    "Uint16Array",
                    "Uint32Array",
                    "BigInt64Array",
                    "BigUint64Array"
                  ];
                }
              ),
              /***/
              "./node_modules/process/browser.js": (
                /*!*****************************************!*\
                  !*** ./node_modules/process/browser.js ***!
                  \*****************************************/
                /***/
                (module2) => {
                  var process2 = module2.exports = {};
                  var cachedSetTimeout;
                  var cachedClearTimeout;
                  function defaultSetTimout() {
                    throw new Error("setTimeout has not been defined");
                  }
                  function defaultClearTimeout() {
                    throw new Error("clearTimeout has not been defined");
                  }
                  (function() {
                    try {
                      if (typeof setTimeout === "function") {
                        cachedSetTimeout = setTimeout;
                      } else {
                        cachedSetTimeout = defaultSetTimout;
                      }
                    } catch (e) {
                      cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                      if (typeof clearTimeout === "function") {
                        cachedClearTimeout = clearTimeout;
                      } else {
                        cachedClearTimeout = defaultClearTimeout;
                      }
                    } catch (e) {
                      cachedClearTimeout = defaultClearTimeout;
                    }
                  })();
                  function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                      return setTimeout(fun, 0);
                    }
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                      cachedSetTimeout = setTimeout;
                      return setTimeout(fun, 0);
                    }
                    try {
                      return cachedSetTimeout(fun, 0);
                    } catch (e) {
                      try {
                        return cachedSetTimeout.call(null, fun, 0);
                      } catch (e2) {
                        return cachedSetTimeout.call(this, fun, 0);
                      }
                    }
                  }
                  function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                      return clearTimeout(marker);
                    }
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                      cachedClearTimeout = clearTimeout;
                      return clearTimeout(marker);
                    }
                    try {
                      return cachedClearTimeout(marker);
                    } catch (e) {
                      try {
                        return cachedClearTimeout.call(null, marker);
                      } catch (e2) {
                        return cachedClearTimeout.call(this, marker);
                      }
                    }
                  }
                  var queue = [];
                  var draining = false;
                  var currentQueue;
                  var queueIndex = -1;
                  function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                      return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                      queue = currentQueue.concat(queue);
                    } else {
                      queueIndex = -1;
                    }
                    if (queue.length) {
                      drainQueue();
                    }
                  }
                  function drainQueue() {
                    if (draining) {
                      return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while (len) {
                      currentQueue = queue;
                      queue = [];
                      while (++queueIndex < len) {
                        if (currentQueue) {
                          currentQueue[queueIndex].run();
                        }
                      }
                      queueIndex = -1;
                      len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                  }
                  process2.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                      for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                      }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                      runTimeout(drainQueue);
                    }
                  };
                  function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                  }
                  Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                  };
                  process2.title = "browser";
                  process2.browser = true;
                  process2.env = {};
                  process2.argv = [];
                  process2.version = "";
                  process2.versions = {};
                  function noop() {
                  }
                  process2.on = noop;
                  process2.addListener = noop;
                  process2.once = noop;
                  process2.off = noop;
                  process2.removeListener = noop;
                  process2.removeAllListeners = noop;
                  process2.emit = noop;
                  process2.prependListener = noop;
                  process2.prependOnceListener = noop;
                  process2.listeners = function(name) {
                    return [];
                  };
                  process2.binding = function(name) {
                    throw new Error("process.binding is not supported");
                  };
                  process2.cwd = function() {
                    return "/";
                  };
                  process2.chdir = function(dir) {
                    throw new Error("process.chdir is not supported");
                  };
                  process2.umask = function() {
                    return 0;
                  };
                }
              ),
              /***/
              "./node_modules/safe-regex-test/index.js": (
                /*!***********************************************!*\
                  !*** ./node_modules/safe-regex-test/index.js ***!
                  \***********************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var callBound = __webpack_require__2(
                    /*! call-bound */
                    "./node_modules/call-bound/index.js"
                  );
                  var isRegex = __webpack_require__2(
                    /*! is-regex */
                    "./node_modules/is-regex/index.js"
                  );
                  var $exec = callBound("RegExp.prototype.exec");
                  var $TypeError = __webpack_require__2(
                    /*! es-errors/type */
                    "./node_modules/es-errors/type.js"
                  );
                  module2.exports = function regexTester(regex) {
                    if (!isRegex(regex)) {
                      throw new $TypeError("`regex` must be a RegExp");
                    }
                    return function test(s) {
                      return $exec(regex, s) !== null;
                    };
                  };
                }
              ),
              /***/
              "./node_modules/set-function-length/index.js": (
                /*!***************************************************!*\
                  !*** ./node_modules/set-function-length/index.js ***!
                  \***************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var GetIntrinsic = __webpack_require__2(
                    /*! get-intrinsic */
                    "./node_modules/get-intrinsic/index.js"
                  );
                  var define2 = __webpack_require__2(
                    /*! define-data-property */
                    "./node_modules/define-data-property/index.js"
                  );
                  var hasDescriptors = __webpack_require__2(
                    /*! has-property-descriptors */
                    "./node_modules/has-property-descriptors/index.js"
                  )();
                  var gOPD = __webpack_require__2(
                    /*! gopd */
                    "./node_modules/gopd/index.js"
                  );
                  var $TypeError = __webpack_require__2(
                    /*! es-errors/type */
                    "./node_modules/es-errors/type.js"
                  );
                  var $floor = GetIntrinsic("%Math.floor%");
                  module2.exports = function setFunctionLength(fn, length) {
                    if (typeof fn !== "function") {
                      throw new $TypeError("`fn` is not a function");
                    }
                    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
                      throw new $TypeError("`length` must be a positive 32-bit integer");
                    }
                    var loose = arguments.length > 2 && !!arguments[2];
                    var functionLengthIsConfigurable = true;
                    var functionLengthIsWritable = true;
                    if ("length" in fn && gOPD) {
                      var desc = gOPD(fn, "length");
                      if (desc && !desc.configurable) {
                        functionLengthIsConfigurable = false;
                      }
                      if (desc && !desc.writable) {
                        functionLengthIsWritable = false;
                      }
                    }
                    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
                      if (hasDescriptors) {
                        define2(
                          /** @type {Parameters<define>[0]} */
                          fn,
                          "length",
                          length,
                          true,
                          true
                        );
                      } else {
                        define2(
                          /** @type {Parameters<define>[0]} */
                          fn,
                          "length",
                          length
                        );
                      }
                    }
                    return fn;
                  };
                }
              ),
              /***/
              "./node_modules/util/support/isBufferBrowser.js": (
                /*!******************************************************!*\
                  !*** ./node_modules/util/support/isBufferBrowser.js ***!
                  \******************************************************/
                /***/
                (module2) => {
                  module2.exports = function isBuffer(arg) {
                    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
                  };
                }
              ),
              /***/
              "./node_modules/util/support/types.js": (
                /*!********************************************!*\
                  !*** ./node_modules/util/support/types.js ***!
                  \********************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  var isArgumentsObject = __webpack_require__2(
                    /*! is-arguments */
                    "./node_modules/is-arguments/index.js"
                  );
                  var isGeneratorFunction = __webpack_require__2(
                    /*! is-generator-function */
                    "./node_modules/is-generator-function/index.js"
                  );
                  var whichTypedArray = __webpack_require__2(
                    /*! which-typed-array */
                    "./node_modules/which-typed-array/index.js"
                  );
                  var isTypedArray = __webpack_require__2(
                    /*! is-typed-array */
                    "./node_modules/is-typed-array/index.js"
                  );
                  function uncurryThis(f) {
                    return f.call.bind(f);
                  }
                  var BigIntSupported = typeof BigInt !== "undefined";
                  var SymbolSupported = typeof Symbol !== "undefined";
                  var ObjectToString = uncurryThis(Object.prototype.toString);
                  var numberValue = uncurryThis(Number.prototype.valueOf);
                  var stringValue = uncurryThis(String.prototype.valueOf);
                  var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                  if (BigIntSupported) {
                    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                  }
                  if (SymbolSupported) {
                    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                  }
                  function checkBoxedPrimitive(value, prototypeValueOf) {
                    if (typeof value !== "object") {
                      return false;
                    }
                    try {
                      prototypeValueOf(value);
                      return true;
                    } catch (e) {
                      return false;
                    }
                  }
                  exports2.isArgumentsObject = isArgumentsObject;
                  exports2.isGeneratorFunction = isGeneratorFunction;
                  exports2.isTypedArray = isTypedArray;
                  function isPromise(input) {
                    return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
                  }
                  exports2.isPromise = isPromise;
                  function isArrayBufferView(value) {
                    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
                      return ArrayBuffer.isView(value);
                    }
                    return isTypedArray(value) || isDataView(value);
                  }
                  exports2.isArrayBufferView = isArrayBufferView;
                  function isUint8Array(value) {
                    return whichTypedArray(value) === "Uint8Array";
                  }
                  exports2.isUint8Array = isUint8Array;
                  function isUint8ClampedArray(value) {
                    return whichTypedArray(value) === "Uint8ClampedArray";
                  }
                  exports2.isUint8ClampedArray = isUint8ClampedArray;
                  function isUint16Array(value) {
                    return whichTypedArray(value) === "Uint16Array";
                  }
                  exports2.isUint16Array = isUint16Array;
                  function isUint32Array(value) {
                    return whichTypedArray(value) === "Uint32Array";
                  }
                  exports2.isUint32Array = isUint32Array;
                  function isInt8Array(value) {
                    return whichTypedArray(value) === "Int8Array";
                  }
                  exports2.isInt8Array = isInt8Array;
                  function isInt16Array(value) {
                    return whichTypedArray(value) === "Int16Array";
                  }
                  exports2.isInt16Array = isInt16Array;
                  function isInt32Array(value) {
                    return whichTypedArray(value) === "Int32Array";
                  }
                  exports2.isInt32Array = isInt32Array;
                  function isFloat32Array(value) {
                    return whichTypedArray(value) === "Float32Array";
                  }
                  exports2.isFloat32Array = isFloat32Array;
                  function isFloat64Array(value) {
                    return whichTypedArray(value) === "Float64Array";
                  }
                  exports2.isFloat64Array = isFloat64Array;
                  function isBigInt64Array(value) {
                    return whichTypedArray(value) === "BigInt64Array";
                  }
                  exports2.isBigInt64Array = isBigInt64Array;
                  function isBigUint64Array(value) {
                    return whichTypedArray(value) === "BigUint64Array";
                  }
                  exports2.isBigUint64Array = isBigUint64Array;
                  function isMapToString(value) {
                    return ObjectToString(value) === "[object Map]";
                  }
                  isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
                  function isMap(value) {
                    if (typeof Map === "undefined") {
                      return false;
                    }
                    return isMapToString.working ? isMapToString(value) : value instanceof Map;
                  }
                  exports2.isMap = isMap;
                  function isSetToString(value) {
                    return ObjectToString(value) === "[object Set]";
                  }
                  isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
                  function isSet(value) {
                    if (typeof Set === "undefined") {
                      return false;
                    }
                    return isSetToString.working ? isSetToString(value) : value instanceof Set;
                  }
                  exports2.isSet = isSet;
                  function isWeakMapToString(value) {
                    return ObjectToString(value) === "[object WeakMap]";
                  }
                  isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
                  function isWeakMap(value) {
                    if (typeof WeakMap === "undefined") {
                      return false;
                    }
                    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
                  }
                  exports2.isWeakMap = isWeakMap;
                  function isWeakSetToString(value) {
                    return ObjectToString(value) === "[object WeakSet]";
                  }
                  isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
                  function isWeakSet(value) {
                    return isWeakSetToString(value);
                  }
                  exports2.isWeakSet = isWeakSet;
                  function isArrayBufferToString(value) {
                    return ObjectToString(value) === "[object ArrayBuffer]";
                  }
                  isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
                  function isArrayBuffer(value) {
                    if (typeof ArrayBuffer === "undefined") {
                      return false;
                    }
                    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
                  }
                  exports2.isArrayBuffer = isArrayBuffer;
                  function isDataViewToString(value) {
                    return ObjectToString(value) === "[object DataView]";
                  }
                  isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                  function isDataView(value) {
                    if (typeof DataView === "undefined") {
                      return false;
                    }
                    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
                  }
                  exports2.isDataView = isDataView;
                  var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
                  function isSharedArrayBufferToString(value) {
                    return ObjectToString(value) === "[object SharedArrayBuffer]";
                  }
                  function isSharedArrayBuffer(value) {
                    if (typeof SharedArrayBufferCopy === "undefined") {
                      return false;
                    }
                    if (typeof isSharedArrayBufferToString.working === "undefined") {
                      isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                    }
                    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
                  }
                  exports2.isSharedArrayBuffer = isSharedArrayBuffer;
                  function isAsyncFunction(value) {
                    return ObjectToString(value) === "[object AsyncFunction]";
                  }
                  exports2.isAsyncFunction = isAsyncFunction;
                  function isMapIterator(value) {
                    return ObjectToString(value) === "[object Map Iterator]";
                  }
                  exports2.isMapIterator = isMapIterator;
                  function isSetIterator(value) {
                    return ObjectToString(value) === "[object Set Iterator]";
                  }
                  exports2.isSetIterator = isSetIterator;
                  function isGeneratorObject(value) {
                    return ObjectToString(value) === "[object Generator]";
                  }
                  exports2.isGeneratorObject = isGeneratorObject;
                  function isWebAssemblyCompiledModule(value) {
                    return ObjectToString(value) === "[object WebAssembly.Module]";
                  }
                  exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                  function isNumberObject(value) {
                    return checkBoxedPrimitive(value, numberValue);
                  }
                  exports2.isNumberObject = isNumberObject;
                  function isStringObject(value) {
                    return checkBoxedPrimitive(value, stringValue);
                  }
                  exports2.isStringObject = isStringObject;
                  function isBooleanObject(value) {
                    return checkBoxedPrimitive(value, booleanValue);
                  }
                  exports2.isBooleanObject = isBooleanObject;
                  function isBigIntObject(value) {
                    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                  }
                  exports2.isBigIntObject = isBigIntObject;
                  function isSymbolObject(value) {
                    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                  }
                  exports2.isSymbolObject = isSymbolObject;
                  function isBoxedPrimitive(value) {
                    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                  }
                  exports2.isBoxedPrimitive = isBoxedPrimitive;
                  function isAnyArrayBuffer(value) {
                    return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                  }
                  exports2.isAnyArrayBuffer = isAnyArrayBuffer;
                  ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
                    Object.defineProperty(exports2, method, {
                      enumerable: false,
                      value: function() {
                        throw new Error(method + " is not supported in userland");
                      }
                    });
                  });
                }
              ),
              /***/
              "./node_modules/util/util.js": (
                /*!***********************************!*\
                  !*** ./node_modules/util/util.js ***!
                  \***********************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  var process2 = __webpack_require__2(
                    /*! process/browser */
                    "./node_modules/process/browser.js"
                  );
                  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
                    var keys = Object.keys(obj);
                    var descriptors = {};
                    for (var i = 0; i < keys.length; i++) {
                      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                    }
                    return descriptors;
                  };
                  var formatRegExp = /%[sdj%]/g;
                  exports2.format = function(f) {
                    if (!isString(f)) {
                      var objects = [];
                      for (var i = 0; i < arguments.length; i++) {
                        objects.push(inspect(arguments[i]));
                      }
                      return objects.join(" ");
                    }
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str2 = String(f).replace(formatRegExp, function(x2) {
                      if (x2 === "%%") return "%";
                      if (i >= len) return x2;
                      switch (x2) {
                        case "%s":
                          return String(args[i++]);
                        case "%d":
                          return Number(args[i++]);
                        case "%j":
                          try {
                            return JSON.stringify(args[i++]);
                          } catch (_) {
                            return "[Circular]";
                          }
                        default:
                          return x2;
                      }
                    });
                    for (var x = args[i]; i < len; x = args[++i]) {
                      if (isNull2(x) || !isObject2(x)) {
                        str2 += " " + x;
                      } else {
                        str2 += " " + inspect(x);
                      }
                    }
                    return str2;
                  };
                  exports2.deprecate = function(fn, msg) {
                    if (typeof process2 !== "undefined" && process2.noDeprecation === true) {
                      return fn;
                    }
                    if (typeof process2 === "undefined") {
                      return function() {
                        return exports2.deprecate(fn, msg).apply(this, arguments);
                      };
                    }
                    var warned = false;
                    function deprecated() {
                      if (!warned) {
                        if (process2.throwDeprecation) {
                          throw new Error(msg);
                        } else if (process2.traceDeprecation) {
                          console.trace(msg);
                        } else {
                          console.error(msg);
                        }
                        warned = true;
                      }
                      return fn.apply(this, arguments);
                    }
                    return deprecated;
                  };
                  var debugs = {};
                  var debugEnvRegex = /^$/;
                  if (process2.env.NODE_DEBUG) {
                    var debugEnv = process2.env.NODE_DEBUG;
                    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
                    debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
                  }
                  exports2.debuglog = function(set2) {
                    set2 = set2.toUpperCase();
                    if (!debugs[set2]) {
                      if (debugEnvRegex.test(set2)) {
                        var pid = process2.pid;
                        debugs[set2] = function() {
                          var msg = exports2.format.apply(exports2, arguments);
                          console.error("%s %d: %s", set2, pid, msg);
                        };
                      } else {
                        debugs[set2] = function() {
                        };
                      }
                    }
                    return debugs[set2];
                  };
                  function inspect(obj, opts) {
                    var ctx = {
                      seen: [],
                      stylize: stylizeNoColor
                    };
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean2(opts)) {
                      ctx.showHidden = opts;
                    } else if (opts) {
                      exports2._extend(ctx, opts);
                    }
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                  }
                  exports2.inspect = inspect;
                  inspect.colors = {
                    "bold": [1, 22],
                    "italic": [3, 23],
                    "underline": [4, 24],
                    "inverse": [7, 27],
                    "white": [37, 39],
                    "grey": [90, 39],
                    "black": [30, 39],
                    "blue": [34, 39],
                    "cyan": [36, 39],
                    "green": [32, 39],
                    "magenta": [35, 39],
                    "red": [31, 39],
                    "yellow": [33, 39]
                  };
                  inspect.styles = {
                    "special": "cyan",
                    "number": "yellow",
                    "boolean": "yellow",
                    "undefined": "grey",
                    "null": "bold",
                    "string": "green",
                    "date": "magenta",
                    // "name": intentionally not styling
                    "regexp": "red"
                  };
                  function stylizeWithColor(str2, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                      return "\x1B[" + inspect.colors[style][0] + "m" + str2 + "\x1B[" + inspect.colors[style][1] + "m";
                    } else {
                      return str2;
                    }
                  }
                  function stylizeNoColor(str2, styleType) {
                    return str2;
                  }
                  function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                      hash[val] = true;
                    });
                    return hash;
                  }
                  function formatValue(ctx, value, recurseTimes) {
                    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                    value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                      var ret = value.inspect(recurseTimes, ctx);
                      if (!isString(ret)) {
                        ret = formatValue(ctx, ret, recurseTimes);
                      }
                      return ret;
                    }
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                      return primitive;
                    }
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden) {
                      keys = Object.getOwnPropertyNames(value);
                    }
                    if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                      return formatError2(value);
                    }
                    if (keys.length === 0) {
                      if (isFunction(value)) {
                        var name = value.name ? ": " + value.name : "";
                        return ctx.stylize("[Function" + name + "]", "special");
                      }
                      if (isRegExp(value)) {
                        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                      }
                      if (isDate(value)) {
                        return ctx.stylize(Date.prototype.toString.call(value), "date");
                      }
                      if (isError(value)) {
                        return formatError2(value);
                      }
                    }
                    var base = "", array = false, braces = ["{", "}"];
                    if (isArray(value)) {
                      array = true;
                      braces = ["[", "]"];
                    }
                    if (isFunction(value)) {
                      var n = value.name ? ": " + value.name : "";
                      base = " [Function" + n + "]";
                    }
                    if (isRegExp(value)) {
                      base = " " + RegExp.prototype.toString.call(value);
                    }
                    if (isDate(value)) {
                      base = " " + Date.prototype.toUTCString.call(value);
                    }
                    if (isError(value)) {
                      base = " " + formatError2(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                      return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                      if (isRegExp(value)) {
                        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                      } else {
                        return ctx.stylize("[Object]", "special");
                      }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                      output = keys.map(function(key) {
                        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                      });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                  }
                  function formatPrimitive(ctx, value) {
                    if (isUndefined(value))
                      return ctx.stylize("undefined", "undefined");
                    if (isString(value)) {
                      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                      return ctx.stylize(simple, "string");
                    }
                    if (isNumber(value))
                      return ctx.stylize("" + value, "number");
                    if (isBoolean2(value))
                      return ctx.stylize("" + value, "boolean");
                    if (isNull2(value))
                      return ctx.stylize("null", "null");
                  }
                  function formatError2(value) {
                    return "[" + Error.prototype.toString.call(value) + "]";
                  }
                  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for (var i = 0, l = value.length; i < l; ++i) {
                      if (hasOwnProperty(value, String(i))) {
                        output.push(formatProperty(
                          ctx,
                          value,
                          recurseTimes,
                          visibleKeys,
                          String(i),
                          true
                        ));
                      } else {
                        output.push("");
                      }
                    }
                    keys.forEach(function(key) {
                      if (!key.match(/^\d+$/)) {
                        output.push(formatProperty(
                          ctx,
                          value,
                          recurseTimes,
                          visibleKeys,
                          key,
                          true
                        ));
                      }
                    });
                    return output;
                  }
                  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str2, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
                    if (desc.get) {
                      if (desc.set) {
                        str2 = ctx.stylize("[Getter/Setter]", "special");
                      } else {
                        str2 = ctx.stylize("[Getter]", "special");
                      }
                    } else {
                      if (desc.set) {
                        str2 = ctx.stylize("[Setter]", "special");
                      }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                      name = "[" + key + "]";
                    }
                    if (!str2) {
                      if (ctx.seen.indexOf(desc.value) < 0) {
                        if (isNull2(recurseTimes)) {
                          str2 = formatValue(ctx, desc.value, null);
                        } else {
                          str2 = formatValue(ctx, desc.value, recurseTimes - 1);
                        }
                        if (str2.indexOf("\n") > -1) {
                          if (array) {
                            str2 = str2.split("\n").map(function(line) {
                              return "  " + line;
                            }).join("\n").slice(2);
                          } else {
                            str2 = "\n" + str2.split("\n").map(function(line) {
                              return "   " + line;
                            }).join("\n");
                          }
                        }
                      } else {
                        str2 = ctx.stylize("[Circular]", "special");
                      }
                    }
                    if (isUndefined(name)) {
                      if (array && key.match(/^\d+$/)) {
                        return str2;
                      }
                      name = JSON.stringify("" + key);
                      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                        name = name.slice(1, -1);
                        name = ctx.stylize(name, "name");
                      } else {
                        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                        name = ctx.stylize(name, "string");
                      }
                    }
                    return name + ": " + str2;
                  }
                  function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                      numLinesEst++;
                      if (cur.indexOf("\n") >= 0) numLinesEst++;
                      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                    }, 0);
                    if (length > 60) {
                      return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                    }
                    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
                  }
                  exports2.types = __webpack_require__2(
                    /*! ./support/types */
                    "./node_modules/util/support/types.js"
                  );
                  function isArray(ar) {
                    return Array.isArray(ar);
                  }
                  exports2.isArray = isArray;
                  function isBoolean2(arg) {
                    return typeof arg === "boolean";
                  }
                  exports2.isBoolean = isBoolean2;
                  function isNull2(arg) {
                    return arg === null;
                  }
                  exports2.isNull = isNull2;
                  function isNullOrUndefined(arg) {
                    return arg == null;
                  }
                  exports2.isNullOrUndefined = isNullOrUndefined;
                  function isNumber(arg) {
                    return typeof arg === "number";
                  }
                  exports2.isNumber = isNumber;
                  function isString(arg) {
                    return typeof arg === "string";
                  }
                  exports2.isString = isString;
                  function isSymbol(arg) {
                    return typeof arg === "symbol";
                  }
                  exports2.isSymbol = isSymbol;
                  function isUndefined(arg) {
                    return arg === void 0;
                  }
                  exports2.isUndefined = isUndefined;
                  function isRegExp(re) {
                    return isObject2(re) && objectToString(re) === "[object RegExp]";
                  }
                  exports2.isRegExp = isRegExp;
                  exports2.types.isRegExp = isRegExp;
                  function isObject2(arg) {
                    return typeof arg === "object" && arg !== null;
                  }
                  exports2.isObject = isObject2;
                  function isDate(d) {
                    return isObject2(d) && objectToString(d) === "[object Date]";
                  }
                  exports2.isDate = isDate;
                  exports2.types.isDate = isDate;
                  function isError(e) {
                    return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
                  }
                  exports2.isError = isError;
                  exports2.types.isNativeError = isError;
                  function isFunction(arg) {
                    return typeof arg === "function";
                  }
                  exports2.isFunction = isFunction;
                  function isPrimitive(arg) {
                    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
                    typeof arg === "undefined";
                  }
                  exports2.isPrimitive = isPrimitive;
                  exports2.isBuffer = __webpack_require__2(
                    /*! ./support/isBuffer */
                    "./node_modules/util/support/isBufferBrowser.js"
                  );
                  function objectToString(o) {
                    return Object.prototype.toString.call(o);
                  }
                  function pad(n) {
                    return n < 10 ? "0" + n.toString(10) : n.toString(10);
                  }
                  var months = [
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec"
                  ];
                  function timestamp2() {
                    var d = /* @__PURE__ */ new Date();
                    var time = [
                      pad(d.getHours()),
                      pad(d.getMinutes()),
                      pad(d.getSeconds())
                    ].join(":");
                    return [d.getDate(), months[d.getMonth()], time].join(" ");
                  }
                  exports2.log = function() {
                    console.log("%s - %s", timestamp2(), exports2.format.apply(exports2, arguments));
                  };
                  exports2.inherits = __webpack_require__2(
                    /*! inherits */
                    "./node_modules/inherits/inherits_browser.js"
                  );
                  exports2._extend = function(origin, add) {
                    if (!add || !isObject2(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while (i--) {
                      origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                  };
                  function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                  }
                  var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
                  exports2.promisify = function promisify(original) {
                    if (typeof original !== "function")
                      throw new TypeError('The "original" argument must be of type Function');
                    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                      var fn = original[kCustomPromisifiedSymbol];
                      if (typeof fn !== "function") {
                        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                      }
                      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: false,
                        writable: false,
                        configurable: true
                      });
                      return fn;
                    }
                    function fn() {
                      var promiseResolve, promiseReject;
                      var promise = new Promise(function(resolve, reject) {
                        promiseResolve = resolve;
                        promiseReject = reject;
                      });
                      var args = [];
                      for (var i = 0; i < arguments.length; i++) {
                        args.push(arguments[i]);
                      }
                      args.push(function(err, value) {
                        if (err) {
                          promiseReject(err);
                        } else {
                          promiseResolve(value);
                        }
                      });
                      try {
                        original.apply(this, args);
                      } catch (err) {
                        promiseReject(err);
                      }
                      return promise;
                    }
                    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                      value: fn,
                      enumerable: false,
                      writable: false,
                      configurable: true
                    });
                    return Object.defineProperties(
                      fn,
                      getOwnPropertyDescriptors(original)
                    );
                  };
                  exports2.promisify.custom = kCustomPromisifiedSymbol;
                  function callbackifyOnRejected(reason, cb) {
                    if (!reason) {
                      var newReason = new Error("Promise was rejected with a falsy value");
                      newReason.reason = reason;
                      reason = newReason;
                    }
                    return cb(reason);
                  }
                  function callbackify(original) {
                    if (typeof original !== "function") {
                      throw new TypeError('The "original" argument must be of type Function');
                    }
                    function callbackified() {
                      var args = [];
                      for (var i = 0; i < arguments.length; i++) {
                        args.push(arguments[i]);
                      }
                      var maybeCb = args.pop();
                      if (typeof maybeCb !== "function") {
                        throw new TypeError("The last argument must be of type Function");
                      }
                      var self2 = this;
                      var cb = function() {
                        return maybeCb.apply(self2, arguments);
                      };
                      original.apply(this, args).then(
                        function(ret) {
                          process2.nextTick(cb.bind(null, null, ret));
                        },
                        function(rej) {
                          process2.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                        }
                      );
                    }
                    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                    Object.defineProperties(
                      callbackified,
                      getOwnPropertyDescriptors(original)
                    );
                    return callbackified;
                  }
                  exports2.callbackify = callbackify;
                }
              ),
              /***/
              "./node_modules/which-typed-array/index.js": (
                /*!*************************************************!*\
                  !*** ./node_modules/which-typed-array/index.js ***!
                  \*************************************************/
                /***/
                (module2, __unused_webpack_exports, __webpack_require__2) => {
                  "use strict";
                  var forEach = __webpack_require__2(
                    /*! for-each */
                    "./node_modules/for-each/index.js"
                  );
                  var availableTypedArrays = __webpack_require__2(
                    /*! available-typed-arrays */
                    "./node_modules/available-typed-arrays/index.js"
                  );
                  var callBind = __webpack_require__2(
                    /*! call-bind */
                    "./node_modules/call-bind/index.js"
                  );
                  var callBound = __webpack_require__2(
                    /*! call-bound */
                    "./node_modules/call-bound/index.js"
                  );
                  var gOPD = __webpack_require__2(
                    /*! gopd */
                    "./node_modules/gopd/index.js"
                  );
                  var getProto = __webpack_require__2(
                    /*! get-proto */
                    "./node_modules/get-proto/index.js"
                  );
                  var $toString = callBound("Object.prototype.toString");
                  var hasToStringTag = __webpack_require__2(
                    /*! has-tostringtag/shams */
                    "./node_modules/has-tostringtag/shams.js"
                  )();
                  var g = typeof globalThis === "undefined" ? __webpack_require__2.g : globalThis;
                  var typedArrays = availableTypedArrays();
                  var $slice = callBound("String.prototype.slice");
                  var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
                    for (var i = 0; i < array.length; i += 1) {
                      if (array[i] === value) {
                        return i;
                      }
                    }
                    return -1;
                  };
                  var cache = { __proto__: null };
                  if (hasToStringTag && gOPD && getProto) {
                    forEach(typedArrays, function(typedArray) {
                      var arr = new g[typedArray]();
                      if (Symbol.toStringTag in arr && getProto) {
                        var proto = getProto(arr);
                        var descriptor = gOPD(proto, Symbol.toStringTag);
                        if (!descriptor && proto) {
                          var superProto = getProto(proto);
                          descriptor = gOPD(superProto, Symbol.toStringTag);
                        }
                        cache["$" + typedArray] = callBind(descriptor.get);
                      }
                    });
                  } else {
                    forEach(typedArrays, function(typedArray) {
                      var arr = new g[typedArray]();
                      var fn = arr.slice || arr.set;
                      if (fn) {
                        cache[
                          /** @type {`$${import('.').TypedArrayName}`} */
                          "$" + typedArray
                        ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
                        // @ts-expect-error TODO FIXME
                        callBind(fn);
                      }
                    });
                  }
                  var tryTypedArrays = function tryAllTypedArrays(value) {
                    var found = false;
                    forEach(
                      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
                      cache,
                      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
                      function(getter, typedArray) {
                        if (!found) {
                          try {
                            if ("$" + getter(value) === typedArray) {
                              found = /** @type {import('.').TypedArrayName} */
                              $slice(typedArray, 1);
                            }
                          } catch (e) {
                          }
                        }
                      }
                    );
                    return found;
                  };
                  var trySlices = function tryAllSlices(value) {
                    var found = false;
                    forEach(
                      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
                      cache,
                      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
                      function(getter, name) {
                        if (!found) {
                          try {
                            getter(value);
                            found = /** @type {import('.').TypedArrayName} */
                            $slice(name, 1);
                          } catch (e) {
                          }
                        }
                      }
                    );
                    return found;
                  };
                  module2.exports = function whichTypedArray(value) {
                    if (!value || typeof value !== "object") {
                      return false;
                    }
                    if (!hasToStringTag) {
                      var tag = $slice($toString(value), 8, -1);
                      if ($indexOf(typedArrays, tag) > -1) {
                        return tag;
                      }
                      if (tag !== "Object") {
                        return false;
                      }
                      return trySlices(value);
                    }
                    if (!gOPD) {
                      return null;
                    }
                    return tryTypedArrays(value);
                  };
                }
              ),
              /***/
              "./src/ForgeExprEvaluator.ts": (
                /*!***********************************!*\
                  !*** ./src/ForgeExprEvaluator.ts ***!
                  \***********************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.NameNotFoundError = exports2.ForgeExprEvaluator = exports2.SUPPORTED_BUILTINS = void 0;
                  exports2.areTupleArraysEqual = areTupleArraysEqual;
                  const AbstractParseTreeVisitor_1 = __webpack_require__2(
                    /*! antlr4ts/tree/AbstractParseTreeVisitor */
                    "./node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js"
                  );
                  const lodash_1 = __webpack_require__2(
                    /*! lodash */
                    "./node_modules/lodash/lodash.js"
                  );
                  const ForgeExprFreeVariableFinder_1 = __webpack_require__2(
                    /*! ./ForgeExprFreeVariableFinder */
                    "./src/ForgeExprFreeVariableFinder.ts"
                  );
                  function isSingleValue2(value) {
                    return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
                  }
                  function isTupleArray(value) {
                    return Array.isArray(value);
                  }
                  function isBoolean2(value) {
                    return typeof value === "boolean";
                  }
                  function isNumber(value) {
                    return typeof value === "number";
                  }
                  function isSingletonNumberTuple(value) {
                    return Array.isArray(value) && value.length === 1 && Array.isArray(value[0]) && value[0].length === 1 && typeof value[0][0] === "number";
                  }
                  function extractNumber(val) {
                    if (isNumber(val))
                      return val;
                    if (isSingletonNumberTuple(val))
                      return val[0][0];
                    return void 0;
                  }
                  function isString(value) {
                    return typeof value === "string";
                  }
                  function areTuplesEqual(a, b) {
                    return a.length === b.length && a.every((val, i) => val === b[i]);
                  }
                  function isTupleArraySubset(a, b) {
                    return a.every((tupleA) => b.some((tupleB) => areTuplesEqual(tupleA, tupleB)));
                  }
                  function areTupleArraysEqual(a, b) {
                    if (a.length !== b.length) {
                      return false;
                    }
                    return isTupleArraySubset(a, b) && isTupleArraySubset(b, a);
                  }
                  function deduplicateTuples(tuples) {
                    const result = [];
                    for (const tuple of tuples) {
                      if (!result.some((existing) => areTuplesEqual(existing, tuple))) {
                        result.push(tuple);
                      }
                    }
                    return result;
                  }
                  function getCombinations(arrays) {
                    const valueSets = arrays.map((tuple) => tuple.flat());
                    function cartesianProduct(arrays2) {
                      if (arrays2.length === 0)
                        return [[]];
                      const [first, ...rest] = arrays2;
                      const restProduct = cartesianProduct(rest);
                      return first.flatMap((value) => restProduct.map((product) => [value, ...product]));
                    }
                    return cartesianProduct(valueSets);
                  }
                  function transitiveClosure(pairs2) {
                    if (pairs2.length === 0)
                      return [];
                    pairs2.forEach((tuple) => {
                      if (tuple.length !== 2) {
                        throw new Error("transitive closure ^ expected a relation of arity 2");
                      }
                    });
                    const graph = /* @__PURE__ */ new Map();
                    for (const [from, to] of pairs2) {
                      if (!graph.has(from)) {
                        graph.set(from, /* @__PURE__ */ new Set());
                      }
                      graph.get(from).add(to);
                    }
                    const transitiveClosure2 = /* @__PURE__ */ new Set();
                    for (const start of graph.keys()) {
                      const visited = /* @__PURE__ */ new Set();
                      const queue = [...graph.get(start) ?? []];
                      while (queue.length > 0) {
                        const current = queue.shift();
                        if (visited.has(current))
                          continue;
                        visited.add(current);
                        transitiveClosure2.add(JSON.stringify([start, current]));
                        const neighbors = graph.get(current);
                        if (neighbors) {
                          for (const neighbor of neighbors) {
                            if (!visited.has(neighbor)) {
                              queue.push(neighbor);
                            }
                          }
                        }
                      }
                    }
                    return Array.from(transitiveClosure2).map((pair) => JSON.parse(pair));
                  }
                  function dotJoin(left, right) {
                    const leftExpr = isSingleValue2(left) ? [[left]] : left;
                    const rightExpr = isSingleValue2(right) ? [[right]] : right;
                    const result = [];
                    leftExpr.forEach((leftTuple) => {
                      rightExpr.forEach((rightTuple) => {
                        if (leftTuple[leftTuple.length - 1] === rightTuple[0]) {
                          result.push([
                            ...leftTuple.slice(0, leftTuple.length - 1),
                            ...rightTuple.slice(1)
                          ]);
                        }
                      });
                    });
                    if (result.some((tuple) => tuple.length === 0)) {
                      throw new Error("Join would create a relation of arity 0");
                    }
                    return result;
                  }
                  function bitwidthWraparound(value, bitwidth) {
                    const modulus = Math.pow(2, bitwidth);
                    const halfValue = Math.pow(2, bitwidth - 1);
                    let wrappedValue = (value % modulus + modulus) % modulus;
                    if (wrappedValue >= halfValue) {
                      wrappedValue -= modulus;
                    }
                    return wrappedValue;
                  }
                  const SUPPORTED_BINARY_BUILTINS = ["add", "subtract", "multiply", "divide", "remainder"];
                  const SUPPORTED_UNARY_BUILTINS = ["abs", "sign"];
                  exports2.SUPPORTED_BUILTINS = SUPPORTED_BINARY_BUILTINS.concat(SUPPORTED_UNARY_BUILTINS);
                  class ForgeExprEvaluator extends AbstractParseTreeVisitor_1.AbstractParseTreeVisitor {
                    constructor(datum) {
                      super();
                      this.cachedResults = /* @__PURE__ */ new Map();
                      this.instanceData = datum;
                      this.environmentStack = [];
                      this.freeVariableFinder = new ForgeExprFreeVariableFinder_1.ForgeExprFreeVariableFinder(datum);
                      this.freeVariables = /* @__PURE__ */ new Map();
                    }
                    //helper function
                    updateFreeVariables(freeVars) {
                      if (this.freeVariables.size === 0) {
                        this.freeVariables = freeVars;
                      }
                      if (this.freeVariables.size === 0) {
                        return;
                      }
                      for (const [contextNode, variables] of freeVars.entries()) {
                        if (!this.freeVariables.has(contextNode)) {
                          this.freeVariables.set(contextNode, /* @__PURE__ */ new Set());
                        }
                        const existingVariables = this.freeVariables.get(contextNode);
                        for (const variable of variables) {
                          existingVariables.add(variable);
                        }
                      }
                    }
                    // helper function
                    constructFreeVariableKey(freeVarValues) {
                      const keys = Object.keys(freeVarValues);
                      keys.sort();
                      return keys.map((key) => `${key}=${freeVarValues[key]}`).join("|");
                    }
                    // helper function to get the label for a value (used for @: operator)
                    getLabelForValue(value) {
                      if (typeof value === "number" || typeof value === "boolean") {
                        return String(value);
                      }
                      if (typeof value === "string") {
                        let atom = this.instanceData.getAtoms().find((a) => a.id === value);
                        if (atom) {
                          return atom.label !== void 0 ? atom.label : atom.id;
                        }
                      }
                      console.error(`No atom found for value: ${value}`);
                      return value;
                    }
                    // helper function to get the label as string (used for @: and @str: operators)
                    getLabelAsString(value) {
                      const label = this.getLabelForValue(value);
                      return String(label);
                    }
                    // helper function to get the label as boolean (used for @bool: operator)
                    getLabelAsBoolean(value) {
                      const label = this.getLabelForValue(value);
                      const labelStr = String(label).toLowerCase();
                      if (labelStr === "true")
                        return true;
                      if (labelStr === "false")
                        return false;
                      const labelNum = Number(label);
                      if (!isNaN(labelNum)) {
                        return labelNum !== 0;
                      }
                      return labelStr !== "";
                    }
                    // helper function to get the label as number (used for @num: operator)
                    getLabelAsNumber(value) {
                      const label = this.getLabelForValue(value);
                      const labelNum = Number(label);
                      if (isNaN(labelNum)) {
                        throw new Error(`Cannot convert label "${label}" to number`);
                      }
                      return labelNum;
                    }
                    // helper function
                    cacheResult(ctx, freeVarsKey, result) {
                      if (!this.cachedResults.has(ctx)) {
                        this.cachedResults.set(ctx, /* @__PURE__ */ new Map());
                      }
                      this.cachedResults.get(ctx).set(freeVarsKey, result);
                    }
                    // helper function
                    getIden() {
                      const instanceTypes = this.instanceData.getTypes();
                      const result = [];
                      for (const t of instanceTypes) {
                        const typeAtoms = t.atoms;
                        typeAtoms.forEach((atom) => {
                          let value = atom.id;
                          if (!isNaN(Number(value))) {
                            value = Number(value);
                          } else if (value == "true" || value === "#t") {
                            value = true;
                          } else if (value == "false" || value === "#f") {
                            value = false;
                          }
                          result.push([value, value]);
                        });
                      }
                      return result;
                    }
                    // THIS SEEMS KINDA JANKY... IS THIS REALLY WHAT WE WANT??
                    aggregateResult(aggregate, nextResult) {
                      if (isTupleArray(aggregate) && aggregate.length === 0)
                        return nextResult;
                      if (isTupleArray(nextResult) && nextResult.length === 0)
                        return aggregate;
                      if (isSingleValue2(aggregate)) {
                        if (isSingleValue2(nextResult)) {
                          return nextResult;
                        } else {
                          throw new Error("Expected nextResult to be a single value");
                        }
                      } else {
                        if (isSingleValue2(nextResult)) {
                          return aggregate.concat([nextResult]);
                        } else {
                          return aggregate.concat(nextResult);
                        }
                      }
                    }
                    defaultResult() {
                      return [];
                    }
                    visitPredDecl(ctx) {
                      const visitResult = this.visit(ctx.block());
                      return visitResult;
                    }
                    visitBlock(ctx) {
                      let result = void 0;
                      for (const expr of ctx.expr()) {
                        const exprResult = this.visit(expr);
                        if (!isBoolean2(exprResult)) {
                          throw new Error("Each expr in a block must evaluate to a boolean!");
                        }
                        if (result === void 0) {
                          result = exprResult;
                        } else {
                          result = result && exprResult;
                        }
                      }
                      if (result === void 0) {
                        throw new Error("Expected the block to be nonempty!");
                      }
                      return result;
                    }
                    visitExpr(ctx) {
                      let exprFreeVars = this.freeVariables.get(ctx);
                      if (exprFreeVars === void 0) {
                        const allContextNodesFreeVars = this.freeVariableFinder.visit(ctx);
                        this.updateFreeVariables(allContextNodesFreeVars);
                        exprFreeVars = allContextNodesFreeVars.get(ctx);
                      }
                      let foundAllVars = true;
                      const freeVarValues = {};
                      for (const freeVar of exprFreeVars) {
                        for (let i = this.environmentStack.length - 1; i >= 0; i--) {
                          const currEnv = this.environmentStack[i];
                          if (currEnv.env[freeVar] !== void 0) {
                            freeVarValues[freeVar] = currEnv.env[freeVar];
                            break;
                          }
                          if (currEnv.type === "predArgs") {
                            foundAllVars = false;
                          }
                        }
                      }
                      const freeVarsKey = this.constructFreeVariableKey(freeVarValues);
                      if (foundAllVars && this.cachedResults.has(ctx)) {
                        if (this.cachedResults.get(ctx).has(freeVarsKey)) {
                          return this.cachedResults.get(ctx).get(freeVarsKey);
                        }
                      }
                      let results = void 0;
                      if (ctx.LET_TOK()) {
                        results = [];
                        results.push(["**UNIMPLEMENTED** Let Binding (`let x = ...`)"]);
                      }
                      if (ctx.BIND_TOK()) {
                        throw new Error("**NOT IMPLEMENTING FOR NOW** Bind Expression");
                      }
                      if (ctx.quant()) {
                        if (ctx.quantDeclList() === void 0) {
                          throw new Error("Expected the quantifier to have a quantDeclList!");
                        }
                        const quantifierFreeVars = this.freeVariableFinder.visit(ctx);
                        this.updateFreeVariables(quantifierFreeVars);
                        const varQuantifiedSets = this.getQuantDeclListValues(ctx.quantDeclList());
                        const isDisjoint = ctx.DISJ_TOK() !== void 0;
                        const blockOrBar = ctx.blockOrBar();
                        if (blockOrBar === void 0) {
                          throw new Error("expected to quantify over something!");
                        }
                        if (blockOrBar.BAR_TOK() === void 0 || blockOrBar.expr() === void 0) {
                          throw new Error("Expected the quantifier to have a bar followed by an expr!");
                        }
                        const barExpr = blockOrBar.expr();
                        const varNames = [];
                        const quantifiedSets = [];
                        for (const varName in varQuantifiedSets) {
                          varNames.push(varName);
                          quantifiedSets.push(varQuantifiedSets[varName]);
                        }
                        const product = getCombinations(quantifiedSets);
                        const result = [];
                        let foundTrue = false;
                        let foundFalse = false;
                        for (let i = 0; i < product.length; i++) {
                          const tuple = product[i];
                          if (isDisjoint) {
                            let tupleDisjoint = true;
                            const seen = /* @__PURE__ */ new Set();
                            for (const val of tuple) {
                              if (seen.has(val)) {
                                tupleDisjoint = false;
                                break;
                              }
                              seen.add(val);
                            }
                            if (!tupleDisjoint) {
                              continue;
                            }
                          }
                          const quantDeclEnv = {
                            env: {},
                            type: "quantDecl"
                          };
                          for (let j = 0; j < varNames.length; j++) {
                            const varName = varNames[j];
                            const varValue = tuple[j];
                            quantDeclEnv.env[varName] = varValue;
                          }
                          this.environmentStack.push(quantDeclEnv);
                          const barExprValue = this.visit(barExpr);
                          if (!isBoolean2(barExprValue)) {
                            throw new Error("Expected the expression after the bar to be a boolean!");
                          }
                          if (barExprValue) {
                            result.push(tuple);
                            foundTrue = true;
                          } else {
                            foundFalse = true;
                          }
                          this.environmentStack.pop();
                          if (ctx.quant().ALL_TOK() && foundFalse) {
                            const value = false;
                            this.cacheResult(ctx, freeVarsKey, value);
                            return value;
                          }
                          if (ctx.quant().NO_TOK() && foundTrue) {
                            const value = false;
                            this.cacheResult(ctx, freeVarsKey, value);
                            return value;
                          }
                          if (ctx.quant().mult()) {
                            const multExpr = ctx.quant().mult();
                            if (multExpr.LONE_TOK() && result.length > 1) {
                              const value = false;
                              this.cacheResult(ctx, freeVarsKey, value);
                              return value;
                            }
                            if (multExpr.SOME_TOK() && foundTrue) {
                              const value = true;
                              this.cacheResult(ctx, freeVarsKey, value);
                              return value;
                            }
                            if (multExpr.ONE_TOK() && result.length > 1) {
                              const value = false;
                              this.cacheResult(ctx, freeVarsKey, value);
                              return value;
                            }
                          }
                        }
                        if (ctx.quant().ALL_TOK()) {
                          const value = !foundFalse;
                          this.cacheResult(ctx, freeVarsKey, value);
                          return value;
                        } else if (ctx.quant().NO_TOK()) {
                          const value = !foundTrue;
                          this.cacheResult(ctx, freeVarsKey, value);
                          return value;
                        } else if (ctx.quant().mult()) {
                          const multExpr = ctx.quant().mult();
                          if (multExpr.LONE_TOK()) {
                            const value = result.length <= 1;
                            this.cacheResult(ctx, freeVarsKey, value);
                            return value;
                          } else if (multExpr.SOME_TOK()) {
                            const value = foundTrue;
                            this.cacheResult(ctx, freeVarsKey, value);
                            return value;
                          } else if (multExpr.ONE_TOK()) {
                            const value = result.length === 1;
                            this.cacheResult(ctx, freeVarsKey, value);
                            return value;
                          } else if (multExpr.TWO_TOK()) {
                            throw new Error("**NOT IMPLEMENTING FOR NOW** Two (`two`)");
                          }
                        }
                      }
                      const childrenResults = this.visitChildren(ctx);
                      if (results === void 0) {
                        this.cacheResult(ctx, freeVarsKey, childrenResults);
                        return childrenResults;
                      }
                      if (isSingleValue2(results)) {
                        throw new Error("Expected results to be a tuple array");
                      }
                      if (isSingleValue2(childrenResults)) {
                        results.push([childrenResults]);
                      } else {
                        results = results.concat(childrenResults);
                      }
                      this.cacheResult(ctx, freeVarsKey, results);
                      return results;
                    }
                    visitExpr1(ctx) {
                      if (ctx.OR_TOK()) {
                        if (ctx.expr1_5() === void 0 || ctx.expr1_5() === void 0) {
                          throw new Error("Expected the OR operator to have 2 operands of the right type!");
                        }
                        const leftChildValue = this.visit(ctx.expr1());
                        if (!isBoolean2(leftChildValue)) {
                          throw new Error("OR operator expected 2 boolean operands!");
                        }
                        if (leftChildValue) {
                          return leftChildValue;
                        }
                        const rightChildValue = this.visit(ctx.expr1_5());
                        if (!isBoolean2(rightChildValue)) {
                          throw new Error("OR operator expected 2 boolean operands!");
                        }
                        return rightChildValue;
                      }
                      const childrenResults = this.visitChildren(ctx);
                      return childrenResults;
                    }
                    visitExpr1_5(ctx) {
                      if (ctx.XOR_TOK()) {
                        if (ctx.expr1_5() === void 0 || ctx.expr2() === void 0) {
                          throw new Error("Expected the XOR operator to have 2 operands of the right type!");
                        }
                        const leftChildValue = this.visit(ctx.expr1_5());
                        const rightChildValue = this.visit(ctx.expr2());
                        if (!isBoolean2(leftChildValue) || !isBoolean2(rightChildValue)) {
                          throw new Error("XOR operator expected 2 boolean operands!");
                        }
                        return leftChildValue !== rightChildValue;
                      }
                      const childrenResults = this.visitChildren(ctx);
                      return childrenResults;
                    }
                    visitExpr2(ctx) {
                      if (ctx.IFF_TOK()) {
                        if (ctx.expr2() === void 0 || ctx.expr3() === void 0) {
                          throw new Error("Expected the IFF operator to have 2 operands of the right type!");
                        }
                        const leftChildValue = this.visit(ctx.expr2());
                        const rightChildValue = this.visit(ctx.expr3());
                        if (!isBoolean2(leftChildValue) || !isBoolean2(rightChildValue)) {
                          throw new Error("IFF operator expected 2 boolean operands!");
                        }
                        return leftChildValue === rightChildValue;
                      }
                      const childrenResults = this.visitChildren(ctx);
                      return childrenResults;
                    }
                    visitExpr3(ctx) {
                      if (ctx.IMP_TOK()) {
                        if (ctx.expr3() === void 0 || ctx.expr4() === void 0) {
                          throw new Error("Expected the IMP operator to have 2 operands of the right type!");
                        }
                        const leftChildValue = this.visit(ctx.expr4());
                        if (!isBoolean2(leftChildValue)) {
                          throw new Error("IMP operator expected 2 boolean operands!");
                        }
                        if (!leftChildValue) {
                          return true;
                        }
                        const rightChildValue = this.visit(ctx.expr3()[0]);
                        if (!isBoolean2(rightChildValue)) {
                          throw new Error("IMP operator expected 2 boolean operands!");
                        }
                        return rightChildValue;
                      }
                      const childrenResults = this.visitChildren(ctx);
                      return childrenResults;
                    }
                    visitExpr4(ctx) {
                      if (ctx.AND_TOK()) {
                        if (ctx.expr4() === void 0 || ctx.expr4_5() === void 0) {
                          throw new Error("Expected the AND operator to have 2 operands of the right type!");
                        }
                        const leftChildValue = this.visit(ctx.expr4());
                        if (!isBoolean2(leftChildValue)) {
                          throw new Error("AND operator expected 2 boolean operands!");
                        }
                        if (!leftChildValue) {
                          return leftChildValue;
                        }
                        const rightChildValue = this.visit(ctx.expr4_5());
                        if (!isBoolean2(rightChildValue)) {
                          throw new Error("AND operator expected 2 boolean operands!");
                        }
                        return rightChildValue;
                      }
                      const childrenResults = this.visitChildren(ctx);
                      return childrenResults;
                    }
                    visitExpr4_5(ctx) {
                      let results = [];
                      if (ctx.UNTIL_TOK()) {
                        results.push(["**UNIMPLEMENTED** Temporal Operator (`until`)"]);
                        return results;
                      }
                      if (ctx.RELEASE_TOK()) {
                        results.push(["**UNIMPLEMENTED** Temporal Operator (`release`)"]);
                        return results;
                      }
                      if (ctx.SINCE_TOK()) {
                        results.push(["**UNIMPLEMENTED** Temporal Operator (`since`)"]);
                        return results;
                      }
                      if (ctx.TRIGGERED_TOK()) {
                        results.push(["**UNIMPLEMENTED** Temporal Operator (`triggered`)"]);
                        return results;
                      }
                      const childrenResults = this.visitChildren(ctx);
                      return childrenResults;
                    }
                    visitExpr5(ctx) {
                      let results = [];
                      if (ctx.expr6()) {
                        return this.visit(ctx.expr6());
                      }
                      if (ctx.expr5() === void 0) {
                        throw new Error("Expected the temporal operator to have 1 operand!");
                      }
                      const childrenResults = this.visit(ctx.expr5());
                      if (ctx.NEG_TOK()) {
                        if (!isBoolean2(childrenResults)) {
                          throw new Error("Expected the negation operator to have a boolean operand!");
                        }
                        return !childrenResults;
                      }
                      if (ctx.ALWAYS_TOK()) {
                        results.push(["**UNIMPLEMENTED** Temporal Operator (`always`)"]);
                        return results;
                      }
                      if (ctx.EVENTUALLY_TOK()) {
                        results.push(["**UNIMPLEMENTED** Temporal Operator (`eventually`)"]);
                        return results;
                      }
                      if (ctx.AFTER_TOK()) {
                        results.push(["**UNIMPLEMENTED** Temporal Operator (`after`)"]);
                        return results;
                      }
                      if (ctx.BEFORE_TOK()) {
                        results.push(["**UNIMPLEMENTED** Temporal Operator (`before`)"]);
                        return results;
                      }
                      if (ctx.ONCE_TOK()) {
                        results.push(["**UNIMPLEMENTED** Temporal Operator (`once`)"]);
                        return results;
                      }
                      if (ctx.HISTORICALLY_TOK()) {
                        results.push(["**UNIMPLEMENTED** Temporal Operator (`historically`)"]);
                        return results;
                      }
                      return childrenResults;
                    }
                    visitExpr6(ctx) {
                      let results = [];
                      let toNegate = false;
                      let foundValue = false;
                      if (ctx.NEG_TOK()) {
                        toNegate = true;
                      }
                      if (ctx.compareOp()) {
                        foundValue = true;
                        if (ctx.expr6() === void 0 || ctx.expr7() === void 0) {
                          throw new Error("Expected the compareOp to have 2 operands!");
                        }
                        const leftChildValue = this.visit(ctx.expr6());
                        const rightChildValue = this.visit(ctx.expr7());
                        let leftNum = extractNumber(leftChildValue);
                        let rightNum = extractNumber(rightChildValue);
                        switch (ctx.compareOp()?.text) {
                          case "=":
                            if (isSingleValue2(leftChildValue) && isSingleValue2(rightChildValue)) {
                              results = leftChildValue === rightChildValue;
                            } else if (isSingleValue2(leftChildValue) && isTupleArray(rightChildValue)) {
                              if (rightChildValue.length === 1 && rightChildValue[0].length === 1) {
                                results = leftChildValue === rightChildValue[0][0];
                              } else {
                                results = false;
                              }
                            } else if (isTupleArray(leftChildValue) && isSingleValue2(rightChildValue)) {
                              if (leftChildValue.length === 1 && leftChildValue[0].length === 1) {
                                results = leftChildValue[0][0] === rightChildValue;
                              } else {
                                results = false;
                              }
                            } else if (isTupleArray(leftChildValue) && isTupleArray(rightChildValue)) {
                              results = areTupleArraysEqual(leftChildValue, rightChildValue);
                            } else {
                              throw new Error("unexpected error: equality operand is not a well defined forge value!");
                            }
                            break;
                          case "<":
                            if (leftNum === void 0 || rightNum === void 0) {
                              throw new Error(`Expected the < operator to have 2 number operands (number or [[number]]), got ${typeof leftChildValue} and ${typeof rightChildValue}!`);
                            }
                            results = leftNum < rightNum;
                            break;
                          case ">":
                            if (leftNum === void 0 || rightNum === void 0) {
                              throw new Error(`Expected the > operator to have 2 number operands (number or [[number]]), got ${typeof leftChildValue} and ${typeof rightChildValue}!`);
                            }
                            results = leftNum > rightNum;
                            break;
                          case "<=":
                            if (leftNum === void 0 || rightNum === void 0) {
                              throw new Error(`Expected the <= operator to have 2 number operands (number or [[number]]), got ${typeof leftChildValue} and ${typeof rightChildValue}!`);
                            }
                            results = leftNum <= rightNum;
                            break;
                          case ">=":
                            if (leftNum === void 0 || rightNum === void 0) {
                              throw new Error(`Expected the >= operator to have 2 number operands (number or [[number]]), got ${typeof leftChildValue} and ${typeof rightChildValue}!`);
                            }
                            results = leftNum >= rightNum;
                            break;
                          case "in":
                            if (isTupleArray(leftChildValue) && isTupleArray(rightChildValue)) {
                              if (areTupleArraysEqual(leftChildValue, rightChildValue)) {
                                results = true;
                              } else {
                                results = isTupleArraySubset(leftChildValue, rightChildValue);
                              }
                            } else if (isTupleArray(rightChildValue)) {
                              results = rightChildValue.some((tuple) => tuple.length === 1 && tuple[0] === leftChildValue);
                            } else {
                              results = false;
                            }
                            break;
                          case "is":
                            throw new Error("**NOT IMPLEMENTING FOR NOW** Type Check (`is`)");
                          case "ni":
                            results.push(["**UNIMPLEMENTED** Set Non-Membership (`ni`)"]);
                            return results;
                            {
                            }
                          // redundant, but it won't be once we implement the TODO above
                          default:
                            throw new Error(`Unexpected compare operator provided: ${ctx.compareOp()?.text}`);
                        }
                      }
                      if (toNegate) {
                        if (!isBoolean2(results)) {
                          throw new Error("Expected the negation operator to have a boolean operand!");
                        }
                        return !results;
                      }
                      if (foundValue) {
                        return results;
                      }
                      return this.visitChildren(ctx);
                    }
                    visitExpr7(ctx) {
                      let results = [];
                      const childrenResults = this.visit(ctx.expr8());
                      if (ctx.SET_TOK()) {
                        throw new Error("**NOT IMPLEMENTING FOR NOW** Set (`set`)");
                      }
                      if (ctx.ONE_TOK()) {
                        return isTupleArray(childrenResults) && childrenResults.length === 1;
                      }
                      if (ctx.TWO_TOK()) {
                        throw new Error("**NOT IMPLEMENTING FOR NOW** Two (`two`)");
                      }
                      if (ctx.NO_TOK()) {
                        return isTupleArray(childrenResults) && childrenResults.length === 0;
                      }
                      if (ctx.SOME_TOK()) {
                        return isTupleArray(childrenResults) && childrenResults.length > 0;
                      }
                      if (ctx.LONE_TOK()) {
                        return isTupleArray(childrenResults) && childrenResults.length <= 1;
                      }
                      return childrenResults;
                    }
                    visitExpr8(ctx) {
                      if (ctx.PLUS_TOK()) {
                        const leftChildValue = this.visit(ctx.expr8());
                        const rightChildValue = this.visit(ctx.expr10());
                        if (isSingleValue2(leftChildValue) && isSingleValue2(rightChildValue)) {
                          return [[leftChildValue], [rightChildValue]];
                        } else if (isSingleValue2(leftChildValue) && isTupleArray(rightChildValue)) {
                          if (rightChildValue.length === 0) {
                            return leftChildValue;
                          }
                          if (rightChildValue[0].length === 1) {
                            return deduplicateTuples([[leftChildValue], ...rightChildValue]);
                          }
                          throw new Error("arity mismatch in set union!");
                        } else if (isTupleArray(leftChildValue) && isSingleValue2(rightChildValue)) {
                          if (leftChildValue.length === 0) {
                            return rightChildValue;
                          }
                          if (leftChildValue[0].length === 1) {
                            return deduplicateTuples([...leftChildValue, [rightChildValue]]);
                          }
                          throw new Error("arity mismatch in set union!");
                        } else if (isTupleArray(leftChildValue) && isTupleArray(rightChildValue)) {
                          if (leftChildValue.length === 0 && rightChildValue.length === 0) {
                            return [];
                          }
                          if (leftChildValue.length === 0) {
                            return rightChildValue;
                          }
                          if (rightChildValue.length === 0) {
                            return leftChildValue;
                          }
                          if (leftChildValue[0].length === rightChildValue[0].length) {
                            return deduplicateTuples([...leftChildValue, ...rightChildValue]);
                          }
                        } else {
                          throw new Error("unexpected error: expressions added are not well defined!");
                        }
                      }
                      if (ctx.MINUS_TOK()) {
                        const leftChildValue = this.visit(ctx.expr8());
                        const rightChildValue = this.visit(ctx.expr10());
                        if (isSingleValue2(leftChildValue) && isSingleValue2(rightChildValue)) {
                          if (leftChildValue === rightChildValue) {
                            return [];
                          }
                          return leftChildValue;
                        } else if (isSingleValue2(leftChildValue) && isTupleArray(rightChildValue)) {
                          if (rightChildValue.length === 0) {
                            return leftChildValue;
                          }
                          if (rightChildValue[0].length === 1) {
                            return rightChildValue.some((tuple) => tuple[0] === leftChildValue) ? [] : leftChildValue;
                          }
                          throw new Error("arity mismatch in set difference!");
                        } else if (isTupleArray(leftChildValue) && isSingleValue2(rightChildValue)) {
                          if (leftChildValue.length === 0) {
                            return [];
                          }
                          if (leftChildValue[0].length === 1) {
                            return leftChildValue.filter((tuple) => tuple[0] !== rightChildValue);
                          }
                          throw new Error("arity mismatch in set difference!");
                        } else if (isTupleArray(leftChildValue) && isTupleArray(rightChildValue)) {
                          if (leftChildValue.length === 0) {
                            return [];
                          }
                          if (rightChildValue.length === 0) {
                            return leftChildValue;
                          }
                          if (leftChildValue[0].length === rightChildValue[0].length) {
                            return leftChildValue.filter((tuple) => !rightChildValue.some((rightTuple) => areTuplesEqual(tuple, rightTuple)));
                          }
                        } else {
                          throw new Error("unexpected error: expressions subtracted are not well defined!");
                        }
                      }
                      return this.visitChildren(ctx);
                    }
                    visitExpr9(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      if (ctx.CARD_TOK()) {
                        if (!isTupleArray(childrenResults)) {
                          throw new Error("The cardinal operator must be applied to a set of tuples!");
                        }
                        return childrenResults.length;
                      }
                      return childrenResults;
                    }
                    visitExpr10(ctx) {
                      let results = [];
                      if (ctx.PPLUS_TOK()) {
                        if (ctx.expr10() === void 0 || ctx.expr11() === void 0) {
                          throw new Error("Expected the pplus operator to have 2 operands of the right type!");
                        }
                        const leftChildValue = this.visit(ctx.expr10());
                        const rightChildValue = this.visit(ctx.expr11());
                        throw new Error("**NOT IMPLEMENTING FOR NOW** pplus (`++`)");
                      }
                      return this.visitChildren(ctx);
                    }
                    visitExpr11(ctx) {
                      if (ctx.AMP_TOK()) {
                        if (ctx.expr11() === void 0 || ctx.expr12() === void 0) {
                          throw new Error("Expected the amp operator to have 2 operands of the right type!");
                        }
                        const leftChildValue = this.visit(ctx.expr11());
                        const rightChildValue = this.visit(ctx.expr12());
                        if (isSingleValue2(leftChildValue) && isSingleValue2(rightChildValue)) {
                          return leftChildValue === rightChildValue ? leftChildValue : [];
                        } else if (isSingleValue2(leftChildValue) && isTupleArray(rightChildValue)) {
                          if (rightChildValue.length === 0) {
                            return [];
                          }
                          if (rightChildValue[0].length === 1) {
                            return rightChildValue.some((tuple) => tuple[0] === leftChildValue) ? leftChildValue : [];
                          }
                          throw new Error("arity mismatch in set intersection!");
                        } else if (isTupleArray(leftChildValue) && isSingleValue2(rightChildValue)) {
                          if (leftChildValue.length === 0) {
                            return [];
                          }
                          if (leftChildValue[0].length === 1) {
                            return leftChildValue.some((tuple) => tuple[0] === rightChildValue) ? rightChildValue : [];
                          }
                          throw new Error("arity mismatch in set intersection!");
                        } else if (isTupleArray(leftChildValue) && isTupleArray(rightChildValue)) {
                          if (leftChildValue.length === 0 || rightChildValue.length === 0) {
                            return [];
                          }
                          if (leftChildValue[0].length === rightChildValue[0].length) {
                            return leftChildValue.filter((tuple) => rightChildValue.some((rightTuple) => areTuplesEqual(tuple, rightTuple)));
                          }
                        } else {
                          throw new Error("unexpected error: expressions intersected are not well defined!");
                        }
                      }
                      return this.visitChildren(ctx);
                    }
                    visitExpr12(ctx) {
                      if (ctx.arrowOp()) {
                        if (ctx.expr12() === void 0 || ctx.expr13() === void 0) {
                          throw new Error("Expected the arrow operator to have 2 operands of the right type!");
                        }
                        const leftChildValue = this.visit(ctx.expr12());
                        const rightChildValue = this.visit(ctx.expr13());
                        const leftTuples = isSingleValue2(leftChildValue) ? [[leftChildValue]] : leftChildValue;
                        const rightTuples = isSingleValue2(rightChildValue) ? [[rightChildValue]] : rightChildValue;
                        if (!isTupleArray(leftTuples) || !isTupleArray(rightTuples)) {
                          throw new Error("Arrow operator operands must be tuple arrays or single values");
                        }
                        const result = [];
                        for (const leftTuple of leftTuples) {
                          for (const rightTuple of rightTuples) {
                            result.push([...leftTuple, ...rightTuple]);
                          }
                        }
                        return deduplicateTuples(result);
                      }
                      return this.visitChildren(ctx);
                    }
                    visitExpr13(ctx) {
                      let results = [];
                      if (ctx.SUPT_TOK()) {
                        if (ctx.expr13() === void 0 || ctx.expr14() === void 0) {
                          throw new Error("Expected the supertype operator to have 2 operands of the right type!");
                        }
                        const leftChildValue = this.visit(ctx.expr13());
                        const rightChildValue = this.visit(ctx.expr14());
                        throw new Error("**NOT IMPLEMENTING FOR NOW** Supertype Operator (`:>`)");
                      }
                      if (ctx.SUBT_TOK()) {
                        if (ctx.expr13() === void 0 || ctx.expr14() === void 0) {
                          throw new Error("Expected the subtype operator to have 2 operands of the right type!");
                        }
                        const leftChildValue = this.visit(ctx.expr13());
                        const rightChildValue = this.visit(ctx.expr14());
                        throw new Error("**NOT IMPLEMENTING FOR NOW** Subtype Operator (`<:`)");
                      }
                      return this.visitChildren(ctx);
                    }
                    visitExpr14(ctx) {
                      let results = [];
                      if (ctx.LEFT_SQUARE_TOK()) {
                        const beforeBracesExpr = this.visit(ctx.expr14());
                        const insideBracesExprs = this.visit(ctx.exprList());
                        if (isString(beforeBracesExpr)) {
                          if (SUPPORTED_BINARY_BUILTINS.includes(beforeBracesExpr)) {
                            return this.evaluateBinaryOperation(beforeBracesExpr, insideBracesExprs);
                          } else if (SUPPORTED_UNARY_BUILTINS.includes(beforeBracesExpr)) {
                            return this.evaluateUnaryOperation(beforeBracesExpr, insideBracesExprs);
                          }
                        }
                        return dotJoin(insideBracesExprs, beforeBracesExpr);
                      }
                      return this.visitChildren(ctx);
                    }
                    visitExpr15(ctx) {
                      let results = [];
                      if (ctx.DOT_TOK()) {
                        if (ctx.expr15() === void 0 || ctx.expr16() === void 0) {
                          throw new Error("Expected the dot operator to have 2 operands of the right type!");
                        }
                        const beforeDotExpr = this.visit(ctx.expr15());
                        const afterDotExpr = this.visit(ctx.expr16());
                        return dotJoin(beforeDotExpr, afterDotExpr);
                      }
                      if (ctx.LEFT_SQUARE_TOK()) {
                        const beforeBracesName = this.visit(ctx.name());
                        const insideBracesExprs = this.visit(ctx.exprList());
                        results.push(["**UNIMPLEMENTED** _[_]"]);
                        return results;
                      }
                      return this.visitChildren(ctx);
                    }
                    visitExpr16(ctx) {
                      let results = [];
                      if (ctx.PRIME_TOK()) {
                        const leftChildValue = this.visit(ctx.expr16());
                        results.push(["**UNIMPLEMENTED** Primed Expression _'"]);
                        return results;
                      }
                      return this.visitChildren(ctx);
                    }
                    visitExpr17(ctx) {
                      let results = [];
                      if (ctx.GET_LABEL_TOK() || ctx.GET_LABEL_STR_TOK() || ctx.GET_LABEL_BOOL_TOK() || ctx.GET_LABEL_NUM_TOK()) {
                        const innerExpr = ctx.expr17();
                        if (!innerExpr) {
                          throw new Error("Label operator requires an expression");
                        }
                        let convertFunction;
                        let operatorName;
                        if (ctx.GET_LABEL_TOK()) {
                          convertFunction = (value) => this.getLabelAsString(value);
                          operatorName = "@:";
                        } else if (ctx.GET_LABEL_STR_TOK()) {
                          convertFunction = (value) => this.getLabelAsString(value);
                          operatorName = "@str:";
                        } else if (ctx.GET_LABEL_BOOL_TOK()) {
                          convertFunction = (value) => this.getLabelAsBoolean(value);
                          operatorName = "@bool:";
                        } else if (ctx.GET_LABEL_NUM_TOK()) {
                          convertFunction = (value) => this.getLabelAsNumber(value);
                          operatorName = "@num:";
                        } else {
                          throw new Error("Unknown label operator");
                        }
                        try {
                          const innerResult = this.visit(innerExpr);
                          if (isTupleArray(innerResult) && innerResult.length === 0) {
                            let text = innerExpr.text;
                            if (text.startsWith("(") && text.endsWith(")")) {
                              text = text.slice(1, -1);
                            }
                            try {
                              return convertFunction(text);
                            } catch (error) {
                              return text;
                            }
                          }
                          if (isSingleValue2(innerResult)) {
                            return convertFunction(innerResult);
                          } else if (isTupleArray(innerResult)) {
                            if (innerResult.length === 1 && innerResult[0].length === 1) {
                              return convertFunction(innerResult[0][0]);
                            }
                            return innerResult.map((tuple) => tuple.map((value) => convertFunction(value)));
                          }
                          throw new Error(`${operatorName} operator can only be applied to single values or tuple arrays`);
                        } catch (error) {
                          if (error instanceof NameNotFoundError) {
                            let identifierText = innerExpr.text;
                            if (identifierText.startsWith("(") && identifierText.endsWith(")")) {
                              identifierText = identifierText.slice(1, -1);
                            }
                            try {
                              return convertFunction(identifierText);
                            } catch (conversionError) {
                              return identifierText;
                            }
                          }
                          throw error;
                        }
                      }
                      const childrenResults = this.visitChildren(ctx);
                      if (ctx.TILDE_TOK()) {
                        if (isTupleArray(childrenResults) && childrenResults.length > 0 && childrenResults[0].length === 2) {
                          return childrenResults.map((tuple) => [tuple[1], tuple[0]]);
                        }
                        throw new Error("expected the expression provided to ~ to have arity 2; bad arity received!");
                      }
                      if (ctx.EXP_TOK()) {
                        if (isTupleArray(childrenResults)) {
                          return transitiveClosure(childrenResults);
                        }
                        throw new Error("transitive closure ^ expected a relation of arity 2, not a singular value!");
                      }
                      if (ctx.STAR_TOK()) {
                        if (isTupleArray(childrenResults)) {
                          const transitiveClosureResult = transitiveClosure(childrenResults);
                          const idenResult = this.getIden();
                          return deduplicateTuples([...idenResult, ...transitiveClosureResult]);
                        }
                      }
                      return childrenResults;
                    }
                    // helper function to get a list of names from a nameList
                    getNameListValues(ctx) {
                      if (ctx.COMMA_TOK()) {
                        const headValue = ctx.name().text;
                        const tailValues = this.getNameListValues(ctx.nameList());
                        return [headValue, ...tailValues];
                      } else {
                        return [ctx.name().text];
                      }
                    }
                    // helper function to get the values each var is bound to in a single quantDecl
                    getQuantDeclValues(ctx) {
                      const nameList = ctx.nameList();
                      const names = this.getNameListValues(nameList);
                      const quantExpr = ctx.expr();
                      let exprValue = this.visitExpr(quantExpr);
                      if (isSingleValue2(exprValue)) {
                        exprValue = [[exprValue]];
                      }
                      const quantDeclValues = {};
                      for (const name of names) {
                        quantDeclValues[name] = exprValue;
                      }
                      return quantDeclValues;
                    }
                    // helper function to get the values each var is bound to in a quantDeclList
                    getQuantDeclListValues(ctx) {
                      if (ctx.COMMA_TOK()) {
                        const head = ctx.quantDecl();
                        const tail = ctx.quantDeclList();
                        if (tail === void 0) {
                          throw new Error("expected a quantDeclList after the comma");
                        }
                        const headValue = this.getQuantDeclValues(head);
                        const tailValues = this.getQuantDeclListValues(tail);
                        return { ...headValue, ...tailValues };
                      } else {
                        return this.getQuantDeclValues(ctx.quantDecl());
                      }
                    }
                    visitExpr18(ctx) {
                      let results = [];
                      if (ctx.const()) {
                        const constant = ctx.const();
                        if (constant.number() !== void 0) {
                          const num3 = Number(constant.number().text);
                          const value = constant.MINUS_TOK() !== void 0 ? -num3 : num3;
                          return value;
                        }
                        if (constant.text === "true") {
                          return true;
                        }
                        if (constant.text === "false") {
                          return false;
                        }
                        return `${constant.text}`;
                      }
                      if (ctx.qualName()) {
                        return this.visitQualName(ctx.qualName());
                      }
                      if (ctx.AT_TOK()) {
                        throw new Error("`@` operator is Alloy specific; it is not supported by Forge!");
                      }
                      if (ctx.BACKQUOTE_TOK()) {
                        const name = this.visitChildren(ctx);
                        results.push(["**UNIMPLEMENTED** Backquoted Name (`` `x` ``)"]);
                        return results;
                      }
                      if (ctx.THIS_TOK()) {
                        throw new Error("`this` is Alloy specific; it is not supported by Forge!");
                      }
                      if (ctx.LEFT_CURLY_TOK()) {
                        if (ctx.quantDeclList() === void 0) {
                          throw new Error("expected a quantDeclList in the set comprehension!");
                        }
                        const quantifierFreeVars = this.freeVariableFinder.visit(ctx);
                        this.updateFreeVariables(quantifierFreeVars);
                        const varQuantifiedSets = this.getQuantDeclListValues(ctx.quantDeclList());
                        const blockOrBar = ctx.blockOrBar();
                        if (blockOrBar === void 0) {
                          throw new Error("expected a blockOrBar in the set comprehension!");
                        }
                        if (blockOrBar.BAR_TOK() === void 0 || blockOrBar.expr() === void 0) {
                          throw new Error("expected a bar followed by an expr in the set comprehension!");
                        }
                        const barExpr = blockOrBar.expr();
                        const varNames = [];
                        const quantifiedSets = [];
                        for (const varName in varQuantifiedSets) {
                          varNames.push(varName);
                          quantifiedSets.push(varQuantifiedSets[varName]);
                        }
                        const product = getCombinations(quantifiedSets);
                        const result = [];
                        for (let i = 0; i < product.length; i++) {
                          const tuple = product[i];
                          const quantDeclEnv = {
                            env: {},
                            type: "quantDecl"
                          };
                          for (let j = 0; j < varNames.length; j++) {
                            const varName = varNames[j];
                            const varValue = tuple[j];
                            quantDeclEnv.env[varName] = varValue;
                          }
                          this.environmentStack.push(quantDeclEnv);
                          const barExprValue = this.visit(barExpr);
                          if (!isBoolean2(barExprValue)) {
                            throw new Error("Expected the expression after the bar to be a boolean value!");
                          }
                          if (barExprValue) {
                            result.push(tuple);
                          }
                          this.environmentStack.pop();
                        }
                        return result;
                      }
                      if (ctx.LEFT_PAREN_TOK()) {
                        return this.visit(ctx.expr());
                      }
                      if (ctx.block()) {
                        return this.visitBlock(ctx.block());
                      }
                      if (ctx.sexpr()) {
                        throw new Error("**NOT IMPLEMENTING FOR NOW** S-Expression");
                      }
                      return this.visitChildren(ctx);
                    }
                    visitExprList(ctx) {
                      let results = [];
                      if (ctx.COMMA_TOK()) {
                        const headValue = this.visit(ctx.expr());
                        if (ctx.exprList() === void 0) {
                          throw new Error("exprList with a comma must have a tail!");
                        }
                        const tailValues = this.visit(ctx.exprList());
                        if (isSingleValue2(headValue)) {
                          results.push([headValue]);
                        } else {
                          results = headValue;
                        }
                        if (isTupleArray(tailValues)) {
                          results = results.concat(tailValues);
                        } else {
                          results.push([tailValues]);
                        }
                        return results;
                      }
                      return this.visitChildren(ctx);
                    }
                    visitName(ctx) {
                      const identifier = ctx.IDENTIFIER_TOK().text;
                      if (identifier === "true") {
                        return true;
                      }
                      if (identifier === "false") {
                        return false;
                      }
                      for (let i = this.environmentStack.length - 1; i >= 0; i--) {
                        const currEnv = this.environmentStack[i];
                        if (currEnv.env[identifier] !== void 0) {
                          return currEnv.env[identifier];
                        }
                        if (currEnv.type === "predArgs") {
                          break;
                        }
                      }
                      let result = void 0;
                      const typeNames = this.instanceData.getTypes().map((t) => t.id);
                      if (typeNames.includes(identifier)) {
                        const typeAtoms = this.instanceData.getTypes().find((t) => t.id === identifier)?.atoms || [];
                        const desiredValues = typeAtoms.map((atom) => atom.id);
                        result = desiredValues.map((singleValue) => [singleValue]);
                      }
                      for (const typeObj of this.instanceData.getTypes()) {
                        const atomIds = typeObj.atoms.map((atom) => atom.id);
                        if (atomIds.includes(identifier)) {
                          result = [[identifier]];
                          break;
                        }
                      }
                      const instanceTypeIds = this.instanceData.getTypes().map((t) => t.id);
                      const toSearch = [identifier];
                      const visited = /* @__PURE__ */ new Set();
                      while (toSearch.length > 0) {
                        const currSearch = toSearch.pop();
                        if (currSearch === void 0) {
                          throw new Error("unexpected error: no identifier could be searched!");
                        }
                        if (visited.has(currSearch))
                          continue;
                        visited.add(currSearch);
                        for (const typeObj of this.instanceData.getTypes()) {
                          if (typeObj.id === currSearch)
                            continue;
                          if (typeObj.types && typeObj.types.includes(currSearch)) {
                            if (result === void 0)
                              result = [];
                            for (const atom of typeObj.atoms) {
                              result.push([atom.id]);
                            }
                            toSearch.push(typeObj.id);
                          }
                        }
                      }
                      const isConvertibleToNumber = (value) => {
                        if (typeof value === "number") {
                          return true;
                        }
                        if (typeof value === "string") {
                          return !isNaN(Number(value));
                        }
                        return false;
                      };
                      const isConvertibleToBoolean = (value) => {
                        if (typeof value === "boolean") {
                          return true;
                        }
                        if (typeof value === "string") {
                          return value === "true" || value === "#t" || value === "false" || value === "#f";
                        }
                        return false;
                      };
                      const convertToBoolean = (value) => {
                        if (typeof value === "boolean") {
                          return value;
                        }
                        if (value === "true" || value === "#t") {
                          return true;
                        }
                        if (value === "false" || value === "#f") {
                          return false;
                        }
                        throw new Error(`Cannot convert ${value} to boolean`);
                      };
                      const relations = this.instanceData.getRelations();
                      for (const relation of relations) {
                        if (relation.name === identifier) {
                          let relationAtoms = relation.tuples.map((tuple) => tuple.atoms);
                          relationAtoms = relationAtoms.map((tuple) => tuple.map((value) => isConvertibleToNumber(value) ? Number(value) : value));
                          relationAtoms = relationAtoms.map((tuple) => tuple.map((value) => isConvertibleToBoolean(value) ? convertToBoolean(value) : value));
                          return relationAtoms;
                        }
                      }
                      if (result !== void 0) {
                        result = result.map((tuple) => tuple.map((value) => isConvertibleToNumber(value) ? Number(value) : value));
                        result = result.map((tuple) => tuple.map((value) => isConvertibleToBoolean(value) ? convertToBoolean(value) : value));
                        return result;
                      }
                      if (exports2.SUPPORTED_BUILTINS.includes(identifier)) {
                        return identifier;
                      }
                      const labelLikePattern = /^[a-z]{3,10}$/;
                      if (labelLikePattern.test(identifier)) {
                        return identifier;
                      }
                      throw new NameNotFoundError(`bad name ${identifier} referenced!`);
                    }
                    visitQualName(ctx) {
                      if (ctx.INT_TOK()) {
                        const intType = this.instanceData.getTypes().find((t) => t.id === "Int");
                        if (!intType) {
                          throw new Error('Type "Int" not found in instance data');
                        }
                        const intVals = intType.atoms.map((atom) => [Number(atom.id)]);
                        return intVals;
                      }
                      return this.visitChildren(ctx);
                    }
                    evaluateBinaryOperation(operation, args) {
                      if (isSingleValue2(args)) {
                        throw new Error(`Expected 2 arguments for ${operation}`);
                      }
                      let arg1;
                      if ((0, lodash_1.isArray)(args[0])) {
                        if (!isNumber(args[0][0])) {
                          throw new Error(`Expected a number for the first argument of ${operation}`);
                        }
                        arg1 = args[0][0];
                      } else {
                        if (!isNumber(args[0])) {
                          throw new Error(`Expected a number for the first argument of ${operation}`);
                        }
                        arg1 = args[0];
                      }
                      let arg2;
                      if ((0, lodash_1.isArray)(args[1])) {
                        if (!isNumber(args[1][0])) {
                          throw new Error(`Expected a number for the second argument of ${operation}`);
                        }
                        arg2 = args[1][0];
                      } else {
                        if (!isNumber(args[1])) {
                          throw new Error(`Expected a number for the second argument of ${operation}`);
                        }
                        arg2 = args[1];
                      }
                      if ((operation === "divide" || operation === "remainder") && arg2 === 0) {
                        throw new Error("Division by zero is not allowed");
                      }
                      let result;
                      switch (operation) {
                        case "add":
                          result = arg1 + arg2;
                          break;
                        case "subtract":
                          result = arg1 - arg2;
                          break;
                        case "multiply":
                          result = arg1 * arg2;
                          break;
                        case "divide":
                          result = Math.floor(arg1 / arg2);
                          break;
                        case "remainder":
                          result = arg1 % arg2;
                          break;
                        default:
                          throw new Error(`Unsupported operation: ${operation}`);
                      }
                      return result;
                    }
                    evaluateUnaryOperation(operation, args) {
                      if (!isSingleValue2(args) || !isNumber(args)) {
                        throw new Error(`Expected 1 argument for ${operation} that evaluates to a number.`);
                      }
                      let v = args;
                      if (operation === "abs") {
                        let res = Math.abs(v);
                        return res;
                      } else if (operation === "sign") {
                        if (v > 0) {
                          return 1;
                        } else if (v < 0) {
                          return -1;
                        } else {
                          return 0;
                        }
                      } else {
                        throw new Error(`Unsupported operation: ${operation}`);
                      }
                    }
                  }
                  exports2.ForgeExprEvaluator = ForgeExprEvaluator;
                  class NameNotFoundError extends Error {
                    constructor(message) {
                      super(message);
                      this.name = "NameNotFoundError";
                    }
                  }
                  exports2.NameNotFoundError = NameNotFoundError;
                }
              ),
              /***/
              "./src/ForgeExprFreeVariableFinder.ts": (
                /*!********************************************!*\
                  !*** ./src/ForgeExprFreeVariableFinder.ts ***!
                  \********************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ForgeExprFreeVariableFinder = void 0;
                  const AbstractParseTreeVisitor_1 = __webpack_require__2(
                    /*! antlr4ts/tree/AbstractParseTreeVisitor */
                    "./node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js"
                  );
                  const ForgeExprEvaluator_1 = __webpack_require__2(
                    /*! ./ForgeExprEvaluator */
                    "./src/ForgeExprEvaluator.ts"
                  );
                  function getAllFreeVariables(freeVariables) {
                    const allVariables = /* @__PURE__ */ new Set();
                    for (const variables of freeVariables.values()) {
                      for (const variable of variables) {
                        allVariables.add(variable);
                      }
                    }
                    return allVariables;
                  }
                  class ForgeExprFreeVariableFinder extends AbstractParseTreeVisitor_1.AbstractParseTreeVisitor {
                    constructor(instanceData) {
                      super();
                      this.instanceData = instanceData;
                    }
                    aggregateResult(aggregate, nextResult) {
                      if (!aggregate) {
                        return nextResult;
                      }
                      if (!nextResult) {
                        return aggregate;
                      }
                      for (const [contextNode, variables] of nextResult.entries()) {
                        if (!aggregate.has(contextNode)) {
                          aggregate.set(contextNode, /* @__PURE__ */ new Set());
                        }
                        const existingVariables = aggregate.get(contextNode);
                        for (const variable of variables) {
                          existingVariables.add(variable);
                        }
                      }
                      return aggregate;
                    }
                    addCtxToFreeVariableMap(ctx, freeVariables, additionalVars) {
                      if (!freeVariables.has(ctx)) {
                        freeVariables.set(ctx, getAllFreeVariables(freeVariables));
                      }
                      const variables = freeVariables.get(ctx);
                      if (additionalVars !== void 0) {
                        for (const variable in additionalVars) {
                          variables.add(variable);
                        }
                      }
                      return freeVariables;
                    }
                    defaultResult() {
                      return /* @__PURE__ */ new Map();
                    }
                    visitPredDecl(ctx) {
                      const visitResult = this.visit(ctx.block());
                      return this.addCtxToFreeVariableMap(ctx, visitResult);
                    }
                    visitBlock(ctx) {
                      let result = this.defaultResult();
                      for (const expr of ctx.expr()) {
                        const exprResult = this.visit(expr);
                        result = this.aggregateResult(result, exprResult);
                      }
                      return this.addCtxToFreeVariableMap(ctx, result);
                    }
                    // helper function to get a list of names from a nameList
                    getNameListValues(ctx) {
                      if (ctx.COMMA_TOK()) {
                        const headValue = ctx.name().text;
                        const tailValues = this.getNameListValues(ctx.nameList());
                        tailValues.add(headValue);
                        return tailValues;
                      } else {
                        return /* @__PURE__ */ new Set([ctx.name().text]);
                      }
                    }
                    // helper function to get the names of each var in a quantDecl
                    getQuantDeclVarNames(ctx) {
                      const nameList = ctx.nameList();
                      return this.getNameListValues(nameList);
                    }
                    // helper function to get the values each var is bound to in a quantDeclList
                    getQuantDeclListVarNames(ctx) {
                      if (ctx.COMMA_TOK()) {
                        const head = ctx.quantDecl();
                        const tail = ctx.quantDeclList();
                        if (tail === void 0) {
                          throw new Error("expected a quantDeclList after the comma");
                        }
                        const headValue = this.getQuantDeclVarNames(head);
                        const tailValues = this.getQuantDeclListVarNames(tail);
                        for (const variable of headValue) {
                          tailValues.add(variable);
                        }
                        return tailValues;
                      } else {
                        return this.getQuantDeclVarNames(ctx.quantDecl());
                      }
                    }
                    // helper function to add the current context to the list obtained from
                    // visiting children
                    visitExpr(ctx) {
                      if (ctx.LET_TOK()) {
                        throw new Error("**UNIMPLEMENTED**: Let binding not yet implemented");
                      }
                      if (ctx.BIND_TOK()) {
                        throw new Error("**NOT IMPLEMENTING FOR NOW**: Bind Expression");
                      }
                      if (ctx.quant()) {
                        if (ctx.quantDeclList() === void 0) {
                          throw new Error("Expected the quantifier to have a quantDeclList");
                        }
                        const quantDeclListVars = this.getQuantDeclListVarNames(ctx.quantDeclList());
                        const blockOrBar = ctx.blockOrBar();
                        if (blockOrBar === void 0) {
                          throw new Error("expected to quantify over something!");
                        }
                        if (blockOrBar.BAR_TOK() === void 0 || blockOrBar.expr() === void 0) {
                          throw new Error("Expected the quantifier to have a bar followed by an expr!");
                        }
                        let allFreeVars;
                        if (blockOrBar.block() !== void 0) {
                          allFreeVars = this.visit(blockOrBar.block());
                        } else {
                          allFreeVars = this.visit(blockOrBar.expr());
                        }
                        const allVars = getAllFreeVariables(allFreeVars);
                        const filteredVariables = /* @__PURE__ */ new Set();
                        for (const variable of allVars) {
                          if (!quantDeclListVars.has(variable)) {
                            filteredVariables.add(variable);
                          }
                        }
                        allFreeVars.set(ctx, filteredVariables);
                        return allFreeVars;
                      }
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr1(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr1_5(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr2(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr3(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr4(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr4_5(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr5(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr6(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr7(ctx) {
                      const childrenResults = this.visit(ctx.expr8());
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr8(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr9(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr10(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr11(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr12(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr13(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr14(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr15(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr16(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr17(ctx) {
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExpr18(ctx) {
                      if (ctx.LEFT_CURLY_TOK()) {
                        if (ctx.quantDeclList() === void 0) {
                          throw new Error("expected a quantDeclList in the set comprehension!");
                        }
                        const quantDeclListVars = this.getQuantDeclListVarNames(ctx.quantDeclList());
                        const blockOrBar = ctx.blockOrBar();
                        if (blockOrBar === void 0) {
                          throw new Error("expected a blockOrBar in the set comprehension!");
                        }
                        if (blockOrBar.BAR_TOK() === void 0 || blockOrBar.expr() === void 0) {
                          throw new Error("expected a bar followed by an expr in the set comprehension!");
                        }
                        let allFreeVars;
                        if (blockOrBar.block() !== void 0) {
                          allFreeVars = this.visit(blockOrBar.block());
                        } else {
                          allFreeVars = this.visit(blockOrBar.expr());
                        }
                        const allVars = getAllFreeVariables(allFreeVars);
                        const filteredVariables = /* @__PURE__ */ new Set();
                        for (const variable of allVars) {
                          if (!quantDeclListVars.has(variable)) {
                            filteredVariables.add(variable);
                          }
                        }
                        allFreeVars.set(ctx, filteredVariables);
                        return allFreeVars;
                      }
                      const childrenResults = this.visitChildren(ctx);
                      return this.addCtxToFreeVariableMap(ctx, childrenResults);
                    }
                    visitExprList(ctx) {
                      let result = this.defaultResult();
                      if (ctx.COMMA_TOK()) {
                        if (ctx.exprList() === void 0) {
                          throw new Error("exprList with a comma must have a tail!");
                        }
                        const headFreeVars = this.visit(ctx.expr());
                        const tailFreeVars = this.visit(ctx.exprList());
                        result = this.aggregateResult(result, headFreeVars);
                        result = this.aggregateResult(result, tailFreeVars);
                      } else {
                        const exprFreeVars = this.visit(ctx.expr());
                        result = this.aggregateResult(result, exprFreeVars);
                      }
                      return this.addCtxToFreeVariableMap(ctx, result);
                    }
                    visitName(ctx) {
                      const identifier = ctx.IDENTIFIER_TOK().text;
                      if (identifier === "true" || identifier === "false") {
                        return this.defaultResult();
                      }
                      const typeNames = this.instanceData.getTypes().map((t) => t.id);
                      if (typeNames.includes(identifier)) {
                        return this.defaultResult();
                      }
                      for (const typeObj of this.instanceData.getTypes()) {
                        const atomIds = typeObj.atoms.map((atom) => atom.id);
                        if (atomIds.includes(identifier)) {
                          return this.defaultResult();
                        }
                      }
                      for (const relation of this.instanceData.getRelations()) {
                        if (relation.name === identifier) {
                          return this.defaultResult();
                        }
                      }
                      if (ForgeExprEvaluator_1.SUPPORTED_BUILTINS.includes(identifier)) {
                        return this.defaultResult();
                      }
                      const freeVariables = this.defaultResult();
                      freeVariables.set(ctx, /* @__PURE__ */ new Set([identifier]));
                      return freeVariables;
                    }
                  }
                  exports2.ForgeExprFreeVariableFinder = ForgeExprFreeVariableFinder;
                }
              ),
              /***/
              "./src/errorListener.ts": (
                /*!******************************!*\
                  !*** ./src/errorListener.ts ***!
                  \******************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ParseErrorListener = void 0;
                  class ParseErrorListener {
                    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
                      throw new Error(`Parse error at ${line}:${charPositionInLine}: ${msg}`);
                    }
                  }
                  exports2.ParseErrorListener = ParseErrorListener;
                }
              ),
              /***/
              "./src/forge-antlr/ForgeLexer.ts": (
                /*!***************************************!*\
                  !*** ./src/forge-antlr/ForgeLexer.ts ***!
                  \***************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === void 0) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                      desc = { enumerable: true, get: function() {
                        return m[k];
                      } };
                    }
                    Object.defineProperty(o, k2, desc);
                  } : function(o, m, k, k2) {
                    if (k2 === void 0) k2 = k;
                    o[k2] = m[k];
                  });
                  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                    Object.defineProperty(o, "default", { enumerable: true, value: v });
                  } : function(o, v) {
                    o["default"] = v;
                  });
                  var __importStar = this && this.__importStar || /* @__PURE__ */ function() {
                    var ownKeys = function(o) {
                      ownKeys = Object.getOwnPropertyNames || function(o2) {
                        var ar = [];
                        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
                        return ar;
                      };
                      return ownKeys(o);
                    };
                    return function(mod) {
                      if (mod && mod.__esModule) return mod;
                      var result = {};
                      if (mod != null) {
                        for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
                      }
                      __setModuleDefault(result, mod);
                      return result;
                    };
                  }();
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ForgeLexer = void 0;
                  const ATNDeserializer_1 = __webpack_require__2(
                    /*! antlr4ts/atn/ATNDeserializer */
                    "./node_modules/antlr4ts/atn/ATNDeserializer.js"
                  );
                  const Lexer_1 = __webpack_require__2(
                    /*! antlr4ts/Lexer */
                    "./node_modules/antlr4ts/Lexer.js"
                  );
                  const LexerATNSimulator_1 = __webpack_require__2(
                    /*! antlr4ts/atn/LexerATNSimulator */
                    "./node_modules/antlr4ts/atn/LexerATNSimulator.js"
                  );
                  const VocabularyImpl_1 = __webpack_require__2(
                    /*! antlr4ts/VocabularyImpl */
                    "./node_modules/antlr4ts/VocabularyImpl.js"
                  );
                  const Utils = __importStar(__webpack_require__2(
                    /*! antlr4ts/misc/Utils */
                    "./node_modules/antlr4ts/misc/Utils.js"
                  ));
                  class ForgeLexer extends Lexer_1.Lexer {
                    // @Override
                    // @NotNull
                    get vocabulary() {
                      return ForgeLexer.VOCABULARY;
                    }
                    // tslint:enable:no-trailing-whitespace
                    constructor(input) {
                      super(input);
                      this._interp = new LexerATNSimulator_1.LexerATNSimulator(ForgeLexer._ATN, this);
                    }
                    // @Override
                    get grammarFileName() {
                      return "ForgeLexer.g4";
                    }
                    // @Override
                    get ruleNames() {
                      return ForgeLexer.ruleNames;
                    }
                    // @Override
                    get serializedATN() {
                      return ForgeLexer._serializedATN;
                    }
                    // @Override
                    get channelNames() {
                      return ForgeLexer.channelNames;
                    }
                    // @Override
                    get modeNames() {
                      return ForgeLexer.modeNames;
                    }
                    static get _ATN() {
                      if (!ForgeLexer.__ATN) {
                        ForgeLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(ForgeLexer._serializedATN));
                      }
                      return ForgeLexer.__ATN;
                    }
                  }
                  exports2.ForgeLexer = ForgeLexer;
                  ForgeLexer.OPEN_TOK = 1;
                  ForgeLexer.LEFT_SQUARE_TOK = 2;
                  ForgeLexer.RIGHT_SQUARE_TOK = 3;
                  ForgeLexer.AS_TOK = 4;
                  ForgeLexer.FILE_PATH_TOK = 5;
                  ForgeLexer.VAR_TOK = 6;
                  ForgeLexer.ABSTRACT_TOK = 7;
                  ForgeLexer.SIG_TOK = 8;
                  ForgeLexer.LEFT_CURLY_TOK = 9;
                  ForgeLexer.RIGHT_CURLY_TOK = 10;
                  ForgeLexer.EXTENDS_TOK = 11;
                  ForgeLexer.IN_TOK = 12;
                  ForgeLexer.PLUS_TOK = 13;
                  ForgeLexer.LONE_TOK = 14;
                  ForgeLexer.SOME_TOK = 15;
                  ForgeLexer.ONE_TOK = 16;
                  ForgeLexer.TWO_TOK = 17;
                  ForgeLexer.SET_TOK = 18;
                  ForgeLexer.FUNC_TOK = 19;
                  ForgeLexer.PFUNC_TOK = 20;
                  ForgeLexer.DISJ_TOK = 21;
                  ForgeLexer.COLON_TOK = 22;
                  ForgeLexer.WHEAT_TOK = 23;
                  ForgeLexer.PRED_TOK = 24;
                  ForgeLexer.DOT_TOK = 25;
                  ForgeLexer.FUN_TOK = 26;
                  ForgeLexer.LEFT_PAREN_TOK = 27;
                  ForgeLexer.RIGHT_PAREN_TOK = 28;
                  ForgeLexer.ASSERT_TOK = 29;
                  ForgeLexer.RUN_TOK = 30;
                  ForgeLexer.CHECK_TOK = 31;
                  ForgeLexer.FOR_TOK = 32;
                  ForgeLexer.BUT_TOK = 33;
                  ForgeLexer.EXACTLY_TOK = 34;
                  ForgeLexer.NONE_TOK = 35;
                  ForgeLexer.UNIV_TOK = 36;
                  ForgeLexer.IDEN_TOK = 37;
                  ForgeLexer.MINUS_TOK = 38;
                  ForgeLexer.IS_TOK = 39;
                  ForgeLexer.SAT_TOK = 40;
                  ForgeLexer.UNSAT_TOK = 41;
                  ForgeLexer.THEOREM_TOK = 42;
                  ForgeLexer.FORGE_ERROR_TOK = 43;
                  ForgeLexer.CHECKED_TOK = 44;
                  ForgeLexer.TEST_TOK = 45;
                  ForgeLexer.EXPECT_TOK = 46;
                  ForgeLexer.SUITE_TOK = 47;
                  ForgeLexer.BAR_TOK = 48;
                  ForgeLexer.ALL_TOK = 49;
                  ForgeLexer.SUFFICIENT_TOK = 50;
                  ForgeLexer.NECESSARY_TOK = 51;
                  ForgeLexer.CONSISTENT_TOK = 52;
                  ForgeLexer.INCONSISTENT_TOK = 53;
                  ForgeLexer.WITH_TOK = 54;
                  ForgeLexer.LET_TOK = 55;
                  ForgeLexer.BIND_TOK = 56;
                  ForgeLexer.OR_TOK = 57;
                  ForgeLexer.XOR_TOK = 58;
                  ForgeLexer.IFF_TOK = 59;
                  ForgeLexer.IMP_TOK = 60;
                  ForgeLexer.ELSE_TOK = 61;
                  ForgeLexer.AND_TOK = 62;
                  ForgeLexer.UNTIL_TOK = 63;
                  ForgeLexer.RELEASE_TOK = 64;
                  ForgeLexer.SINCE_TOK = 65;
                  ForgeLexer.TRIGGERED_TOK = 66;
                  ForgeLexer.NEG_TOK = 67;
                  ForgeLexer.ALWAYS_TOK = 68;
                  ForgeLexer.EVENTUALLY_TOK = 69;
                  ForgeLexer.AFTER_TOK = 70;
                  ForgeLexer.BEFORE_TOK = 71;
                  ForgeLexer.ONCE_TOK = 72;
                  ForgeLexer.HISTORICALLY_TOK = 73;
                  ForgeLexer.CARD_TOK = 74;
                  ForgeLexer.PPLUS_TOK = 75;
                  ForgeLexer.AMP_TOK = 76;
                  ForgeLexer.SUBT_TOK = 77;
                  ForgeLexer.SUPT_TOK = 78;
                  ForgeLexer.PRIME_TOK = 79;
                  ForgeLexer.TILDE_TOK = 80;
                  ForgeLexer.EXP_TOK = 81;
                  ForgeLexer.STAR_TOK = 82;
                  ForgeLexer.AT_TOK = 83;
                  ForgeLexer.BACKQUOTE_TOK = 84;
                  ForgeLexer.THIS_TOK = 85;
                  ForgeLexer.SEXPR_TOK = 86;
                  ForgeLexer.INST_TOK = 87;
                  ForgeLexer.EVAL_TOK = 88;
                  ForgeLexer.EXAMPLE_TOK = 89;
                  ForgeLexer.ARROW_TOK = 90;
                  ForgeLexer.GET_LABEL_TOK = 91;
                  ForgeLexer.GET_LABEL_STR_TOK = 92;
                  ForgeLexer.GET_LABEL_BOOL_TOK = 93;
                  ForgeLexer.GET_LABEL_NUM_TOK = 94;
                  ForgeLexer.EQ_TOK = 95;
                  ForgeLexer.LT_TOK = 96;
                  ForgeLexer.GT_TOK = 97;
                  ForgeLexer.LEQ_TOK = 98;
                  ForgeLexer.GEQ_TOK = 99;
                  ForgeLexer.NI_TOK = 100;
                  ForgeLexer.NO_TOK = 101;
                  ForgeLexer.SUM_TOK = 102;
                  ForgeLexer.INT_TOK = 103;
                  ForgeLexer.OPTION_TOK = 104;
                  ForgeLexer.COMMA_TOK = 105;
                  ForgeLexer.SLASH_TOK = 106;
                  ForgeLexer.NUM_CONST_TOK = 107;
                  ForgeLexer.IDENTIFIER_TOK = 108;
                  ForgeLexer.WS = 109;
                  ForgeLexer.CCOMMENT = 110;
                  ForgeLexer.COMMENT = 111;
                  ForgeLexer.MULTCOMMENT = 112;
                  ForgeLexer.LANG_DECL = 113;
                  ForgeLexer.channelNames = [
                    "DEFAULT_TOKEN_CHANNEL",
                    "HIDDEN"
                  ];
                  ForgeLexer.modeNames = [
                    "DEFAULT_MODE"
                  ];
                  ForgeLexer.ruleNames = [
                    "OPEN_TOK",
                    "LEFT_SQUARE_TOK",
                    "RIGHT_SQUARE_TOK",
                    "AS_TOK",
                    "FILE_PATH_TOK",
                    "VAR_TOK",
                    "ABSTRACT_TOK",
                    "SIG_TOK",
                    "LEFT_CURLY_TOK",
                    "RIGHT_CURLY_TOK",
                    "EXTENDS_TOK",
                    "IN_TOK",
                    "PLUS_TOK",
                    "LONE_TOK",
                    "SOME_TOK",
                    "ONE_TOK",
                    "TWO_TOK",
                    "SET_TOK",
                    "FUNC_TOK",
                    "PFUNC_TOK",
                    "DISJ_TOK",
                    "COLON_TOK",
                    "WHEAT_TOK",
                    "PRED_TOK",
                    "DOT_TOK",
                    "FUN_TOK",
                    "LEFT_PAREN_TOK",
                    "RIGHT_PAREN_TOK",
                    "ASSERT_TOK",
                    "RUN_TOK",
                    "CHECK_TOK",
                    "FOR_TOK",
                    "BUT_TOK",
                    "EXACTLY_TOK",
                    "NONE_TOK",
                    "UNIV_TOK",
                    "IDEN_TOK",
                    "MINUS_TOK",
                    "IS_TOK",
                    "SAT_TOK",
                    "UNSAT_TOK",
                    "THEOREM_TOK",
                    "FORGE_ERROR_TOK",
                    "CHECKED_TOK",
                    "TEST_TOK",
                    "EXPECT_TOK",
                    "SUITE_TOK",
                    "BAR_TOK",
                    "ALL_TOK",
                    "SUFFICIENT_TOK",
                    "NECESSARY_TOK",
                    "CONSISTENT_TOK",
                    "INCONSISTENT_TOK",
                    "WITH_TOK",
                    "LET_TOK",
                    "BIND_TOK",
                    "OR_TOK",
                    "XOR_TOK",
                    "IFF_TOK",
                    "IMP_TOK",
                    "ELSE_TOK",
                    "AND_TOK",
                    "UNTIL_TOK",
                    "RELEASE_TOK",
                    "SINCE_TOK",
                    "TRIGGERED_TOK",
                    "NEG_TOK",
                    "ALWAYS_TOK",
                    "EVENTUALLY_TOK",
                    "AFTER_TOK",
                    "BEFORE_TOK",
                    "ONCE_TOK",
                    "HISTORICALLY_TOK",
                    "CARD_TOK",
                    "PPLUS_TOK",
                    "AMP_TOK",
                    "SUBT_TOK",
                    "SUPT_TOK",
                    "PRIME_TOK",
                    "TILDE_TOK",
                    "EXP_TOK",
                    "STAR_TOK",
                    "AT_TOK",
                    "BACKQUOTE_TOK",
                    "THIS_TOK",
                    "SEXPR_TOK",
                    "INST_TOK",
                    "EVAL_TOK",
                    "EXAMPLE_TOK",
                    "ARROW_TOK",
                    "GET_LABEL_TOK",
                    "GET_LABEL_STR_TOK",
                    "GET_LABEL_BOOL_TOK",
                    "GET_LABEL_NUM_TOK",
                    "EQ_TOK",
                    "LT_TOK",
                    "GT_TOK",
                    "LEQ_TOK",
                    "GEQ_TOK",
                    "NI_TOK",
                    "NO_TOK",
                    "SUM_TOK",
                    "INT_TOK",
                    "OPTION_TOK",
                    "COMMA_TOK",
                    "SLASH_TOK",
                    "NUM_CONST_TOK",
                    "IDENTIFIER_TOK",
                    "WS",
                    "CCOMMENT",
                    "COMMENT",
                    "MULTCOMMENT",
                    "LANG_DECL"
                  ];
                  ForgeLexer._LITERAL_NAMES = [
                    void 0,
                    "'open'",
                    "'['",
                    "']'",
                    "'as'",
                    void 0,
                    "'var'",
                    "'abstract'",
                    "'sig'",
                    "'{'",
                    "'}'",
                    "'extends'",
                    "'in'",
                    "'+'",
                    "'lone'",
                    "'some'",
                    "'one'",
                    "'two'",
                    "'set'",
                    "'func'",
                    "'pfunc'",
                    "'disj'",
                    "':'",
                    "'wheat'",
                    "'pred'",
                    "'.'",
                    "'fun'",
                    "'('",
                    "')'",
                    "'assert'",
                    "'run'",
                    "'check'",
                    "'for'",
                    "'but'",
                    "'exactly'",
                    "'none'",
                    "'univ'",
                    "'iden'",
                    "'-'",
                    "'is'",
                    "'sat'",
                    "'unsat'",
                    "'theorem'",
                    "'forge_error'",
                    "'checked'",
                    "'test'",
                    "'expect'",
                    "'suite'",
                    "'|'",
                    "'all'",
                    "'sufficient'",
                    "'necessary'",
                    "'consistent'",
                    "'inconsistent'",
                    "'with'",
                    "'let'",
                    "'bind'",
                    void 0,
                    "'xor'",
                    void 0,
                    void 0,
                    "'else'",
                    void 0,
                    "'until'",
                    "'release'",
                    "'since'",
                    "'triggered'",
                    void 0,
                    "'always'",
                    "'eventually'",
                    "'after'",
                    "'before'",
                    "'once'",
                    "'historically'",
                    "'#'",
                    "'++'",
                    "'&'",
                    "'<:'",
                    "':>'",
                    "'''",
                    "'~'",
                    "'^'",
                    "'*'",
                    "'@'",
                    "'`'",
                    "'this'",
                    "'sexpr'",
                    "'inst'",
                    "'eval'",
                    "'example'",
                    "'->'",
                    "'@:'",
                    "'@str:'",
                    "'@bool:'",
                    "'@num:'",
                    "'='",
                    "'<'",
                    "'>'",
                    void 0,
                    "'>='",
                    "'ni'",
                    "'no'",
                    "'sum'",
                    "'Int'",
                    "'option'",
                    "','",
                    "'/'"
                  ];
                  ForgeLexer._SYMBOLIC_NAMES = [
                    void 0,
                    "OPEN_TOK",
                    "LEFT_SQUARE_TOK",
                    "RIGHT_SQUARE_TOK",
                    "AS_TOK",
                    "FILE_PATH_TOK",
                    "VAR_TOK",
                    "ABSTRACT_TOK",
                    "SIG_TOK",
                    "LEFT_CURLY_TOK",
                    "RIGHT_CURLY_TOK",
                    "EXTENDS_TOK",
                    "IN_TOK",
                    "PLUS_TOK",
                    "LONE_TOK",
                    "SOME_TOK",
                    "ONE_TOK",
                    "TWO_TOK",
                    "SET_TOK",
                    "FUNC_TOK",
                    "PFUNC_TOK",
                    "DISJ_TOK",
                    "COLON_TOK",
                    "WHEAT_TOK",
                    "PRED_TOK",
                    "DOT_TOK",
                    "FUN_TOK",
                    "LEFT_PAREN_TOK",
                    "RIGHT_PAREN_TOK",
                    "ASSERT_TOK",
                    "RUN_TOK",
                    "CHECK_TOK",
                    "FOR_TOK",
                    "BUT_TOK",
                    "EXACTLY_TOK",
                    "NONE_TOK",
                    "UNIV_TOK",
                    "IDEN_TOK",
                    "MINUS_TOK",
                    "IS_TOK",
                    "SAT_TOK",
                    "UNSAT_TOK",
                    "THEOREM_TOK",
                    "FORGE_ERROR_TOK",
                    "CHECKED_TOK",
                    "TEST_TOK",
                    "EXPECT_TOK",
                    "SUITE_TOK",
                    "BAR_TOK",
                    "ALL_TOK",
                    "SUFFICIENT_TOK",
                    "NECESSARY_TOK",
                    "CONSISTENT_TOK",
                    "INCONSISTENT_TOK",
                    "WITH_TOK",
                    "LET_TOK",
                    "BIND_TOK",
                    "OR_TOK",
                    "XOR_TOK",
                    "IFF_TOK",
                    "IMP_TOK",
                    "ELSE_TOK",
                    "AND_TOK",
                    "UNTIL_TOK",
                    "RELEASE_TOK",
                    "SINCE_TOK",
                    "TRIGGERED_TOK",
                    "NEG_TOK",
                    "ALWAYS_TOK",
                    "EVENTUALLY_TOK",
                    "AFTER_TOK",
                    "BEFORE_TOK",
                    "ONCE_TOK",
                    "HISTORICALLY_TOK",
                    "CARD_TOK",
                    "PPLUS_TOK",
                    "AMP_TOK",
                    "SUBT_TOK",
                    "SUPT_TOK",
                    "PRIME_TOK",
                    "TILDE_TOK",
                    "EXP_TOK",
                    "STAR_TOK",
                    "AT_TOK",
                    "BACKQUOTE_TOK",
                    "THIS_TOK",
                    "SEXPR_TOK",
                    "INST_TOK",
                    "EVAL_TOK",
                    "EXAMPLE_TOK",
                    "ARROW_TOK",
                    "GET_LABEL_TOK",
                    "GET_LABEL_STR_TOK",
                    "GET_LABEL_BOOL_TOK",
                    "GET_LABEL_NUM_TOK",
                    "EQ_TOK",
                    "LT_TOK",
                    "GT_TOK",
                    "LEQ_TOK",
                    "GEQ_TOK",
                    "NI_TOK",
                    "NO_TOK",
                    "SUM_TOK",
                    "INT_TOK",
                    "OPTION_TOK",
                    "COMMA_TOK",
                    "SLASH_TOK",
                    "NUM_CONST_TOK",
                    "IDENTIFIER_TOK",
                    "WS",
                    "CCOMMENT",
                    "COMMENT",
                    "MULTCOMMENT",
                    "LANG_DECL"
                  ];
                  ForgeLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(ForgeLexer._LITERAL_NAMES, ForgeLexer._SYMBOLIC_NAMES, []);
                  ForgeLexer._serializedATNSegments = 2;
                  ForgeLexer._serializedATNSegment0 = `\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241s\u0343\b					\x07	\x07\b	\b			
	
\v	\v\f	\f\r	\r													\x1B	\x1B				 	 !	!"	"#	#$	$%	%&	&'	'(	()	)*	*+	+,	,-	-.	./	/0	01	12	23	34	45	56	67	78	89	9:	:;	;<	<=	=>	>?	?@	@A	AB	BC	CD	DE	EF	FG	GH	HI	IJ	JK	KL	LM	MN	NO	OP	PQ	QR	RS	ST	TU	UV	VW	WX	XY	YZ	Z[	[\\	\\]	]^	^_	_\`	\`a	ab	bc	cd	de	ef	fg	gh	hi	ij	jk	kl	lm	mn	no	op	pq	qr	r\x07\xF6
\f\xF9\v\x07\x07\x07\x07\b\b\b\b\b\b\b\b\b				

\v\v\f\f\f\f\f\f\f\f\r\r\r\x1B\x1B\x1B\x1B      !!!!""""########$$$$$%%%%%&&&&&''((())))******++++++++,,,,,,,,,,,,--------.....///////00000011222233333333333444444444455555555555666666666666677777888899999:::::\u020E
:;;;;<<<<<<<\u021A
<==========\u0225
=>>>>>??????\u0231
?@@@@@@AAAAAAAABBBBBBCCCCCCCCCCDDDDD\u0255
DEEEEEEEFFFFFFFFFFFGGGGGGHHHHHHHIIIIIJJJJJJJJJJJJJKKLLLMMNNNOOOPPQQRRSSTTUUVVVVVWWWWWWXXXXXYYYYYZZZZZZZZ[[[\\\\\\]]]]]]^^^^^^^______\`\`aabbccccc\u02E1
cdddeeefffgggghhhhiiiiiiijjkkll\u0300
l\rll\u0301mm\x07m\u0306
m\fmm\u0309\vmnn\u030C
n\rnn\u030Dnnoooo\x07o\u0316
o\foo\u0319\vooopppp\x07p\u0321
p\fpp\u0324\vpppqqqq\x07q\u032C
q\fqq\u032F\vqqqqqqrrrrrrr\x07r\u033D
r\frr\u0340\vrrr\u032Ds\x07	\v\x07\r\b	
\v\f\r\x1B!#%')+-/13\x1B579;= ?!A"C#E$G%I&K'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s;u<w=y>{?}@\x7FA\x81B\x83C\x85D\x87E\x89F\x8BG\x8DH\x8FI\x91J\x93K\x95L\x97M\x99N\x9BO\x9DP\x9FQ\xA1R\xA3S\xA5T\xA7U\xA9V\xABW\xADX\xAFY\xB1Z\xB3[\xB5\\\xB7]\xB9^\xBB_\xBD\`\xBFa\xC1b\xC3c\xC5d\xC7e\xC9f\xCBg\xCDh\xCFi\xD1j\xD3k\xD5l\xD7m\xD9n\xDBo\xDDp\xDFq\xE1r\xE3s\b$$^^2;\x07&&11C\\aac|\x07&&1;C\\aac|\v\f""\f\f\u0351\x07	\v\r\x1B!#%')+-/13579;=?ACEGIKMOQSUWY[]_acegikmoqsuwy{}\x7F\x81\x83\x85\x87\x89\x8B\x8D\x8F\x91\x93\x95\x97\x99\x9B\x9D\x9F\xA1\xA3\xA5\xA7\xA9\xAB\xAD\xAF\xB1\xB3\xB5\xB7\xB9\xBB\xBD\xBF\xC1\xC3\xC5\xC7\xC9\xCB\xCD\xCF\xD1\xD3\xD5\xD7\xD9\xDB\xDD\xDF\xE1\xE3\xE5\xEA\x07\xEC	\xEE\v\xF1\r\xFC\u0100\u0109\u010D\u010F\u0111\u0119\x1B\u011C\u011E\u0123!\u0128#\u012C%\u0130'\u0134)\u0139+\u013F-\u0144/\u01461\u014C3\u01515\u01537\u01579\u0159;\u015B=\u0162?\u0166A\u016CC\u0170E\u0174G\u017CI\u0181K\u0186M\u018BO\u018DQ\u0190S\u0194U\u019AW\u01A2Y\u01AE[\u01B6]\u01BB_\u01C2a\u01C8c\u01CAe\u01CEg\u01D9i\u01E3k\u01EEm\u01FBo\u0200q\u0204s\u020Du\u020Fw\u0219y\u0224{\u0226}\u0230\x7F\u0232\x81\u0238\x83\u0240\x85\u0246\x87\u0254\x89\u0256\x8B\u025D\x8D\u0268\x8F\u026E\x91\u0275\x93\u027A\x95\u0287\x97\u0289\x99\u028C\x9B\u028E\x9D\u0291\x9F\u0294\xA1\u0296\xA3\u0298\xA5\u029A\xA7\u029C\xA9\u029E\xAB\u02A0\xAD\u02A5\xAF\u02AB\xB1\u02B0\xB3\u02B5\xB5\u02BD\xB7\u02C0\xB9\u02C3\xBB\u02C9\xBD\u02D0\xBF\u02D6\xC1\u02D8\xC3\u02DA\xC5\u02E0\xC7\u02E2\xC9\u02E5\xCB\u02E8\xCD\u02EB\xCF\u02EF\xD1\u02F3\xD3\u02FA\xD5\u02FC\xD7\u02FF\xD9\u0303\xDB\u030B\xDD\u0311\xDF\u031C\xE1\u0327\xE3\u0335\xE5\xE6\x07q\xE6\xE7\x07r\xE7\xE8\x07g\xE8\xE9\x07p\xE9\xEA\xEB\x07]\xEB\xEC\xED\x07_\xED\b\xEE\xEF\x07c\xEF\xF0\x07u\xF0
\xF1\xF7\x07$\xF2\xF6
\xF3\xF4\x07^\xF4\xF6\v\xF5\xF2\xF5\xF3\xF6\xF9\xF7\xF5\xF7\xF8\xF8\xFA\xF9\xF7\xFA\xFB\x07$\xFB\f\xFC\xFD\x07x\xFD\xFE\x07c\xFE\xFF\x07t\xFF\u0100\u0101\x07c\u0101\u0102\x07d\u0102\u0103\x07u\u0103\u0104\x07v\u0104\u0105\x07t\u0105\u0106\x07c\u0106\u0107\x07e\u0107\u0108\x07v\u0108\u0109\u010A\x07u\u010A\u010B\x07k\u010B\u010C\x07i\u010C\u010D\u010E\x07}\u010E\u010F\u0110\x07\x7F\u0110\u0111\u0112\x07g\u0112\u0113\x07z\u0113\u0114\x07v\u0114\u0115\x07g\u0115\u0116\x07p\u0116\u0117\x07f\u0117\u0118\x07u\u0118\u0119\u011A\x07k\u011A\u011B\x07p\u011B\u011C\u011D\x07-\u011D\u011E\u011F\x07n\u011F\u0120\x07q\u0120\u0121\x07p\u0121\u0122\x07g\u0122\u0123\u0124\x07u\u0124\u0125\x07q\u0125\u0126\x07o\u0126\u0127\x07g\u0127 \u0128\u0129\x07q\u0129\u012A\x07p\u012A\u012B\x07g\u012B"\u012C\u012D\x07v\u012D\u012E\x07y\u012E\u012F\x07q\u012F$\u0130\u0131\x07u\u0131\u0132\x07g\u0132\u0133\x07v\u0133&\u0134\u0135\x07h\u0135\u0136\x07w\u0136\u0137\x07p\u0137\u0138\x07e\u0138(\u0139\u013A\x07r\u013A\u013B\x07h\u013B\u013C\x07w\u013C\u013D\x07p\u013D\u013E\x07e\u013E*\u013F\u0140\x07f\u0140\u0141\x07k\u0141\u0142\x07u\u0142\u0143\x07l\u0143,\u0144\u0145\x07<\u0145.\u0146\u0147\x07y\u0147\u0148\x07j\u0148\u0149\x07g\u0149\u014A\x07c\u014A\u014B\x07v\u014B0\u014C\u014D\x07r\u014D\u014E\x07t\u014E\u014F\x07g\u014F\u0150\x07f\u01502\u0151\u0152\x070\u01524\u0153\u0154\x07h\u0154\u0155\x07w\u0155\u0156\x07p\u01566\u0157\u0158\x07*\u01588\u0159\u015A\x07+\u015A:\u015B\u015C\x07c\u015C\u015D\x07u\u015D\u015E\x07u\u015E\u015F\x07g\u015F\u0160\x07t\u0160\u0161\x07v\u0161<\u0162\u0163\x07t\u0163\u0164\x07w\u0164\u0165\x07p\u0165>\u0166\u0167\x07e\u0167\u0168\x07j\u0168\u0169\x07g\u0169\u016A\x07e\u016A\u016B\x07m\u016B@\u016C\u016D\x07h\u016D\u016E\x07q\u016E\u016F\x07t\u016FB\u0170\u0171\x07d\u0171\u0172\x07w\u0172\u0173\x07v\u0173D\u0174\u0175\x07g\u0175\u0176\x07z\u0176\u0177\x07c\u0177\u0178\x07e\u0178\u0179\x07v\u0179\u017A\x07n\u017A\u017B\x07{\u017BF\u017C\u017D\x07p\u017D\u017E\x07q\u017E\u017F\x07p\u017F\u0180\x07g\u0180H\u0181\u0182\x07w\u0182\u0183\x07p\u0183\u0184\x07k\u0184\u0185\x07x\u0185J\u0186\u0187\x07k\u0187\u0188\x07f\u0188\u0189\x07g\u0189\u018A\x07p\u018AL\u018B\u018C\x07/\u018CN\u018D\u018E\x07k\u018E\u018F\x07u\u018FP\u0190\u0191\x07u\u0191\u0192\x07c\u0192\u0193\x07v\u0193R\u0194\u0195\x07w\u0195\u0196\x07p\u0196\u0197\x07u\u0197\u0198\x07c\u0198\u0199\x07v\u0199T\u019A\u019B\x07v\u019B\u019C\x07j\u019C\u019D\x07g\u019D\u019E\x07q\u019E\u019F\x07t\u019F\u01A0\x07g\u01A0\u01A1\x07o\u01A1V\u01A2\u01A3\x07h\u01A3\u01A4\x07q\u01A4\u01A5\x07t\u01A5\u01A6\x07i\u01A6\u01A7\x07g\u01A7\u01A8\x07a\u01A8\u01A9\x07g\u01A9\u01AA\x07t\u01AA\u01AB\x07t\u01AB\u01AC\x07q\u01AC\u01AD\x07t\u01ADX\u01AE\u01AF\x07e\u01AF\u01B0\x07j\u01B0\u01B1\x07g\u01B1\u01B2\x07e\u01B2\u01B3\x07m\u01B3\u01B4\x07g\u01B4\u01B5\x07f\u01B5Z\u01B6\u01B7\x07v\u01B7\u01B8\x07g\u01B8\u01B9\x07u\u01B9\u01BA\x07v\u01BA\\\u01BB\u01BC\x07g\u01BC\u01BD\x07z\u01BD\u01BE\x07r\u01BE\u01BF\x07g\u01BF\u01C0\x07e\u01C0\u01C1\x07v\u01C1^\u01C2\u01C3\x07u\u01C3\u01C4\x07w\u01C4\u01C5\x07k\u01C5\u01C6\x07v\u01C6\u01C7\x07g\u01C7\`\u01C8\u01C9\x07~\u01C9b\u01CA\u01CB\x07c\u01CB\u01CC\x07n\u01CC\u01CD\x07n\u01CDd\u01CE\u01CF\x07u\u01CF\u01D0\x07w\u01D0\u01D1\x07h\u01D1\u01D2\x07h\u01D2\u01D3\x07k\u01D3\u01D4\x07e\u01D4\u01D5\x07k\u01D5\u01D6\x07g\u01D6\u01D7\x07p\u01D7\u01D8\x07v\u01D8f\u01D9\u01DA\x07p\u01DA\u01DB\x07g\u01DB\u01DC\x07e\u01DC\u01DD\x07g\u01DD\u01DE\x07u\u01DE\u01DF\x07u\u01DF\u01E0\x07c\u01E0\u01E1\x07t\u01E1\u01E2\x07{\u01E2h\u01E3\u01E4\x07e\u01E4\u01E5\x07q`;
                  ForgeLexer._serializedATNSegment1 = "\u01E5\u01E6\x07p\u01E6\u01E7\x07u\u01E7\u01E8\x07k\u01E8\u01E9\x07u\u01E9\u01EA\x07v\u01EA\u01EB\x07g\u01EB\u01EC\x07p\u01EC\u01ED\x07v\u01EDj\u01EE\u01EF\x07k\u01EF\u01F0\x07p\u01F0\u01F1\x07e\u01F1\u01F2\x07q\u01F2\u01F3\x07p\u01F3\u01F4\x07u\u01F4\u01F5\x07k\u01F5\u01F6\x07u\u01F6\u01F7\x07v\u01F7\u01F8\x07g\u01F8\u01F9\x07p\u01F9\u01FA\x07v\u01FAl\u01FB\u01FC\x07y\u01FC\u01FD\x07k\u01FD\u01FE\x07v\u01FE\u01FF\x07j\u01FFn\u0200\u0201\x07n\u0201\u0202\x07g\u0202\u0203\x07v\u0203p\u0204\u0205\x07d\u0205\u0206\x07k\u0206\u0207\x07p\u0207\u0208\x07f\u0208r\u0209\u020A\x07~\u020A\u020E\x07~\u020B\u020C\x07q\u020C\u020E\x07t\u020D\u0209\u020D\u020B\u020Et\u020F\u0210\x07z\u0210\u0211\x07q\u0211\u0212\x07t\u0212v\u0213\u0214\x07>\u0214\u0215\x07?\u0215\u021A\x07@\u0216\u0217\x07k\u0217\u0218\x07h\u0218\u021A\x07h\u0219\u0213\u0219\u0216\u021Ax\u021B\u021C\x07k\u021C\u021D\x07o\u021D\u021E\x07r\u021E\u021F\x07n\u021F\u0220\x07k\u0220\u0221\x07g\u0221\u0225\x07u\u0222\u0223\x07?\u0223\u0225\x07@\u0224\u021B\u0224\u0222\u0225z\u0226\u0227\x07g\u0227\u0228\x07n\u0228\u0229\x07u\u0229\u022A\x07g\u022A|\u022B\u022C\x07(\u022C\u0231\x07(\u022D\u022E\x07c\u022E\u022F\x07p\u022F\u0231\x07f\u0230\u022B\u0230\u022D\u0231~\u0232\u0233\x07w\u0233\u0234\x07p\u0234\u0235\x07v\u0235\u0236\x07k\u0236\u0237\x07n\u0237\x80\u0238\u0239\x07t\u0239\u023A\x07g\u023A\u023B\x07n\u023B\u023C\x07g\u023C\u023D\x07c\u023D\u023E\x07u\u023E\u023F\x07g\u023F\x82\u0240\u0241\x07u\u0241\u0242\x07k\u0242\u0243\x07p\u0243\u0244\x07e\u0244\u0245\x07g\u0245\x84\u0246\u0247\x07v\u0247\u0248\x07t\u0248\u0249\x07k\u0249\u024A\x07i\u024A\u024B\x07i\u024B\u024C\x07g\u024C\u024D\x07t\u024D\u024E\x07g\u024E\u024F\x07f\u024F\x86\u0250\u0255\x07#\u0251\u0252\x07p\u0252\u0253\x07q\u0253\u0255\x07v\u0254\u0250\u0254\u0251\u0255\x88\u0256\u0257\x07c\u0257\u0258\x07n\u0258\u0259\x07y\u0259\u025A\x07c\u025A\u025B\x07{\u025B\u025C\x07u\u025C\x8A\u025D\u025E\x07g\u025E\u025F\x07x\u025F\u0260\x07g\u0260\u0261\x07p\u0261\u0262\x07v\u0262\u0263\x07w\u0263\u0264\x07c\u0264\u0265\x07n\u0265\u0266\x07n\u0266\u0267\x07{\u0267\x8C\u0268\u0269\x07c\u0269\u026A\x07h\u026A\u026B\x07v\u026B\u026C\x07g\u026C\u026D\x07t\u026D\x8E\u026E\u026F\x07d\u026F\u0270\x07g\u0270\u0271\x07h\u0271\u0272\x07q\u0272\u0273\x07t\u0273\u0274\x07g\u0274\x90\u0275\u0276\x07q\u0276\u0277\x07p\u0277\u0278\x07e\u0278\u0279\x07g\u0279\x92\u027A\u027B\x07j\u027B\u027C\x07k\u027C\u027D\x07u\u027D\u027E\x07v\u027E\u027F\x07q\u027F\u0280\x07t\u0280\u0281\x07k\u0281\u0282\x07e\u0282\u0283\x07c\u0283\u0284\x07n\u0284\u0285\x07n\u0285\u0286\x07{\u0286\x94\u0287\u0288\x07%\u0288\x96\u0289\u028A\x07-\u028A\u028B\x07-\u028B\x98\u028C\u028D\x07(\u028D\x9A\u028E\u028F\x07>\u028F\u0290\x07<\u0290\x9C\u0291\u0292\x07<\u0292\u0293\x07@\u0293\x9E\u0294\u0295\x07)\u0295\xA0\u0296\u0297\x07\x80\u0297\xA2\u0298\u0299\x07`\u0299\xA4\u029A\u029B\x07,\u029B\xA6\u029C\u029D\x07B\u029D\xA8\u029E\u029F\x07b\u029F\xAA\u02A0\u02A1\x07v\u02A1\u02A2\x07j\u02A2\u02A3\x07k\u02A3\u02A4\x07u\u02A4\xAC\u02A5\u02A6\x07u\u02A6\u02A7\x07g\u02A7\u02A8\x07z\u02A8\u02A9\x07r\u02A9\u02AA\x07t\u02AA\xAE\u02AB\u02AC\x07k\u02AC\u02AD\x07p\u02AD\u02AE\x07u\u02AE\u02AF\x07v\u02AF\xB0\u02B0\u02B1\x07g\u02B1\u02B2\x07x\u02B2\u02B3\x07c\u02B3\u02B4\x07n\u02B4\xB2\u02B5\u02B6\x07g\u02B6\u02B7\x07z\u02B7\u02B8\x07c\u02B8\u02B9\x07o\u02B9\u02BA\x07r\u02BA\u02BB\x07n\u02BB\u02BC\x07g\u02BC\xB4\u02BD\u02BE\x07/\u02BE\u02BF\x07@\u02BF\xB6\u02C0\u02C1\x07B\u02C1\u02C2\x07<\u02C2\xB8\u02C3\u02C4\x07B\u02C4\u02C5\x07u\u02C5\u02C6\x07v\u02C6\u02C7\x07t\u02C7\u02C8\x07<\u02C8\xBA\u02C9\u02CA\x07B\u02CA\u02CB\x07d\u02CB\u02CC\x07q\u02CC\u02CD\x07q\u02CD\u02CE\x07n\u02CE\u02CF\x07<\u02CF\xBC\u02D0\u02D1\x07B\u02D1\u02D2\x07p\u02D2\u02D3\x07w\u02D3\u02D4\x07o\u02D4\u02D5\x07<\u02D5\xBE\u02D6\u02D7\x07?\u02D7\xC0\u02D8\u02D9\x07>\u02D9\xC2\u02DA\u02DB\x07@\u02DB\xC4\u02DC\u02DD\x07>\u02DD\u02E1\x07?\u02DE\u02DF\x07?\u02DF\u02E1\x07>\u02E0\u02DC\u02E0\u02DE\u02E1\xC6\u02E2\u02E3\x07@\u02E3\u02E4\x07?\u02E4\xC8\u02E5\u02E6\x07p\u02E6\u02E7\x07k\u02E7\xCA\u02E8\u02E9\x07p\u02E9\u02EA\x07q\u02EA\xCC\u02EB\u02EC\x07u\u02EC\u02ED\x07w\u02ED\u02EE\x07o\u02EE\xCE\u02EF\u02F0\x07K\u02F0\u02F1\x07p\u02F1\u02F2\x07v\u02F2\xD0\u02F3\u02F4\x07q\u02F4\u02F5\x07r\u02F5\u02F6\x07v\u02F6\u02F7\x07k\u02F7\u02F8\x07q\u02F8\u02F9\x07p\u02F9\xD2\u02FA\u02FB\x07.\u02FB\xD4\u02FC\u02FD\x071\u02FD\xD6\u02FE\u0300	\u02FF\u02FE\u0300\u0301\u0301\u02FF\u0301\u0302\u0302\xD8\u0303\u0307	\u0304\u0306	\u0305\u0304\u0306\u0309\u0307\u0305\u0307\u0308\u0308\xDA\u0309\u0307\u030A\u030C	\u030B\u030A\u030C\u030D\u030D\u030B\u030D\u030E\u030E\u030F\u030F\u0310\bn\u0310\xDC\u0311\u0312\x071\u0312\u0313\x071\u0313\u0317\u0314\u0316\n\x07\u0315\u0314\u0316\u0319\u0317\u0315\u0317\u0318\u0318\u031A\u0319\u0317\u031A\u031B\bo\u031B\xDE\u031C\u031D\x07/\u031D\u031E\x07/\u031E\u0322\u031F\u0321\n\x07\u0320\u031F\u0321\u0324\u0322\u0320\u0322\u0323\u0323\u0325\u0324\u0322\u0325\u0326\bp\u0326\xE0\u0327\u0328\x071\u0328\u0329\x07,\u0329\u032D\u032A\u032C\v\u032B\u032A\u032C\u032F\u032D\u032E\u032D\u032B\u032E\u0330\u032F\u032D\u0330\u0331\x07,\u0331\u0332\x071\u0332\u0333\u0333\u0334\bq\u0334\xE2\u0335\u0336\x07%\u0336\u0337\x07n\u0337\u0338\x07c\u0338\u0339\x07p\u0339\u033A\x07i\u033A\u033E\u033B\u033D\n\x07\u033C\u033B\u033D\u0340\u033E\u033C\u033E\u033F\u033F\u0341\u0340\u033E\u0341\u0342\br\u0342\xE4\xF5\xF7\u020D\u0219\u0224\u0230\u0254\u02E0\u0301\u0307\u030D\u0317\u0322\u032D\u033E\b";
                  ForgeLexer._serializedATN = Utils.join([
                    ForgeLexer._serializedATNSegment0,
                    ForgeLexer._serializedATNSegment1
                  ], "");
                }
              ),
              /***/
              "./src/forge-antlr/ForgeListenerImpl.ts": (
                /*!**********************************************!*\
                  !*** ./src/forge-antlr/ForgeListenerImpl.ts ***!
                  \**********************************************/
                /***/
                (__unused_webpack_module, exports2, __webpack_require__2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.ForgeListenerImpl = void 0;
                  const ForgeSyntaxConstructs_1 = __webpack_require__2(
                    /*! ./ForgeSyntaxConstructs */
                    "./src/forge-antlr/ForgeSyntaxConstructs.ts"
                  );
                  function getRandomName() {
                    return Math.random().toString(36).substring(7);
                  }
                  function exitExpr(ctx) {
                    const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                    const exprTree = getLocationOnlyExpr(ctx);
                  }
                  function getLocations(ctx) {
                    const startLine = ctx.start.line;
                    const startColumn = ctx.start.charPositionInLine;
                    const endLine = ctx.stop ? ctx.stop.line : -1;
                    const endColumn = ctx.stop ? ctx.stop.charPositionInLine + (ctx.stop.text?.length || 0) : 0;
                    return { startLine, startColumn, endLine, endColumn };
                  }
                  function getLocationOnlyBlock(ctx) {
                    const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                    const block = new ForgeSyntaxConstructs_1.Block(startLine, startColumn, endLine, endColumn, []);
                    return block;
                  }
                  function getLocationOnlyExpr(ctx) {
                    const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                    const expr = new ForgeSyntaxConstructs_1.Expr(startLine, startColumn, endLine, endColumn, "");
                    return expr;
                  }
                  class ForgeListenerImpl {
                    constructor() {
                      this._sigs = [];
                      this._predicates = [];
                      this._tests = [];
                      this._assertions = [];
                      this._examples = [];
                      this._quantifiedAssertions = [];
                      this._satisfiabilityAssertions = [];
                      this._functions = [];
                      this._consistencyAssertions = [];
                    }
                    get sigs() {
                      return this._sigs;
                    }
                    get predicates() {
                      return this._predicates;
                    }
                    get tests() {
                      return this._tests;
                    }
                    get assertions() {
                      return this._assertions;
                    }
                    get examples() {
                      return this._examples;
                    }
                    get quantifiedAssertions() {
                      return this._quantifiedAssertions;
                    }
                    get satisfiabilityAssertions() {
                      return this._satisfiabilityAssertions;
                    }
                    get functions() {
                      return this._functions;
                    }
                    get consistencyAssertions() {
                      return this._consistencyAssertions;
                    }
                    /**
                     * Exit a parse tree produced by `ForgeParser.sigDecl`.
                     * @param ctx the parse tree
                     */
                    exitSigDecl(ctx) {
                      const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                      const sigNames = this.getAllNames(ctx.nameList());
                      const multiplicity = ctx.mult()?.toStringTree();
                      const inheritsFrom = ctx.sigExt()?.toStringTree();
                      const sigBlock = ctx.block();
                      const sigBody = sigBlock ? getLocationOnlyBlock(sigBlock) : void 0;
                      for (const sigName of sigNames) {
                        let s = new ForgeSyntaxConstructs_1.Sig(startLine, startColumn, endLine, endColumn, sigName, sigBody, inheritsFrom, multiplicity);
                        this._sigs.push(s);
                      }
                    }
                    /**
                     * Exit a parse tree produced by `ForgeParser.predDecl`.
                     * @param ctx the parse tree
                     */
                    exitPredDecl(ctx) {
                      const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                      const predName = ctx.name().text;
                      const paraDecls = ctx.paraDecls();
                      const predArgsBlock = paraDecls ? getLocationOnlyBlock(paraDecls) : void 0;
                      const predBody = ctx.block();
                      let predBlock = getLocationOnlyBlock(predBody);
                      const predBodyStatements = [];
                      let p = new ForgeSyntaxConstructs_1.Predicate(startLine, startColumn, endLine, endColumn, predName, predArgsBlock, predBlock);
                      this._predicates.push(p);
                    }
                    /**
                     * Exit a parse tree produced by `ForgeParser.funDecl`.
                     * @param ctx the parse tree
                     */
                    exitFunDecl(ctx) {
                      const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                      const funName = ctx.name().text;
                      let f = new Function(startLine, startColumn, endLine, endColumn, funName);
                      this._functions.push(f);
                    }
                    /**
                     * Exit a parse tree produced by `ForgeParser.testDecl`.
                     * @param ctx the parse tree
                     */
                    exitTestDecl(ctx) {
                      const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                      const testName = ctx.name()?.IDENTIFIER_TOK().text || getRandomName();
                      const testBlock = ctx.block();
                      const testBody = testBlock ? getLocationOnlyBlock(testBlock) : void 0;
                      const testScope = ctx.scope()?.toStringTree();
                      const testBounds = ctx.bounds()?.toStringTree();
                      const check = ctx.SAT_TOK() ? "sat" : ctx.UNSAT_TOK() ? "unsat" : ctx.THEOREM_TOK() ? "theorem" : ctx.FORGE_ERROR_TOK() ? "forge_error" : ctx.CHECKED_TOK() ? "checked" : "unknown";
                      let t = new ForgeSyntaxConstructs_1.Test(startLine, startColumn, endLine, endColumn, testName, check, testBody, testBounds, testScope);
                      this._tests.push(t);
                    }
                    /**
                     * Exit a parse tree produced by `ForgeParser.satisfiabilityDecl`.
                     * @param ctx the parse tree
                     */
                    exitSatisfiabilityDecl(ctx) {
                      const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                      const expr = getLocationOnlyExpr(ctx.expr());
                      const testScope = ctx.scope()?.toStringTree();
                      const testBounds = ctx.bounds()?.toStringTree();
                      const check = ctx.SAT_TOK() ? "sat" : ctx.UNSAT_TOK() ? "unsat" : ctx.FORGE_ERROR_TOK() ? "forge_error" : "unknown";
                      const st = new ForgeSyntaxConstructs_1.SatisfiabilityAssertionTest(startLine, startColumn, endLine, endColumn, expr, check, testBounds, testScope);
                      this._satisfiabilityAssertions.push(st);
                    }
                    /**
                     * Exit a parse tree produced by `ForgeParser.propertyDecl`.
                     * @param ctx the parse tree
                     */
                    exitPropertyDecl(ctx) {
                      const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                      const rel = ctx.SUFFICIENT_TOK() ? "sufficient" : ctx.NECESSARY_TOK() ? "necessary" : "unknown";
                      if (rel === "unknown") {
                        throw new Error("Property relation must be either necessary or sufficient.");
                      }
                      const expr = getLocationOnlyExpr(ctx.expr());
                      const predName = ctx.name().text;
                      const testScope = ctx.scope()?.toStringTree();
                      const testBounds = ctx.bounds()?.toStringTree();
                      const at = new ForgeSyntaxConstructs_1.AssertionTest(startLine, startColumn, endLine, endColumn, predName, expr, rel, testBounds, testScope);
                      this._assertions.push(at);
                    }
                    /**
                     * Exit a parse tree produced by `ForgeParser.quantifiedPropertyDecl`.
                     * @param ctx the parse tree
                     *
                     */
                    exitQuantifiedPropertyDecl(ctx) {
                      const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                      const disj = ctx.DISJ_TOK() ? true : false;
                      const rel = ctx.SUFFICIENT_TOK() ? "sufficient" : ctx.NECESSARY_TOK() ? "necessary" : "unknown";
                      if (rel === "unknown") {
                        throw new Error("Property relation must be either necessary or sufficient.");
                      }
                      let predIndex = rel === "sufficient" ? 0 : 1;
                      let propIndex = rel === "sufficient" ? 1 : 0;
                      const predName = ctx.name().text;
                      const expr = getLocationOnlyExpr(ctx.expr());
                      let argsT = ctx.exprList();
                      let predArgsBlock = argsT ? getLocationOnlyBlock(argsT) : void 0;
                      const testScope = ctx.scope()?.toStringTree();
                      const testBounds = ctx.bounds()?.toStringTree();
                      const quantDecls = ctx.quantDeclList();
                      const quantDeclsBlock = quantDecls ? getLocationOnlyBlock(quantDecls) : void 0;
                      let qa = new ForgeSyntaxConstructs_1.QuantifiedAssertionTest(startLine, startColumn, endLine, endColumn, predName, expr, rel, disj, quantDeclsBlock, testBounds, testScope, predArgsBlock);
                      this._quantifiedAssertions.push(qa);
                    }
                    /**
                     * Exit a parse tree produced by `ForgeParser.consistencyDecl`.
                     * @param ctx the parse tree
                     */
                    exitConsistencyDecl(ctx) {
                      const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                      let consistencyType = ctx.CONSISTENT_TOK() ? "consistent" : ctx.INCONSISTENT_TOK() ? "inconsistent" : "unknown";
                      if (consistencyType === "unknown") {
                        throw new Error("Consistency assertion relation must be either consistent or inconsistent.");
                      }
                      let consistent = consistencyType === "consistent" ? true : false;
                      const predName = ctx.name().text;
                      const expr = getLocationOnlyExpr(ctx.expr());
                      const testScope = ctx.scope()?.toStringTree();
                      const testBounds = ctx.bounds()?.toStringTree();
                      const ct = new ForgeSyntaxConstructs_1.ConsistencyAssertionTest(startLine, startColumn, endLine, endColumn, predName, expr, consistent, testBounds, testScope);
                      this._consistencyAssertions.push(ct);
                    }
                    /**
                     * Exit a parse tree produced by `ForgeParser.exampleDecl`.
                     * @param ctx the parse tree
                     *
                     *
                     *      * TODO: THIS IS HARD, WE NEED TO PARSE THE EXPRLIST (WHICH WILL ALWAYS BE ALL)
                     *
                     */
                    exitExampleDecl(ctx) {
                      const { startLine, startColumn, endLine, endColumn } = getLocations(ctx);
                      const exampleName = ctx.name().text;
                      const testExpr = ctx.expr();
                      const testExprBlock = getLocationOnlyBlock(testExpr);
                      const bounds = ctx.bounds();
                      const boundsBlock = getLocationOnlyBlock(bounds);
                      let e = new ForgeSyntaxConstructs_1.Example(startLine, startColumn, endLine, endColumn, exampleName, testExprBlock, boundsBlock);
                      this._examples.push(e);
                    }
                    /////////////////////
                    /**
                     * Collects all names from the given NameListContext.
                     * @param ctx the NameListContext
                     * @returns an array of NameContext
                     */
                    getAllNames(ctx) {
                      const names = [];
                      function collectNames(nameListCtx) {
                        if (nameListCtx.name()) {
                          names.push(nameListCtx.name());
                        }
                        const nestedNameList = nameListCtx.nameList();
                        if (nestedNameList) {
                          collectNames(nestedNameList);
                        }
                      }
                      collectNames(ctx);
                      return names.map((nameCtx) => nameCtx.IDENTIFIER_TOK().text);
                    }
                  }
                  exports2.ForgeListenerImpl = ForgeListenerImpl;
                }
              ),
              /***/
              "./src/forge-antlr/ForgeParser.ts": (
                /*!****************************************!*\
                  !*** ./src/forge-antlr/ForgeParser.ts ***!
                  \****************************************/
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  "use strict";
                  var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === void 0) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                      desc = { enumerable: true, get: function() {
                        return m[k];
                      } };
                    }
                    Object.defineProperty(o, k2, desc);
                  } : function(o, m, k, k2) {
                    if (k2 === void 0) k2 = k;
                    o[k2] = m[k];
                  });
                  var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
                    Object.defineProperty(o, "default", { enumerable: true, value: v });
                  } : function(o, v) {
                    o["default"] = v;
                  });
                  var __importStar = this && this.__importStar || /* @__PURE__ */ function() {
                    var ownKeys = function(o) {
                      ownKeys = Object.getOwnPropertyNames || function(o2) {
                        var ar = [];
                        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
                        return ar;
                      };
                      return ownKeys(o);
                    };
                    return function(mod) {
                      if (mod && mod.__esModule) return mod;
                      var result = {};
                      if (mod != null) {
                        for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
                      }
                      __setModuleDefault(result, mod);
                      return result;
                    };
                  }();
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Expr1Context = exports2.ExprContext = exports2.ExprListContext = exports2.TypescopeListContext = exports2.LetDeclListContext = exports2.ArrowDeclListContext = exports2.QuantDeclListContext = exports2.ParaDeclListContext = exports2.QualNameListContext = exports2.NameListContext = exports2.NameContext = exports2.OptionDeclContext = exports2.QualNameContext = exports2.QuantContext = exports2.BlockOrBarContext = exports2.BlockContext = exports2.LetDeclContext = exports2.CompareOpContext = exports2.ArrowOpContext = exports2.TestConstructContext = exports2.TestSuiteDeclContext = exports2.ConsistencyDeclContext = exports2.PropertyDeclContext = exports2.QuantifiedPropertyDeclContext = exports2.SatisfiabilityDeclContext = exports2.ConstContext = exports2.TypescopeContext = exports2.ScopeContext = exports2.TestBlockContext = exports2.TestExpectDeclContext = exports2.TestDeclContext = exports2.CmdDeclContext = exports2.AssertDeclContext = exports2.ParaDeclsContext = exports2.FunDeclContext = exports2.PredTypeContext = exports2.ArrowDeclContext = exports2.QuantDeclContext = exports2.ParaDeclContext = exports2.HelperMultContext = exports2.ArrowMultContext = exports2.MultContext = exports2.SigExtContext = exports2.SigDeclContext = exports2.ParagraphContext = exports2.ImportDeclContext = exports2.AlloyModuleContext = exports2.ParseExprContext = exports2.PredDeclContext = exports2.ForgeParser = void 0;
                  exports2.BindRHSProductBaseContext = exports2.BindRHSProductContext = exports2.BindRHSUnionContext = exports2.BoundLHSContext = exports2.BoundContext = exports2.AtomNameOrNumberContext = exports2.BoundsContext = exports2.NumberContext = exports2.NumberListContext = exports2.QueryDeclContext = exports2.ExampleDeclContext = exports2.EvalDeclContext = exports2.EvalRelDeclContext = exports2.InstDeclContext = exports2.SexprContext = exports2.SexprDeclContext = exports2.ArrowExprContext = exports2.Expr18Context = exports2.Expr17Context = exports2.Expr16Context = exports2.Expr15Context = exports2.Expr14Context = exports2.Expr13Context = exports2.Expr12Context = exports2.Expr11Context = exports2.Expr10Context = exports2.Expr9Context = exports2.Expr8Context = exports2.Expr7Context = exports2.Expr6Context = exports2.Expr5Context = exports2.Expr4_5Context = exports2.Expr4Context = exports2.Expr3Context = exports2.Expr2Context = exports2.Expr1_5Context = void 0;
                  const ATN_1 = __webpack_require__2(
                    /*! antlr4ts/atn/ATN */
                    "./node_modules/antlr4ts/atn/ATN.js"
                  );
                  const ATNDeserializer_1 = __webpack_require__2(
                    /*! antlr4ts/atn/ATNDeserializer */
                    "./node_modules/antlr4ts/atn/ATNDeserializer.js"
                  );
                  const FailedPredicateException_1 = __webpack_require__2(
                    /*! antlr4ts/FailedPredicateException */
                    "./node_modules/antlr4ts/FailedPredicateException.js"
                  );
                  const NoViableAltException_1 = __webpack_require__2(
                    /*! antlr4ts/NoViableAltException */
                    "./node_modules/antlr4ts/NoViableAltException.js"
                  );
                  const Parser_1 = __webpack_require__2(
                    /*! antlr4ts/Parser */
                    "./node_modules/antlr4ts/Parser.js"
                  );
                  const ParserRuleContext_1 = __webpack_require__2(
                    /*! antlr4ts/ParserRuleContext */
                    "./node_modules/antlr4ts/ParserRuleContext.js"
                  );
                  const ParserATNSimulator_1 = __webpack_require__2(
                    /*! antlr4ts/atn/ParserATNSimulator */
                    "./node_modules/antlr4ts/atn/ParserATNSimulator.js"
                  );
                  const RecognitionException_1 = __webpack_require__2(
                    /*! antlr4ts/RecognitionException */
                    "./node_modules/antlr4ts/RecognitionException.js"
                  );
                  const Token_1 = __webpack_require__2(
                    /*! antlr4ts/Token */
                    "./node_modules/antlr4ts/Token.js"
                  );
                  const VocabularyImpl_1 = __webpack_require__2(
                    /*! antlr4ts/VocabularyImpl */
                    "./node_modules/antlr4ts/VocabularyImpl.js"
                  );
                  const Utils = __importStar(__webpack_require__2(
                    /*! antlr4ts/misc/Utils */
                    "./node_modules/antlr4ts/misc/Utils.js"
                  ));
                  class ForgeParser extends Parser_1.Parser {
                    // @Override
                    // @NotNull
                    get vocabulary() {
                      return ForgeParser.VOCABULARY;
                    }
                    // tslint:enable:no-trailing-whitespace
                    // @Override
                    get grammarFileName() {
                      return "Forge.g4";
                    }
                    // @Override
                    get ruleNames() {
                      return ForgeParser.ruleNames;
                    }
                    // @Override
                    get serializedATN() {
                      return ForgeParser._serializedATN;
                    }
                    createFailedPredicateException(predicate, message) {
                      return new FailedPredicateException_1.FailedPredicateException(this, predicate, message);
                    }
                    constructor(input) {
                      super(input);
                      this._interp = new ParserATNSimulator_1.ParserATNSimulator(ForgeParser._ATN, this);
                    }
                    // @RuleVersion(0)
                    predDecl() {
                      let _localctx = new PredDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 0, ForgeParser.RULE_predDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 170;
                          this.match(ForgeParser.PRED_TOK);
                          this.state = 172;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.WHEAT_TOK) {
                            {
                              this.state = 171;
                              this.predType();
                            }
                          }
                          this.state = 177;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 1, this._ctx)) {
                            case 1:
                              {
                                this.state = 174;
                                this.qualName();
                                this.state = 175;
                                this.match(ForgeParser.DOT_TOK);
                              }
                              break;
                          }
                          this.state = 179;
                          this.name();
                          this.state = 181;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.LEFT_SQUARE_TOK || _la === ForgeParser.LEFT_PAREN_TOK) {
                            {
                              this.state = 180;
                              this.paraDecls();
                            }
                          }
                          this.state = 183;
                          this.block();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    parseExpr() {
                      let _localctx = new ParseExprContext(this._ctx, this.state);
                      this.enterRule(_localctx, 2, ForgeParser.RULE_parseExpr);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 185;
                          this.expr();
                          this.state = 186;
                          this.match(ForgeParser.EOF);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    alloyModule() {
                      let _localctx = new AlloyModuleContext(this._ctx, this.state);
                      this.enterRule(_localctx, 4, ForgeParser.RULE_alloyModule);
                      let _la;
                      try {
                        this.state = 206;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 6, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 191;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              while (_la === ForgeParser.OPEN_TOK) {
                                {
                                  {
                                    this.state = 188;
                                    this.importDecl();
                                  }
                                }
                                this.state = 193;
                                this._errHandler.sync(this);
                                _la = this._input.LA(1);
                              }
                              this.state = 197;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              while ((_la & ~31) === 0 && (1 << _la & (1 << ForgeParser.VAR_TOK | 1 << ForgeParser.ABSTRACT_TOK | 1 << ForgeParser.SIG_TOK | 1 << ForgeParser.LONE_TOK | 1 << ForgeParser.SOME_TOK | 1 << ForgeParser.ONE_TOK | 1 << ForgeParser.TWO_TOK | 1 << ForgeParser.PRED_TOK | 1 << ForgeParser.FUN_TOK | 1 << ForgeParser.ASSERT_TOK | 1 << ForgeParser.RUN_TOK | 1 << ForgeParser.CHECK_TOK)) !== 0 || _la === ForgeParser.TEST_TOK || _la === ForgeParser.EXPECT_TOK || (_la - 86 & ~31) === 0 && (1 << _la - 86 & (1 << ForgeParser.SEXPR_TOK - 86 | 1 << ForgeParser.INST_TOK - 86 | 1 << ForgeParser.EXAMPLE_TOK - 86 | 1 << ForgeParser.OPTION_TOK - 86 | 1 << ForgeParser.IDENTIFIER_TOK - 86)) !== 0) {
                                {
                                  {
                                    this.state = 194;
                                    this.paragraph();
                                  }
                                }
                                this.state = 199;
                                this._errHandler.sync(this);
                                _la = this._input.LA(1);
                              }
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 203;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              while (_la === ForgeParser.EVAL_TOK) {
                                {
                                  {
                                    this.state = 200;
                                    this.evalDecl();
                                  }
                                }
                                this.state = 205;
                                this._errHandler.sync(this);
                                _la = this._input.LA(1);
                              }
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    importDecl() {
                      let _localctx = new ImportDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 6, ForgeParser.RULE_importDecl);
                      let _la;
                      try {
                        this.state = 226;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 10, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 208;
                              this.match(ForgeParser.OPEN_TOK);
                              this.state = 209;
                              this.qualName();
                              this.state = 214;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              if (_la === ForgeParser.LEFT_SQUARE_TOK) {
                                {
                                  this.state = 210;
                                  this.match(ForgeParser.LEFT_SQUARE_TOK);
                                  this.state = 211;
                                  this.qualNameList();
                                  this.state = 212;
                                  this.match(ForgeParser.RIGHT_SQUARE_TOK);
                                }
                              }
                              this.state = 218;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              if (_la === ForgeParser.AS_TOK) {
                                {
                                  this.state = 216;
                                  this.match(ForgeParser.AS_TOK);
                                  this.state = 217;
                                  this.name();
                                }
                              }
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 220;
                              this.match(ForgeParser.OPEN_TOK);
                              this.state = 221;
                              this.match(ForgeParser.FILE_PATH_TOK);
                              this.state = 224;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              if (_la === ForgeParser.AS_TOK) {
                                {
                                  this.state = 222;
                                  this.match(ForgeParser.AS_TOK);
                                  this.state = 223;
                                  this.name();
                                }
                              }
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    paragraph() {
                      let _localctx = new ParagraphContext(this._ctx, this.state);
                      this.enterRule(_localctx, 8, ForgeParser.RULE_paragraph);
                      try {
                        this.state = 245;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 11, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 228;
                              this.sigDecl();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 229;
                              this.predDecl();
                            }
                            break;
                          case 3:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 230;
                              this.funDecl();
                            }
                            break;
                          case 4:
                            this.enterOuterAlt(_localctx, 4);
                            {
                              this.state = 231;
                              this.assertDecl();
                            }
                            break;
                          case 5:
                            this.enterOuterAlt(_localctx, 5);
                            {
                              this.state = 232;
                              this.cmdDecl();
                            }
                            break;
                          case 6:
                            this.enterOuterAlt(_localctx, 6);
                            {
                              this.state = 233;
                              this.testExpectDecl();
                            }
                            break;
                          case 7:
                            this.enterOuterAlt(_localctx, 7);
                            {
                              this.state = 234;
                              this.sexprDecl();
                            }
                            break;
                          case 8:
                            this.enterOuterAlt(_localctx, 8);
                            {
                              this.state = 235;
                              this.queryDecl();
                            }
                            break;
                          case 9:
                            this.enterOuterAlt(_localctx, 9);
                            {
                              this.state = 236;
                              this.evalRelDecl();
                            }
                            break;
                          case 10:
                            this.enterOuterAlt(_localctx, 10);
                            {
                              this.state = 237;
                              this.optionDecl();
                            }
                            break;
                          case 11:
                            this.enterOuterAlt(_localctx, 11);
                            {
                              this.state = 238;
                              this.instDecl();
                            }
                            break;
                          case 12:
                            this.enterOuterAlt(_localctx, 12);
                            {
                              this.state = 239;
                              this.exampleDecl();
                            }
                            break;
                          case 13:
                            this.enterOuterAlt(_localctx, 13);
                            {
                              this.state = 240;
                              this.propertyDecl();
                            }
                            break;
                          case 14:
                            this.enterOuterAlt(_localctx, 14);
                            {
                              this.state = 241;
                              this.quantifiedPropertyDecl();
                            }
                            break;
                          case 15:
                            this.enterOuterAlt(_localctx, 15);
                            {
                              this.state = 242;
                              this.satisfiabilityDecl();
                            }
                            break;
                          case 16:
                            this.enterOuterAlt(_localctx, 16);
                            {
                              this.state = 243;
                              this.consistencyDecl();
                            }
                            break;
                          case 17:
                            this.enterOuterAlt(_localctx, 17);
                            {
                              this.state = 244;
                              this.testSuiteDecl();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    sigDecl() {
                      let _localctx = new SigDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 10, ForgeParser.RULE_sigDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 248;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.VAR_TOK) {
                            {
                              this.state = 247;
                              this.match(ForgeParser.VAR_TOK);
                            }
                          }
                          this.state = 251;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.ABSTRACT_TOK) {
                            {
                              this.state = 250;
                              this.match(ForgeParser.ABSTRACT_TOK);
                            }
                          }
                          this.state = 254;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if ((_la & ~31) === 0 && (1 << _la & (1 << ForgeParser.LONE_TOK | 1 << ForgeParser.SOME_TOK | 1 << ForgeParser.ONE_TOK | 1 << ForgeParser.TWO_TOK)) !== 0) {
                            {
                              this.state = 253;
                              this.mult();
                            }
                          }
                          this.state = 256;
                          this.match(ForgeParser.SIG_TOK);
                          this.state = 257;
                          this.nameList();
                          this.state = 259;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.EXTENDS_TOK || _la === ForgeParser.IN_TOK) {
                            {
                              this.state = 258;
                              this.sigExt();
                            }
                          }
                          this.state = 261;
                          this.match(ForgeParser.LEFT_CURLY_TOK);
                          this.state = 263;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.VAR_TOK || _la === ForgeParser.IDENTIFIER_TOK) {
                            {
                              this.state = 262;
                              this.arrowDeclList();
                            }
                          }
                          this.state = 265;
                          this.match(ForgeParser.RIGHT_CURLY_TOK);
                          this.state = 267;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.LEFT_CURLY_TOK) {
                            {
                              this.state = 266;
                              this.block();
                            }
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    sigExt() {
                      let _localctx = new SigExtContext(this._ctx, this.state);
                      this.enterRule(_localctx, 12, ForgeParser.RULE_sigExt);
                      let _la;
                      try {
                        this.state = 280;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.EXTENDS_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 269;
                              this.match(ForgeParser.EXTENDS_TOK);
                              this.state = 270;
                              this.qualName();
                            }
                            break;
                          case ForgeParser.IN_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 271;
                              this.match(ForgeParser.IN_TOK);
                              this.state = 272;
                              this.qualName();
                              this.state = 277;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              while (_la === ForgeParser.PLUS_TOK) {
                                {
                                  {
                                    this.state = 273;
                                    this.match(ForgeParser.PLUS_TOK);
                                    this.state = 274;
                                    this.qualName();
                                  }
                                }
                                this.state = 279;
                                this._errHandler.sync(this);
                                _la = this._input.LA(1);
                              }
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    mult() {
                      let _localctx = new MultContext(this._ctx, this.state);
                      this.enterRule(_localctx, 14, ForgeParser.RULE_mult);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 282;
                          _la = this._input.LA(1);
                          if (!((_la & ~31) === 0 && (1 << _la & (1 << ForgeParser.LONE_TOK | 1 << ForgeParser.SOME_TOK | 1 << ForgeParser.ONE_TOK | 1 << ForgeParser.TWO_TOK)) !== 0)) {
                            this._errHandler.recoverInline(this);
                          } else {
                            if (this._input.LA(1) === Token_1.Token.EOF) {
                              this.matchedEOF = true;
                            }
                            this._errHandler.reportMatch(this);
                            this.consume();
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    arrowMult() {
                      let _localctx = new ArrowMultContext(this._ctx, this.state);
                      this.enterRule(_localctx, 16, ForgeParser.RULE_arrowMult);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 284;
                          _la = this._input.LA(1);
                          if (!((_la & ~31) === 0 && (1 << _la & (1 << ForgeParser.LONE_TOK | 1 << ForgeParser.ONE_TOK | 1 << ForgeParser.TWO_TOK | 1 << ForgeParser.SET_TOK | 1 << ForgeParser.FUNC_TOK | 1 << ForgeParser.PFUNC_TOK)) !== 0)) {
                            this._errHandler.recoverInline(this);
                          } else {
                            if (this._input.LA(1) === Token_1.Token.EOF) {
                              this.matchedEOF = true;
                            }
                            this._errHandler.reportMatch(this);
                            this.consume();
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    helperMult() {
                      let _localctx = new HelperMultContext(this._ctx, this.state);
                      this.enterRule(_localctx, 18, ForgeParser.RULE_helperMult);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 286;
                          _la = this._input.LA(1);
                          if (!((_la & ~31) === 0 && (1 << _la & (1 << ForgeParser.LONE_TOK | 1 << ForgeParser.ONE_TOK | 1 << ForgeParser.SET_TOK | 1 << ForgeParser.FUNC_TOK | 1 << ForgeParser.PFUNC_TOK)) !== 0)) {
                            this._errHandler.recoverInline(this);
                          } else {
                            if (this._input.LA(1) === Token_1.Token.EOF) {
                              this.matchedEOF = true;
                            }
                            this._errHandler.reportMatch(this);
                            this.consume();
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    paraDecl() {
                      let _localctx = new ParaDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 20, ForgeParser.RULE_paraDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 289;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.DISJ_TOK) {
                            {
                              this.state = 288;
                              this.match(ForgeParser.DISJ_TOK);
                            }
                          }
                          this.state = 291;
                          this.nameList();
                          this.state = 292;
                          this.match(ForgeParser.COLON_TOK);
                          this.state = 294;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 21, this._ctx)) {
                            case 1:
                              {
                                this.state = 293;
                                this.helperMult();
                              }
                              break;
                          }
                          this.state = 296;
                          this.expr();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    quantDecl() {
                      let _localctx = new QuantDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 22, ForgeParser.RULE_quantDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 299;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.DISJ_TOK) {
                            {
                              this.state = 298;
                              this.match(ForgeParser.DISJ_TOK);
                            }
                          }
                          this.state = 301;
                          this.nameList();
                          this.state = 302;
                          this.match(ForgeParser.COLON_TOK);
                          this.state = 304;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 23, this._ctx)) {
                            case 1:
                              {
                                this.state = 303;
                                this.match(ForgeParser.SET_TOK);
                              }
                              break;
                          }
                          this.state = 306;
                          this.expr();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    arrowDecl() {
                      let _localctx = new ArrowDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 24, ForgeParser.RULE_arrowDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 309;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.VAR_TOK) {
                            {
                              this.state = 308;
                              this.match(ForgeParser.VAR_TOK);
                            }
                          }
                          this.state = 311;
                          this.nameList();
                          this.state = 312;
                          this.match(ForgeParser.COLON_TOK);
                          this.state = 313;
                          this.arrowMult();
                          this.state = 314;
                          this.arrowExpr();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    predType() {
                      let _localctx = new PredTypeContext(this._ctx, this.state);
                      this.enterRule(_localctx, 26, ForgeParser.RULE_predType);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 316;
                          this.match(ForgeParser.WHEAT_TOK);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    funDecl() {
                      let _localctx = new FunDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 28, ForgeParser.RULE_funDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 318;
                          this.match(ForgeParser.FUN_TOK);
                          this.state = 322;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 25, this._ctx)) {
                            case 1:
                              {
                                this.state = 319;
                                this.qualName();
                                this.state = 320;
                                this.match(ForgeParser.DOT_TOK);
                              }
                              break;
                          }
                          this.state = 324;
                          this.name();
                          this.state = 326;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.LEFT_SQUARE_TOK || _la === ForgeParser.LEFT_PAREN_TOK) {
                            {
                              this.state = 325;
                              this.paraDecls();
                            }
                          }
                          this.state = 328;
                          this.match(ForgeParser.COLON_TOK);
                          this.state = 330;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 27, this._ctx)) {
                            case 1:
                              {
                                this.state = 329;
                                this.helperMult();
                              }
                              break;
                          }
                          this.state = 332;
                          this.expr();
                          this.state = 333;
                          this.match(ForgeParser.LEFT_CURLY_TOK);
                          this.state = 334;
                          this.expr();
                          this.state = 335;
                          this.match(ForgeParser.RIGHT_CURLY_TOK);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    paraDecls() {
                      let _localctx = new ParaDeclsContext(this._ctx, this.state);
                      this.enterRule(_localctx, 30, ForgeParser.RULE_paraDecls);
                      let _la;
                      try {
                        this.state = 347;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.LEFT_PAREN_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 337;
                              this.match(ForgeParser.LEFT_PAREN_TOK);
                              this.state = 339;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              if (_la === ForgeParser.DISJ_TOK || _la === ForgeParser.IDENTIFIER_TOK) {
                                {
                                  this.state = 338;
                                  this.paraDeclList();
                                }
                              }
                              this.state = 341;
                              this.match(ForgeParser.RIGHT_PAREN_TOK);
                            }
                            break;
                          case ForgeParser.LEFT_SQUARE_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 342;
                              this.match(ForgeParser.LEFT_SQUARE_TOK);
                              this.state = 344;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              if (_la === ForgeParser.DISJ_TOK || _la === ForgeParser.IDENTIFIER_TOK) {
                                {
                                  this.state = 343;
                                  this.paraDeclList();
                                }
                              }
                              this.state = 346;
                              this.match(ForgeParser.RIGHT_SQUARE_TOK);
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    assertDecl() {
                      let _localctx = new AssertDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 32, ForgeParser.RULE_assertDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 349;
                          this.match(ForgeParser.ASSERT_TOK);
                          this.state = 351;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.IDENTIFIER_TOK) {
                            {
                              this.state = 350;
                              this.name();
                            }
                          }
                          this.state = 353;
                          this.block();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    cmdDecl() {
                      let _localctx = new CmdDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 34, ForgeParser.RULE_cmdDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 358;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.IDENTIFIER_TOK) {
                            {
                              this.state = 355;
                              this.name();
                              this.state = 356;
                              this.match(ForgeParser.COLON_TOK);
                            }
                          }
                          this.state = 360;
                          _la = this._input.LA(1);
                          if (!(_la === ForgeParser.RUN_TOK || _la === ForgeParser.CHECK_TOK)) {
                            this._errHandler.recoverInline(this);
                          } else {
                            if (this._input.LA(1) === Token_1.Token.EOF) {
                              this.matchedEOF = true;
                            }
                            this._errHandler.reportMatch(this);
                            this.consume();
                          }
                          this.state = 363;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 33, this._ctx)) {
                            case 1:
                              {
                                this.state = 361;
                                this.qualName();
                              }
                              break;
                            case 2:
                              {
                                this.state = 362;
                                this.block();
                              }
                              break;
                          }
                          this.state = 366;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 34, this._ctx)) {
                            case 1:
                              {
                                this.state = 365;
                                this.scope();
                              }
                              break;
                          }
                          this.state = 370;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.FOR_TOK) {
                            {
                              this.state = 368;
                              this.match(ForgeParser.FOR_TOK);
                              this.state = 369;
                              this.bounds();
                            }
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    testDecl() {
                      let _localctx = new TestDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 36, ForgeParser.RULE_testDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 375;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 36, this._ctx)) {
                            case 1:
                              {
                                this.state = 372;
                                this.name();
                                this.state = 373;
                                this.match(ForgeParser.COLON_TOK);
                              }
                              break;
                          }
                          this.state = 379;
                          this._errHandler.sync(this);
                          switch (this._input.LA(1)) {
                            case ForgeParser.THIS_TOK:
                            case ForgeParser.SUM_TOK:
                            case ForgeParser.INT_TOK:
                            case ForgeParser.IDENTIFIER_TOK:
                              {
                                this.state = 377;
                                this.qualName();
                              }
                              break;
                            case ForgeParser.LEFT_CURLY_TOK:
                              {
                                this.state = 378;
                                this.block();
                              }
                              break;
                            default:
                              throw new NoViableAltException_1.NoViableAltException(this);
                          }
                          this.state = 382;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 38, this._ctx)) {
                            case 1:
                              {
                                this.state = 381;
                                this.scope();
                              }
                              break;
                          }
                          this.state = 386;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.FOR_TOK) {
                            {
                              this.state = 384;
                              this.match(ForgeParser.FOR_TOK);
                              this.state = 385;
                              this.bounds();
                            }
                          }
                          this.state = 388;
                          this.match(ForgeParser.IS_TOK);
                          this.state = 389;
                          _la = this._input.LA(1);
                          if (!((_la - 40 & ~31) === 0 && (1 << _la - 40 & (1 << ForgeParser.SAT_TOK - 40 | 1 << ForgeParser.UNSAT_TOK - 40 | 1 << ForgeParser.THEOREM_TOK - 40 | 1 << ForgeParser.FORGE_ERROR_TOK - 40 | 1 << ForgeParser.CHECKED_TOK - 40)) !== 0)) {
                            this._errHandler.recoverInline(this);
                          } else {
                            if (this._input.LA(1) === Token_1.Token.EOF) {
                              this.matchedEOF = true;
                            }
                            this._errHandler.reportMatch(this);
                            this.consume();
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    testExpectDecl() {
                      let _localctx = new TestExpectDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 38, ForgeParser.RULE_testExpectDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 392;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.TEST_TOK) {
                            {
                              this.state = 391;
                              this.match(ForgeParser.TEST_TOK);
                            }
                          }
                          this.state = 394;
                          this.match(ForgeParser.EXPECT_TOK);
                          this.state = 396;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.IDENTIFIER_TOK) {
                            {
                              this.state = 395;
                              this.name();
                            }
                          }
                          this.state = 398;
                          this.testBlock();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    testBlock() {
                      let _localctx = new TestBlockContext(this._ctx, this.state);
                      this.enterRule(_localctx, 40, ForgeParser.RULE_testBlock);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 400;
                          this.match(ForgeParser.LEFT_CURLY_TOK);
                          this.state = 404;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          while (_la === ForgeParser.LEFT_CURLY_TOK || (_la - 85 & ~31) === 0 && (1 << _la - 85 & (1 << ForgeParser.THIS_TOK - 85 | 1 << ForgeParser.SUM_TOK - 85 | 1 << ForgeParser.INT_TOK - 85 | 1 << ForgeParser.IDENTIFIER_TOK - 85)) !== 0) {
                            {
                              {
                                this.state = 401;
                                this.testDecl();
                              }
                            }
                            this.state = 406;
                            this._errHandler.sync(this);
                            _la = this._input.LA(1);
                          }
                          this.state = 407;
                          this.match(ForgeParser.RIGHT_CURLY_TOK);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    scope() {
                      let _localctx = new ScopeContext(this._ctx, this.state);
                      this.enterRule(_localctx, 42, ForgeParser.RULE_scope);
                      let _la;
                      try {
                        this.state = 417;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 44, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 409;
                              this.match(ForgeParser.FOR_TOK);
                              this.state = 410;
                              this.number();
                              this.state = 413;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              if (_la === ForgeParser.BUT_TOK) {
                                {
                                  this.state = 411;
                                  this.match(ForgeParser.BUT_TOK);
                                  this.state = 412;
                                  this.typescopeList();
                                }
                              }
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 415;
                              this.match(ForgeParser.FOR_TOK);
                              this.state = 416;
                              this.typescopeList();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    typescope() {
                      let _localctx = new TypescopeContext(this._ctx, this.state);
                      this.enterRule(_localctx, 44, ForgeParser.RULE_typescope);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 420;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.EXACTLY_TOK) {
                            {
                              this.state = 419;
                              this.match(ForgeParser.EXACTLY_TOK);
                            }
                          }
                          this.state = 422;
                          this.number();
                          this.state = 423;
                          this.qualName();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    const() {
                      let _localctx = new ConstContext(this._ctx, this.state);
                      this.enterRule(_localctx, 46, ForgeParser.RULE_const);
                      let _la;
                      try {
                        this.state = 432;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.NONE_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 425;
                              this.match(ForgeParser.NONE_TOK);
                            }
                            break;
                          case ForgeParser.UNIV_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 426;
                              this.match(ForgeParser.UNIV_TOK);
                            }
                            break;
                          case ForgeParser.IDEN_TOK:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 427;
                              this.match(ForgeParser.IDEN_TOK);
                            }
                            break;
                          case ForgeParser.MINUS_TOK:
                          case ForgeParser.NUM_CONST_TOK:
                            this.enterOuterAlt(_localctx, 4);
                            {
                              this.state = 429;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              if (_la === ForgeParser.MINUS_TOK) {
                                {
                                  this.state = 428;
                                  this.match(ForgeParser.MINUS_TOK);
                                }
                              }
                              this.state = 431;
                              this.number();
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    satisfiabilityDecl() {
                      let _localctx = new SatisfiabilityDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 48, ForgeParser.RULE_satisfiabilityDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 434;
                          this.match(ForgeParser.ASSERT_TOK);
                          this.state = 435;
                          this.expr();
                          this.state = 436;
                          this.match(ForgeParser.IS_TOK);
                          this.state = 437;
                          _la = this._input.LA(1);
                          if (!((_la - 40 & ~31) === 0 && (1 << _la - 40 & (1 << ForgeParser.SAT_TOK - 40 | 1 << ForgeParser.UNSAT_TOK - 40 | 1 << ForgeParser.FORGE_ERROR_TOK - 40)) !== 0)) {
                            this._errHandler.recoverInline(this);
                          } else {
                            if (this._input.LA(1) === Token_1.Token.EOF) {
                              this.matchedEOF = true;
                            }
                            this._errHandler.reportMatch(this);
                            this.consume();
                          }
                          this.state = 439;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 48, this._ctx)) {
                            case 1:
                              {
                                this.state = 438;
                                this.scope();
                              }
                              break;
                          }
                          this.state = 443;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.FOR_TOK) {
                            {
                              this.state = 441;
                              this.match(ForgeParser.FOR_TOK);
                              this.state = 442;
                              this.bounds();
                            }
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    quantifiedPropertyDecl() {
                      let _localctx = new QuantifiedPropertyDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 50, ForgeParser.RULE_quantifiedPropertyDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 445;
                          this.match(ForgeParser.ASSERT_TOK);
                          this.state = 446;
                          this.match(ForgeParser.ALL_TOK);
                          this.state = 448;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 50, this._ctx)) {
                            case 1:
                              {
                                this.state = 447;
                                this.match(ForgeParser.DISJ_TOK);
                              }
                              break;
                          }
                          this.state = 450;
                          this.quantDeclList();
                          this.state = 451;
                          this.match(ForgeParser.BAR_TOK);
                          this.state = 452;
                          this.expr();
                          this.state = 453;
                          this.match(ForgeParser.IS_TOK);
                          this.state = 454;
                          _la = this._input.LA(1);
                          if (!(_la === ForgeParser.SUFFICIENT_TOK || _la === ForgeParser.NECESSARY_TOK)) {
                            this._errHandler.recoverInline(this);
                          } else {
                            if (this._input.LA(1) === Token_1.Token.EOF) {
                              this.matchedEOF = true;
                            }
                            this._errHandler.reportMatch(this);
                            this.consume();
                          }
                          this.state = 455;
                          this.match(ForgeParser.FOR_TOK);
                          this.state = 456;
                          this.name();
                          this.state = 461;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.LEFT_SQUARE_TOK) {
                            {
                              this.state = 457;
                              this.match(ForgeParser.LEFT_SQUARE_TOK);
                              this.state = 458;
                              this.exprList();
                              this.state = 459;
                              this.match(ForgeParser.RIGHT_SQUARE_TOK);
                            }
                          }
                          this.state = 464;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 52, this._ctx)) {
                            case 1:
                              {
                                this.state = 463;
                                this.scope();
                              }
                              break;
                          }
                          this.state = 468;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.FOR_TOK) {
                            {
                              this.state = 466;
                              this.match(ForgeParser.FOR_TOK);
                              this.state = 467;
                              this.bounds();
                            }
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    propertyDecl() {
                      let _localctx = new PropertyDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 52, ForgeParser.RULE_propertyDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 470;
                          this.match(ForgeParser.ASSERT_TOK);
                          this.state = 471;
                          this.expr();
                          this.state = 472;
                          this.match(ForgeParser.IS_TOK);
                          this.state = 473;
                          _la = this._input.LA(1);
                          if (!(_la === ForgeParser.SUFFICIENT_TOK || _la === ForgeParser.NECESSARY_TOK)) {
                            this._errHandler.recoverInline(this);
                          } else {
                            if (this._input.LA(1) === Token_1.Token.EOF) {
                              this.matchedEOF = true;
                            }
                            this._errHandler.reportMatch(this);
                            this.consume();
                          }
                          this.state = 474;
                          this.match(ForgeParser.FOR_TOK);
                          this.state = 475;
                          this.name();
                          this.state = 477;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 54, this._ctx)) {
                            case 1:
                              {
                                this.state = 476;
                                this.scope();
                              }
                              break;
                          }
                          this.state = 481;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.FOR_TOK) {
                            {
                              this.state = 479;
                              this.match(ForgeParser.FOR_TOK);
                              this.state = 480;
                              this.bounds();
                            }
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    consistencyDecl() {
                      let _localctx = new ConsistencyDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 54, ForgeParser.RULE_consistencyDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 483;
                          this.match(ForgeParser.ASSERT_TOK);
                          this.state = 484;
                          this.expr();
                          this.state = 485;
                          this.match(ForgeParser.IS_TOK);
                          this.state = 486;
                          _la = this._input.LA(1);
                          if (!(_la === ForgeParser.CONSISTENT_TOK || _la === ForgeParser.INCONSISTENT_TOK)) {
                            this._errHandler.recoverInline(this);
                          } else {
                            if (this._input.LA(1) === Token_1.Token.EOF) {
                              this.matchedEOF = true;
                            }
                            this._errHandler.reportMatch(this);
                            this.consume();
                          }
                          this.state = 487;
                          this.match(ForgeParser.WITH_TOK);
                          this.state = 488;
                          this.name();
                          this.state = 490;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 56, this._ctx)) {
                            case 1:
                              {
                                this.state = 489;
                                this.scope();
                              }
                              break;
                          }
                          this.state = 494;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.FOR_TOK) {
                            {
                              this.state = 492;
                              this.match(ForgeParser.FOR_TOK);
                              this.state = 493;
                              this.bounds();
                            }
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    testSuiteDecl() {
                      let _localctx = new TestSuiteDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 56, ForgeParser.RULE_testSuiteDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 496;
                          this.match(ForgeParser.TEST_TOK);
                          this.state = 497;
                          this.match(ForgeParser.SUITE_TOK);
                          this.state = 498;
                          this.match(ForgeParser.FOR_TOK);
                          this.state = 499;
                          this.name();
                          this.state = 500;
                          this.match(ForgeParser.LEFT_CURLY_TOK);
                          this.state = 504;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          while ((_la - 29 & ~31) === 0 && (1 << _la - 29 & (1 << ForgeParser.ASSERT_TOK - 29 | 1 << ForgeParser.TEST_TOK - 29 | 1 << ForgeParser.EXPECT_TOK - 29)) !== 0 || _la === ForgeParser.EXAMPLE_TOK) {
                            {
                              {
                                this.state = 501;
                                this.testConstruct();
                              }
                            }
                            this.state = 506;
                            this._errHandler.sync(this);
                            _la = this._input.LA(1);
                          }
                          this.state = 507;
                          this.match(ForgeParser.RIGHT_CURLY_TOK);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    testConstruct() {
                      let _localctx = new TestConstructContext(this._ctx, this.state);
                      this.enterRule(_localctx, 58, ForgeParser.RULE_testConstruct);
                      try {
                        this.state = 515;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 59, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 509;
                              this.exampleDecl();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 510;
                              this.testExpectDecl();
                            }
                            break;
                          case 3:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 511;
                              this.quantifiedPropertyDecl();
                            }
                            break;
                          case 4:
                            this.enterOuterAlt(_localctx, 4);
                            {
                              this.state = 512;
                              this.propertyDecl();
                            }
                            break;
                          case 5:
                            this.enterOuterAlt(_localctx, 5);
                            {
                              this.state = 513;
                              this.satisfiabilityDecl();
                            }
                            break;
                          case 6:
                            this.enterOuterAlt(_localctx, 6);
                            {
                              this.state = 514;
                              this.consistencyDecl();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    arrowOp() {
                      let _localctx = new ArrowOpContext(this._ctx, this.state);
                      this.enterRule(_localctx, 60, ForgeParser.RULE_arrowOp);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 519;
                          this._errHandler.sync(this);
                          switch (this._input.LA(1)) {
                            case ForgeParser.LONE_TOK:
                            case ForgeParser.SOME_TOK:
                            case ForgeParser.ONE_TOK:
                            case ForgeParser.TWO_TOK:
                              {
                                this.state = 517;
                                this.mult();
                              }
                              break;
                            case ForgeParser.SET_TOK:
                              {
                                this.state = 518;
                                this.match(ForgeParser.SET_TOK);
                              }
                              break;
                            case ForgeParser.ARROW_TOK:
                              break;
                            default:
                              break;
                          }
                          this.state = 521;
                          this.match(ForgeParser.ARROW_TOK);
                          this.state = 524;
                          this._errHandler.sync(this);
                          switch (this._input.LA(1)) {
                            case ForgeParser.LONE_TOK:
                            case ForgeParser.SOME_TOK:
                            case ForgeParser.ONE_TOK:
                            case ForgeParser.TWO_TOK:
                              {
                                this.state = 522;
                                this.mult();
                              }
                              break;
                            case ForgeParser.SET_TOK:
                              {
                                this.state = 523;
                                this.match(ForgeParser.SET_TOK);
                              }
                              break;
                            case ForgeParser.LEFT_CURLY_TOK:
                            case ForgeParser.LEFT_PAREN_TOK:
                            case ForgeParser.NONE_TOK:
                            case ForgeParser.UNIV_TOK:
                            case ForgeParser.IDEN_TOK:
                            case ForgeParser.MINUS_TOK:
                            case ForgeParser.TILDE_TOK:
                            case ForgeParser.EXP_TOK:
                            case ForgeParser.STAR_TOK:
                            case ForgeParser.AT_TOK:
                            case ForgeParser.BACKQUOTE_TOK:
                            case ForgeParser.THIS_TOK:
                            case ForgeParser.SEXPR_TOK:
                            case ForgeParser.GET_LABEL_TOK:
                            case ForgeParser.GET_LABEL_STR_TOK:
                            case ForgeParser.GET_LABEL_BOOL_TOK:
                            case ForgeParser.GET_LABEL_NUM_TOK:
                            case ForgeParser.SUM_TOK:
                            case ForgeParser.INT_TOK:
                            case ForgeParser.NUM_CONST_TOK:
                            case ForgeParser.IDENTIFIER_TOK:
                              break;
                            default:
                              break;
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    compareOp() {
                      let _localctx = new CompareOpContext(this._ctx, this.state);
                      this.enterRule(_localctx, 62, ForgeParser.RULE_compareOp);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 526;
                          _la = this._input.LA(1);
                          if (!(_la === ForgeParser.IN_TOK || _la === ForgeParser.IS_TOK || (_la - 95 & ~31) === 0 && (1 << _la - 95 & (1 << ForgeParser.EQ_TOK - 95 | 1 << ForgeParser.LT_TOK - 95 | 1 << ForgeParser.GT_TOK - 95 | 1 << ForgeParser.LEQ_TOK - 95 | 1 << ForgeParser.GEQ_TOK - 95 | 1 << ForgeParser.NI_TOK - 95)) !== 0)) {
                            this._errHandler.recoverInline(this);
                          } else {
                            if (this._input.LA(1) === Token_1.Token.EOF) {
                              this.matchedEOF = true;
                            }
                            this._errHandler.reportMatch(this);
                            this.consume();
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    letDecl() {
                      let _localctx = new LetDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 64, ForgeParser.RULE_letDecl);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 528;
                          this.name();
                          this.state = 529;
                          this.match(ForgeParser.EQ_TOK);
                          this.state = 530;
                          this.expr();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    block() {
                      let _localctx = new BlockContext(this._ctx, this.state);
                      this.enterRule(_localctx, 66, ForgeParser.RULE_block);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 532;
                          this.match(ForgeParser.LEFT_CURLY_TOK);
                          this.state = 536;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          while ((_la - 9 & ~31) === 0 && (1 << _la - 9 & (1 << ForgeParser.LEFT_CURLY_TOK - 9 | 1 << ForgeParser.LONE_TOK - 9 | 1 << ForgeParser.SOME_TOK - 9 | 1 << ForgeParser.ONE_TOK - 9 | 1 << ForgeParser.TWO_TOK - 9 | 1 << ForgeParser.SET_TOK - 9 | 1 << ForgeParser.LEFT_PAREN_TOK - 9 | 1 << ForgeParser.NONE_TOK - 9 | 1 << ForgeParser.UNIV_TOK - 9 | 1 << ForgeParser.IDEN_TOK - 9 | 1 << ForgeParser.MINUS_TOK - 9)) !== 0 || (_la - 49 & ~31) === 0 && (1 << _la - 49 & (1 << ForgeParser.ALL_TOK - 49 | 1 << ForgeParser.LET_TOK - 49 | 1 << ForgeParser.BIND_TOK - 49 | 1 << ForgeParser.NEG_TOK - 49 | 1 << ForgeParser.ALWAYS_TOK - 49 | 1 << ForgeParser.EVENTUALLY_TOK - 49 | 1 << ForgeParser.AFTER_TOK - 49 | 1 << ForgeParser.BEFORE_TOK - 49 | 1 << ForgeParser.ONCE_TOK - 49 | 1 << ForgeParser.HISTORICALLY_TOK - 49 | 1 << ForgeParser.CARD_TOK - 49 | 1 << ForgeParser.TILDE_TOK - 49)) !== 0 || (_la - 81 & ~31) === 0 && (1 << _la - 81 & (1 << ForgeParser.EXP_TOK - 81 | 1 << ForgeParser.STAR_TOK - 81 | 1 << ForgeParser.AT_TOK - 81 | 1 << ForgeParser.BACKQUOTE_TOK - 81 | 1 << ForgeParser.THIS_TOK - 81 | 1 << ForgeParser.SEXPR_TOK - 81 | 1 << ForgeParser.GET_LABEL_TOK - 81 | 1 << ForgeParser.GET_LABEL_STR_TOK - 81 | 1 << ForgeParser.GET_LABEL_BOOL_TOK - 81 | 1 << ForgeParser.GET_LABEL_NUM_TOK - 81 | 1 << ForgeParser.NO_TOK - 81 | 1 << ForgeParser.SUM_TOK - 81 | 1 << ForgeParser.INT_TOK - 81 | 1 << ForgeParser.NUM_CONST_TOK - 81 | 1 << ForgeParser.IDENTIFIER_TOK - 81)) !== 0) {
                            {
                              {
                                this.state = 533;
                                this.expr();
                              }
                            }
                            this.state = 538;
                            this._errHandler.sync(this);
                            _la = this._input.LA(1);
                          }
                          this.state = 539;
                          this.match(ForgeParser.RIGHT_CURLY_TOK);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    blockOrBar() {
                      let _localctx = new BlockOrBarContext(this._ctx, this.state);
                      this.enterRule(_localctx, 68, ForgeParser.RULE_blockOrBar);
                      try {
                        this.state = 544;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.LEFT_CURLY_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 541;
                              this.block();
                            }
                            break;
                          case ForgeParser.BAR_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 542;
                              this.match(ForgeParser.BAR_TOK);
                              this.state = 543;
                              this.expr();
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    quant() {
                      let _localctx = new QuantContext(this._ctx, this.state);
                      this.enterRule(_localctx, 70, ForgeParser.RULE_quant);
                      try {
                        this.state = 550;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.ALL_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 546;
                              this.match(ForgeParser.ALL_TOK);
                            }
                            break;
                          case ForgeParser.NO_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 547;
                              this.match(ForgeParser.NO_TOK);
                            }
                            break;
                          case ForgeParser.SUM_TOK:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 548;
                              this.match(ForgeParser.SUM_TOK);
                            }
                            break;
                          case ForgeParser.LONE_TOK:
                          case ForgeParser.SOME_TOK:
                          case ForgeParser.ONE_TOK:
                          case ForgeParser.TWO_TOK:
                            this.enterOuterAlt(_localctx, 4);
                            {
                              this.state = 549;
                              this.mult();
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    qualName() {
                      let _localctx = new QualNameContext(this._ctx, this.state);
                      this.enterRule(_localctx, 72, ForgeParser.RULE_qualName);
                      let _la;
                      try {
                        let _alt;
                        this.state = 567;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.THIS_TOK:
                          case ForgeParser.IDENTIFIER_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 554;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              if (_la === ForgeParser.THIS_TOK) {
                                {
                                  this.state = 552;
                                  this.match(ForgeParser.THIS_TOK);
                                  this.state = 553;
                                  this.match(ForgeParser.SLASH_TOK);
                                }
                              }
                              this.state = 561;
                              this._errHandler.sync(this);
                              _alt = this.interpreter.adaptivePredict(this._input, 66, this._ctx);
                              while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                                if (_alt === 1) {
                                  {
                                    {
                                      this.state = 556;
                                      this.name();
                                      this.state = 557;
                                      this.match(ForgeParser.SLASH_TOK);
                                    }
                                  }
                                }
                                this.state = 563;
                                this._errHandler.sync(this);
                                _alt = this.interpreter.adaptivePredict(this._input, 66, this._ctx);
                              }
                              this.state = 564;
                              this.name();
                            }
                            break;
                          case ForgeParser.INT_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 565;
                              this.match(ForgeParser.INT_TOK);
                            }
                            break;
                          case ForgeParser.SUM_TOK:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 566;
                              this.match(ForgeParser.SUM_TOK);
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    optionDecl() {
                      let _localctx = new OptionDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 74, ForgeParser.RULE_optionDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 569;
                          this.match(ForgeParser.OPTION_TOK);
                          this.state = 570;
                          this.qualName();
                          this.state = 577;
                          this._errHandler.sync(this);
                          switch (this._input.LA(1)) {
                            case ForgeParser.THIS_TOK:
                            case ForgeParser.SUM_TOK:
                            case ForgeParser.INT_TOK:
                            case ForgeParser.IDENTIFIER_TOK:
                              {
                                this.state = 571;
                                this.qualName();
                              }
                              break;
                            case ForgeParser.FILE_PATH_TOK:
                              {
                                this.state = 572;
                                this.match(ForgeParser.FILE_PATH_TOK);
                              }
                              break;
                            case ForgeParser.MINUS_TOK:
                            case ForgeParser.NUM_CONST_TOK:
                              {
                                this.state = 574;
                                this._errHandler.sync(this);
                                _la = this._input.LA(1);
                                if (_la === ForgeParser.MINUS_TOK) {
                                  {
                                    this.state = 573;
                                    this.match(ForgeParser.MINUS_TOK);
                                  }
                                }
                                this.state = 576;
                                this.number();
                              }
                              break;
                            default:
                              throw new NoViableAltException_1.NoViableAltException(this);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    name() {
                      let _localctx = new NameContext(this._ctx, this.state);
                      this.enterRule(_localctx, 76, ForgeParser.RULE_name);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 579;
                          this.match(ForgeParser.IDENTIFIER_TOK);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    nameList() {
                      let _localctx = new NameListContext(this._ctx, this.state);
                      this.enterRule(_localctx, 78, ForgeParser.RULE_nameList);
                      try {
                        this.state = 586;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 70, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 581;
                              this.name();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 582;
                              this.name();
                              this.state = 583;
                              this.match(ForgeParser.COMMA_TOK);
                              this.state = 584;
                              this.nameList();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    qualNameList() {
                      let _localctx = new QualNameListContext(this._ctx, this.state);
                      this.enterRule(_localctx, 80, ForgeParser.RULE_qualNameList);
                      try {
                        this.state = 593;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 71, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 588;
                              this.qualName();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 589;
                              this.qualName();
                              this.state = 590;
                              this.match(ForgeParser.COMMA_TOK);
                              this.state = 591;
                              this.qualNameList();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    paraDeclList() {
                      let _localctx = new ParaDeclListContext(this._ctx, this.state);
                      this.enterRule(_localctx, 82, ForgeParser.RULE_paraDeclList);
                      try {
                        this.state = 600;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 72, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 595;
                              this.paraDecl();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 596;
                              this.paraDecl();
                              this.state = 597;
                              this.match(ForgeParser.COMMA_TOK);
                              this.state = 598;
                              this.paraDeclList();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    quantDeclList() {
                      let _localctx = new QuantDeclListContext(this._ctx, this.state);
                      this.enterRule(_localctx, 84, ForgeParser.RULE_quantDeclList);
                      try {
                        this.state = 607;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 73, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 602;
                              this.quantDecl();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 603;
                              this.quantDecl();
                              this.state = 604;
                              this.match(ForgeParser.COMMA_TOK);
                              this.state = 605;
                              this.quantDeclList();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    arrowDeclList() {
                      let _localctx = new ArrowDeclListContext(this._ctx, this.state);
                      this.enterRule(_localctx, 86, ForgeParser.RULE_arrowDeclList);
                      try {
                        this.state = 614;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 74, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 609;
                              this.arrowDecl();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 610;
                              this.arrowDecl();
                              this.state = 611;
                              this.match(ForgeParser.COMMA_TOK);
                              this.state = 612;
                              this.arrowDeclList();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    letDeclList() {
                      let _localctx = new LetDeclListContext(this._ctx, this.state);
                      this.enterRule(_localctx, 88, ForgeParser.RULE_letDeclList);
                      try {
                        this.state = 621;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 75, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 616;
                              this.letDecl();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 617;
                              this.letDecl();
                              this.state = 618;
                              this.match(ForgeParser.COMMA_TOK);
                              this.state = 619;
                              this.letDeclList();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    typescopeList() {
                      let _localctx = new TypescopeListContext(this._ctx, this.state);
                      this.enterRule(_localctx, 90, ForgeParser.RULE_typescopeList);
                      try {
                        this.state = 628;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 76, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 623;
                              this.typescope();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 624;
                              this.typescope();
                              this.state = 625;
                              this.match(ForgeParser.COMMA_TOK);
                              this.state = 626;
                              this.typescopeList();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    exprList() {
                      let _localctx = new ExprListContext(this._ctx, this.state);
                      this.enterRule(_localctx, 92, ForgeParser.RULE_exprList);
                      try {
                        this.state = 635;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 77, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 630;
                              this.expr();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 631;
                              this.expr();
                              this.state = 632;
                              this.match(ForgeParser.COMMA_TOK);
                              this.state = 633;
                              this.exprList();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr() {
                      let _localctx = new ExprContext(this._ctx, this.state);
                      this.enterRule(_localctx, 94, ForgeParser.RULE_expr);
                      try {
                        this.state = 653;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 79, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 637;
                              this.expr1(0);
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 638;
                              this.match(ForgeParser.LET_TOK);
                              this.state = 639;
                              this.letDeclList();
                              this.state = 640;
                              this.blockOrBar();
                            }
                            break;
                          case 3:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 642;
                              this.match(ForgeParser.BIND_TOK);
                              this.state = 643;
                              this.letDeclList();
                              this.state = 644;
                              this.blockOrBar();
                            }
                            break;
                          case 4:
                            this.enterOuterAlt(_localctx, 4);
                            {
                              this.state = 646;
                              this.quant();
                              this.state = 648;
                              this._errHandler.sync(this);
                              switch (this.interpreter.adaptivePredict(this._input, 78, this._ctx)) {
                                case 1:
                                  {
                                    this.state = 647;
                                    this.match(ForgeParser.DISJ_TOK);
                                  }
                                  break;
                              }
                              this.state = 650;
                              this.quantDeclList();
                              this.state = 651;
                              this.blockOrBar();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr1(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr1Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 96;
                      this.enterRecursionRule(_localctx, 96, ForgeParser.RULE_expr1, _p);
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 656;
                            this.expr1_5(0);
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 663;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 80, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr1Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr1);
                                  this.state = 658;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 659;
                                  this.match(ForgeParser.OR_TOK);
                                  this.state = 660;
                                  this.expr1_5(0);
                                }
                              }
                            }
                            this.state = 665;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 80, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr1_5(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr1_5Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 98;
                      this.enterRecursionRule(_localctx, 98, ForgeParser.RULE_expr1_5, _p);
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 667;
                            this.expr2(0);
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 674;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 81, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr1_5Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr1_5);
                                  this.state = 669;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 670;
                                  this.match(ForgeParser.XOR_TOK);
                                  this.state = 671;
                                  this.expr2(0);
                                }
                              }
                            }
                            this.state = 676;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 81, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr2(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr2Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 100;
                      this.enterRecursionRule(_localctx, 100, ForgeParser.RULE_expr2, _p);
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 678;
                            this.expr3();
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 685;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 82, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr2Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr2);
                                  this.state = 680;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 681;
                                  this.match(ForgeParser.IFF_TOK);
                                  this.state = 682;
                                  this.expr3();
                                }
                              }
                            }
                            this.state = 687;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 82, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr3() {
                      let _localctx = new Expr3Context(this._ctx, this.state);
                      this.enterRule(_localctx, 102, ForgeParser.RULE_expr3);
                      try {
                        this.state = 696;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 84, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 688;
                              this.expr4(0);
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 689;
                              this.expr4(0);
                              this.state = 690;
                              this.match(ForgeParser.IMP_TOK);
                              this.state = 691;
                              this.expr3();
                              this.state = 694;
                              this._errHandler.sync(this);
                              switch (this.interpreter.adaptivePredict(this._input, 83, this._ctx)) {
                                case 1:
                                  {
                                    this.state = 692;
                                    this.match(ForgeParser.ELSE_TOK);
                                    this.state = 693;
                                    this.expr3();
                                  }
                                  break;
                              }
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr4(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr4Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 104;
                      this.enterRecursionRule(_localctx, 104, ForgeParser.RULE_expr4, _p);
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 699;
                            this.expr4_5();
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 706;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 85, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr4Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr4);
                                  this.state = 701;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 702;
                                  this.match(ForgeParser.AND_TOK);
                                  this.state = 703;
                                  this.expr4_5();
                                }
                              }
                            }
                            this.state = 708;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 85, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr4_5() {
                      let _localctx = new Expr4_5Context(this._ctx, this.state);
                      this.enterRule(_localctx, 106, ForgeParser.RULE_expr4_5);
                      try {
                        this.state = 726;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 86, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 709;
                              this.expr5();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 710;
                              this.expr5();
                              this.state = 711;
                              this.match(ForgeParser.UNTIL_TOK);
                              this.state = 712;
                              this.expr5();
                            }
                            break;
                          case 3:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 714;
                              this.expr5();
                              this.state = 715;
                              this.match(ForgeParser.RELEASE_TOK);
                              this.state = 716;
                              this.expr5();
                            }
                            break;
                          case 4:
                            this.enterOuterAlt(_localctx, 4);
                            {
                              this.state = 718;
                              this.expr5();
                              this.state = 719;
                              this.match(ForgeParser.SINCE_TOK);
                              this.state = 720;
                              this.expr5();
                            }
                            break;
                          case 5:
                            this.enterOuterAlt(_localctx, 5);
                            {
                              this.state = 722;
                              this.expr5();
                              this.state = 723;
                              this.match(ForgeParser.TRIGGERED_TOK);
                              this.state = 724;
                              this.expr5();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr5() {
                      let _localctx = new Expr5Context(this._ctx, this.state);
                      this.enterRule(_localctx, 108, ForgeParser.RULE_expr5);
                      try {
                        this.state = 743;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.LEFT_CURLY_TOK:
                          case ForgeParser.LONE_TOK:
                          case ForgeParser.SOME_TOK:
                          case ForgeParser.ONE_TOK:
                          case ForgeParser.TWO_TOK:
                          case ForgeParser.SET_TOK:
                          case ForgeParser.LEFT_PAREN_TOK:
                          case ForgeParser.NONE_TOK:
                          case ForgeParser.UNIV_TOK:
                          case ForgeParser.IDEN_TOK:
                          case ForgeParser.MINUS_TOK:
                          case ForgeParser.CARD_TOK:
                          case ForgeParser.TILDE_TOK:
                          case ForgeParser.EXP_TOK:
                          case ForgeParser.STAR_TOK:
                          case ForgeParser.AT_TOK:
                          case ForgeParser.BACKQUOTE_TOK:
                          case ForgeParser.THIS_TOK:
                          case ForgeParser.SEXPR_TOK:
                          case ForgeParser.GET_LABEL_TOK:
                          case ForgeParser.GET_LABEL_STR_TOK:
                          case ForgeParser.GET_LABEL_BOOL_TOK:
                          case ForgeParser.GET_LABEL_NUM_TOK:
                          case ForgeParser.NO_TOK:
                          case ForgeParser.SUM_TOK:
                          case ForgeParser.INT_TOK:
                          case ForgeParser.NUM_CONST_TOK:
                          case ForgeParser.IDENTIFIER_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 728;
                              this.expr6(0);
                            }
                            break;
                          case ForgeParser.NEG_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 729;
                              this.match(ForgeParser.NEG_TOK);
                              this.state = 730;
                              this.expr5();
                            }
                            break;
                          case ForgeParser.ALWAYS_TOK:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 731;
                              this.match(ForgeParser.ALWAYS_TOK);
                              this.state = 732;
                              this.expr5();
                            }
                            break;
                          case ForgeParser.EVENTUALLY_TOK:
                            this.enterOuterAlt(_localctx, 4);
                            {
                              this.state = 733;
                              this.match(ForgeParser.EVENTUALLY_TOK);
                              this.state = 734;
                              this.expr5();
                            }
                            break;
                          case ForgeParser.AFTER_TOK:
                            this.enterOuterAlt(_localctx, 5);
                            {
                              this.state = 735;
                              this.match(ForgeParser.AFTER_TOK);
                              this.state = 736;
                              this.expr5();
                            }
                            break;
                          case ForgeParser.BEFORE_TOK:
                            this.enterOuterAlt(_localctx, 6);
                            {
                              this.state = 737;
                              this.match(ForgeParser.BEFORE_TOK);
                              this.state = 738;
                              this.expr5();
                            }
                            break;
                          case ForgeParser.ONCE_TOK:
                            this.enterOuterAlt(_localctx, 7);
                            {
                              this.state = 739;
                              this.match(ForgeParser.ONCE_TOK);
                              this.state = 740;
                              this.expr5();
                            }
                            break;
                          case ForgeParser.HISTORICALLY_TOK:
                            this.enterOuterAlt(_localctx, 8);
                            {
                              this.state = 741;
                              this.match(ForgeParser.HISTORICALLY_TOK);
                              this.state = 742;
                              this.expr5();
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr6(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr6Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 110;
                      this.enterRecursionRule(_localctx, 110, ForgeParser.RULE_expr6, _p);
                      let _la;
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 746;
                            this.expr7();
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 757;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 89, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr6Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr6);
                                  this.state = 748;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 750;
                                  this._errHandler.sync(this);
                                  _la = this._input.LA(1);
                                  if (_la === ForgeParser.NEG_TOK) {
                                    {
                                      this.state = 749;
                                      this.match(ForgeParser.NEG_TOK);
                                    }
                                  }
                                  this.state = 752;
                                  this.compareOp();
                                  this.state = 753;
                                  this.expr7();
                                }
                              }
                            }
                            this.state = 759;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 89, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr7() {
                      let _localctx = new Expr7Context(this._ctx, this.state);
                      this.enterRule(_localctx, 112, ForgeParser.RULE_expr7);
                      let _la;
                      try {
                        this.state = 763;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.LEFT_CURLY_TOK:
                          case ForgeParser.LEFT_PAREN_TOK:
                          case ForgeParser.NONE_TOK:
                          case ForgeParser.UNIV_TOK:
                          case ForgeParser.IDEN_TOK:
                          case ForgeParser.MINUS_TOK:
                          case ForgeParser.CARD_TOK:
                          case ForgeParser.TILDE_TOK:
                          case ForgeParser.EXP_TOK:
                          case ForgeParser.STAR_TOK:
                          case ForgeParser.AT_TOK:
                          case ForgeParser.BACKQUOTE_TOK:
                          case ForgeParser.THIS_TOK:
                          case ForgeParser.SEXPR_TOK:
                          case ForgeParser.GET_LABEL_TOK:
                          case ForgeParser.GET_LABEL_STR_TOK:
                          case ForgeParser.GET_LABEL_BOOL_TOK:
                          case ForgeParser.GET_LABEL_NUM_TOK:
                          case ForgeParser.SUM_TOK:
                          case ForgeParser.INT_TOK:
                          case ForgeParser.NUM_CONST_TOK:
                          case ForgeParser.IDENTIFIER_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 760;
                              this.expr8(0);
                            }
                            break;
                          case ForgeParser.LONE_TOK:
                          case ForgeParser.SOME_TOK:
                          case ForgeParser.ONE_TOK:
                          case ForgeParser.TWO_TOK:
                          case ForgeParser.SET_TOK:
                          case ForgeParser.NO_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 761;
                              _la = this._input.LA(1);
                              if (!((_la & ~31) === 0 && (1 << _la & (1 << ForgeParser.LONE_TOK | 1 << ForgeParser.SOME_TOK | 1 << ForgeParser.ONE_TOK | 1 << ForgeParser.TWO_TOK | 1 << ForgeParser.SET_TOK)) !== 0 || _la === ForgeParser.NO_TOK)) {
                                this._errHandler.recoverInline(this);
                              } else {
                                if (this._input.LA(1) === Token_1.Token.EOF) {
                                  this.matchedEOF = true;
                                }
                                this._errHandler.reportMatch(this);
                                this.consume();
                              }
                              this.state = 762;
                              this.expr8(0);
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr8(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr8Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 114;
                      this.enterRecursionRule(_localctx, 114, ForgeParser.RULE_expr8, _p);
                      let _la;
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 766;
                            this.expr9();
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 773;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 91, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr8Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr8);
                                  this.state = 768;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 769;
                                  _la = this._input.LA(1);
                                  if (!(_la === ForgeParser.PLUS_TOK || _la === ForgeParser.MINUS_TOK)) {
                                    this._errHandler.recoverInline(this);
                                  } else {
                                    if (this._input.LA(1) === Token_1.Token.EOF) {
                                      this.matchedEOF = true;
                                    }
                                    this._errHandler.reportMatch(this);
                                    this.consume();
                                  }
                                  this.state = 770;
                                  this.expr10(0);
                                }
                              }
                            }
                            this.state = 775;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 91, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr9() {
                      let _localctx = new Expr9Context(this._ctx, this.state);
                      this.enterRule(_localctx, 116, ForgeParser.RULE_expr9);
                      try {
                        this.state = 779;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.LEFT_CURLY_TOK:
                          case ForgeParser.LEFT_PAREN_TOK:
                          case ForgeParser.NONE_TOK:
                          case ForgeParser.UNIV_TOK:
                          case ForgeParser.IDEN_TOK:
                          case ForgeParser.MINUS_TOK:
                          case ForgeParser.TILDE_TOK:
                          case ForgeParser.EXP_TOK:
                          case ForgeParser.STAR_TOK:
                          case ForgeParser.AT_TOK:
                          case ForgeParser.BACKQUOTE_TOK:
                          case ForgeParser.THIS_TOK:
                          case ForgeParser.SEXPR_TOK:
                          case ForgeParser.GET_LABEL_TOK:
                          case ForgeParser.GET_LABEL_STR_TOK:
                          case ForgeParser.GET_LABEL_BOOL_TOK:
                          case ForgeParser.GET_LABEL_NUM_TOK:
                          case ForgeParser.SUM_TOK:
                          case ForgeParser.INT_TOK:
                          case ForgeParser.NUM_CONST_TOK:
                          case ForgeParser.IDENTIFIER_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 776;
                              this.expr10(0);
                            }
                            break;
                          case ForgeParser.CARD_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 777;
                              this.match(ForgeParser.CARD_TOK);
                              this.state = 778;
                              this.expr9();
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr10(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr10Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 118;
                      this.enterRecursionRule(_localctx, 118, ForgeParser.RULE_expr10, _p);
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 782;
                            this.expr11(0);
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 789;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 93, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr10Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr10);
                                  this.state = 784;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 785;
                                  this.match(ForgeParser.PPLUS_TOK);
                                  this.state = 786;
                                  this.expr11(0);
                                }
                              }
                            }
                            this.state = 791;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 93, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr11(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr11Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 120;
                      this.enterRecursionRule(_localctx, 120, ForgeParser.RULE_expr11, _p);
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 793;
                            this.expr12(0);
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 800;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 94, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr11Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr11);
                                  this.state = 795;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 796;
                                  this.match(ForgeParser.AMP_TOK);
                                  this.state = 797;
                                  this.expr12(0);
                                }
                              }
                            }
                            this.state = 802;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 94, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr12(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr12Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 122;
                      this.enterRecursionRule(_localctx, 122, ForgeParser.RULE_expr12, _p);
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 804;
                            this.expr13(0);
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 812;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 95, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr12Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr12);
                                  this.state = 806;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 807;
                                  this.arrowOp();
                                  this.state = 808;
                                  this.expr13(0);
                                }
                              }
                            }
                            this.state = 814;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 95, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr13(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr13Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 124;
                      this.enterRecursionRule(_localctx, 124, ForgeParser.RULE_expr13, _p);
                      let _la;
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 816;
                            this.expr14(0);
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 823;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 96, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr13Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr13);
                                  this.state = 818;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 819;
                                  _la = this._input.LA(1);
                                  if (!(_la === ForgeParser.SUBT_TOK || _la === ForgeParser.SUPT_TOK)) {
                                    this._errHandler.recoverInline(this);
                                  } else {
                                    if (this._input.LA(1) === Token_1.Token.EOF) {
                                      this.matchedEOF = true;
                                    }
                                    this._errHandler.reportMatch(this);
                                    this.consume();
                                  }
                                  this.state = 820;
                                  this.expr14(0);
                                }
                              }
                            }
                            this.state = 825;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 96, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr14(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr14Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 126;
                      this.enterRecursionRule(_localctx, 126, ForgeParser.RULE_expr14, _p);
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 827;
                            this.expr15(0);
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 836;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 97, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr14Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr14);
                                  this.state = 829;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 830;
                                  this.match(ForgeParser.LEFT_SQUARE_TOK);
                                  this.state = 831;
                                  this.exprList();
                                  this.state = 832;
                                  this.match(ForgeParser.RIGHT_SQUARE_TOK);
                                }
                              }
                            }
                            this.state = 838;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 97, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr15(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr15Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 128;
                      this.enterRecursionRule(_localctx, 128, ForgeParser.RULE_expr15, _p);
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 846;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 98, this._ctx)) {
                            case 1:
                              {
                                this.state = 840;
                                this.expr16(0);
                              }
                              break;
                            case 2:
                              {
                                this.state = 841;
                                this.name();
                                this.state = 842;
                                this.match(ForgeParser.LEFT_SQUARE_TOK);
                                this.state = 843;
                                this.exprList();
                                this.state = 844;
                                this.match(ForgeParser.RIGHT_SQUARE_TOK);
                              }
                              break;
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 853;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 99, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr15Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr15);
                                  this.state = 848;
                                  if (!this.precpred(this._ctx, 2)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 2)");
                                  }
                                  this.state = 849;
                                  this.match(ForgeParser.DOT_TOK);
                                  this.state = 850;
                                  this.expr16(0);
                                }
                              }
                            }
                            this.state = 855;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 99, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr16(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new Expr16Context(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 130;
                      this.enterRecursionRule(_localctx, 130, ForgeParser.RULE_expr16, _p);
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          {
                            this.state = 857;
                            this.expr17();
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 863;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 100, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new Expr16Context(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_expr16);
                                  this.state = 859;
                                  if (!this.precpred(this._ctx, 1)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 1)");
                                  }
                                  this.state = 860;
                                  this.match(ForgeParser.PRIME_TOK);
                                }
                              }
                            }
                            this.state = 865;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 100, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr17() {
                      let _localctx = new Expr17Context(this._ctx, this.state);
                      this.enterRule(_localctx, 132, ForgeParser.RULE_expr17);
                      let _la;
                      try {
                        this.state = 869;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.LEFT_CURLY_TOK:
                          case ForgeParser.LEFT_PAREN_TOK:
                          case ForgeParser.NONE_TOK:
                          case ForgeParser.UNIV_TOK:
                          case ForgeParser.IDEN_TOK:
                          case ForgeParser.MINUS_TOK:
                          case ForgeParser.AT_TOK:
                          case ForgeParser.BACKQUOTE_TOK:
                          case ForgeParser.THIS_TOK:
                          case ForgeParser.SEXPR_TOK:
                          case ForgeParser.SUM_TOK:
                          case ForgeParser.INT_TOK:
                          case ForgeParser.NUM_CONST_TOK:
                          case ForgeParser.IDENTIFIER_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 866;
                              this.expr18();
                            }
                            break;
                          case ForgeParser.TILDE_TOK:
                          case ForgeParser.EXP_TOK:
                          case ForgeParser.STAR_TOK:
                          case ForgeParser.GET_LABEL_TOK:
                          case ForgeParser.GET_LABEL_STR_TOK:
                          case ForgeParser.GET_LABEL_BOOL_TOK:
                          case ForgeParser.GET_LABEL_NUM_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 867;
                              _la = this._input.LA(1);
                              if (!((_la - 80 & ~31) === 0 && (1 << _la - 80 & (1 << ForgeParser.TILDE_TOK - 80 | 1 << ForgeParser.EXP_TOK - 80 | 1 << ForgeParser.STAR_TOK - 80 | 1 << ForgeParser.GET_LABEL_TOK - 80 | 1 << ForgeParser.GET_LABEL_STR_TOK - 80 | 1 << ForgeParser.GET_LABEL_BOOL_TOK - 80 | 1 << ForgeParser.GET_LABEL_NUM_TOK - 80)) !== 0)) {
                                this._errHandler.recoverInline(this);
                              } else {
                                if (this._input.LA(1) === Token_1.Token.EOF) {
                                  this.matchedEOF = true;
                                }
                                this._errHandler.reportMatch(this);
                                this.consume();
                              }
                              this.state = 868;
                              this.expr17();
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    expr18() {
                      let _localctx = new Expr18Context(this._ctx, this.state);
                      this.enterRule(_localctx, 134, ForgeParser.RULE_expr18);
                      try {
                        this.state = 889;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 102, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 871;
                              this.const();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 872;
                              this.qualName();
                            }
                            break;
                          case 3:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 873;
                              this.match(ForgeParser.AT_TOK);
                              this.state = 874;
                              this.name();
                            }
                            break;
                          case 4:
                            this.enterOuterAlt(_localctx, 4);
                            {
                              this.state = 875;
                              this.match(ForgeParser.BACKQUOTE_TOK);
                              this.state = 876;
                              this.name();
                            }
                            break;
                          case 5:
                            this.enterOuterAlt(_localctx, 5);
                            {
                              this.state = 877;
                              this.match(ForgeParser.THIS_TOK);
                            }
                            break;
                          case 6:
                            this.enterOuterAlt(_localctx, 6);
                            {
                              this.state = 878;
                              this.match(ForgeParser.LEFT_CURLY_TOK);
                              this.state = 879;
                              this.quantDeclList();
                              this.state = 880;
                              this.blockOrBar();
                              this.state = 881;
                              this.match(ForgeParser.RIGHT_CURLY_TOK);
                            }
                            break;
                          case 7:
                            this.enterOuterAlt(_localctx, 7);
                            {
                              this.state = 883;
                              this.match(ForgeParser.LEFT_PAREN_TOK);
                              this.state = 884;
                              this.expr();
                              this.state = 885;
                              this.match(ForgeParser.RIGHT_PAREN_TOK);
                            }
                            break;
                          case 8:
                            this.enterOuterAlt(_localctx, 8);
                            {
                              this.state = 887;
                              this.block();
                            }
                            break;
                          case 9:
                            this.enterOuterAlt(_localctx, 9);
                            {
                              this.state = 888;
                              this.sexpr();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    arrowExpr() {
                      let _localctx = new ArrowExprContext(this._ctx, this.state);
                      this.enterRule(_localctx, 136, ForgeParser.RULE_arrowExpr);
                      try {
                        this.state = 896;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 103, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 891;
                              this.qualName();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 892;
                              this.qualName();
                              this.state = 893;
                              this.match(ForgeParser.ARROW_TOK);
                              this.state = 894;
                              this.arrowExpr();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    sexprDecl() {
                      let _localctx = new SexprDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 138, ForgeParser.RULE_sexprDecl);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 898;
                          this.sexpr();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    sexpr() {
                      let _localctx = new SexprContext(this._ctx, this.state);
                      this.enterRule(_localctx, 140, ForgeParser.RULE_sexpr);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 900;
                          this.match(ForgeParser.SEXPR_TOK);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    instDecl() {
                      let _localctx = new InstDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 142, ForgeParser.RULE_instDecl);
                      let _la;
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 902;
                          this.match(ForgeParser.INST_TOK);
                          this.state = 903;
                          this.name();
                          this.state = 904;
                          this.bounds();
                          this.state = 906;
                          this._errHandler.sync(this);
                          _la = this._input.LA(1);
                          if (_la === ForgeParser.FOR_TOK) {
                            {
                              this.state = 905;
                              this.scope();
                            }
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    evalRelDecl() {
                      let _localctx = new EvalRelDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 144, ForgeParser.RULE_evalRelDecl);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 908;
                          this.arrowDecl();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    evalDecl() {
                      let _localctx = new EvalDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 146, ForgeParser.RULE_evalDecl);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 910;
                          this.match(ForgeParser.EVAL_TOK);
                          this.state = 911;
                          this.expr();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    exampleDecl() {
                      let _localctx = new ExampleDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 148, ForgeParser.RULE_exampleDecl);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 913;
                          this.match(ForgeParser.EXAMPLE_TOK);
                          this.state = 914;
                          this.name();
                          this.state = 915;
                          this.match(ForgeParser.IS_TOK);
                          this.state = 916;
                          this.expr();
                          this.state = 917;
                          this.match(ForgeParser.FOR_TOK);
                          this.state = 918;
                          this.bounds();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    queryDecl() {
                      let _localctx = new QueryDeclContext(this._ctx, this.state);
                      this.enterRule(_localctx, 150, ForgeParser.RULE_queryDecl);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 920;
                          this.name();
                          this.state = 921;
                          this.match(ForgeParser.COLON_TOK);
                          this.state = 922;
                          this.arrowExpr();
                          this.state = 923;
                          this.match(ForgeParser.EQ_TOK);
                          this.state = 924;
                          this.expr();
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    numberList() {
                      let _localctx = new NumberListContext(this._ctx, this.state);
                      this.enterRule(_localctx, 152, ForgeParser.RULE_numberList);
                      try {
                        this.state = 931;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 105, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 926;
                              this.number();
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 927;
                              this.number();
                              this.state = 928;
                              this.match(ForgeParser.COMMA_TOK);
                              this.state = 929;
                              this.numberList();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    number() {
                      let _localctx = new NumberContext(this._ctx, this.state);
                      this.enterRule(_localctx, 154, ForgeParser.RULE_number);
                      try {
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 933;
                          this.match(ForgeParser.NUM_CONST_TOK);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    bounds() {
                      let _localctx = new BoundsContext(this._ctx, this.state);
                      this.enterRule(_localctx, 156, ForgeParser.RULE_bounds);
                      let _la;
                      try {
                        this.state = 947;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.LEFT_CURLY_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 935;
                              this.match(ForgeParser.LEFT_CURLY_TOK);
                              this.state = 939;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              while (_la === ForgeParser.MINUS_TOK || (_la - 74 & ~31) === 0 && (1 << _la - 74 & (1 << ForgeParser.CARD_TOK - 74 | 1 << ForgeParser.BACKQUOTE_TOK - 74 | 1 << ForgeParser.THIS_TOK - 74 | 1 << ForgeParser.NO_TOK - 74 | 1 << ForgeParser.SUM_TOK - 74 | 1 << ForgeParser.INT_TOK - 74)) !== 0 || _la === ForgeParser.NUM_CONST_TOK || _la === ForgeParser.IDENTIFIER_TOK) {
                                {
                                  {
                                    this.state = 936;
                                    this.bound();
                                  }
                                }
                                this.state = 941;
                                this._errHandler.sync(this);
                                _la = this._input.LA(1);
                              }
                              this.state = 942;
                              this.match(ForgeParser.RIGHT_CURLY_TOK);
                            }
                            break;
                          case ForgeParser.EXACTLY_TOK:
                          case ForgeParser.THIS_TOK:
                          case ForgeParser.SUM_TOK:
                          case ForgeParser.INT_TOK:
                          case ForgeParser.IDENTIFIER_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 944;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              if (_la === ForgeParser.EXACTLY_TOK) {
                                {
                                  this.state = 943;
                                  this.match(ForgeParser.EXACTLY_TOK);
                                }
                              }
                              this.state = 946;
                              this.qualName();
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    atomNameOrNumber() {
                      let _localctx = new AtomNameOrNumberContext(this._ctx, this.state);
                      this.enterRule(_localctx, 158, ForgeParser.RULE_atomNameOrNumber);
                      try {
                        this.state = 954;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.BACKQUOTE_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 949;
                              this.match(ForgeParser.BACKQUOTE_TOK);
                              this.state = 950;
                              this.name();
                            }
                            break;
                          case ForgeParser.NUM_CONST_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 951;
                              this.number();
                            }
                            break;
                          case ForgeParser.MINUS_TOK:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 952;
                              this.match(ForgeParser.MINUS_TOK);
                              this.state = 953;
                              this.number();
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    bound() {
                      let _localctx = new BoundContext(this._ctx, this.state);
                      this.enterRule(_localctx, 160, ForgeParser.RULE_bound);
                      try {
                        this.state = 963;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 110, this._ctx)) {
                          case 1:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 956;
                              this.boundLHS();
                              this.state = 957;
                              this.compareOp();
                              this.state = 958;
                              this.bindRHSUnion(0);
                            }
                            break;
                          case 2:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 960;
                              this.match(ForgeParser.NO_TOK);
                              this.state = 961;
                              this.boundLHS();
                            }
                            break;
                          case 3:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 962;
                              this.qualName();
                            }
                            break;
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    boundLHS() {
                      let _localctx = new BoundLHSContext(this._ctx, this.state);
                      this.enterRule(_localctx, 162, ForgeParser.RULE_boundLHS);
                      let _la;
                      try {
                        this.state = 975;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.CARD_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 965;
                              this.match(ForgeParser.CARD_TOK);
                              this.state = 966;
                              this.qualName();
                            }
                            break;
                          case ForgeParser.THIS_TOK:
                          case ForgeParser.SUM_TOK:
                          case ForgeParser.INT_TOK:
                          case ForgeParser.IDENTIFIER_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 967;
                              this.qualName();
                            }
                            break;
                          case ForgeParser.MINUS_TOK:
                          case ForgeParser.BACKQUOTE_TOK:
                          case ForgeParser.NUM_CONST_TOK:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 968;
                              this.atomNameOrNumber();
                              this.state = 971;
                              this._errHandler.sync(this);
                              _la = this._input.LA(1);
                              do {
                                {
                                  {
                                    this.state = 969;
                                    this.match(ForgeParser.DOT_TOK);
                                    this.state = 970;
                                    this.qualName();
                                  }
                                }
                                this.state = 973;
                                this._errHandler.sync(this);
                                _la = this._input.LA(1);
                              } while (_la === ForgeParser.DOT_TOK);
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    bindRHSUnion(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new BindRHSUnionContext(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 164;
                      this.enterRecursionRule(_localctx, 164, ForgeParser.RULE_bindRHSUnion, _p);
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 983;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 113, this._ctx)) {
                            case 1:
                              {
                                this.state = 978;
                                this.bindRHSProduct(0);
                              }
                              break;
                            case 2:
                              {
                                this.state = 979;
                                this.match(ForgeParser.LEFT_PAREN_TOK);
                                this.state = 980;
                                this.bindRHSUnion(0);
                                this.state = 981;
                                this.match(ForgeParser.RIGHT_PAREN_TOK);
                              }
                              break;
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 990;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 114, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new BindRHSUnionContext(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_bindRHSUnion);
                                  this.state = 985;
                                  if (!this.precpred(this._ctx, 2)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 2)");
                                  }
                                  this.state = 986;
                                  this.match(ForgeParser.PLUS_TOK);
                                  this.state = 987;
                                  this.bindRHSProduct(0);
                                }
                              }
                            }
                            this.state = 992;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 114, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    bindRHSProduct(_p) {
                      if (_p === void 0) {
                        _p = 0;
                      }
                      let _parentctx = this._ctx;
                      let _parentState = this.state;
                      let _localctx = new BindRHSProductContext(this._ctx, _parentState);
                      let _prevctx = _localctx;
                      let _startState = 166;
                      this.enterRecursionRule(_localctx, 166, ForgeParser.RULE_bindRHSProduct, _p);
                      let _la;
                      try {
                        let _alt;
                        this.enterOuterAlt(_localctx, 1);
                        {
                          this.state = 999;
                          this._errHandler.sync(this);
                          switch (this.interpreter.adaptivePredict(this._input, 115, this._ctx)) {
                            case 1:
                              {
                                this.state = 994;
                                this.match(ForgeParser.LEFT_PAREN_TOK);
                                this.state = 995;
                                this.bindRHSProduct(0);
                                this.state = 996;
                                this.match(ForgeParser.RIGHT_PAREN_TOK);
                              }
                              break;
                            case 2:
                              {
                                this.state = 998;
                                this.bindRHSProductBase();
                              }
                              break;
                          }
                          this._ctx._stop = this._input.tryLT(-1);
                          this.state = 1006;
                          this._errHandler.sync(this);
                          _alt = this.interpreter.adaptivePredict(this._input, 116, this._ctx);
                          while (_alt !== 2 && _alt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
                            if (_alt === 1) {
                              if (this._parseListeners != null) {
                                this.triggerExitRuleEvent();
                              }
                              _prevctx = _localctx;
                              {
                                {
                                  _localctx = new BindRHSProductContext(_parentctx, _parentState);
                                  this.pushNewRecursionContext(_localctx, _startState, ForgeParser.RULE_bindRHSProduct);
                                  this.state = 1001;
                                  if (!this.precpred(this._ctx, 2)) {
                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 2)");
                                  }
                                  this.state = 1002;
                                  _la = this._input.LA(1);
                                  if (!(_la === ForgeParser.ARROW_TOK || _la === ForgeParser.COMMA_TOK)) {
                                    this._errHandler.recoverInline(this);
                                  } else {
                                    if (this._input.LA(1) === Token_1.Token.EOF) {
                                      this.matchedEOF = true;
                                    }
                                    this._errHandler.reportMatch(this);
                                    this.consume();
                                  }
                                  this.state = 1003;
                                  this.bindRHSProductBase();
                                }
                              }
                            }
                            this.state = 1008;
                            this._errHandler.sync(this);
                            _alt = this.interpreter.adaptivePredict(this._input, 116, this._ctx);
                          }
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.unrollRecursionContexts(_parentctx);
                      }
                      return _localctx;
                    }
                    // @RuleVersion(0)
                    bindRHSProductBase() {
                      let _localctx = new BindRHSProductBaseContext(this._ctx, this.state);
                      this.enterRule(_localctx, 168, ForgeParser.RULE_bindRHSProductBase);
                      try {
                        this.state = 1015;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                          case ForgeParser.MINUS_TOK:
                          case ForgeParser.BACKQUOTE_TOK:
                          case ForgeParser.NUM_CONST_TOK:
                            this.enterOuterAlt(_localctx, 1);
                            {
                              this.state = 1009;
                              this.atomNameOrNumber();
                            }
                            break;
                          case ForgeParser.THIS_TOK:
                          case ForgeParser.SUM_TOK:
                          case ForgeParser.INT_TOK:
                          case ForgeParser.IDENTIFIER_TOK:
                            this.enterOuterAlt(_localctx, 2);
                            {
                              this.state = 1010;
                              this.qualName();
                            }
                            break;
                          case ForgeParser.LEFT_PAREN_TOK:
                            this.enterOuterAlt(_localctx, 3);
                            {
                              this.state = 1011;
                              this.match(ForgeParser.LEFT_PAREN_TOK);
                              this.state = 1012;
                              this.bindRHSUnion(0);
                              this.state = 1013;
                              this.match(ForgeParser.RIGHT_PAREN_TOK);
                            }
                            break;
                          default:
                            throw new NoViableAltException_1.NoViableAltException(this);
                        }
                      } catch (re) {
                        if (re instanceof RecognitionException_1.RecognitionException) {
                          _localctx.exception = re;
                          this._errHandler.reportError(this, re);
                          this._errHandler.recover(this, re);
                        } else {
                          throw re;
                        }
                      } finally {
                        this.exitRule();
                      }
                      return _localctx;
                    }
                    sempred(_localctx, ruleIndex, predIndex) {
                      switch (ruleIndex) {
                        case 48:
                          return this.expr1_sempred(_localctx, predIndex);
                        case 49:
                          return this.expr1_5_sempred(_localctx, predIndex);
                        case 50:
                          return this.expr2_sempred(_localctx, predIndex);
                        case 52:
                          return this.expr4_sempred(_localctx, predIndex);
                        case 55:
                          return this.expr6_sempred(_localctx, predIndex);
                        case 57:
                          return this.expr8_sempred(_localctx, predIndex);
                        case 59:
                          return this.expr10_sempred(_localctx, predIndex);
                        case 60:
                          return this.expr11_sempred(_localctx, predIndex);
                        case 61:
                          return this.expr12_sempred(_localctx, predIndex);
                        case 62:
                          return this.expr13_sempred(_localctx, predIndex);
                        case 63:
                          return this.expr14_sempred(_localctx, predIndex);
                        case 64:
                          return this.expr15_sempred(_localctx, predIndex);
                        case 65:
                          return this.expr16_sempred(_localctx, predIndex);
                        case 82:
                          return this.bindRHSUnion_sempred(_localctx, predIndex);
                        case 83:
                          return this.bindRHSProduct_sempred(_localctx, predIndex);
                      }
                      return true;
                    }
                    expr1_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 0:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    expr1_5_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 1:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    expr2_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 2:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    expr4_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 3:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    expr6_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 4:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    expr8_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 5:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    expr10_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 6:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    expr11_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 7:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    expr12_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 8:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    expr13_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 9:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    expr14_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 10:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    expr15_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 11:
                          return this.precpred(this._ctx, 2);
                      }
                      return true;
                    }
                    expr16_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 12:
                          return this.precpred(this._ctx, 1);
                      }
                      return true;
                    }
                    bindRHSUnion_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 13:
                          return this.precpred(this._ctx, 2);
                      }
                      return true;
                    }
                    bindRHSProduct_sempred(_localctx, predIndex) {
                      switch (predIndex) {
                        case 14:
                          return this.precpred(this._ctx, 2);
                      }
                      return true;
                    }
                    static get _ATN() {
                      if (!ForgeParser.__ATN) {
                        ForgeParser.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(ForgeParser._serializedATN));
                      }
                      return ForgeParser.__ATN;
                    }
                  }
                  exports2.ForgeParser = ForgeParser;
                  ForgeParser.OPEN_TOK = 1;
                  ForgeParser.LEFT_SQUARE_TOK = 2;
                  ForgeParser.RIGHT_SQUARE_TOK = 3;
                  ForgeParser.AS_TOK = 4;
                  ForgeParser.FILE_PATH_TOK = 5;
                  ForgeParser.VAR_TOK = 6;
                  ForgeParser.ABSTRACT_TOK = 7;
                  ForgeParser.SIG_TOK = 8;
                  ForgeParser.LEFT_CURLY_TOK = 9;
                  ForgeParser.RIGHT_CURLY_TOK = 10;
                  ForgeParser.EXTENDS_TOK = 11;
                  ForgeParser.IN_TOK = 12;
                  ForgeParser.PLUS_TOK = 13;
                  ForgeParser.LONE_TOK = 14;
                  ForgeParser.SOME_TOK = 15;
                  ForgeParser.ONE_TOK = 16;
                  ForgeParser.TWO_TOK = 17;
                  ForgeParser.SET_TOK = 18;
                  ForgeParser.FUNC_TOK = 19;
                  ForgeParser.PFUNC_TOK = 20;
                  ForgeParser.DISJ_TOK = 21;
                  ForgeParser.COLON_TOK = 22;
                  ForgeParser.WHEAT_TOK = 23;
                  ForgeParser.PRED_TOK = 24;
                  ForgeParser.DOT_TOK = 25;
                  ForgeParser.FUN_TOK = 26;
                  ForgeParser.LEFT_PAREN_TOK = 27;
                  ForgeParser.RIGHT_PAREN_TOK = 28;
                  ForgeParser.ASSERT_TOK = 29;
                  ForgeParser.RUN_TOK = 30;
                  ForgeParser.CHECK_TOK = 31;
                  ForgeParser.FOR_TOK = 32;
                  ForgeParser.BUT_TOK = 33;
                  ForgeParser.EXACTLY_TOK = 34;
                  ForgeParser.NONE_TOK = 35;
                  ForgeParser.UNIV_TOK = 36;
                  ForgeParser.IDEN_TOK = 37;
                  ForgeParser.MINUS_TOK = 38;
                  ForgeParser.IS_TOK = 39;
                  ForgeParser.SAT_TOK = 40;
                  ForgeParser.UNSAT_TOK = 41;
                  ForgeParser.THEOREM_TOK = 42;
                  ForgeParser.FORGE_ERROR_TOK = 43;
                  ForgeParser.CHECKED_TOK = 44;
                  ForgeParser.TEST_TOK = 45;
                  ForgeParser.EXPECT_TOK = 46;
                  ForgeParser.SUITE_TOK = 47;
                  ForgeParser.BAR_TOK = 48;
                  ForgeParser.ALL_TOK = 49;
                  ForgeParser.SUFFICIENT_TOK = 50;
                  ForgeParser.NECESSARY_TOK = 51;
                  ForgeParser.CONSISTENT_TOK = 52;
                  ForgeParser.INCONSISTENT_TOK = 53;
                  ForgeParser.WITH_TOK = 54;
                  ForgeParser.LET_TOK = 55;
                  ForgeParser.BIND_TOK = 56;
                  ForgeParser.OR_TOK = 57;
                  ForgeParser.XOR_TOK = 58;
                  ForgeParser.IFF_TOK = 59;
                  ForgeParser.IMP_TOK = 60;
                  ForgeParser.ELSE_TOK = 61;
                  ForgeParser.AND_TOK = 62;
                  ForgeParser.UNTIL_TOK = 63;
                  ForgeParser.RELEASE_TOK = 64;
                  ForgeParser.SINCE_TOK = 65;
                  ForgeParser.TRIGGERED_TOK = 66;
                  ForgeParser.NEG_TOK = 67;
                  ForgeParser.ALWAYS_TOK = 68;
                  ForgeParser.EVENTUALLY_TOK = 69;
                  ForgeParser.AFTER_TOK = 70;
                  ForgeParser.BEFORE_TOK = 71;
                  ForgeParser.ONCE_TOK = 72;
                  ForgeParser.HISTORICALLY_TOK = 73;
                  ForgeParser.CARD_TOK = 74;
                  ForgeParser.PPLUS_TOK = 75;
                  ForgeParser.AMP_TOK = 76;
                  ForgeParser.SUBT_TOK = 77;
                  ForgeParser.SUPT_TOK = 78;
                  ForgeParser.PRIME_TOK = 79;
                  ForgeParser.TILDE_TOK = 80;
                  ForgeParser.EXP_TOK = 81;
                  ForgeParser.STAR_TOK = 82;
                  ForgeParser.AT_TOK = 83;
                  ForgeParser.BACKQUOTE_TOK = 84;
                  ForgeParser.THIS_TOK = 85;
                  ForgeParser.SEXPR_TOK = 86;
                  ForgeParser.INST_TOK = 87;
                  ForgeParser.EVAL_TOK = 88;
                  ForgeParser.EXAMPLE_TOK = 89;
                  ForgeParser.ARROW_TOK = 90;
                  ForgeParser.GET_LABEL_TOK = 91;
                  ForgeParser.GET_LABEL_STR_TOK = 92;
                  ForgeParser.GET_LABEL_BOOL_TOK = 93;
                  ForgeParser.GET_LABEL_NUM_TOK = 94;
                  ForgeParser.EQ_TOK = 95;
                  ForgeParser.LT_TOK = 96;
                  ForgeParser.GT_TOK = 97;
                  ForgeParser.LEQ_TOK = 98;
                  ForgeParser.GEQ_TOK = 99;
                  ForgeParser.NI_TOK = 100;
                  ForgeParser.NO_TOK = 101;
                  ForgeParser.SUM_TOK = 102;
                  ForgeParser.INT_TOK = 103;
                  ForgeParser.OPTION_TOK = 104;
                  ForgeParser.COMMA_TOK = 105;
                  ForgeParser.SLASH_TOK = 106;
                  ForgeParser.NUM_CONST_TOK = 107;
                  ForgeParser.IDENTIFIER_TOK = 108;
                  ForgeParser.WS = 109;
                  ForgeParser.CCOMMENT = 110;
                  ForgeParser.COMMENT = 111;
                  ForgeParser.MULTCOMMENT = 112;
                  ForgeParser.LANG_DECL = 113;
                  ForgeParser.RULE_predDecl = 0;
                  ForgeParser.RULE_parseExpr = 1;
                  ForgeParser.RULE_alloyModule = 2;
                  ForgeParser.RULE_importDecl = 3;
                  ForgeParser.RULE_paragraph = 4;
                  ForgeParser.RULE_sigDecl = 5;
                  ForgeParser.RULE_sigExt = 6;
                  ForgeParser.RULE_mult = 7;
                  ForgeParser.RULE_arrowMult = 8;
                  ForgeParser.RULE_helperMult = 9;
                  ForgeParser.RULE_paraDecl = 10;
                  ForgeParser.RULE_quantDecl = 11;
                  ForgeParser.RULE_arrowDecl = 12;
                  ForgeParser.RULE_predType = 13;
                  ForgeParser.RULE_funDecl = 14;
                  ForgeParser.RULE_paraDecls = 15;
                  ForgeParser.RULE_assertDecl = 16;
                  ForgeParser.RULE_cmdDecl = 17;
                  ForgeParser.RULE_testDecl = 18;
                  ForgeParser.RULE_testExpectDecl = 19;
                  ForgeParser.RULE_testBlock = 20;
                  ForgeParser.RULE_scope = 21;
                  ForgeParser.RULE_typescope = 22;
                  ForgeParser.RULE_const = 23;
                  ForgeParser.RULE_satisfiabilityDecl = 24;
                  ForgeParser.RULE_quantifiedPropertyDecl = 25;
                  ForgeParser.RULE_propertyDecl = 26;
                  ForgeParser.RULE_consistencyDecl = 27;
                  ForgeParser.RULE_testSuiteDecl = 28;
                  ForgeParser.RULE_testConstruct = 29;
                  ForgeParser.RULE_arrowOp = 30;
                  ForgeParser.RULE_compareOp = 31;
                  ForgeParser.RULE_letDecl = 32;
                  ForgeParser.RULE_block = 33;
                  ForgeParser.RULE_blockOrBar = 34;
                  ForgeParser.RULE_quant = 35;
                  ForgeParser.RULE_qualName = 36;
                  ForgeParser.RULE_optionDecl = 37;
                  ForgeParser.RULE_name = 38;
                  ForgeParser.RULE_nameList = 39;
                  ForgeParser.RULE_qualNameList = 40;
                  ForgeParser.RULE_paraDeclList = 41;
                  ForgeParser.RULE_quantDeclList = 42;
                  ForgeParser.RULE_arrowDeclList = 43;
                  ForgeParser.RULE_letDeclList = 44;
                  ForgeParser.RULE_typescopeList = 45;
                  ForgeParser.RULE_exprList = 46;
                  ForgeParser.RULE_expr = 47;
                  ForgeParser.RULE_expr1 = 48;
                  ForgeParser.RULE_expr1_5 = 49;
                  ForgeParser.RULE_expr2 = 50;
                  ForgeParser.RULE_expr3 = 51;
                  ForgeParser.RULE_expr4 = 52;
                  ForgeParser.RULE_expr4_5 = 53;
                  ForgeParser.RULE_expr5 = 54;
                  ForgeParser.RULE_expr6 = 55;
                  ForgeParser.RULE_expr7 = 56;
                  ForgeParser.RULE_expr8 = 57;
                  ForgeParser.RULE_expr9 = 58;
                  ForgeParser.RULE_expr10 = 59;
                  ForgeParser.RULE_expr11 = 60;
                  ForgeParser.RULE_expr12 = 61;
                  ForgeParser.RULE_expr13 = 62;
                  ForgeParser.RULE_expr14 = 63;
                  ForgeParser.RULE_expr15 = 64;
                  ForgeParser.RULE_expr16 = 65;
                  ForgeParser.RULE_expr17 = 66;
                  ForgeParser.RULE_expr18 = 67;
                  ForgeParser.RULE_arrowExpr = 68;
                  ForgeParser.RULE_sexprDecl = 69;
                  ForgeParser.RULE_sexpr = 70;
                  ForgeParser.RULE_instDecl = 71;
                  ForgeParser.RULE_evalRelDecl = 72;
                  ForgeParser.RULE_evalDecl = 73;
                  ForgeParser.RULE_exampleDecl = 74;
                  ForgeParser.RULE_queryDecl = 75;
                  ForgeParser.RULE_numberList = 76;
                  ForgeParser.RULE_number = 77;
                  ForgeParser.RULE_bounds = 78;
                  ForgeParser.RULE_atomNameOrNumber = 79;
                  ForgeParser.RULE_bound = 80;
                  ForgeParser.RULE_boundLHS = 81;
                  ForgeParser.RULE_bindRHSUnion = 82;
                  ForgeParser.RULE_bindRHSProduct = 83;
                  ForgeParser.RULE_bindRHSProductBase = 84;
                  ForgeParser.ruleNames = [
                    "predDecl",
                    "parseExpr",
                    "alloyModule",
                    "importDecl",
                    "paragraph",
                    "sigDecl",
                    "sigExt",
                    "mult",
                    "arrowMult",
                    "helperMult",
                    "paraDecl",
                    "quantDecl",
                    "arrowDecl",
                    "predType",
                    "funDecl",
                    "paraDecls",
                    "assertDecl",
                    "cmdDecl",
                    "testDecl",
                    "testExpectDecl",
                    "testBlock",
                    "scope",
                    "typescope",
                    "const",
                    "satisfiabilityDecl",
                    "quantifiedPropertyDecl",
                    "propertyDecl",
                    "consistencyDecl",
                    "testSuiteDecl",
                    "testConstruct",
                    "arrowOp",
                    "compareOp",
                    "letDecl",
                    "block",
                    "blockOrBar",
                    "quant",
                    "qualName",
                    "optionDecl",
                    "name",
                    "nameList",
                    "qualNameList",
                    "paraDeclList",
                    "quantDeclList",
                    "arrowDeclList",
                    "letDeclList",
                    "typescopeList",
                    "exprList",
                    "expr",
                    "expr1",
                    "expr1_5",
                    "expr2",
                    "expr3",
                    "expr4",
                    "expr4_5",
                    "expr5",
                    "expr6",
                    "expr7",
                    "expr8",
                    "expr9",
                    "expr10",
                    "expr11",
                    "expr12",
                    "expr13",
                    "expr14",
                    "expr15",
                    "expr16",
                    "expr17",
                    "expr18",
                    "arrowExpr",
                    "sexprDecl",
                    "sexpr",
                    "instDecl",
                    "evalRelDecl",
                    "evalDecl",
                    "exampleDecl",
                    "queryDecl",
                    "numberList",
                    "number",
                    "bounds",
                    "atomNameOrNumber",
                    "bound",
                    "boundLHS",
                    "bindRHSUnion",
                    "bindRHSProduct",
                    "bindRHSProductBase"
                  ];
                  ForgeParser._LITERAL_NAMES = [
                    void 0,
                    "'open'",
                    "'['",
                    "']'",
                    "'as'",
                    void 0,
                    "'var'",
                    "'abstract'",
                    "'sig'",
                    "'{'",
                    "'}'",
                    "'extends'",
                    "'in'",
                    "'+'",
                    "'lone'",
                    "'some'",
                    "'one'",
                    "'two'",
                    "'set'",
                    "'func'",
                    "'pfunc'",
                    "'disj'",
                    "':'",
                    "'wheat'",
                    "'pred'",
                    "'.'",
                    "'fun'",
                    "'('",
                    "')'",
                    "'assert'",
                    "'run'",
                    "'check'",
                    "'for'",
                    "'but'",
                    "'exactly'",
                    "'none'",
                    "'univ'",
                    "'iden'",
                    "'-'",
                    "'is'",
                    "'sat'",
                    "'unsat'",
                    "'theorem'",
                    "'forge_error'",
                    "'checked'",
                    "'test'",
                    "'expect'",
                    "'suite'",
                    "'|'",
                    "'all'",
                    "'sufficient'",
                    "'necessary'",
                    "'consistent'",
                    "'inconsistent'",
                    "'with'",
                    "'let'",
                    "'bind'",
                    void 0,
                    "'xor'",
                    void 0,
                    void 0,
                    "'else'",
                    void 0,
                    "'until'",
                    "'release'",
                    "'since'",
                    "'triggered'",
                    void 0,
                    "'always'",
                    "'eventually'",
                    "'after'",
                    "'before'",
                    "'once'",
                    "'historically'",
                    "'#'",
                    "'++'",
                    "'&'",
                    "'<:'",
                    "':>'",
                    "'''",
                    "'~'",
                    "'^'",
                    "'*'",
                    "'@'",
                    "'`'",
                    "'this'",
                    "'sexpr'",
                    "'inst'",
                    "'eval'",
                    "'example'",
                    "'->'",
                    "'@:'",
                    "'@str:'",
                    "'@bool:'",
                    "'@num:'",
                    "'='",
                    "'<'",
                    "'>'",
                    void 0,
                    "'>='",
                    "'ni'",
                    "'no'",
                    "'sum'",
                    "'Int'",
                    "'option'",
                    "','",
                    "'/'"
                  ];
                  ForgeParser._SYMBOLIC_NAMES = [
                    void 0,
                    "OPEN_TOK",
                    "LEFT_SQUARE_TOK",
                    "RIGHT_SQUARE_TOK",
                    "AS_TOK",
                    "FILE_PATH_TOK",
                    "VAR_TOK",
                    "ABSTRACT_TOK",
                    "SIG_TOK",
                    "LEFT_CURLY_TOK",
                    "RIGHT_CURLY_TOK",
                    "EXTENDS_TOK",
                    "IN_TOK",
                    "PLUS_TOK",
                    "LONE_TOK",
                    "SOME_TOK",
                    "ONE_TOK",
                    "TWO_TOK",
                    "SET_TOK",
                    "FUNC_TOK",
                    "PFUNC_TOK",
                    "DISJ_TOK",
                    "COLON_TOK",
                    "WHEAT_TOK",
                    "PRED_TOK",
                    "DOT_TOK",
                    "FUN_TOK",
                    "LEFT_PAREN_TOK",
                    "RIGHT_PAREN_TOK",
                    "ASSERT_TOK",
                    "RUN_TOK",
                    "CHECK_TOK",
                    "FOR_TOK",
                    "BUT_TOK",
                    "EXACTLY_TOK",
                    "NONE_TOK",
                    "UNIV_TOK",
                    "IDEN_TOK",
                    "MINUS_TOK",
                    "IS_TOK",
                    "SAT_TOK",
                    "UNSAT_TOK",
                    "THEOREM_TOK",
                    "FORGE_ERROR_TOK",
                    "CHECKED_TOK",
                    "TEST_TOK",
                    "EXPECT_TOK",
                    "SUITE_TOK",
                    "BAR_TOK",
                    "ALL_TOK",
                    "SUFFICIENT_TOK",
                    "NECESSARY_TOK",
                    "CONSISTENT_TOK",
                    "INCONSISTENT_TOK",
                    "WITH_TOK",
                    "LET_TOK",
                    "BIND_TOK",
                    "OR_TOK",
                    "XOR_TOK",
                    "IFF_TOK",
                    "IMP_TOK",
                    "ELSE_TOK",
                    "AND_TOK",
                    "UNTIL_TOK",
                    "RELEASE_TOK",
                    "SINCE_TOK",
                    "TRIGGERED_TOK",
                    "NEG_TOK",
                    "ALWAYS_TOK",
                    "EVENTUALLY_TOK",
                    "AFTER_TOK",
                    "BEFORE_TOK",
                    "ONCE_TOK",
                    "HISTORICALLY_TOK",
                    "CARD_TOK",
                    "PPLUS_TOK",
                    "AMP_TOK",
                    "SUBT_TOK",
                    "SUPT_TOK",
                    "PRIME_TOK",
                    "TILDE_TOK",
                    "EXP_TOK",
                    "STAR_TOK",
                    "AT_TOK",
                    "BACKQUOTE_TOK",
                    "THIS_TOK",
                    "SEXPR_TOK",
                    "INST_TOK",
                    "EVAL_TOK",
                    "EXAMPLE_TOK",
                    "ARROW_TOK",
                    "GET_LABEL_TOK",
                    "GET_LABEL_STR_TOK",
                    "GET_LABEL_BOOL_TOK",
                    "GET_LABEL_NUM_TOK",
                    "EQ_TOK",
                    "LT_TOK",
                    "GT_TOK",
                    "LEQ_TOK",
                    "GEQ_TOK",
                    "NI_TOK",
                    "NO_TOK",
                    "SUM_TOK",
                    "INT_TOK",
                    "OPTION_TOK",
                    "COMMA_TOK",
                    "SLASH_TOK",
                    "NUM_CONST_TOK",
                    "IDENTIFIER_TOK",
                    "WS",
                    "CCOMMENT",
                    "COMMENT",
                    "MULTCOMMENT",
                    "LANG_DECL"
                  ];
                  ForgeParser.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(ForgeParser._LITERAL_NAMES, ForgeParser._SYMBOLIC_NAMES, []);
                  ForgeParser._serializedATNSegments = 2;
                  ForgeParser._serializedATNSegment0 = `\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241s\u03FC					\x07	\x07\b	\b			
	
\v	\v\f	\f\r	\r													\x1B	\x1B				 	 !	!"	"#	#$	$%	%&	&'	'(	()	)*	*+	+,	,-	-.	./	/0	01	12	23	34	45	56	67	78	89	9:	:;	;<	<=	=>	>?	?@	@A	AB	BC	CD	DE	EF	FG	GH	HI	IJ	JK	KL	LM	MN	NO	OP	PQ	QR	RS	ST	TU	UV	V\xAF
\xB4
\xB8
\x07\xC0
\f\xC3\v\x07\xC6
\f\xC9\v\x07\xCC
\f\xCF\v\xD1
\xD9
\xDD
\xE3
\xE5
\xF8
\x07\x07\xFB
\x07\x07\x07\xFE
\x07\x07\x07\u0101
\x07\x07\x07\x07\x07\u0106
\x07\x07\x07\x07\u010A
\x07\x07\x07\x07\u010E
\x07\b\b\b\b\b\b\x07\b\u0116
\b\f\b\b\u0119\v\b\b\u011B
\b		

\v\v\f\f\u0124
\f\f\f\f\f\u0129
\f\f\f\r\r\u012E
\r\r\r\r\r\u0133
\r\r\r\u0138
\u0145
\u0149
\u014D
\u0156
\u015B
\u015E
\u0162
\u0169
\u016E
\u0171
\u0175
\u017A
\u017E
\u0181
\u0185
\u018B
\u018F
\x07\u0195
\f\u0198\v\u01A0
\u01A4
\u01A7
\u01B0
\u01B3
\u01BA
\u01BE
\x1B\x1B\x1B\x1B\u01C3
\x1B\x1B\x1B\x1B\x1B\x1B\x1B\x1B\x1B\x1B\x1B\x1B\x1B\u01D0
\x1B\x1B\x1B\u01D3
\x1B\x1B\x1B\x1B\u01D7
\x1B\u01E0
\u01E4
\u01ED
\u01F1
\x07\u01F9
\f\u01FC\v\u0206
   \u020A
     \u020F
 !!""""##\x07#\u0219
#\f##\u021C\v###$$$$\u0223
$%%%%%\u0229
%&&&\u022D
&&&&\x07&\u0232
&\f&&\u0235\v&&&&&\u023A
&''''''\u0241
'''\u0244
'(())))))\u024D
)******\u0254
*++++++\u025B
+,,,,,,\u0262
,------\u0269
-......\u0270
.//////\u0277
/000000\u027E
0111111111111\u028B
11111\u0290
1222222\x072\u0298
2\f22\u029B\v2333333\x073\u02A3
3\f33\u02A6\v3444444\x074\u02AE
4\f44\u02B1\v45555555\u02B9
55\u02BB
5666666\x076\u02C3
6\f66\u02C6\v6777777777777777777\u02D9
78888888888888888\u02EA
8999999\u02F1
9999\x079\u02F6
9\f99\u02F9\v9::::\u02FE
:;;;;;;\x07;\u0306
;\f;;\u0309\v;<<<<\u030E
<======\x07=\u0316
=\f==\u0319\v=>>>>>>\x07>\u0321
>\f>>\u0324\v>???????\x07?\u032D
?\f??\u0330\v?@@@@@@\x07@\u0338
@\f@@\u033B\v@AAAAAAAA\x07A\u0345
A\fAA\u0348\vABBBBBBBB\u0351
BBBB\x07B\u0356
B\fBB\u0359\vBCCCCC\x07C\u0360
C\fCC\u0363\vCDDDD\u0368
DEEEEEEEEEEEEEEEEEEE\u037C
EFFFFFF\u0383
FGGHHIIIII\u038D
IJJKKKLLLLLLLMMMMMMNNNNNN\u03A6
NOOPP\x07P\u03AC
P\fPP\u03AF\vPPPP\u03B3
PPP\u03B6
PQQQQQQ\u03BD
QRRRRRRRR\u03C6
RSSSSSSS\u03CE
S\rSS\u03CFS\u03D2
STTTTTTT\u03DA
TTTT\x07T\u03DF
T\fTT\u03E2\vTUUUUUUU\u03EA
UUUU\x07U\u03EF
U\fUU\u03F2\vUVVVVVVV\u03FA
VVbdfjptxz|~\x80\x82\x84\xA6\xA8W\b
\f "$&(*,.02468:<>@BDFHJLNPRTVXZ\\^\`bdfhjlnprtvxz|~\x80\x82\x84\x86\x88\x8A\x8C\x8E\x90\x92\x94\x96\x98\x9A\x9C\x9E\xA0\xA2\xA4\xA6\xA8\xAA !*.*+--4567))afgg((OPRT]\`\\\\kk\u044E\xAC\xBB\xD0\b\xE4
\xF7\f\xFA\u011A\u011C\u011E\u0120\u0123\u012D\u0137\u013E\u0140 \u015D"\u015F$\u0168&\u0179(\u018A*\u0192,\u01A3.\u01A60\u01B22\u01B44\u01BF6\u01D88\u01E5:\u01F2<\u0205>\u0209@\u0210B\u0212D\u0216F\u0222H\u0228J\u0239L\u023BN\u0245P\u024CR\u0253T\u025AV\u0261X\u0268Z\u026F\\\u0276^\u027D\`\u028Fb\u0291d\u029Cf\u02A7h\u02BAj\u02BCl\u02D8n\u02E9p\u02EBr\u02FDt\u02FFv\u030Dx\u030Fz\u031A|\u0325~\u0331\x80\u033C\x82\u0350\x84\u035A\x86\u0367\x88\u037B\x8A\u0382\x8C\u0384\x8E\u0386\x90\u0388\x92\u038E\x94\u0390\x96\u0393\x98\u039A\x9A\u03A5\x9C\u03A7\x9E\u03B5\xA0\u03BC\xA2\u03C5\xA4\u03D1\xA6\u03D9\xA8\u03E9\xAA\u03F9\xAC\xAE\x07\xAD\xAF\xAE\xAD\xAE\xAF\xAF\xB3\xB0\xB1J&\xB1\xB2\x07\x1B\xB2\xB4\xB3\xB0\xB3\xB4\xB4\xB5\xB5\xB7N(\xB6\xB8 \xB7\xB6\xB7\xB8\xB8\xB9\xB9\xBAD#\xBA\xBB\xBC\`1\xBC\xBD\x07\xBD\xBE\xC0\b\xBF\xBE\xC0\xC3\xC1\xBF\xC1\xC2\xC2\xC7\xC3\xC1\xC4\xC6
\xC5\xC4\xC6\xC9\xC7\xC5\xC7\xC8\xC8\xD1\xC9\xC7\xCA\xCC\x94K\xCB\xCA\xCC\xCF\xCD\xCB\xCD\xCE\xCE\xD1\xCF\xCD\xD0\xC1\xD0\xCD\xD1\x07\xD2\xD3\x07\xD3\xD8J&\xD4\xD5\x07\xD5\xD6R*\xD6\xD7\x07\xD7\xD9\xD8\xD4\xD8\xD9\xD9\xDC\xDA\xDB\x07\xDB\xDDN(\xDC\xDA\xDC\xDD\xDD\xE5\xDE\xDF\x07\xDF\xE2\x07\x07\xE0\xE1\x07\xE1\xE3N(\xE2\xE0\xE2\xE3\xE3\xE5\xE4\xD2\xE4\xDE\xE5	\xE6\xF8\f\x07\xE7\xF8\xE8\xF8\xE9\xF8"\xEA\xF8$\xEB\xF8(\xEC\xF8\x8CG\xED\xF8\x98M\xEE\xF8\x92J\xEF\xF8L'\xF0\xF8\x90I\xF1\xF8\x96L\xF2\xF86\xF3\xF84\x1B\xF4\xF82\xF5\xF88\xF6\xF8:\xF7\xE6\xF7\xE7\xF7\xE8\xF7\xE9\xF7\xEA\xF7\xEB\xF7\xEC\xF7\xED\xF7\xEE\xF7\xEF\xF7\xF0\xF7\xF1\xF7\xF2\xF7\xF3\xF7\xF4\xF7\xF5\xF7\xF6\xF8\v\xF9\xFB\x07\b\xFA\xF9\xFA\xFB\xFB\xFD\xFC\xFE\x07	\xFD\xFC\xFD\xFE\xFE\u0100\xFF\u0101	\u0100\xFF\u0100\u0101\u0101\u0102\u0102\u0103\x07
\u0103\u0105P)\u0104\u0106\b\u0105\u0104\u0105\u0106\u0106\u0107\u0107\u0109\x07\v\u0108\u010AX-\u0109\u0108\u0109\u010A\u010A\u010B\u010B\u010D\x07\f\u010C\u010ED#\u010D\u010C\u010D\u010E\u010E\r\u010F\u0110\x07\r\u0110\u011BJ&\u0111\u0112\x07\u0112\u0117J&\u0113\u0114\x07\u0114\u0116J&\u0115\u0113\u0116\u0119\u0117\u0115\u0117\u0118\u0118\u011B\u0119\u0117\u011A\u010F\u011A\u0111\u011B\u011C\u011D	\u011D\u011E\u011F	\u011F\u0120\u0121	\u0121\u0122\u0124\x07\u0123\u0122\u0123\u0124\u0124\u0125\u0125\u0126P)\u0126\u0128\x07\u0127\u0129\v\u0128\u0127\u0128\u0129\u0129\u012A\u012A\u012B\`1\u012B\u012C\u012E\x07\u012D\u012C\u012D\u012E\u012E\u012F\u012F\u0130P)\u0130\u0132\x07\u0131\u0133\x07\u0132\u0131\u0132\u0133\u0133\u0134\u0134\u0135\`1\u0135\u0136\u0138\x07\b\u0137\u0136\u0137\u0138\u0138\u0139\u0139\u013AP)\u013A\u013B\x07\u013B\u013C
\u013C\u013D\x8AF\u013D\x1B\u013E\u013F\x07\u013F\u0140\u0144\x07\u0141\u0142J&\u0142\u0143\x07\x1B\u0143\u0145\u0144\u0141\u0144\u0145\u0145\u0146\u0146\u0148N(\u0147\u0149 \u0148\u0147\u0148\u0149\u0149\u014A\u014A\u014C\x07\u014B\u014D\v\u014C\u014B\u014C\u014D\u014D\u014E\u014E\u014F\`1\u014F\u0150\x07\v\u0150\u0151\`1\u0151\u0152\x07\f\u0152\u0153\u0155\x07\u0154\u0156T+\u0155\u0154\u0155\u0156\u0156\u0157\u0157\u015E\x07\u0158\u015A\x07\u0159\u015BT+\u015A\u0159\u015A\u015B\u015B\u015C\u015C\u015E\x07\u015D\u0153\u015D\u0158\u015E!\u015F\u0161\x07\u0160\u0162N(\u0161\u0160\u0161\u0162\u0162\u0163\u0163\u0164D#\u0164#\u0165\u0166N(\u0166\u0167\x07\u0167\u0169\u0168\u0165\u0168\u0169\u0169\u016A\u016A\u016D	\u016B\u016EJ&\u016C\u016ED#\u016D\u016B\u016D\u016C\u016D\u016E\u016E\u0170\u016F\u0171,\u0170\u016F\u0170\u0171\u0171\u0174\u0172\u0173\x07"\u0173\u0175\x9EP\u0174\u0172\u0174\u0175\u0175%\u0176\u0177N(\u0177\u0178\x07\u0178\u017A\u0179\u0176\u0179\u017A\u017A\u017D\u017B\u017EJ&\u017C\u017ED#\u017D\u017B\u017D\u017C\u017E\u0180\u017F\u0181,\u0180\u017F\u0180\u0181\u0181\u0184\u0182\u0183\x07"\u0183\u0185\x9EP\u0184\u0182\u0184\u0185\u0185\u0186\u0186\u0187\x07)\u0187\u0188	\u0188'\u0189\u018B\x07/\u018A\u0189\u018A\u018B\u018B\u018C\u018C\u018E\x070\u018D\u018FN(\u018E\u018D\u018E\u018F\u018F\u0190\u0190\u0191*\u0191)\u0192\u0196\x07\v\u0193\u0195&\u0194\u0193\u0195\u0198\u0196\u0194\u0196\u0197\u0197\u0199\u0198\u0196\u0199\u019A\x07\f\u019A+\u019B\u019C\x07"\u019C\u019F\x9CO\u019D\u019E\x07#\u019E\u01A0\\/\u019F\u019D\u019F\u01A0\u01A0\u01A4\u01A1\u01A2\x07"\u01A2\u01A4\\/\u01A3\u019B\u01A3\u01A1\u01A4-\u01A5\u01A7\x07$\u01A6\u01A5\u01A6\u01A7\u01A7\u01A8\u01A8\u01A9\x9CO\u01A9\u01AAJ&\u01AA/\u01AB\u01B3\x07%\u01AC\u01B3\x07&\u01AD\u01B3\x07'\u01AE\u01B0\x07(\u01AF\u01AE\u01AF\u01B0\u01B0\u01B1\u01B1\u01B3\x9CO\u01B2\u01AB\u01B2\u01AC\u01B2\u01AD\u01B2\u01AF\u01B31\u01B4\u01B5\x07\u01B5\u01B6\`1\u01B6\u01B7\x07)\u01B7\u01B9	\x07\u01B8\u01BA,\u01B9\u01B8\u01B9\u01BA\u01BA\u01BD\u01BB\u01BC`;
                  ForgeParser._serializedATNSegment1 = '\x07"\u01BC\u01BE\x9EP\u01BD\u01BB\u01BD\u01BE\u01BE3\u01BF\u01C0\x07\u01C0\u01C2\x073\u01C1\u01C3\x07\u01C2\u01C1\u01C2\u01C3\u01C3\u01C4\u01C4\u01C5V,\u01C5\u01C6\x072\u01C6\u01C7`1\u01C7\u01C8\x07)\u01C8\u01C9	\b\u01C9\u01CA\x07"\u01CA\u01CFN(\u01CB\u01CC\x07\u01CC\u01CD^0\u01CD\u01CE\x07\u01CE\u01D0\u01CF\u01CB\u01CF\u01D0\u01D0\u01D2\u01D1\u01D3,\u01D2\u01D1\u01D2\u01D3\u01D3\u01D6\u01D4\u01D5\x07"\u01D5\u01D7\x9EP\u01D6\u01D4\u01D6\u01D7\u01D75\u01D8\u01D9\x07\u01D9\u01DA`1\u01DA\u01DB\x07)\u01DB\u01DC	\b\u01DC\u01DD\x07"\u01DD\u01DFN(\u01DE\u01E0,\u01DF\u01DE\u01DF\u01E0\u01E0\u01E3\u01E1\u01E2\x07"\u01E2\u01E4\x9EP\u01E3\u01E1\u01E3\u01E4\u01E47\u01E5\u01E6\x07\u01E6\u01E7`1\u01E7\u01E8\x07)\u01E8\u01E9		\u01E9\u01EA\x078\u01EA\u01ECN(\u01EB\u01ED,\u01EC\u01EB\u01EC\u01ED\u01ED\u01F0\u01EE\u01EF\x07"\u01EF\u01F1\x9EP\u01F0\u01EE\u01F0\u01F1\u01F19\u01F2\u01F3\x07/\u01F3\u01F4\x071\u01F4\u01F5\x07"\u01F5\u01F6N(\u01F6\u01FA\x07\v\u01F7\u01F9<\u01F8\u01F7\u01F9\u01FC\u01FA\u01F8\u01FA\u01FB\u01FB\u01FD\u01FC\u01FA\u01FD\u01FE\x07\f\u01FE;\u01FF\u0206\x96L\u0200\u0206(\u0201\u02064\x1B\u0202\u02066\u0203\u02062\u0204\u02068\u0205\u01FF\u0205\u0200\u0205\u0201\u0205\u0202\u0205\u0203\u0205\u0204\u0206=\u0207\u020A	\u0208\u020A\x07\u0209\u0207\u0209\u0208\u0209\u020A\u020A\u020B\u020B\u020E\x07\\\u020C\u020F	\u020D\u020F\x07\u020E\u020C\u020E\u020D\u020E\u020F\u020F?\u0210\u0211	\n\u0211A\u0212\u0213N(\u0213\u0214\x07a\u0214\u0215`1\u0215C\u0216\u021A\x07\v\u0217\u0219`1\u0218\u0217\u0219\u021C\u021A\u0218\u021A\u021B\u021B\u021D\u021C\u021A\u021D\u021E\x07\f\u021EE\u021F\u0223D#\u0220\u0221\x072\u0221\u0223`1\u0222\u021F\u0222\u0220\u0223G\u0224\u0229\x073\u0225\u0229\x07g\u0226\u0229\x07h\u0227\u0229	\u0228\u0224\u0228\u0225\u0228\u0226\u0228\u0227\u0229I\u022A\u022B\x07W\u022B\u022D\x07l\u022C\u022A\u022C\u022D\u022D\u0233\u022E\u022FN(\u022F\u0230\x07l\u0230\u0232\u0231\u022E\u0232\u0235\u0233\u0231\u0233\u0234\u0234\u0236\u0235\u0233\u0236\u023AN(\u0237\u023A\x07i\u0238\u023A\x07h\u0239\u022C\u0239\u0237\u0239\u0238\u023AK\u023B\u023C\x07j\u023C\u0243J&\u023D\u0244J&\u023E\u0244\x07\x07\u023F\u0241\x07(\u0240\u023F\u0240\u0241\u0241\u0242\u0242\u0244\x9CO\u0243\u023D\u0243\u023E\u0243\u0240\u0244M\u0245\u0246\x07n\u0246O\u0247\u024DN(\u0248\u0249N(\u0249\u024A\x07k\u024A\u024BP)\u024B\u024D\u024C\u0247\u024C\u0248\u024DQ\u024E\u0254J&\u024F\u0250J&\u0250\u0251\x07k\u0251\u0252R*\u0252\u0254\u0253\u024E\u0253\u024F\u0254S\u0255\u025B\f\u0256\u0257\f\u0257\u0258\x07k\u0258\u0259T+\u0259\u025B\u025A\u0255\u025A\u0256\u025BU\u025C\u0262\r\u025D\u025E\r\u025E\u025F\x07k\u025F\u0260V,\u0260\u0262\u0261\u025C\u0261\u025D\u0262W\u0263\u0269\u0264\u0265\u0265\u0266\x07k\u0266\u0267X-\u0267\u0269\u0268\u0263\u0268\u0264\u0269Y\u026A\u0270B"\u026B\u026CB"\u026C\u026D\x07k\u026D\u026EZ.\u026E\u0270\u026F\u026A\u026F\u026B\u0270[\u0271\u0277.\u0272\u0273.\u0273\u0274\x07k\u0274\u0275\\/\u0275\u0277\u0276\u0271\u0276\u0272\u0277]\u0278\u027E`1\u0279\u027A`1\u027A\u027B\x07k\u027B\u027C^0\u027C\u027E\u027D\u0278\u027D\u0279\u027E_\u027F\u0290b2\u0280\u0281\x079\u0281\u0282Z.\u0282\u0283F$\u0283\u0290\u0284\u0285\x07:\u0285\u0286Z.\u0286\u0287F$\u0287\u0290\u0288\u028AH%\u0289\u028B\x07\u028A\u0289\u028A\u028B\u028B\u028C\u028C\u028DV,\u028D\u028EF$\u028E\u0290\u028F\u027F\u028F\u0280\u028F\u0284\u028F\u0288\u0290a\u0291\u0292\b2\u0292\u0293d3\u0293\u0299\u0294\u0295\f\u0295\u0296\x07;\u0296\u0298d3\u0297\u0294\u0298\u029B\u0299\u0297\u0299\u029A\u029Ac\u029B\u0299\u029C\u029D\b3\u029D\u029Ef4\u029E\u02A4\u029F\u02A0\f\u02A0\u02A1\x07<\u02A1\u02A3f4\u02A2\u029F\u02A3\u02A6\u02A4\u02A2\u02A4\u02A5\u02A5e\u02A6\u02A4\u02A7\u02A8\b4\u02A8\u02A9h5\u02A9\u02AF\u02AA\u02AB\f\u02AB\u02AC\x07=\u02AC\u02AEh5\u02AD\u02AA\u02AE\u02B1\u02AF\u02AD\u02AF\u02B0\u02B0g\u02B1\u02AF\u02B2\u02BBj6\u02B3\u02B4j6\u02B4\u02B5\x07>\u02B5\u02B8h5\u02B6\u02B7\x07?\u02B7\u02B9h5\u02B8\u02B6\u02B8\u02B9\u02B9\u02BB\u02BA\u02B2\u02BA\u02B3\u02BBi\u02BC\u02BD\b6\u02BD\u02BEl7\u02BE\u02C4\u02BF\u02C0\f\u02C0\u02C1\x07@\u02C1\u02C3l7\u02C2\u02BF\u02C3\u02C6\u02C4\u02C2\u02C4\u02C5\u02C5k\u02C6\u02C4\u02C7\u02D9n8\u02C8\u02C9n8\u02C9\u02CA\x07A\u02CA\u02CBn8\u02CB\u02D9\u02CC\u02CDn8\u02CD\u02CE\x07B\u02CE\u02CFn8\u02CF\u02D9\u02D0\u02D1n8\u02D1\u02D2\x07C\u02D2\u02D3n8\u02D3\u02D9\u02D4\u02D5n8\u02D5\u02D6\x07D\u02D6\u02D7n8\u02D7\u02D9\u02D8\u02C7\u02D8\u02C8\u02D8\u02CC\u02D8\u02D0\u02D8\u02D4\u02D9m\u02DA\u02EAp9\u02DB\u02DC\x07E\u02DC\u02EAn8\u02DD\u02DE\x07F\u02DE\u02EAn8\u02DF\u02E0\x07G\u02E0\u02EAn8\u02E1\u02E2\x07H\u02E2\u02EAn8\u02E3\u02E4\x07I\u02E4\u02EAn8\u02E5\u02E6\x07J\u02E6\u02EAn8\u02E7\u02E8\x07K\u02E8\u02EAn8\u02E9\u02DA\u02E9\u02DB\u02E9\u02DD\u02E9\u02DF\u02E9\u02E1\u02E9\u02E3\u02E9\u02E5\u02E9\u02E7\u02EAo\u02EB\u02EC\b9\u02EC\u02EDr:\u02ED\u02F7\u02EE\u02F0\f\u02EF\u02F1\x07E\u02F0\u02EF\u02F0\u02F1\u02F1\u02F2\u02F2\u02F3@!\u02F3\u02F4r:\u02F4\u02F6\u02F5\u02EE\u02F6\u02F9\u02F7\u02F5\u02F7\u02F8\u02F8q\u02F9\u02F7\u02FA\u02FEt;\u02FB\u02FC	\v\u02FC\u02FEt;\u02FD\u02FA\u02FD\u02FB\u02FEs\u02FF\u0300\b;\u0300\u0301v<\u0301\u0307\u0302\u0303\f\u0303\u0304	\f\u0304\u0306x=\u0305\u0302\u0306\u0309\u0307\u0305\u0307\u0308\u0308u\u0309\u0307\u030A\u030Ex=\u030B\u030C\x07L\u030C\u030Ev<\u030D\u030A\u030D\u030B\u030Ew\u030F\u0310\b=\u0310\u0311z>\u0311\u0317\u0312\u0313\f\u0313\u0314\x07M\u0314\u0316z>\u0315\u0312\u0316\u0319\u0317\u0315\u0317\u0318\u0318y\u0319\u0317\u031A\u031B\b>\u031B\u031C|?\u031C\u0322\u031D\u031E\f\u031E\u031F\x07N\u031F\u0321|?\u0320\u031D\u0321\u0324\u0322\u0320\u0322\u0323\u0323{\u0324\u0322\u0325\u0326\b?\u0326\u0327~@\u0327\u032E\u0328\u0329\f\u0329\u032A> \u032A\u032B~@\u032B\u032D\u032C\u0328\u032D\u0330\u032E\u032C\u032E\u032F\u032F}\u0330\u032E\u0331\u0332\b@\u0332\u0333\x80A\u0333\u0339\u0334\u0335\f\u0335\u0336	\r\u0336\u0338\x80A\u0337\u0334\u0338\u033B\u0339\u0337\u0339\u033A\u033A\x7F\u033B\u0339\u033C\u033D\bA\u033D\u033E\x82B\u033E\u0346\u033F\u0340\f\u0340\u0341\x07\u0341\u0342^0\u0342\u0343\x07\u0343\u0345\u0344\u033F\u0345\u0348\u0346\u0344\u0346\u0347\u0347\x81\u0348\u0346\u0349\u034A\bB\u034A\u0351\x84C\u034B\u034CN(\u034C\u034D\x07\u034D\u034E^0\u034E\u034F\x07\u034F\u0351\u0350\u0349\u0350\u034B\u0351\u0357\u0352\u0353\f\u0353\u0354\x07\x1B\u0354\u0356\x84C\u0355\u0352\u0356\u0359\u0357\u0355\u0357\u0358\u0358\x83\u0359\u0357\u035A\u035B\bC\u035B\u035C\x86D\u035C\u0361\u035D\u035E\f\u035E\u0360\x07Q\u035F\u035D\u0360\u0363\u0361\u035F\u0361\u0362\u0362\x85\u0363\u0361\u0364\u0368\x88E\u0365\u0366	\u0366\u0368\x86D\u0367\u0364\u0367\u0365\u0368\x87\u0369\u037C0\u036A\u037CJ&\u036B\u036C\x07U\u036C\u037CN(\u036D\u036E\x07V\u036E\u037CN(\u036F\u037C\x07W\u0370\u0371\x07\v\u0371\u0372V,\u0372\u0373F$\u0373\u0374\x07\f\u0374\u037C\u0375\u0376\x07\u0376\u0377`1\u0377\u0378\x07\u0378\u037C\u0379\u037CD#\u037A\u037C\x8EH\u037B\u0369\u037B\u036A\u037B\u036B\u037B\u036D\u037B\u036F\u037B\u0370\u037B\u0375\u037B\u0379\u037B\u037A\u037C\x89\u037D\u0383J&\u037E\u037FJ&\u037F\u0380\x07\\\u0380\u0381\x8AF\u0381\u0383\u0382\u037D\u0382\u037E\u0383\x8B\u0384\u0385\x8EH\u0385\x8D\u0386\u0387\x07X\u0387\x8F\u0388\u0389\x07Y\u0389\u038AN(\u038A\u038C\x9EP\u038B\u038D,\u038C\u038B\u038C\u038D\u038D\x91\u038E\u038F\u038F\x93\u0390\u0391\x07Z\u0391\u0392`1\u0392\x95\u0393\u0394\x07[\u0394\u0395N(\u0395\u0396\x07)\u0396\u0397`1\u0397\u0398\x07"\u0398\u0399\x9EP\u0399\x97\u039A\u039BN(\u039B\u039C\x07\u039C\u039D\x8AF\u039D\u039E\x07a\u039E\u039F`1\u039F\x99\u03A0\u03A6\x9CO\u03A1\u03A2\x9CO\u03A2\u03A3\x07k\u03A3\u03A4\x9AN\u03A4\u03A6\u03A5\u03A0\u03A5\u03A1\u03A6\x9B\u03A7\u03A8\x07m\u03A8\x9D\u03A9\u03AD\x07\v\u03AA\u03AC\xA2R\u03AB\u03AA\u03AC\u03AF\u03AD\u03AB\u03AD\u03AE\u03AE\u03B0\u03AF\u03AD\u03B0\u03B6\x07\f\u03B1\u03B3\x07$\u03B2\u03B1\u03B2\u03B3\u03B3\u03B4\u03B4\u03B6J&\u03B5\u03A9\u03B5\u03B2\u03B6\x9F\u03B7\u03B8\x07V\u03B8\u03BDN(\u03B9\u03BD\x9CO\u03BA\u03BB\x07(\u03BB\u03BD\x9CO\u03BC\u03B7\u03BC\u03B9\u03BC\u03BA\u03BD\xA1\u03BE\u03BF\xA4S\u03BF\u03C0@!\u03C0\u03C1\xA6T\u03C1\u03C6\u03C2\u03C3\x07g\u03C3\u03C6\xA4S\u03C4\u03C6J&\u03C5\u03BE\u03C5\u03C2\u03C5\u03C4\u03C6\xA3\u03C7\u03C8\x07L\u03C8\u03D2J&\u03C9\u03D2J&\u03CA\u03CD\xA0Q\u03CB\u03CC\x07\x1B\u03CC\u03CEJ&\u03CD\u03CB\u03CE\u03CF\u03CF\u03CD\u03CF\u03D0\u03D0\u03D2\u03D1\u03C7\u03D1\u03C9\u03D1\u03CA\u03D2\xA5\u03D3\u03D4\bT\u03D4\u03DA\xA8U\u03D5\u03D6\x07\u03D6\u03D7\xA6T\u03D7\u03D8\x07\u03D8\u03DA\u03D9\u03D3\u03D9\u03D5\u03DA\u03E0\u03DB\u03DC\f\u03DC\u03DD\x07\u03DD\u03DF\xA8U\u03DE\u03DB\u03DF\u03E2\u03E0\u03DE\u03E0\u03E1\u03E1\xA7\u03E2\u03E0\u03E3\u03E4\bU\u03E4\u03E5\x07\u03E5\u03E6\xA8U\u03E6\u03E7\x07\u03E7\u03EA\u03E8\u03EA\xAAV\u03E9\u03E3\u03E9\u03E8\u03EA\u03F0\u03EB\u03EC\f\u03EC\u03ED	\u03ED\u03EF\xAAV\u03EE\u03EB\u03EF\u03F2\u03F0\u03EE\u03F0\u03F1\u03F1\xA9\u03F2\u03F0\u03F3\u03FA\xA0Q\u03F4\u03FAJ&\u03F5\u03F6\x07\u03F6\u03F7\xA6T\u03F7\u03F8\x07\u03F8\u03FA\u03F9\u03F3\u03F9\u03F4\u03F9\u03F5\u03FA\xABx\xAE\xB3\xB7\xC1\xC7\xCD\xD0\xD8\xDC\xE2\xE4\xF7\xFA\xFD\u0100\u0105\u0109\u010D\u0117\u011A\u0123\u0128\u012D\u0132\u0137\u0144\u0148\u014C\u0155\u015A\u015D\u0161\u0168\u016D\u0170\u0174\u0179\u017D\u0180\u0184\u018A\u018E\u0196\u019F\u01A3\u01A6\u01AF\u01B2\u01B9\u01BD\u01C2\u01CF\u01D2\u01D6\u01DF\u01E3\u01EC\u01F0\u01FA\u0205\u0209\u020E\u021A\u0222\u0228\u022C\u0233\u0239\u0240\u0243\u024C\u0253\u025A\u0261\u0268\u026F\u0276\u027D\u028A\u028F\u0299\u02A4\u02AF\u02B8\u02BA\u02C4\u02D8\u02E9\u02F0\u02F7\u02FD\u0307\u030D\u0317\u0322\u032E\u0339\u0346\u0350\u0357\u0361\u0367\u037B\u0382\u038C\u03A5\u03AD\u03B2\u03B5\u03BC\u03C5\u03CF\u03D1\u03D9\u03E0\u03E9\u03F0\u03F9';
                  ForgeParser._serializedATN = Utils.join([
                    ForgeParser._serializedATNSegment0,
                    ForgeParser._serializedATNSegment1
                  ], "");
                  class PredDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    PRED_TOK() {
                      return this.getToken(ForgeParser.PRED_TOK, 0);
                    }
                    name() {
                      return this.getRuleContext(0, NameContext);
                    }
                    block() {
                      return this.getRuleContext(0, BlockContext);
                    }
                    predType() {
                      return this.tryGetRuleContext(0, PredTypeContext);
                    }
                    qualName() {
                      return this.tryGetRuleContext(0, QualNameContext);
                    }
                    DOT_TOK() {
                      return this.tryGetToken(ForgeParser.DOT_TOK, 0);
                    }
                    paraDecls() {
                      return this.tryGetRuleContext(0, ParaDeclsContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_predDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterPredDecl) {
                        listener.enterPredDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitPredDecl) {
                        listener.exitPredDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitPredDecl) {
                        return visitor.visitPredDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.PredDeclContext = PredDeclContext;
                  class ParseExprContext extends ParserRuleContext_1.ParserRuleContext {
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    EOF() {
                      return this.getToken(ForgeParser.EOF, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_parseExpr;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterParseExpr) {
                        listener.enterParseExpr(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitParseExpr) {
                        listener.exitParseExpr(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitParseExpr) {
                        return visitor.visitParseExpr(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ParseExprContext = ParseExprContext;
                  class AlloyModuleContext extends ParserRuleContext_1.ParserRuleContext {
                    importDecl(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(ImportDeclContext);
                      } else {
                        return this.getRuleContext(i, ImportDeclContext);
                      }
                    }
                    paragraph(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(ParagraphContext);
                      } else {
                        return this.getRuleContext(i, ParagraphContext);
                      }
                    }
                    evalDecl(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(EvalDeclContext);
                      } else {
                        return this.getRuleContext(i, EvalDeclContext);
                      }
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_alloyModule;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterAlloyModule) {
                        listener.enterAlloyModule(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitAlloyModule) {
                        listener.exitAlloyModule(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitAlloyModule) {
                        return visitor.visitAlloyModule(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.AlloyModuleContext = AlloyModuleContext;
                  class ImportDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    OPEN_TOK() {
                      return this.getToken(ForgeParser.OPEN_TOK, 0);
                    }
                    qualName() {
                      return this.tryGetRuleContext(0, QualNameContext);
                    }
                    LEFT_SQUARE_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_SQUARE_TOK, 0);
                    }
                    qualNameList() {
                      return this.tryGetRuleContext(0, QualNameListContext);
                    }
                    RIGHT_SQUARE_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_SQUARE_TOK, 0);
                    }
                    AS_TOK() {
                      return this.tryGetToken(ForgeParser.AS_TOK, 0);
                    }
                    name() {
                      return this.tryGetRuleContext(0, NameContext);
                    }
                    FILE_PATH_TOK() {
                      return this.tryGetToken(ForgeParser.FILE_PATH_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_importDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterImportDecl) {
                        listener.enterImportDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitImportDecl) {
                        listener.exitImportDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitImportDecl) {
                        return visitor.visitImportDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ImportDeclContext = ImportDeclContext;
                  class ParagraphContext extends ParserRuleContext_1.ParserRuleContext {
                    sigDecl() {
                      return this.tryGetRuleContext(0, SigDeclContext);
                    }
                    predDecl() {
                      return this.tryGetRuleContext(0, PredDeclContext);
                    }
                    funDecl() {
                      return this.tryGetRuleContext(0, FunDeclContext);
                    }
                    assertDecl() {
                      return this.tryGetRuleContext(0, AssertDeclContext);
                    }
                    cmdDecl() {
                      return this.tryGetRuleContext(0, CmdDeclContext);
                    }
                    testExpectDecl() {
                      return this.tryGetRuleContext(0, TestExpectDeclContext);
                    }
                    sexprDecl() {
                      return this.tryGetRuleContext(0, SexprDeclContext);
                    }
                    queryDecl() {
                      return this.tryGetRuleContext(0, QueryDeclContext);
                    }
                    evalRelDecl() {
                      return this.tryGetRuleContext(0, EvalRelDeclContext);
                    }
                    optionDecl() {
                      return this.tryGetRuleContext(0, OptionDeclContext);
                    }
                    instDecl() {
                      return this.tryGetRuleContext(0, InstDeclContext);
                    }
                    exampleDecl() {
                      return this.tryGetRuleContext(0, ExampleDeclContext);
                    }
                    propertyDecl() {
                      return this.tryGetRuleContext(0, PropertyDeclContext);
                    }
                    quantifiedPropertyDecl() {
                      return this.tryGetRuleContext(0, QuantifiedPropertyDeclContext);
                    }
                    satisfiabilityDecl() {
                      return this.tryGetRuleContext(0, SatisfiabilityDeclContext);
                    }
                    consistencyDecl() {
                      return this.tryGetRuleContext(0, ConsistencyDeclContext);
                    }
                    testSuiteDecl() {
                      return this.tryGetRuleContext(0, TestSuiteDeclContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_paragraph;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterParagraph) {
                        listener.enterParagraph(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitParagraph) {
                        listener.exitParagraph(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitParagraph) {
                        return visitor.visitParagraph(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ParagraphContext = ParagraphContext;
                  class SigDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    SIG_TOK() {
                      return this.getToken(ForgeParser.SIG_TOK, 0);
                    }
                    nameList() {
                      return this.getRuleContext(0, NameListContext);
                    }
                    LEFT_CURLY_TOK() {
                      return this.getToken(ForgeParser.LEFT_CURLY_TOK, 0);
                    }
                    RIGHT_CURLY_TOK() {
                      return this.getToken(ForgeParser.RIGHT_CURLY_TOK, 0);
                    }
                    VAR_TOK() {
                      return this.tryGetToken(ForgeParser.VAR_TOK, 0);
                    }
                    ABSTRACT_TOK() {
                      return this.tryGetToken(ForgeParser.ABSTRACT_TOK, 0);
                    }
                    mult() {
                      return this.tryGetRuleContext(0, MultContext);
                    }
                    sigExt() {
                      return this.tryGetRuleContext(0, SigExtContext);
                    }
                    arrowDeclList() {
                      return this.tryGetRuleContext(0, ArrowDeclListContext);
                    }
                    block() {
                      return this.tryGetRuleContext(0, BlockContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_sigDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterSigDecl) {
                        listener.enterSigDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitSigDecl) {
                        listener.exitSigDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitSigDecl) {
                        return visitor.visitSigDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.SigDeclContext = SigDeclContext;
                  class SigExtContext extends ParserRuleContext_1.ParserRuleContext {
                    EXTENDS_TOK() {
                      return this.tryGetToken(ForgeParser.EXTENDS_TOK, 0);
                    }
                    qualName(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(QualNameContext);
                      } else {
                        return this.getRuleContext(i, QualNameContext);
                      }
                    }
                    IN_TOK() {
                      return this.tryGetToken(ForgeParser.IN_TOK, 0);
                    }
                    PLUS_TOK(i) {
                      if (i === void 0) {
                        return this.getTokens(ForgeParser.PLUS_TOK);
                      } else {
                        return this.getToken(ForgeParser.PLUS_TOK, i);
                      }
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_sigExt;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterSigExt) {
                        listener.enterSigExt(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitSigExt) {
                        listener.exitSigExt(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitSigExt) {
                        return visitor.visitSigExt(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.SigExtContext = SigExtContext;
                  class MultContext extends ParserRuleContext_1.ParserRuleContext {
                    LONE_TOK() {
                      return this.tryGetToken(ForgeParser.LONE_TOK, 0);
                    }
                    SOME_TOK() {
                      return this.tryGetToken(ForgeParser.SOME_TOK, 0);
                    }
                    ONE_TOK() {
                      return this.tryGetToken(ForgeParser.ONE_TOK, 0);
                    }
                    TWO_TOK() {
                      return this.tryGetToken(ForgeParser.TWO_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_mult;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterMult) {
                        listener.enterMult(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitMult) {
                        listener.exitMult(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitMult) {
                        return visitor.visitMult(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.MultContext = MultContext;
                  class ArrowMultContext extends ParserRuleContext_1.ParserRuleContext {
                    LONE_TOK() {
                      return this.tryGetToken(ForgeParser.LONE_TOK, 0);
                    }
                    SET_TOK() {
                      return this.tryGetToken(ForgeParser.SET_TOK, 0);
                    }
                    ONE_TOK() {
                      return this.tryGetToken(ForgeParser.ONE_TOK, 0);
                    }
                    TWO_TOK() {
                      return this.tryGetToken(ForgeParser.TWO_TOK, 0);
                    }
                    FUNC_TOK() {
                      return this.tryGetToken(ForgeParser.FUNC_TOK, 0);
                    }
                    PFUNC_TOK() {
                      return this.tryGetToken(ForgeParser.PFUNC_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_arrowMult;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterArrowMult) {
                        listener.enterArrowMult(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitArrowMult) {
                        listener.exitArrowMult(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitArrowMult) {
                        return visitor.visitArrowMult(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ArrowMultContext = ArrowMultContext;
                  class HelperMultContext extends ParserRuleContext_1.ParserRuleContext {
                    LONE_TOK() {
                      return this.tryGetToken(ForgeParser.LONE_TOK, 0);
                    }
                    SET_TOK() {
                      return this.tryGetToken(ForgeParser.SET_TOK, 0);
                    }
                    ONE_TOK() {
                      return this.tryGetToken(ForgeParser.ONE_TOK, 0);
                    }
                    FUNC_TOK() {
                      return this.tryGetToken(ForgeParser.FUNC_TOK, 0);
                    }
                    PFUNC_TOK() {
                      return this.tryGetToken(ForgeParser.PFUNC_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_helperMult;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterHelperMult) {
                        listener.enterHelperMult(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitHelperMult) {
                        listener.exitHelperMult(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitHelperMult) {
                        return visitor.visitHelperMult(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.HelperMultContext = HelperMultContext;
                  class ParaDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    nameList() {
                      return this.getRuleContext(0, NameListContext);
                    }
                    COLON_TOK() {
                      return this.getToken(ForgeParser.COLON_TOK, 0);
                    }
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    DISJ_TOK() {
                      return this.tryGetToken(ForgeParser.DISJ_TOK, 0);
                    }
                    helperMult() {
                      return this.tryGetRuleContext(0, HelperMultContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_paraDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterParaDecl) {
                        listener.enterParaDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitParaDecl) {
                        listener.exitParaDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitParaDecl) {
                        return visitor.visitParaDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ParaDeclContext = ParaDeclContext;
                  class QuantDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    nameList() {
                      return this.getRuleContext(0, NameListContext);
                    }
                    COLON_TOK() {
                      return this.getToken(ForgeParser.COLON_TOK, 0);
                    }
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    DISJ_TOK() {
                      return this.tryGetToken(ForgeParser.DISJ_TOK, 0);
                    }
                    SET_TOK() {
                      return this.tryGetToken(ForgeParser.SET_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_quantDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterQuantDecl) {
                        listener.enterQuantDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitQuantDecl) {
                        listener.exitQuantDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitQuantDecl) {
                        return visitor.visitQuantDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.QuantDeclContext = QuantDeclContext;
                  class ArrowDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    nameList() {
                      return this.getRuleContext(0, NameListContext);
                    }
                    COLON_TOK() {
                      return this.getToken(ForgeParser.COLON_TOK, 0);
                    }
                    arrowMult() {
                      return this.getRuleContext(0, ArrowMultContext);
                    }
                    arrowExpr() {
                      return this.getRuleContext(0, ArrowExprContext);
                    }
                    VAR_TOK() {
                      return this.tryGetToken(ForgeParser.VAR_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_arrowDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterArrowDecl) {
                        listener.enterArrowDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitArrowDecl) {
                        listener.exitArrowDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitArrowDecl) {
                        return visitor.visitArrowDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ArrowDeclContext = ArrowDeclContext;
                  class PredTypeContext extends ParserRuleContext_1.ParserRuleContext {
                    WHEAT_TOK() {
                      return this.getToken(ForgeParser.WHEAT_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_predType;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterPredType) {
                        listener.enterPredType(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitPredType) {
                        listener.exitPredType(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitPredType) {
                        return visitor.visitPredType(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.PredTypeContext = PredTypeContext;
                  class FunDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    FUN_TOK() {
                      return this.getToken(ForgeParser.FUN_TOK, 0);
                    }
                    name() {
                      return this.getRuleContext(0, NameContext);
                    }
                    COLON_TOK() {
                      return this.getToken(ForgeParser.COLON_TOK, 0);
                    }
                    expr(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(ExprContext);
                      } else {
                        return this.getRuleContext(i, ExprContext);
                      }
                    }
                    LEFT_CURLY_TOK() {
                      return this.getToken(ForgeParser.LEFT_CURLY_TOK, 0);
                    }
                    RIGHT_CURLY_TOK() {
                      return this.getToken(ForgeParser.RIGHT_CURLY_TOK, 0);
                    }
                    qualName() {
                      return this.tryGetRuleContext(0, QualNameContext);
                    }
                    DOT_TOK() {
                      return this.tryGetToken(ForgeParser.DOT_TOK, 0);
                    }
                    paraDecls() {
                      return this.tryGetRuleContext(0, ParaDeclsContext);
                    }
                    helperMult() {
                      return this.tryGetRuleContext(0, HelperMultContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_funDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterFunDecl) {
                        listener.enterFunDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitFunDecl) {
                        listener.exitFunDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitFunDecl) {
                        return visitor.visitFunDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.FunDeclContext = FunDeclContext;
                  class ParaDeclsContext extends ParserRuleContext_1.ParserRuleContext {
                    LEFT_PAREN_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_PAREN_TOK, 0);
                    }
                    RIGHT_PAREN_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_PAREN_TOK, 0);
                    }
                    paraDeclList() {
                      return this.tryGetRuleContext(0, ParaDeclListContext);
                    }
                    LEFT_SQUARE_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_SQUARE_TOK, 0);
                    }
                    RIGHT_SQUARE_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_SQUARE_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_paraDecls;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterParaDecls) {
                        listener.enterParaDecls(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitParaDecls) {
                        listener.exitParaDecls(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitParaDecls) {
                        return visitor.visitParaDecls(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ParaDeclsContext = ParaDeclsContext;
                  class AssertDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    ASSERT_TOK() {
                      return this.getToken(ForgeParser.ASSERT_TOK, 0);
                    }
                    block() {
                      return this.getRuleContext(0, BlockContext);
                    }
                    name() {
                      return this.tryGetRuleContext(0, NameContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_assertDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterAssertDecl) {
                        listener.enterAssertDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitAssertDecl) {
                        listener.exitAssertDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitAssertDecl) {
                        return visitor.visitAssertDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.AssertDeclContext = AssertDeclContext;
                  class CmdDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    RUN_TOK() {
                      return this.tryGetToken(ForgeParser.RUN_TOK, 0);
                    }
                    CHECK_TOK() {
                      return this.tryGetToken(ForgeParser.CHECK_TOK, 0);
                    }
                    name() {
                      return this.tryGetRuleContext(0, NameContext);
                    }
                    COLON_TOK() {
                      return this.tryGetToken(ForgeParser.COLON_TOK, 0);
                    }
                    qualName() {
                      return this.tryGetRuleContext(0, QualNameContext);
                    }
                    block() {
                      return this.tryGetRuleContext(0, BlockContext);
                    }
                    scope() {
                      return this.tryGetRuleContext(0, ScopeContext);
                    }
                    FOR_TOK() {
                      return this.tryGetToken(ForgeParser.FOR_TOK, 0);
                    }
                    bounds() {
                      return this.tryGetRuleContext(0, BoundsContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_cmdDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterCmdDecl) {
                        listener.enterCmdDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitCmdDecl) {
                        listener.exitCmdDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitCmdDecl) {
                        return visitor.visitCmdDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.CmdDeclContext = CmdDeclContext;
                  class TestDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    IS_TOK() {
                      return this.getToken(ForgeParser.IS_TOK, 0);
                    }
                    SAT_TOK() {
                      return this.tryGetToken(ForgeParser.SAT_TOK, 0);
                    }
                    UNSAT_TOK() {
                      return this.tryGetToken(ForgeParser.UNSAT_TOK, 0);
                    }
                    THEOREM_TOK() {
                      return this.tryGetToken(ForgeParser.THEOREM_TOK, 0);
                    }
                    CHECKED_TOK() {
                      return this.tryGetToken(ForgeParser.CHECKED_TOK, 0);
                    }
                    FORGE_ERROR_TOK() {
                      return this.tryGetToken(ForgeParser.FORGE_ERROR_TOK, 0);
                    }
                    qualName() {
                      return this.tryGetRuleContext(0, QualNameContext);
                    }
                    block() {
                      return this.tryGetRuleContext(0, BlockContext);
                    }
                    name() {
                      return this.tryGetRuleContext(0, NameContext);
                    }
                    COLON_TOK() {
                      return this.tryGetToken(ForgeParser.COLON_TOK, 0);
                    }
                    scope() {
                      return this.tryGetRuleContext(0, ScopeContext);
                    }
                    FOR_TOK() {
                      return this.tryGetToken(ForgeParser.FOR_TOK, 0);
                    }
                    bounds() {
                      return this.tryGetRuleContext(0, BoundsContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_testDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterTestDecl) {
                        listener.enterTestDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitTestDecl) {
                        listener.exitTestDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitTestDecl) {
                        return visitor.visitTestDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.TestDeclContext = TestDeclContext;
                  class TestExpectDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    EXPECT_TOK() {
                      return this.getToken(ForgeParser.EXPECT_TOK, 0);
                    }
                    testBlock() {
                      return this.getRuleContext(0, TestBlockContext);
                    }
                    TEST_TOK() {
                      return this.tryGetToken(ForgeParser.TEST_TOK, 0);
                    }
                    name() {
                      return this.tryGetRuleContext(0, NameContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_testExpectDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterTestExpectDecl) {
                        listener.enterTestExpectDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitTestExpectDecl) {
                        listener.exitTestExpectDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitTestExpectDecl) {
                        return visitor.visitTestExpectDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.TestExpectDeclContext = TestExpectDeclContext;
                  class TestBlockContext extends ParserRuleContext_1.ParserRuleContext {
                    LEFT_CURLY_TOK() {
                      return this.getToken(ForgeParser.LEFT_CURLY_TOK, 0);
                    }
                    RIGHT_CURLY_TOK() {
                      return this.getToken(ForgeParser.RIGHT_CURLY_TOK, 0);
                    }
                    testDecl(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(TestDeclContext);
                      } else {
                        return this.getRuleContext(i, TestDeclContext);
                      }
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_testBlock;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterTestBlock) {
                        listener.enterTestBlock(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitTestBlock) {
                        listener.exitTestBlock(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitTestBlock) {
                        return visitor.visitTestBlock(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.TestBlockContext = TestBlockContext;
                  class ScopeContext extends ParserRuleContext_1.ParserRuleContext {
                    FOR_TOK() {
                      return this.getToken(ForgeParser.FOR_TOK, 0);
                    }
                    number() {
                      return this.tryGetRuleContext(0, NumberContext);
                    }
                    BUT_TOK() {
                      return this.tryGetToken(ForgeParser.BUT_TOK, 0);
                    }
                    typescopeList() {
                      return this.tryGetRuleContext(0, TypescopeListContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_scope;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterScope) {
                        listener.enterScope(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitScope) {
                        listener.exitScope(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitScope) {
                        return visitor.visitScope(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ScopeContext = ScopeContext;
                  class TypescopeContext extends ParserRuleContext_1.ParserRuleContext {
                    number() {
                      return this.getRuleContext(0, NumberContext);
                    }
                    qualName() {
                      return this.getRuleContext(0, QualNameContext);
                    }
                    EXACTLY_TOK() {
                      return this.tryGetToken(ForgeParser.EXACTLY_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_typescope;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterTypescope) {
                        listener.enterTypescope(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitTypescope) {
                        listener.exitTypescope(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitTypescope) {
                        return visitor.visitTypescope(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.TypescopeContext = TypescopeContext;
                  class ConstContext extends ParserRuleContext_1.ParserRuleContext {
                    NONE_TOK() {
                      return this.tryGetToken(ForgeParser.NONE_TOK, 0);
                    }
                    UNIV_TOK() {
                      return this.tryGetToken(ForgeParser.UNIV_TOK, 0);
                    }
                    IDEN_TOK() {
                      return this.tryGetToken(ForgeParser.IDEN_TOK, 0);
                    }
                    number() {
                      return this.tryGetRuleContext(0, NumberContext);
                    }
                    MINUS_TOK() {
                      return this.tryGetToken(ForgeParser.MINUS_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_const;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterConst) {
                        listener.enterConst(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitConst) {
                        listener.exitConst(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitConst) {
                        return visitor.visitConst(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ConstContext = ConstContext;
                  class SatisfiabilityDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    ASSERT_TOK() {
                      return this.getToken(ForgeParser.ASSERT_TOK, 0);
                    }
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    IS_TOK() {
                      return this.getToken(ForgeParser.IS_TOK, 0);
                    }
                    SAT_TOK() {
                      return this.tryGetToken(ForgeParser.SAT_TOK, 0);
                    }
                    UNSAT_TOK() {
                      return this.tryGetToken(ForgeParser.UNSAT_TOK, 0);
                    }
                    FORGE_ERROR_TOK() {
                      return this.tryGetToken(ForgeParser.FORGE_ERROR_TOK, 0);
                    }
                    scope() {
                      return this.tryGetRuleContext(0, ScopeContext);
                    }
                    FOR_TOK() {
                      return this.tryGetToken(ForgeParser.FOR_TOK, 0);
                    }
                    bounds() {
                      return this.tryGetRuleContext(0, BoundsContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_satisfiabilityDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterSatisfiabilityDecl) {
                        listener.enterSatisfiabilityDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitSatisfiabilityDecl) {
                        listener.exitSatisfiabilityDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitSatisfiabilityDecl) {
                        return visitor.visitSatisfiabilityDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.SatisfiabilityDeclContext = SatisfiabilityDeclContext;
                  class QuantifiedPropertyDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    ASSERT_TOK() {
                      return this.getToken(ForgeParser.ASSERT_TOK, 0);
                    }
                    ALL_TOK() {
                      return this.getToken(ForgeParser.ALL_TOK, 0);
                    }
                    quantDeclList() {
                      return this.getRuleContext(0, QuantDeclListContext);
                    }
                    BAR_TOK() {
                      return this.getToken(ForgeParser.BAR_TOK, 0);
                    }
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    IS_TOK() {
                      return this.getToken(ForgeParser.IS_TOK, 0);
                    }
                    FOR_TOK(i) {
                      if (i === void 0) {
                        return this.getTokens(ForgeParser.FOR_TOK);
                      } else {
                        return this.getToken(ForgeParser.FOR_TOK, i);
                      }
                    }
                    name() {
                      return this.getRuleContext(0, NameContext);
                    }
                    SUFFICIENT_TOK() {
                      return this.tryGetToken(ForgeParser.SUFFICIENT_TOK, 0);
                    }
                    NECESSARY_TOK() {
                      return this.tryGetToken(ForgeParser.NECESSARY_TOK, 0);
                    }
                    DISJ_TOK() {
                      return this.tryGetToken(ForgeParser.DISJ_TOK, 0);
                    }
                    LEFT_SQUARE_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_SQUARE_TOK, 0);
                    }
                    exprList() {
                      return this.tryGetRuleContext(0, ExprListContext);
                    }
                    RIGHT_SQUARE_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_SQUARE_TOK, 0);
                    }
                    scope() {
                      return this.tryGetRuleContext(0, ScopeContext);
                    }
                    bounds() {
                      return this.tryGetRuleContext(0, BoundsContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_quantifiedPropertyDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterQuantifiedPropertyDecl) {
                        listener.enterQuantifiedPropertyDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitQuantifiedPropertyDecl) {
                        listener.exitQuantifiedPropertyDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitQuantifiedPropertyDecl) {
                        return visitor.visitQuantifiedPropertyDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.QuantifiedPropertyDeclContext = QuantifiedPropertyDeclContext;
                  class PropertyDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    ASSERT_TOK() {
                      return this.getToken(ForgeParser.ASSERT_TOK, 0);
                    }
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    IS_TOK() {
                      return this.getToken(ForgeParser.IS_TOK, 0);
                    }
                    FOR_TOK(i) {
                      if (i === void 0) {
                        return this.getTokens(ForgeParser.FOR_TOK);
                      } else {
                        return this.getToken(ForgeParser.FOR_TOK, i);
                      }
                    }
                    name() {
                      return this.getRuleContext(0, NameContext);
                    }
                    SUFFICIENT_TOK() {
                      return this.tryGetToken(ForgeParser.SUFFICIENT_TOK, 0);
                    }
                    NECESSARY_TOK() {
                      return this.tryGetToken(ForgeParser.NECESSARY_TOK, 0);
                    }
                    scope() {
                      return this.tryGetRuleContext(0, ScopeContext);
                    }
                    bounds() {
                      return this.tryGetRuleContext(0, BoundsContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_propertyDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterPropertyDecl) {
                        listener.enterPropertyDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitPropertyDecl) {
                        listener.exitPropertyDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitPropertyDecl) {
                        return visitor.visitPropertyDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.PropertyDeclContext = PropertyDeclContext;
                  class ConsistencyDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    ASSERT_TOK() {
                      return this.getToken(ForgeParser.ASSERT_TOK, 0);
                    }
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    IS_TOK() {
                      return this.getToken(ForgeParser.IS_TOK, 0);
                    }
                    WITH_TOK() {
                      return this.getToken(ForgeParser.WITH_TOK, 0);
                    }
                    name() {
                      return this.getRuleContext(0, NameContext);
                    }
                    CONSISTENT_TOK() {
                      return this.tryGetToken(ForgeParser.CONSISTENT_TOK, 0);
                    }
                    INCONSISTENT_TOK() {
                      return this.tryGetToken(ForgeParser.INCONSISTENT_TOK, 0);
                    }
                    scope() {
                      return this.tryGetRuleContext(0, ScopeContext);
                    }
                    FOR_TOK() {
                      return this.tryGetToken(ForgeParser.FOR_TOK, 0);
                    }
                    bounds() {
                      return this.tryGetRuleContext(0, BoundsContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_consistencyDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterConsistencyDecl) {
                        listener.enterConsistencyDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitConsistencyDecl) {
                        listener.exitConsistencyDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitConsistencyDecl) {
                        return visitor.visitConsistencyDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ConsistencyDeclContext = ConsistencyDeclContext;
                  class TestSuiteDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    TEST_TOK() {
                      return this.getToken(ForgeParser.TEST_TOK, 0);
                    }
                    SUITE_TOK() {
                      return this.getToken(ForgeParser.SUITE_TOK, 0);
                    }
                    FOR_TOK() {
                      return this.getToken(ForgeParser.FOR_TOK, 0);
                    }
                    name() {
                      return this.getRuleContext(0, NameContext);
                    }
                    LEFT_CURLY_TOK() {
                      return this.getToken(ForgeParser.LEFT_CURLY_TOK, 0);
                    }
                    RIGHT_CURLY_TOK() {
                      return this.getToken(ForgeParser.RIGHT_CURLY_TOK, 0);
                    }
                    testConstruct(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(TestConstructContext);
                      } else {
                        return this.getRuleContext(i, TestConstructContext);
                      }
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_testSuiteDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterTestSuiteDecl) {
                        listener.enterTestSuiteDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitTestSuiteDecl) {
                        listener.exitTestSuiteDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitTestSuiteDecl) {
                        return visitor.visitTestSuiteDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.TestSuiteDeclContext = TestSuiteDeclContext;
                  class TestConstructContext extends ParserRuleContext_1.ParserRuleContext {
                    exampleDecl() {
                      return this.tryGetRuleContext(0, ExampleDeclContext);
                    }
                    testExpectDecl() {
                      return this.tryGetRuleContext(0, TestExpectDeclContext);
                    }
                    quantifiedPropertyDecl() {
                      return this.tryGetRuleContext(0, QuantifiedPropertyDeclContext);
                    }
                    propertyDecl() {
                      return this.tryGetRuleContext(0, PropertyDeclContext);
                    }
                    satisfiabilityDecl() {
                      return this.tryGetRuleContext(0, SatisfiabilityDeclContext);
                    }
                    consistencyDecl() {
                      return this.tryGetRuleContext(0, ConsistencyDeclContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_testConstruct;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterTestConstruct) {
                        listener.enterTestConstruct(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitTestConstruct) {
                        listener.exitTestConstruct(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitTestConstruct) {
                        return visitor.visitTestConstruct(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.TestConstructContext = TestConstructContext;
                  class ArrowOpContext extends ParserRuleContext_1.ParserRuleContext {
                    ARROW_TOK() {
                      return this.getToken(ForgeParser.ARROW_TOK, 0);
                    }
                    mult(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(MultContext);
                      } else {
                        return this.getRuleContext(i, MultContext);
                      }
                    }
                    SET_TOK(i) {
                      if (i === void 0) {
                        return this.getTokens(ForgeParser.SET_TOK);
                      } else {
                        return this.getToken(ForgeParser.SET_TOK, i);
                      }
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_arrowOp;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterArrowOp) {
                        listener.enterArrowOp(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitArrowOp) {
                        listener.exitArrowOp(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitArrowOp) {
                        return visitor.visitArrowOp(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ArrowOpContext = ArrowOpContext;
                  class CompareOpContext extends ParserRuleContext_1.ParserRuleContext {
                    IN_TOK() {
                      return this.tryGetToken(ForgeParser.IN_TOK, 0);
                    }
                    EQ_TOK() {
                      return this.tryGetToken(ForgeParser.EQ_TOK, 0);
                    }
                    LT_TOK() {
                      return this.tryGetToken(ForgeParser.LT_TOK, 0);
                    }
                    GT_TOK() {
                      return this.tryGetToken(ForgeParser.GT_TOK, 0);
                    }
                    LEQ_TOK() {
                      return this.tryGetToken(ForgeParser.LEQ_TOK, 0);
                    }
                    GEQ_TOK() {
                      return this.tryGetToken(ForgeParser.GEQ_TOK, 0);
                    }
                    IS_TOK() {
                      return this.tryGetToken(ForgeParser.IS_TOK, 0);
                    }
                    NI_TOK() {
                      return this.tryGetToken(ForgeParser.NI_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_compareOp;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterCompareOp) {
                        listener.enterCompareOp(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitCompareOp) {
                        listener.exitCompareOp(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitCompareOp) {
                        return visitor.visitCompareOp(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.CompareOpContext = CompareOpContext;
                  class LetDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    name() {
                      return this.getRuleContext(0, NameContext);
                    }
                    EQ_TOK() {
                      return this.getToken(ForgeParser.EQ_TOK, 0);
                    }
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_letDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterLetDecl) {
                        listener.enterLetDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitLetDecl) {
                        listener.exitLetDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitLetDecl) {
                        return visitor.visitLetDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.LetDeclContext = LetDeclContext;
                  class BlockContext extends ParserRuleContext_1.ParserRuleContext {
                    LEFT_CURLY_TOK() {
                      return this.getToken(ForgeParser.LEFT_CURLY_TOK, 0);
                    }
                    RIGHT_CURLY_TOK() {
                      return this.getToken(ForgeParser.RIGHT_CURLY_TOK, 0);
                    }
                    expr(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(ExprContext);
                      } else {
                        return this.getRuleContext(i, ExprContext);
                      }
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_block;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterBlock) {
                        listener.enterBlock(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitBlock) {
                        listener.exitBlock(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitBlock) {
                        return visitor.visitBlock(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.BlockContext = BlockContext;
                  class BlockOrBarContext extends ParserRuleContext_1.ParserRuleContext {
                    block() {
                      return this.tryGetRuleContext(0, BlockContext);
                    }
                    BAR_TOK() {
                      return this.tryGetToken(ForgeParser.BAR_TOK, 0);
                    }
                    expr() {
                      return this.tryGetRuleContext(0, ExprContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_blockOrBar;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterBlockOrBar) {
                        listener.enterBlockOrBar(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitBlockOrBar) {
                        listener.exitBlockOrBar(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitBlockOrBar) {
                        return visitor.visitBlockOrBar(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.BlockOrBarContext = BlockOrBarContext;
                  class QuantContext extends ParserRuleContext_1.ParserRuleContext {
                    ALL_TOK() {
                      return this.tryGetToken(ForgeParser.ALL_TOK, 0);
                    }
                    NO_TOK() {
                      return this.tryGetToken(ForgeParser.NO_TOK, 0);
                    }
                    SUM_TOK() {
                      return this.tryGetToken(ForgeParser.SUM_TOK, 0);
                    }
                    mult() {
                      return this.tryGetRuleContext(0, MultContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_quant;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterQuant) {
                        listener.enterQuant(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitQuant) {
                        listener.exitQuant(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitQuant) {
                        return visitor.visitQuant(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.QuantContext = QuantContext;
                  class QualNameContext extends ParserRuleContext_1.ParserRuleContext {
                    name(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(NameContext);
                      } else {
                        return this.getRuleContext(i, NameContext);
                      }
                    }
                    THIS_TOK() {
                      return this.tryGetToken(ForgeParser.THIS_TOK, 0);
                    }
                    SLASH_TOK(i) {
                      if (i === void 0) {
                        return this.getTokens(ForgeParser.SLASH_TOK);
                      } else {
                        return this.getToken(ForgeParser.SLASH_TOK, i);
                      }
                    }
                    INT_TOK() {
                      return this.tryGetToken(ForgeParser.INT_TOK, 0);
                    }
                    SUM_TOK() {
                      return this.tryGetToken(ForgeParser.SUM_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_qualName;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterQualName) {
                        listener.enterQualName(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitQualName) {
                        listener.exitQualName(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitQualName) {
                        return visitor.visitQualName(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.QualNameContext = QualNameContext;
                  class OptionDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    OPTION_TOK() {
                      return this.getToken(ForgeParser.OPTION_TOK, 0);
                    }
                    qualName(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(QualNameContext);
                      } else {
                        return this.getRuleContext(i, QualNameContext);
                      }
                    }
                    FILE_PATH_TOK() {
                      return this.tryGetToken(ForgeParser.FILE_PATH_TOK, 0);
                    }
                    number() {
                      return this.tryGetRuleContext(0, NumberContext);
                    }
                    MINUS_TOK() {
                      return this.tryGetToken(ForgeParser.MINUS_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_optionDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterOptionDecl) {
                        listener.enterOptionDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitOptionDecl) {
                        listener.exitOptionDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitOptionDecl) {
                        return visitor.visitOptionDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.OptionDeclContext = OptionDeclContext;
                  class NameContext extends ParserRuleContext_1.ParserRuleContext {
                    IDENTIFIER_TOK() {
                      return this.getToken(ForgeParser.IDENTIFIER_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_name;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterName) {
                        listener.enterName(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitName) {
                        listener.exitName(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitName) {
                        return visitor.visitName(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.NameContext = NameContext;
                  class NameListContext extends ParserRuleContext_1.ParserRuleContext {
                    name() {
                      return this.getRuleContext(0, NameContext);
                    }
                    COMMA_TOK() {
                      return this.tryGetToken(ForgeParser.COMMA_TOK, 0);
                    }
                    nameList() {
                      return this.tryGetRuleContext(0, NameListContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_nameList;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterNameList) {
                        listener.enterNameList(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitNameList) {
                        listener.exitNameList(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitNameList) {
                        return visitor.visitNameList(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.NameListContext = NameListContext;
                  class QualNameListContext extends ParserRuleContext_1.ParserRuleContext {
                    qualName() {
                      return this.getRuleContext(0, QualNameContext);
                    }
                    COMMA_TOK() {
                      return this.tryGetToken(ForgeParser.COMMA_TOK, 0);
                    }
                    qualNameList() {
                      return this.tryGetRuleContext(0, QualNameListContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_qualNameList;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterQualNameList) {
                        listener.enterQualNameList(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitQualNameList) {
                        listener.exitQualNameList(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitQualNameList) {
                        return visitor.visitQualNameList(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.QualNameListContext = QualNameListContext;
                  class ParaDeclListContext extends ParserRuleContext_1.ParserRuleContext {
                    paraDecl() {
                      return this.getRuleContext(0, ParaDeclContext);
                    }
                    COMMA_TOK() {
                      return this.tryGetToken(ForgeParser.COMMA_TOK, 0);
                    }
                    paraDeclList() {
                      return this.tryGetRuleContext(0, ParaDeclListContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_paraDeclList;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterParaDeclList) {
                        listener.enterParaDeclList(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitParaDeclList) {
                        listener.exitParaDeclList(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitParaDeclList) {
                        return visitor.visitParaDeclList(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ParaDeclListContext = ParaDeclListContext;
                  class QuantDeclListContext extends ParserRuleContext_1.ParserRuleContext {
                    quantDecl() {
                      return this.getRuleContext(0, QuantDeclContext);
                    }
                    COMMA_TOK() {
                      return this.tryGetToken(ForgeParser.COMMA_TOK, 0);
                    }
                    quantDeclList() {
                      return this.tryGetRuleContext(0, QuantDeclListContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_quantDeclList;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterQuantDeclList) {
                        listener.enterQuantDeclList(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitQuantDeclList) {
                        listener.exitQuantDeclList(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitQuantDeclList) {
                        return visitor.visitQuantDeclList(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.QuantDeclListContext = QuantDeclListContext;
                  class ArrowDeclListContext extends ParserRuleContext_1.ParserRuleContext {
                    arrowDecl() {
                      return this.getRuleContext(0, ArrowDeclContext);
                    }
                    COMMA_TOK() {
                      return this.tryGetToken(ForgeParser.COMMA_TOK, 0);
                    }
                    arrowDeclList() {
                      return this.tryGetRuleContext(0, ArrowDeclListContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_arrowDeclList;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterArrowDeclList) {
                        listener.enterArrowDeclList(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitArrowDeclList) {
                        listener.exitArrowDeclList(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitArrowDeclList) {
                        return visitor.visitArrowDeclList(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ArrowDeclListContext = ArrowDeclListContext;
                  class LetDeclListContext extends ParserRuleContext_1.ParserRuleContext {
                    letDecl() {
                      return this.getRuleContext(0, LetDeclContext);
                    }
                    COMMA_TOK() {
                      return this.tryGetToken(ForgeParser.COMMA_TOK, 0);
                    }
                    letDeclList() {
                      return this.tryGetRuleContext(0, LetDeclListContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_letDeclList;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterLetDeclList) {
                        listener.enterLetDeclList(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitLetDeclList) {
                        listener.exitLetDeclList(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitLetDeclList) {
                        return visitor.visitLetDeclList(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.LetDeclListContext = LetDeclListContext;
                  class TypescopeListContext extends ParserRuleContext_1.ParserRuleContext {
                    typescope() {
                      return this.getRuleContext(0, TypescopeContext);
                    }
                    COMMA_TOK() {
                      return this.tryGetToken(ForgeParser.COMMA_TOK, 0);
                    }
                    typescopeList() {
                      return this.tryGetRuleContext(0, TypescopeListContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_typescopeList;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterTypescopeList) {
                        listener.enterTypescopeList(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitTypescopeList) {
                        listener.exitTypescopeList(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitTypescopeList) {
                        return visitor.visitTypescopeList(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.TypescopeListContext = TypescopeListContext;
                  class ExprListContext extends ParserRuleContext_1.ParserRuleContext {
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    COMMA_TOK() {
                      return this.tryGetToken(ForgeParser.COMMA_TOK, 0);
                    }
                    exprList() {
                      return this.tryGetRuleContext(0, ExprListContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_exprList;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExprList) {
                        listener.enterExprList(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExprList) {
                        listener.exitExprList(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExprList) {
                        return visitor.visitExprList(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ExprListContext = ExprListContext;
                  class ExprContext extends ParserRuleContext_1.ParserRuleContext {
                    expr1() {
                      return this.tryGetRuleContext(0, Expr1Context);
                    }
                    LET_TOK() {
                      return this.tryGetToken(ForgeParser.LET_TOK, 0);
                    }
                    letDeclList() {
                      return this.tryGetRuleContext(0, LetDeclListContext);
                    }
                    blockOrBar() {
                      return this.tryGetRuleContext(0, BlockOrBarContext);
                    }
                    BIND_TOK() {
                      return this.tryGetToken(ForgeParser.BIND_TOK, 0);
                    }
                    quant() {
                      return this.tryGetRuleContext(0, QuantContext);
                    }
                    quantDeclList() {
                      return this.tryGetRuleContext(0, QuantDeclListContext);
                    }
                    DISJ_TOK() {
                      return this.tryGetToken(ForgeParser.DISJ_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr) {
                        listener.enterExpr(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr) {
                        listener.exitExpr(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr) {
                        return visitor.visitExpr(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ExprContext = ExprContext;
                  class Expr1Context extends ParserRuleContext_1.ParserRuleContext {
                    expr1_5() {
                      return this.getRuleContext(0, Expr1_5Context);
                    }
                    expr1() {
                      return this.tryGetRuleContext(0, Expr1Context);
                    }
                    OR_TOK() {
                      return this.tryGetToken(ForgeParser.OR_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr1;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr1) {
                        listener.enterExpr1(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr1) {
                        listener.exitExpr1(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr1) {
                        return visitor.visitExpr1(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr1Context = Expr1Context;
                  class Expr1_5Context extends ParserRuleContext_1.ParserRuleContext {
                    expr2() {
                      return this.getRuleContext(0, Expr2Context);
                    }
                    expr1_5() {
                      return this.tryGetRuleContext(0, Expr1_5Context);
                    }
                    XOR_TOK() {
                      return this.tryGetToken(ForgeParser.XOR_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr1_5;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr1_5) {
                        listener.enterExpr1_5(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr1_5) {
                        listener.exitExpr1_5(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr1_5) {
                        return visitor.visitExpr1_5(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr1_5Context = Expr1_5Context;
                  class Expr2Context extends ParserRuleContext_1.ParserRuleContext {
                    expr3() {
                      return this.getRuleContext(0, Expr3Context);
                    }
                    expr2() {
                      return this.tryGetRuleContext(0, Expr2Context);
                    }
                    IFF_TOK() {
                      return this.tryGetToken(ForgeParser.IFF_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr2;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr2) {
                        listener.enterExpr2(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr2) {
                        listener.exitExpr2(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr2) {
                        return visitor.visitExpr2(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr2Context = Expr2Context;
                  class Expr3Context extends ParserRuleContext_1.ParserRuleContext {
                    expr4() {
                      return this.getRuleContext(0, Expr4Context);
                    }
                    IMP_TOK() {
                      return this.tryGetToken(ForgeParser.IMP_TOK, 0);
                    }
                    expr3(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(Expr3Context);
                      } else {
                        return this.getRuleContext(i, Expr3Context);
                      }
                    }
                    ELSE_TOK() {
                      return this.tryGetToken(ForgeParser.ELSE_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr3;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr3) {
                        listener.enterExpr3(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr3) {
                        listener.exitExpr3(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr3) {
                        return visitor.visitExpr3(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr3Context = Expr3Context;
                  class Expr4Context extends ParserRuleContext_1.ParserRuleContext {
                    expr4_5() {
                      return this.getRuleContext(0, Expr4_5Context);
                    }
                    expr4() {
                      return this.tryGetRuleContext(0, Expr4Context);
                    }
                    AND_TOK() {
                      return this.tryGetToken(ForgeParser.AND_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr4;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr4) {
                        listener.enterExpr4(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr4) {
                        listener.exitExpr4(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr4) {
                        return visitor.visitExpr4(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr4Context = Expr4Context;
                  class Expr4_5Context extends ParserRuleContext_1.ParserRuleContext {
                    expr5(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(Expr5Context);
                      } else {
                        return this.getRuleContext(i, Expr5Context);
                      }
                    }
                    UNTIL_TOK() {
                      return this.tryGetToken(ForgeParser.UNTIL_TOK, 0);
                    }
                    RELEASE_TOK() {
                      return this.tryGetToken(ForgeParser.RELEASE_TOK, 0);
                    }
                    SINCE_TOK() {
                      return this.tryGetToken(ForgeParser.SINCE_TOK, 0);
                    }
                    TRIGGERED_TOK() {
                      return this.tryGetToken(ForgeParser.TRIGGERED_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr4_5;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr4_5) {
                        listener.enterExpr4_5(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr4_5) {
                        listener.exitExpr4_5(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr4_5) {
                        return visitor.visitExpr4_5(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr4_5Context = Expr4_5Context;
                  class Expr5Context extends ParserRuleContext_1.ParserRuleContext {
                    expr6() {
                      return this.tryGetRuleContext(0, Expr6Context);
                    }
                    NEG_TOK() {
                      return this.tryGetToken(ForgeParser.NEG_TOK, 0);
                    }
                    expr5() {
                      return this.tryGetRuleContext(0, Expr5Context);
                    }
                    ALWAYS_TOK() {
                      return this.tryGetToken(ForgeParser.ALWAYS_TOK, 0);
                    }
                    EVENTUALLY_TOK() {
                      return this.tryGetToken(ForgeParser.EVENTUALLY_TOK, 0);
                    }
                    AFTER_TOK() {
                      return this.tryGetToken(ForgeParser.AFTER_TOK, 0);
                    }
                    BEFORE_TOK() {
                      return this.tryGetToken(ForgeParser.BEFORE_TOK, 0);
                    }
                    ONCE_TOK() {
                      return this.tryGetToken(ForgeParser.ONCE_TOK, 0);
                    }
                    HISTORICALLY_TOK() {
                      return this.tryGetToken(ForgeParser.HISTORICALLY_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr5;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr5) {
                        listener.enterExpr5(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr5) {
                        listener.exitExpr5(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr5) {
                        return visitor.visitExpr5(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr5Context = Expr5Context;
                  class Expr6Context extends ParserRuleContext_1.ParserRuleContext {
                    expr7() {
                      return this.getRuleContext(0, Expr7Context);
                    }
                    expr6() {
                      return this.tryGetRuleContext(0, Expr6Context);
                    }
                    compareOp() {
                      return this.tryGetRuleContext(0, CompareOpContext);
                    }
                    NEG_TOK() {
                      return this.tryGetToken(ForgeParser.NEG_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr6;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr6) {
                        listener.enterExpr6(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr6) {
                        listener.exitExpr6(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr6) {
                        return visitor.visitExpr6(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr6Context = Expr6Context;
                  class Expr7Context extends ParserRuleContext_1.ParserRuleContext {
                    expr8() {
                      return this.getRuleContext(0, Expr8Context);
                    }
                    NO_TOK() {
                      return this.tryGetToken(ForgeParser.NO_TOK, 0);
                    }
                    SOME_TOK() {
                      return this.tryGetToken(ForgeParser.SOME_TOK, 0);
                    }
                    LONE_TOK() {
                      return this.tryGetToken(ForgeParser.LONE_TOK, 0);
                    }
                    ONE_TOK() {
                      return this.tryGetToken(ForgeParser.ONE_TOK, 0);
                    }
                    TWO_TOK() {
                      return this.tryGetToken(ForgeParser.TWO_TOK, 0);
                    }
                    SET_TOK() {
                      return this.tryGetToken(ForgeParser.SET_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr7;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr7) {
                        listener.enterExpr7(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr7) {
                        listener.exitExpr7(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr7) {
                        return visitor.visitExpr7(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr7Context = Expr7Context;
                  class Expr8Context extends ParserRuleContext_1.ParserRuleContext {
                    expr9() {
                      return this.tryGetRuleContext(0, Expr9Context);
                    }
                    expr8() {
                      return this.tryGetRuleContext(0, Expr8Context);
                    }
                    expr10() {
                      return this.tryGetRuleContext(0, Expr10Context);
                    }
                    PLUS_TOK() {
                      return this.tryGetToken(ForgeParser.PLUS_TOK, 0);
                    }
                    MINUS_TOK() {
                      return this.tryGetToken(ForgeParser.MINUS_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr8;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr8) {
                        listener.enterExpr8(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr8) {
                        listener.exitExpr8(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr8) {
                        return visitor.visitExpr8(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr8Context = Expr8Context;
                  class Expr9Context extends ParserRuleContext_1.ParserRuleContext {
                    expr10() {
                      return this.tryGetRuleContext(0, Expr10Context);
                    }
                    CARD_TOK() {
                      return this.tryGetToken(ForgeParser.CARD_TOK, 0);
                    }
                    expr9() {
                      return this.tryGetRuleContext(0, Expr9Context);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr9;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr9) {
                        listener.enterExpr9(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr9) {
                        listener.exitExpr9(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr9) {
                        return visitor.visitExpr9(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr9Context = Expr9Context;
                  class Expr10Context extends ParserRuleContext_1.ParserRuleContext {
                    expr11() {
                      return this.getRuleContext(0, Expr11Context);
                    }
                    expr10() {
                      return this.tryGetRuleContext(0, Expr10Context);
                    }
                    PPLUS_TOK() {
                      return this.tryGetToken(ForgeParser.PPLUS_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr10;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr10) {
                        listener.enterExpr10(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr10) {
                        listener.exitExpr10(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr10) {
                        return visitor.visitExpr10(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr10Context = Expr10Context;
                  class Expr11Context extends ParserRuleContext_1.ParserRuleContext {
                    expr12() {
                      return this.getRuleContext(0, Expr12Context);
                    }
                    expr11() {
                      return this.tryGetRuleContext(0, Expr11Context);
                    }
                    AMP_TOK() {
                      return this.tryGetToken(ForgeParser.AMP_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr11;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr11) {
                        listener.enterExpr11(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr11) {
                        listener.exitExpr11(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr11) {
                        return visitor.visitExpr11(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr11Context = Expr11Context;
                  class Expr12Context extends ParserRuleContext_1.ParserRuleContext {
                    expr13() {
                      return this.getRuleContext(0, Expr13Context);
                    }
                    expr12() {
                      return this.tryGetRuleContext(0, Expr12Context);
                    }
                    arrowOp() {
                      return this.tryGetRuleContext(0, ArrowOpContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr12;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr12) {
                        listener.enterExpr12(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr12) {
                        listener.exitExpr12(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr12) {
                        return visitor.visitExpr12(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr12Context = Expr12Context;
                  class Expr13Context extends ParserRuleContext_1.ParserRuleContext {
                    expr14() {
                      return this.getRuleContext(0, Expr14Context);
                    }
                    expr13() {
                      return this.tryGetRuleContext(0, Expr13Context);
                    }
                    SUBT_TOK() {
                      return this.tryGetToken(ForgeParser.SUBT_TOK, 0);
                    }
                    SUPT_TOK() {
                      return this.tryGetToken(ForgeParser.SUPT_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr13;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr13) {
                        listener.enterExpr13(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr13) {
                        listener.exitExpr13(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr13) {
                        return visitor.visitExpr13(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr13Context = Expr13Context;
                  class Expr14Context extends ParserRuleContext_1.ParserRuleContext {
                    expr15() {
                      return this.tryGetRuleContext(0, Expr15Context);
                    }
                    expr14() {
                      return this.tryGetRuleContext(0, Expr14Context);
                    }
                    LEFT_SQUARE_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_SQUARE_TOK, 0);
                    }
                    exprList() {
                      return this.tryGetRuleContext(0, ExprListContext);
                    }
                    RIGHT_SQUARE_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_SQUARE_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr14;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr14) {
                        listener.enterExpr14(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr14) {
                        listener.exitExpr14(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr14) {
                        return visitor.visitExpr14(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr14Context = Expr14Context;
                  class Expr15Context extends ParserRuleContext_1.ParserRuleContext {
                    expr16() {
                      return this.tryGetRuleContext(0, Expr16Context);
                    }
                    expr15() {
                      return this.tryGetRuleContext(0, Expr15Context);
                    }
                    DOT_TOK() {
                      return this.tryGetToken(ForgeParser.DOT_TOK, 0);
                    }
                    name() {
                      return this.tryGetRuleContext(0, NameContext);
                    }
                    LEFT_SQUARE_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_SQUARE_TOK, 0);
                    }
                    exprList() {
                      return this.tryGetRuleContext(0, ExprListContext);
                    }
                    RIGHT_SQUARE_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_SQUARE_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr15;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr15) {
                        listener.enterExpr15(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr15) {
                        listener.exitExpr15(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr15) {
                        return visitor.visitExpr15(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr15Context = Expr15Context;
                  class Expr16Context extends ParserRuleContext_1.ParserRuleContext {
                    expr17() {
                      return this.tryGetRuleContext(0, Expr17Context);
                    }
                    expr16() {
                      return this.tryGetRuleContext(0, Expr16Context);
                    }
                    PRIME_TOK() {
                      return this.tryGetToken(ForgeParser.PRIME_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr16;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr16) {
                        listener.enterExpr16(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr16) {
                        listener.exitExpr16(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr16) {
                        return visitor.visitExpr16(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr16Context = Expr16Context;
                  class Expr17Context extends ParserRuleContext_1.ParserRuleContext {
                    expr18() {
                      return this.tryGetRuleContext(0, Expr18Context);
                    }
                    expr17() {
                      return this.tryGetRuleContext(0, Expr17Context);
                    }
                    TILDE_TOK() {
                      return this.tryGetToken(ForgeParser.TILDE_TOK, 0);
                    }
                    EXP_TOK() {
                      return this.tryGetToken(ForgeParser.EXP_TOK, 0);
                    }
                    STAR_TOK() {
                      return this.tryGetToken(ForgeParser.STAR_TOK, 0);
                    }
                    GET_LABEL_TOK() {
                      return this.tryGetToken(ForgeParser.GET_LABEL_TOK, 0);
                    }
                    GET_LABEL_STR_TOK() {
                      return this.tryGetToken(ForgeParser.GET_LABEL_STR_TOK, 0);
                    }
                    GET_LABEL_BOOL_TOK() {
                      return this.tryGetToken(ForgeParser.GET_LABEL_BOOL_TOK, 0);
                    }
                    GET_LABEL_NUM_TOK() {
                      return this.tryGetToken(ForgeParser.GET_LABEL_NUM_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr17;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr17) {
                        listener.enterExpr17(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr17) {
                        listener.exitExpr17(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr17) {
                        return visitor.visitExpr17(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr17Context = Expr17Context;
                  class Expr18Context extends ParserRuleContext_1.ParserRuleContext {
                    const() {
                      return this.tryGetRuleContext(0, ConstContext);
                    }
                    qualName() {
                      return this.tryGetRuleContext(0, QualNameContext);
                    }
                    AT_TOK() {
                      return this.tryGetToken(ForgeParser.AT_TOK, 0);
                    }
                    name() {
                      return this.tryGetRuleContext(0, NameContext);
                    }
                    BACKQUOTE_TOK() {
                      return this.tryGetToken(ForgeParser.BACKQUOTE_TOK, 0);
                    }
                    THIS_TOK() {
                      return this.tryGetToken(ForgeParser.THIS_TOK, 0);
                    }
                    LEFT_CURLY_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_CURLY_TOK, 0);
                    }
                    quantDeclList() {
                      return this.tryGetRuleContext(0, QuantDeclListContext);
                    }
                    blockOrBar() {
                      return this.tryGetRuleContext(0, BlockOrBarContext);
                    }
                    RIGHT_CURLY_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_CURLY_TOK, 0);
                    }
                    LEFT_PAREN_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_PAREN_TOK, 0);
                    }
                    expr() {
                      return this.tryGetRuleContext(0, ExprContext);
                    }
                    RIGHT_PAREN_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_PAREN_TOK, 0);
                    }
                    block() {
                      return this.tryGetRuleContext(0, BlockContext);
                    }
                    sexpr() {
                      return this.tryGetRuleContext(0, SexprContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_expr18;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExpr18) {
                        listener.enterExpr18(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExpr18) {
                        listener.exitExpr18(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExpr18) {
                        return visitor.visitExpr18(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.Expr18Context = Expr18Context;
                  class ArrowExprContext extends ParserRuleContext_1.ParserRuleContext {
                    qualName() {
                      return this.getRuleContext(0, QualNameContext);
                    }
                    ARROW_TOK() {
                      return this.tryGetToken(ForgeParser.ARROW_TOK, 0);
                    }
                    arrowExpr() {
                      return this.tryGetRuleContext(0, ArrowExprContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_arrowExpr;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterArrowExpr) {
                        listener.enterArrowExpr(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitArrowExpr) {
                        listener.exitArrowExpr(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitArrowExpr) {
                        return visitor.visitArrowExpr(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ArrowExprContext = ArrowExprContext;
                  class SexprDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    sexpr() {
                      return this.getRuleContext(0, SexprContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_sexprDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterSexprDecl) {
                        listener.enterSexprDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitSexprDecl) {
                        listener.exitSexprDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitSexprDecl) {
                        return visitor.visitSexprDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.SexprDeclContext = SexprDeclContext;
                  class SexprContext extends ParserRuleContext_1.ParserRuleContext {
                    SEXPR_TOK() {
                      return this.getToken(ForgeParser.SEXPR_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_sexpr;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterSexpr) {
                        listener.enterSexpr(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitSexpr) {
                        listener.exitSexpr(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitSexpr) {
                        return visitor.visitSexpr(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.SexprContext = SexprContext;
                  class InstDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    INST_TOK() {
                      return this.getToken(ForgeParser.INST_TOK, 0);
                    }
                    name() {
                      return this.getRuleContext(0, NameContext);
                    }
                    bounds() {
                      return this.getRuleContext(0, BoundsContext);
                    }
                    scope() {
                      return this.tryGetRuleContext(0, ScopeContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_instDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterInstDecl) {
                        listener.enterInstDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitInstDecl) {
                        listener.exitInstDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitInstDecl) {
                        return visitor.visitInstDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.InstDeclContext = InstDeclContext;
                  class EvalRelDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    arrowDecl() {
                      return this.getRuleContext(0, ArrowDeclContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_evalRelDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterEvalRelDecl) {
                        listener.enterEvalRelDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitEvalRelDecl) {
                        listener.exitEvalRelDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitEvalRelDecl) {
                        return visitor.visitEvalRelDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.EvalRelDeclContext = EvalRelDeclContext;
                  class EvalDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    EVAL_TOK() {
                      return this.getToken(ForgeParser.EVAL_TOK, 0);
                    }
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_evalDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterEvalDecl) {
                        listener.enterEvalDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitEvalDecl) {
                        listener.exitEvalDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitEvalDecl) {
                        return visitor.visitEvalDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.EvalDeclContext = EvalDeclContext;
                  class ExampleDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    EXAMPLE_TOK() {
                      return this.getToken(ForgeParser.EXAMPLE_TOK, 0);
                    }
                    name() {
                      return this.getRuleContext(0, NameContext);
                    }
                    IS_TOK() {
                      return this.getToken(ForgeParser.IS_TOK, 0);
                    }
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    FOR_TOK() {
                      return this.getToken(ForgeParser.FOR_TOK, 0);
                    }
                    bounds() {
                      return this.getRuleContext(0, BoundsContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_exampleDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterExampleDecl) {
                        listener.enterExampleDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitExampleDecl) {
                        listener.exitExampleDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitExampleDecl) {
                        return visitor.visitExampleDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.ExampleDeclContext = ExampleDeclContext;
                  class QueryDeclContext extends ParserRuleContext_1.ParserRuleContext {
                    name() {
                      return this.getRuleContext(0, NameContext);
                    }
                    COLON_TOK() {
                      return this.getToken(ForgeParser.COLON_TOK, 0);
                    }
                    arrowExpr() {
                      return this.getRuleContext(0, ArrowExprContext);
                    }
                    EQ_TOK() {
                      return this.getToken(ForgeParser.EQ_TOK, 0);
                    }
                    expr() {
                      return this.getRuleContext(0, ExprContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_queryDecl;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterQueryDecl) {
                        listener.enterQueryDecl(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitQueryDecl) {
                        listener.exitQueryDecl(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitQueryDecl) {
                        return visitor.visitQueryDecl(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.QueryDeclContext = QueryDeclContext;
                  class NumberListContext extends ParserRuleContext_1.ParserRuleContext {
                    number() {
                      return this.getRuleContext(0, NumberContext);
                    }
                    COMMA_TOK() {
                      return this.tryGetToken(ForgeParser.COMMA_TOK, 0);
                    }
                    numberList() {
                      return this.tryGetRuleContext(0, NumberListContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_numberList;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterNumberList) {
                        listener.enterNumberList(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitNumberList) {
                        listener.exitNumberList(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitNumberList) {
                        return visitor.visitNumberList(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.NumberListContext = NumberListContext;
                  class NumberContext extends ParserRuleContext_1.ParserRuleContext {
                    NUM_CONST_TOK() {
                      return this.getToken(ForgeParser.NUM_CONST_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_number;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterNumber) {
                        listener.enterNumber(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitNumber) {
                        listener.exitNumber(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitNumber) {
                        return visitor.visitNumber(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.NumberContext = NumberContext;
                  class BoundsContext extends ParserRuleContext_1.ParserRuleContext {
                    LEFT_CURLY_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_CURLY_TOK, 0);
                    }
                    RIGHT_CURLY_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_CURLY_TOK, 0);
                    }
                    bound(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(BoundContext);
                      } else {
                        return this.getRuleContext(i, BoundContext);
                      }
                    }
                    qualName() {
                      return this.tryGetRuleContext(0, QualNameContext);
                    }
                    EXACTLY_TOK() {
                      return this.tryGetToken(ForgeParser.EXACTLY_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_bounds;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterBounds) {
                        listener.enterBounds(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitBounds) {
                        listener.exitBounds(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitBounds) {
                        return visitor.visitBounds(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.BoundsContext = BoundsContext;
                  class AtomNameOrNumberContext extends ParserRuleContext_1.ParserRuleContext {
                    BACKQUOTE_TOK() {
                      return this.tryGetToken(ForgeParser.BACKQUOTE_TOK, 0);
                    }
                    name() {
                      return this.tryGetRuleContext(0, NameContext);
                    }
                    number() {
                      return this.tryGetRuleContext(0, NumberContext);
                    }
                    MINUS_TOK() {
                      return this.tryGetToken(ForgeParser.MINUS_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_atomNameOrNumber;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterAtomNameOrNumber) {
                        listener.enterAtomNameOrNumber(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitAtomNameOrNumber) {
                        listener.exitAtomNameOrNumber(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitAtomNameOrNumber) {
                        return visitor.visitAtomNameOrNumber(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.AtomNameOrNumberContext = AtomNameOrNumberContext;
                  class BoundContext extends ParserRuleContext_1.ParserRuleContext {
                    boundLHS() {
                      return this.tryGetRuleContext(0, BoundLHSContext);
                    }
                    compareOp() {
                      return this.tryGetRuleContext(0, CompareOpContext);
                    }
                    bindRHSUnion() {
                      return this.tryGetRuleContext(0, BindRHSUnionContext);
                    }
                    NO_TOK() {
                      return this.tryGetToken(ForgeParser.NO_TOK, 0);
                    }
                    qualName() {
                      return this.tryGetRuleContext(0, QualNameContext);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_bound;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterBound) {
                        listener.enterBound(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitBound) {
                        listener.exitBound(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitBound) {
                        return visitor.visitBound(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.BoundContext = BoundContext;
                  class BoundLHSContext extends ParserRuleContext_1.ParserRuleContext {
                    CARD_TOK() {
                      return this.tryGetToken(ForgeParser.CARD_TOK, 0);
                    }
                    qualName(i) {
                      if (i === void 0) {
                        return this.getRuleContexts(QualNameContext);
                      } else {
                        return this.getRuleContext(i, QualNameContext);
                      }
                    }
                    atomNameOrNumber() {
                      return this.tryGetRuleContext(0, AtomNameOrNumberContext);
                    }
                    DOT_TOK(i) {
                      if (i === void 0) {
                        return this.getTokens(ForgeParser.DOT_TOK);
                      } else {
                        return this.getToken(ForgeParser.DOT_TOK, i);
                      }
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_boundLHS;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterBoundLHS) {
                        listener.enterBoundLHS(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitBoundLHS) {
                        listener.exitBoundLHS(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitBoundLHS) {
                        return visitor.visitBoundLHS(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.BoundLHSContext = BoundLHSContext;
                  class BindRHSUnionContext extends ParserRuleContext_1.ParserRuleContext {
                    bindRHSProduct() {
                      return this.tryGetRuleContext(0, BindRHSProductContext);
                    }
                    bindRHSUnion() {
                      return this.tryGetRuleContext(0, BindRHSUnionContext);
                    }
                    PLUS_TOK() {
                      return this.tryGetToken(ForgeParser.PLUS_TOK, 0);
                    }
                    LEFT_PAREN_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_PAREN_TOK, 0);
                    }
                    RIGHT_PAREN_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_PAREN_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_bindRHSUnion;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterBindRHSUnion) {
                        listener.enterBindRHSUnion(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitBindRHSUnion) {
                        listener.exitBindRHSUnion(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitBindRHSUnion) {
                        return visitor.visitBindRHSUnion(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.BindRHSUnionContext = BindRHSUnionContext;
                  class BindRHSProductContext extends ParserRuleContext_1.ParserRuleContext {
                    LEFT_PAREN_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_PAREN_TOK, 0);
                    }
                    bindRHSProduct() {
                      return this.tryGetRuleContext(0, BindRHSProductContext);
                    }
                    RIGHT_PAREN_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_PAREN_TOK, 0);
                    }
                    bindRHSProductBase() {
                      return this.tryGetRuleContext(0, BindRHSProductBaseContext);
                    }
                    COMMA_TOK() {
                      return this.tryGetToken(ForgeParser.COMMA_TOK, 0);
                    }
                    ARROW_TOK() {
                      return this.tryGetToken(ForgeParser.ARROW_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_bindRHSProduct;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterBindRHSProduct) {
                        listener.enterBindRHSProduct(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitBindRHSProduct) {
                        listener.exitBindRHSProduct(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitBindRHSProduct) {
                        return visitor.visitBindRHSProduct(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.BindRHSProductContext = BindRHSProductContext;
                  class BindRHSProductBaseContext extends ParserRuleContext_1.ParserRuleContext {
                    atomNameOrNumber() {
                      return this.tryGetRuleContext(0, AtomNameOrNumberContext);
                    }
                    qualName() {
                      return this.tryGetRuleContext(0, QualNameContext);
                    }
                    LEFT_PAREN_TOK() {
                      return this.tryGetToken(ForgeParser.LEFT_PAREN_TOK, 0);
                    }
                    bindRHSUnion() {
                      return this.tryGetRuleContext(0, BindRHSUnionContext);
                    }
                    RIGHT_PAREN_TOK() {
                      return this.tryGetToken(ForgeParser.RIGHT_PAREN_TOK, 0);
                    }
                    constructor(parent, invokingState) {
                      super(parent, invokingState);
                    }
                    // @Override
                    get ruleIndex() {
                      return ForgeParser.RULE_bindRHSProductBase;
                    }
                    // @Override
                    enterRule(listener) {
                      if (listener.enterBindRHSProductBase) {
                        listener.enterBindRHSProductBase(this);
                      }
                    }
                    // @Override
                    exitRule(listener) {
                      if (listener.exitBindRHSProductBase) {
                        listener.exitBindRHSProductBase(this);
                      }
                    }
                    // @Override
                    accept(visitor) {
                      if (visitor.visitBindRHSProductBase) {
                        return visitor.visitBindRHSProductBase(this);
                      } else {
                        return visitor.visitChildren(this);
                      }
                    }
                  }
                  exports2.BindRHSProductBaseContext = BindRHSProductBaseContext;
                }
              ),
              /***/
              "./src/forge-antlr/ForgeSyntaxConstructs.ts": (
                /*!**************************************************!*\
                  !*** ./src/forge-antlr/ForgeSyntaxConstructs.ts ***!
                  \**************************************************/
                /***/
                (__unused_webpack_module, exports2) => {
                  "use strict";
                  Object.defineProperty(exports2, "__esModule", { value: true });
                  exports2.Expr = exports2.ConsistencyAssertionTest = exports2.SatisfiabilityAssertionTest = exports2.Example = exports2.QuantifiedAssertionTest = exports2.AssertionTest = exports2.Test = exports2.Function = exports2.Predicate = exports2.Sig = exports2.Block = exports2.SyntaxNode = void 0;
                  class SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn) {
                      this.startRow = startRow;
                      this.startColumn = startColumn;
                      this.endRow = endRow;
                      this.endColumn = endColumn;
                    }
                  }
                  exports2.SyntaxNode = SyntaxNode;
                  class Block extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, statements) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.statements = statements;
                    }
                  }
                  exports2.Block = Block;
                  class Sig extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, name, body, inheritsFrom, annotation) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.name = name;
                      this.body = body;
                      this.inheritsFrom = inheritsFrom;
                      this.annotation = annotation;
                    }
                  }
                  exports2.Sig = Sig;
                  class Formula extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, formula) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.formula = formula;
                    }
                  }
                  class Expr extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, expr) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.expr = expr;
                    }
                  }
                  exports2.Expr = Expr;
                  class Predicate extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, name, params, body) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.name = name;
                      this.params = params;
                      this.body = body;
                    }
                  }
                  exports2.Predicate = Predicate;
                  class Test extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, name, check, body, bounds, scope) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.name = name;
                      this.check = check;
                      this.body = body;
                      this.bounds = bounds;
                      this.scope = scope;
                    }
                  }
                  exports2.Test = Test;
                  class AssertionTest extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, pred, prop, check, bounds, scope) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.pred = pred;
                      this.prop = prop;
                      this.check = check;
                      this.bounds = bounds;
                      this.scope = scope;
                    }
                  }
                  exports2.AssertionTest = AssertionTest;
                  class QuantifiedAssertionTest extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, pred, prop, check, disj, quantDecls, bounds, scope, predArgs) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.pred = pred;
                      this.prop = prop;
                      this.check = check;
                      this.disj = disj;
                      this.quantDecls = quantDecls;
                      this.bounds = bounds;
                      this.scope = scope;
                      this.predArgs = predArgs;
                    }
                  }
                  exports2.QuantifiedAssertionTest = QuantifiedAssertionTest;
                  class Example extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, name, testExpr, bounds) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.name = name;
                      this.testExpr = testExpr;
                      this.bounds = bounds;
                    }
                  }
                  exports2.Example = Example;
                  class Function2 extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, name, params, body) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.name = name;
                      this.params = params;
                      this.body = body;
                    }
                  }
                  exports2.Function = Function2;
                  class SatisfiabilityAssertionTest extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, exp2, check, bounds, scope) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.exp = exp2;
                      this.check = check;
                      this.bounds = bounds;
                      this.scope = scope;
                    }
                  }
                  exports2.SatisfiabilityAssertionTest = SatisfiabilityAssertionTest;
                  class ConsistencyAssertionTest extends SyntaxNode {
                    constructor(startRow, startColumn, endRow, endColumn, pred, prop, consistent, bounds, scope) {
                      super(startRow, startColumn, endRow, endColumn);
                      this.pred = pred;
                      this.prop = prop;
                      this.consistent = consistent;
                      this.bounds = bounds;
                      this.scope = scope;
                    }
                  }
                  exports2.ConsistencyAssertionTest = ConsistencyAssertionTest;
                }
              )
              /******/
            };
            var __webpack_module_cache__ = {};
            function __webpack_require__(moduleId) {
              var cachedModule = __webpack_module_cache__[moduleId];
              if (cachedModule !== void 0) {
                return cachedModule.exports;
              }
              var module2 = __webpack_module_cache__[moduleId] = {
                /******/
                id: moduleId,
                /******/
                loaded: false,
                /******/
                exports: {}
                /******/
              };
              __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
              module2.loaded = true;
              return module2.exports;
            }
            (() => {
              __webpack_require__.g = function() {
                if (typeof globalThis === "object") return globalThis;
                try {
                  return this || new Function("return this")();
                } catch (e) {
                  if (typeof window === "object") return window;
                }
              }();
            })();
            (() => {
              __webpack_require__.nmd = (module2) => {
                module2.paths = [];
                if (!module2.children) module2.children = [];
                return module2;
              };
            })();
            var __webpack_exports__ = {};
            (() => {
              "use strict";
              var exports2 = __webpack_exports__;
              Object.defineProperty(exports2, "__esModule", { value: true });
              exports2.SimpleGraphQueryEvaluator = void 0;
              const antlr4ts_1 = __webpack_require__(
                /*! antlr4ts */
                "./node_modules/antlr4ts/index.js"
              );
              const ForgeParser_1 = __webpack_require__(
                /*! ./forge-antlr/ForgeParser */
                "./src/forge-antlr/ForgeParser.ts"
              );
              const ForgeLexer_1 = __webpack_require__(
                /*! ./forge-antlr/ForgeLexer */
                "./src/forge-antlr/ForgeLexer.ts"
              );
              const ForgeListenerImpl_1 = __webpack_require__(
                /*! ./forge-antlr/ForgeListenerImpl */
                "./src/forge-antlr/ForgeListenerImpl.ts"
              );
              const ParseTreeWalker_1 = __webpack_require__(
                /*! antlr4ts/tree/ParseTreeWalker */
                "./node_modules/antlr4ts/tree/ParseTreeWalker.js"
              );
              const ForgeExprEvaluator_1 = __webpack_require__(
                /*! ./ForgeExprEvaluator */
                "./src/ForgeExprEvaluator.ts"
              );
              const errorListener_1 = __webpack_require__(
                /*! ./errorListener */
                "./src/errorListener.ts"
              );
              function createForgeParser(input) {
                const inputStream = antlr4ts_1.CharStreams.fromString(input);
                const lexer = new ForgeLexer_1.ForgeLexer(inputStream);
                const tokenStream = new antlr4ts_1.CommonTokenStream(lexer);
                const parser = new ForgeParser_1.ForgeParser(tokenStream);
                parser.buildParseTree = true;
                parser.removeErrorListeners();
                parser.addErrorListener(new errorListener_1.ParseErrorListener());
                return parser;
              }
              class SimpleGraphQueryEvaluator2 {
                constructor(datum) {
                  this.forgeListener = new ForgeListenerImpl_1.ForgeListenerImpl();
                  this.walker = new ParseTreeWalker_1.ParseTreeWalker();
                  this.datum = datum;
                }
                getExpressionParseTree(forgeExpr) {
                  const parser = createForgeParser(forgeExpr);
                  const tree = parser.parseExpr();
                  if (!tree || tree.childCount === 0) {
                    throw new Error(`Parse error in ${forgeExpr}`);
                  }
                  return tree;
                }
                evaluateExpression(forgeExpr) {
                  try {
                    var tree = this.getExpressionParseTree(forgeExpr);
                  } catch (e) {
                    return {
                      error: new Error(`Error parsing expression "${forgeExpr}"`)
                    };
                  }
                  const evaluator = new ForgeExprEvaluator_1.ForgeExprEvaluator(this.datum);
                  try {
                    let result = evaluator.visit(tree instanceof ForgeParser_1.ExprContext ? tree : tree.getChild(0));
                    return result;
                  } catch (error) {
                    if (error instanceof ForgeExprEvaluator_1.NameNotFoundError) {
                      let emptyResult = [];
                      return emptyResult;
                    }
                    if (error instanceof Error) {
                      const stackTrace = error.stack;
                      const errorMessage = error.message;
                      return {
                        error: new Error(`Error evaluating expression "${forgeExpr}": ${errorMessage}`),
                        stackTrace
                      };
                    }
                    return {
                      error: new Error(`Error evaluating expression "${forgeExpr}"`)
                    };
                  }
                }
              }
              exports2.SimpleGraphQueryEvaluator = SimpleGraphQueryEvaluator2;
            })();
            return __webpack_exports__;
          })()
        );
      });
    }
  });

  // webcola-demo/react-component-integration.tsx
  var react_component_integration_exports = {};
  __export(react_component_integration_exports, {
    CnDCore: () => CnDCore,
    CndLayoutStateManager: () => CndLayoutStateManager,
    DataAPI: () => DataAPI,
    ErrorAPI: () => ErrorAPI,
    InstanceStateManager: () => InstanceStateManager,
    PyretReplStateManager: () => PyretReplStateManager,
    getCurrentCNDSpecFromReact: () => getCurrentCNDSpecFromReact,
    getCurrentInstanceFromReact: () => getCurrentInstanceFromReact,
    globalErrorManager: () => globalErrorManager,
    mountAllComponents: () => mountAllComponents,
    mountAllComponentsWithPyret: () => mountAllComponentsWithPyret,
    mountCndLayoutInterface: () => mountCndLayoutInterface,
    mountCombinedInputComponent: () => mountCombinedInputComponent,
    mountErrorMessageModal: () => mountErrorMessageModal,
    mountEvaluatorRepl: () => mountEvaluatorRepl,
    mountInstanceBuilder: () => mountInstanceBuilder,
    mountPyretRepl: () => mountPyretRepl,
    mountRelationHighlighter: () => mountRelationHighlighter,
    mountReplWithVisualization: () => mountReplWithVisualization
  });
  var import_react15 = __toESM(require_react());
  var import_client2 = __toESM(require_client());

  // src/components/CndLayoutInterface.tsx
  var import_react5 = __toESM(require_react());

  // src/components/NoCodeView/NoCodeView.tsx
  var import_react4 = __toESM(require_react());

  // src/components/NoCodeView/ConstraintCard.tsx
  var import_react2 = __toESM(require_react());

  // src/components/NoCodeView/constants.ts
  var TUPLE_SELECTOR_TEXT = `Forge expression yielding tuples (arity \u2265 2); constraint applies from first to last element.`;
  var UNARY_SELECTOR_TEXT = `Forge expression yielding singletons.`;
  var CYCLIC_DESCRIPTION = "Arrange elements along the perimeter of a circle.";
  var ORIENTATION_DESCRIPTION = "Specify the relative positioning of elements.";
  var GROUPING_SELECTOR_DESCRIPTION = "Group elements based on a selector.";
  var GROUPING_FIELD_DESCRIPTION = "Group elements based on a field.";

  // src/components/NoCodeView/Selectors/AttributeSelector.tsx
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  var AttributeSelector = (props) => {
    const handleInputChange = (event) => {
      const { name, value } = event.target;
      props.onUpdate({
        params: {
          ...props.directiveData.params,
          [name]: value || void 0
        }
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: "input-group-text", children: "Field" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "input",
          {
            type: "text",
            name: "field",
            className: "form-control",
            defaultValue: props.directiveData.params.field || "",
            onChange: handleInputChange,
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: "input-group-text", children: "Selector" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "input",
          {
            type: "text",
            name: "selector",
            className: "form-control code-input",
            defaultValue: props.directiveData.params.selector || "",
            placeholder: "Optional: target specific atoms (e.g., Person)",
            onChange: handleInputChange
          }
        )
      ] })
    ] });
  };

  // src/components/NoCodeView/Selectors/ColorAtomSelector.tsx
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  var ColorAtomSelector = (props) => {
    const handleInputChange = (event) => {
      const { name, value } = event.target;
      props.onUpdate({
        params: {
          ...props.directiveData.params,
          [name]: value
        }
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "input-group-text infolabel", title: UNARY_SELECTOR_TEXT, children: "Selector" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
          "input",
          {
            type: "text",
            name: "selector",
            className: "form-control code-input",
            onChange: handleInputChange,
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "input-group-text", children: "Color" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
          "input",
          {
            type: "color",
            name: "value",
            className: "form-control",
            onChange: handleInputChange,
            required: true
          }
        )
      ] })
    ] });
  };

  // src/components/NoCodeView/Selectors/ColorEdgeSelector.tsx
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());
  var ColorEdgeSelector = ({
    directiveData,
    onUpdate
  }) => {
    const field = directiveData.params.field || "";
    const value = directiveData.params.value || "#000000";
    const selector = directiveData.params.selector || "";
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { className: "input-group-text", children: "Field" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "input",
          {
            type: "text",
            name: "field",
            className: "form-control",
            defaultValue: field,
            onChange: (e) => onUpdate({ params: { ...directiveData.params, field: e.target.value } }),
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { className: "input-group-text", children: "Selector" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "input",
          {
            type: "text",
            name: "selector",
            className: "form-control code-input",
            defaultValue: selector,
            placeholder: "Optional: target specific atoms (e.g., Person)",
            onChange: (e) => onUpdate({ params: { ...directiveData.params, selector: e.target.value || void 0 } })
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { className: "input-group-text", children: "Color" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "input",
          {
            type: "color",
            name: "value",
            className: "form-control",
            defaultValue: value,
            onChange: (e) => onUpdate({ params: { ...directiveData.params, value: e.target.value } }),
            required: true
          }
        )
      ] })
    ] });
  };

  // src/components/NoCodeView/Selectors/CyclicSelector.tsx
  var import_jsx_runtime4 = __toESM(require_jsx_runtime());
  var CyclicSelector = (props) => {
    const handleParamsChange = (event) => {
      const { name, value } = event.target;
      props.onUpdate({
        params: {
          ...props.constraintData.params,
          [name]: value
        }
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "input-group-text infolabel", title: TUPLE_SELECTOR_TEXT, children: "Selector" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("input", { type: "text", name: "selector", className: "form-control code-input", required: true, onChange: handleParamsChange, value: props.constraintData.params.selector || "" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "input-group-text", children: "Direction" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("select", { name: "direction", onChange: handleParamsChange, value: props.constraintData.params.direction || "clockwise", children: [
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("option", { value: "clockwise", children: "Clockwise" }),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("option", { value: "counterclockwise", children: "Counterclockwise" })
        ] })
      ] })
    ] });
  };

  // src/components/NoCodeView/Selectors/FlagSelector.tsx
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  var FlagSelector = ({
    directiveData,
    onUpdate
  }) => {
    const flag = directiveData.params.flag || "";
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "input-group", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
      "select",
      {
        name: "flag",
        className: "form-control",
        defaultValue: flag,
        onChange: (e) => onUpdate({ params: { ...directiveData.params, flag: e.target.value } }),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("option", { value: "", children: "Select flag..." }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("option", { value: "hideDisconnectedBuiltIns", children: "Hide disconnected built ins." }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("option", { value: "hideDisconnected", children: "Hide all disconnected." })
        ]
      }
    ) });
  };

  // src/components/NoCodeView/Selectors/GroupByFieldSelector.tsx
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());
  var GroupByFieldSelector = (props) => {
    const handleInputChange = (event) => {
      const { name, value } = event.target;
      props.onUpdate({
        params: {
          ...props.constraintData.params,
          [name]: event.target.type === "number" ? Number(value) : value
        }
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "input-group-text", children: "Field" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
          "input",
          {
            type: "text",
            name: "field",
            className: "form-control",
            onChange: handleInputChange,
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "input-group-text", children: "Selector" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
          "input",
          {
            type: "text",
            name: "selector",
            className: "form-control code-input",
            defaultValue: props.constraintData.params.selector || "",
            placeholder: "Optional: target specific atoms (e.g., Person)",
            onChange: handleInputChange
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "input-group-text infolabel", title: "Which 0-indexed element of the field to use as the group key.", children: "Group On" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
          "input",
          {
            type: "number",
            name: "groupOn",
            className: "form-control",
            onChange: handleInputChange,
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "input-group-text infolabel", title: "Which 0-indexed element of the field are group members.", children: "Add to Group" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
          "input",
          {
            type: "number",
            name: "addToGroup",
            className: "form-control",
            onChange: handleInputChange,
            required: true
          }
        )
      ] })
    ] });
  };

  // src/components/NoCodeView/Selectors/GroupBySelectorSelector.tsx
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  var GroupBySelectorSelector = (props) => {
    const handleInputChange = (event) => {
      const { name, value } = event.target;
      props.onUpdate({
        params: {
          ...props.constraintData.params,
          [name]: value
        }
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("span", { className: "input-group-text infolabel", title: `${UNARY_SELECTOR_TEXT} or ${TUPLE_SELECTOR_TEXT}`, children: "Selector" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
          "input",
          {
            type: "text",
            name: "selector",
            className: "form-control code-input",
            defaultValue: props.constraintData.params.selector || "",
            onChange: handleInputChange,
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("span", { className: "input-group-text", children: "Group Name" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
          "input",
          {
            type: "text",
            name: "name",
            className: "form-control",
            defaultValue: props.constraintData.params.name || "",
            onChange: handleInputChange,
            required: true
          }
        )
      ] })
    ] });
  };

  // src/components/NoCodeView/Selectors/HelperEdgeSelector.tsx
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  var HelperEdgeSelector = ({
    directiveData,
    onUpdate
  }) => {
    const selector = directiveData.params.selector || "";
    const name = directiveData.params.name || "";
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "input-group-text infolabel", title: TUPLE_SELECTOR_TEXT, children: "Selector" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
          "input",
          {
            type: "text",
            name: "selector",
            className: "form-control code-input",
            defaultValue: selector,
            onChange: (e) => onUpdate({ params: { ...directiveData.params, selector: e.target.value } }),
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "input-group-text", children: "Edge Name" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
          "input",
          {
            type: "text",
            name: "name",
            className: "form-control",
            defaultValue: name,
            onChange: (e) => onUpdate({ params: { ...directiveData.params, name: e.target.value } }),
            required: true
          }
        )
      ] })
    ] });
  };

  // src/components/NoCodeView/Selectors/HideAtomSelector.tsx
  var import_jsx_runtime9 = __toESM(require_jsx_runtime());
  var HideAtomSelector = (props) => {
    const handleInputChange = (event) => {
      const { name, value } = event.target;
      props.onUpdate({
        params: {
          ...props.directiveData.params,
          [name]: value
        }
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "input-group", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "input-group-text infolabel", title: UNARY_SELECTOR_TEXT, children: "Selector" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        "input",
        {
          type: "text",
          name: "selector",
          className: "form-control code-input",
          defaultValue: props.directiveData.params.selector || "",
          onChange: handleInputChange,
          required: true
        }
      )
    ] });
  };

  // src/components/NoCodeView/Selectors/HideFieldSelector.tsx
  var import_jsx_runtime10 = __toESM(require_jsx_runtime());
  var HideFieldSelector = (props) => {
    const handleInputChange = (event) => {
      const { name, value } = event.target;
      props.onUpdate({
        params: {
          ...props.directiveData.params,
          [name]: value || void 0
        }
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("span", { className: "input-group-text", children: "Field" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
          "input",
          {
            type: "text",
            name: "field",
            className: "form-control",
            defaultValue: props.directiveData.params.field || "",
            onChange: handleInputChange,
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("span", { className: "input-group-text", children: "Selector" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
          "input",
          {
            type: "text",
            name: "selector",
            className: "form-control code-input",
            defaultValue: props.directiveData.params.selector || "",
            placeholder: "Optional: target specific atoms (e.g., Person)",
            onChange: handleInputChange
          }
        )
      ] })
    ] });
  };

  // src/components/NoCodeView/Selectors/IconSelector.tsx
  var import_jsx_runtime11 = __toESM(require_jsx_runtime());
  var IconSelector = ({
    directiveData,
    onUpdate
  }) => {
    const selector = directiveData.params.selector || "";
    const path = directiveData.params.path || "";
    const showLabels = directiveData.params.showLabels || false;
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("span", { className: "input-group-text infolabel", title: UNARY_SELECTOR_TEXT, children: "Selector" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
          "input",
          {
            type: "text",
            name: "selector",
            className: "form-control code-input",
            defaultValue: selector,
            onChange: (e) => onUpdate({ params: { ...directiveData.params, selector: e.target.value } }),
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("span", { className: "input-group-text", children: "Path" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
          "input",
          {
            type: "text",
            name: "path",
            className: "form-control",
            defaultValue: path,
            onChange: (e) => onUpdate({ params: { ...directiveData.params, path: e.target.value } }),
            placeholder: "/path/to/icon.png",
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("span", { className: "input-group-text", children: "Show Labels" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "form-check ml-3", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
          "input",
          {
            className: "form-check-input",
            type: "checkbox",
            name: "showLabels",
            defaultChecked: showLabels,
            onChange: (e) => onUpdate({ params: { ...directiveData.params, showLabels: e.target.checked } })
          }
        ) })
      ] })
    ] });
  };

  // src/components/NoCodeView/Selectors/OrientationSelector.tsx
  var import_jsx_runtime12 = __toESM(require_jsx_runtime());
  var OrientationSelector = (props) => {
    const handleInputChange = (event) => {
      const { name, value } = event.target;
      props.onUpdate({
        params: {
          ...props.constraintData.params,
          [name]: value
        }
      });
    };
    const handleSelectChange = (event) => {
      const { name } = event.target;
      const selectedValues = Array.from(event.target.selectedOptions, (option) => option.value);
      props.onUpdate({
        params: {
          ...props.constraintData.params,
          [name]: selectedValues
        }
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("span", { className: "input-group-text infolabel", title: TUPLE_SELECTOR_TEXT, children: "Selector" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
          "input",
          {
            type: "text",
            name: "selector",
            className: "form-control code-input",
            defaultValue: props.constraintData.params.selector || "",
            onChange: handleInputChange,
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("span", { className: "input-group-text stretch-height", children: "Directions" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(
          "select",
          {
            name: "directions",
            className: "form-control",
            multiple: true,
            defaultValue: props.constraintData.params.directions || [],
            onChange: handleSelectChange,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("option", { value: "left", children: "Left" }),
              /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("option", { value: "right", children: "Right" }),
              /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("option", { value: "above", children: "Above" }),
              /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("option", { value: "below", children: "Below" }),
              /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("option", { value: "directlyLeft", children: "Directly Left" }),
              /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("option", { value: "directlyRight", children: "Directly Right" }),
              /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("option", { value: "directlyAbove", children: "Directly Above" }),
              /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("option", { value: "directlyBelow", children: "Directly Below" })
            ]
          }
        )
      ] })
    ] });
  };

  // src/components/NoCodeView/Selectors/ProjectionSelector.tsx
  var import_jsx_runtime13 = __toESM(require_jsx_runtime());
  var ProjectionSelector = (props) => {
    const handleInputChange = (event) => {
      const { name, value } = event.target;
      props.onUpdate({
        params: {
          ...props.directiveData.params,
          [name]: value
        }
      });
    };
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)("div", { className: "input-group", children: [
      /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("span", { className: "input-group-text", children: "Sig" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
        "input",
        {
          type: "text",
          className: "form-control",
          name: "sig",
          onChange: handleInputChange,
          required: true
        }
      )
    ] });
  };

  // src/components/NoCodeView/Selectors/SizeSelector.tsx
  var import_jsx_runtime14 = __toESM(require_jsx_runtime());
  var SizeSelector = ({
    directiveData,
    onUpdate
  }) => {
    const selector = directiveData.params.selector || "";
    const width = directiveData.params.width || 10;
    const height = directiveData.params.height || 10;
    return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(import_jsx_runtime14.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: "input-group-text infolabel", title: UNARY_SELECTOR_TEXT, children: "Selector" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
          "input",
          {
            type: "text",
            name: "selector",
            className: "form-control code-input",
            defaultValue: selector,
            onChange: (e) => onUpdate({ params: { ...directiveData.params, selector: e.target.value } }),
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("label", { children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: "input-group-text", children: "Width" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
          "input",
          {
            type: "number",
            name: "width",
            className: "form-control",
            defaultValue: width,
            onChange: (e) => onUpdate({ params: { ...directiveData.params, width: Number(e.target.value) } }),
            required: true
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("label", { children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: "input-group-text", children: "Height" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
          "input",
          {
            type: "number",
            name: "height",
            className: "form-control",
            defaultValue: height,
            onChange: (e) => onUpdate({ params: { ...directiveData.params, height: Number(e.target.value) } }),
            required: true
          }
        )
      ] })
    ] });
  };

  // node_modules/js-yaml/dist/js-yaml.mjs
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];
    return [sequence];
  }
  function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string, count) {
    var result = "", cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }
  var isNothing_1 = isNothing;
  var isObject_1 = isObject;
  var toArray_1 = toArray;
  var repeat_1 = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1 = extend;
  var common = {
    isNothing: isNothing_1,
    isObject: isObject_1,
    toArray: toArray_1,
    repeat: repeat_1,
    isNegativeZero: isNegativeZero_1,
    extend: extend_1
  };
  function formatError(exception2, compact) {
    var where = "", message = exception2.reason || "(unknown reason)";
    if (!exception2.mark) return message;
    if (exception2.mark.name) {
      where += 'in "' + exception2.mark.name + '" ';
    }
    where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
    if (!compact && exception2.mark.snippet) {
      where += "\n\n" + exception2.mark.snippet;
    }
    return message + " " + where;
  }
  function YAMLException$1(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException$1.prototype = Object.create(Error.prototype);
  YAMLException$1.prototype.constructor = YAMLException$1;
  YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + ": " + formatError(this, compact);
  };
  var exception = YAMLException$1;
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = "";
    var tail = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position - lineStart > maxHalfLength) {
      head = " ... ";
      lineStart = position - maxHalfLength + head.length;
    }
    if (lineEnd - position > maxHalfLength) {
      tail = " ...";
      lineEnd = position + maxHalfLength - tail.length;
    }
    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
      pos: position - lineStart + head.length
      // relative position
    };
  }
  function padStart(string, max6) {
    return common.repeat(" ", max6 - string.length) + string;
  }
  function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer) return null;
    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent !== "number") options.indent = 1;
    if (typeof options.linesBefore !== "number") options.linesBefore = 3;
    if (typeof options.linesAfter !== "number") options.linesAfter = 2;
    var re = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;
    while (match = re.exec(mark.buffer)) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);
      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }
    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
    var result = "", i, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
    for (i = 1; i <= options.linesBefore; i++) {
      if (foundLineNo - i < 0) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i],
        lineEnds[foundLineNo - i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
        maxLineLength
      );
      result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
    for (i = 1; i <= options.linesAfter; i++) {
      if (foundLineNo + i >= lineEnds.length) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i],
        lineEnds[foundLineNo + i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
        maxLineLength
      );
      result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    }
    return result.replace(/\n$/, "");
  }
  var snippet = makeSnippet;
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    if (map2 !== null) {
      Object.keys(map2).forEach(function(style) {
        map2[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type$1(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.options = options;
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.representName = options["representName"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.multi = options["multi"] || false;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  var type = Type$1;
  function compileList(schema2, name) {
    var result = [];
    schema2[name].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index, length;
    function collectType(type2) {
      if (type2.multi) {
        result.multi[type2.kind].push(type2);
        result.multi["fallback"].push(type2);
      } else {
        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
      }
    }
    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema$1(definition) {
    return this.extend(definition);
  }
  Schema$1.prototype.extend = function extend2(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof type) {
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      if (definition.implicit) implicit = implicit.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);
    } else {
      throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    }
    implicit.forEach(function(type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      if (type$1.loadKind && type$1.loadKind !== "scalar") {
        throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
      if (type$1.multi) {
        throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }
    });
    explicit.forEach(function(type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
    });
    var result = Object.create(Schema$1.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };
  var schema = Schema$1;
  var str = new type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
  var seq = new type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
  var map = new type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
  var failsafe = new schema({
    explicit: [
      str,
      seq,
      map
    ]
  });
  function resolveYamlNull(data) {
    if (data === null) return true;
    var max6 = data.length;
    return max6 === 1 && data === "~" || max6 === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  var _null = new type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max6 = data.length;
    return max6 === 4 && (data === "true" || data === "True" || data === "TRUE") || max6 === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  var bool = new type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  function isHexCode(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function isOctCode(c) {
    return 48 <= c && c <= 55;
  }
  function isDecCode(c) {
    return 48 <= c && c <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null) return false;
    var max6 = data.length, index = 0, hasDigits = false, ch;
    if (!max6) return false;
    ch = data[index];
    if (ch === "-" || ch === "+") {
      ch = data[++index];
    }
    if (ch === "0") {
      if (index + 1 === max6) return true;
      ch = data[++index];
      if (ch === "b") {
        index++;
        for (; index < max6; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (ch !== "0" && ch !== "1") return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index++;
        for (; index < max6; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "o") {
        index++;
        for (; index < max6; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
    }
    if (ch === "_") return false;
    for (; index < max6; index++) {
      ch = data[index];
      if (ch === "_") continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_") return false;
    return true;
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch;
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-") sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0") return 0;
    if (ch === "0") {
      if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
      if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
  }
  var int = new type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    if (data === null) return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
  }
  var float = new type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
  var json = failsafe.extend({
    implicit: [
      _null,
      bool,
      int,
      float
    ]
  });
  var core = json;
  var YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  );
  var YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  var timestamp = new type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  var merge = new type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max6 = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max6; idx++) {
      code = map2.indexOf(data.charAt(idx));
      if (code > 64) continue;
      if (code < 0) return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max6 = input.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max6; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map2.indexOf(input.charAt(idx));
    }
    tailbits = max6 % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    return new Uint8Array(result);
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max6 = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max6; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max6 % 3;
    if (tail === 0) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    } else if (tail === 2) {
      result += map2[bits >> 10 & 63];
      result += map2[bits >> 4 & 63];
      result += map2[bits << 2 & 63];
      result += map2[64];
    } else if (tail === 1) {
      result += map2[bits >> 2 & 63];
      result += map2[bits << 4 & 63];
      result += map2[64];
      result += map2[64];
    }
    return result;
  }
  function isBinary(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  var binary = new type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2 = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString$2.call(pair) !== "[object Object]") return false;
      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }
      if (!pairHasKey) return false;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  var omap = new type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
  var _toString$1 = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      if (_toString$1.call(pair) !== "[object Object]") return false;
      keys = Object.keys(pair);
      if (keys.length !== 1) return false;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  var pairs = new type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  var set = new type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
  var _default = core.extend({
    implicit: [
      timestamp,
      merge
    ],
    explicit: [
      binary,
      omap,
      pairs,
      set
    ]
  });
  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c) {
    return c === 10 || c === 13;
  }
  function is_WHITE_SPACE(c) {
    return c === 9 || c === 32;
  }
  function is_WS_OR_EOL(c) {
    return c === 9 || c === 32 || c === 10 || c === 13;
  }
  function is_FLOW_INDICATOR(c) {
    return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
  }
  function fromHexCode(c) {
    var lc;
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    lc = c | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c) {
    if (c === 120) {
      return 2;
    }
    if (c === 117) {
      return 4;
    }
    if (c === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c) {
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c) {
    return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c) {
    if (c <= 65535) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode(
      (c - 65536 >> 10) + 55296,
      (c - 65536 & 1023) + 56320
    );
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  var i;
  function State$1(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || _default;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.firstTabInLine = -1;
    this.documents = [];
  }
  function generateError(state, message) {
    var mark = {
      name: state.filename,
      buffer: state.input.slice(0, -1),
      // omit trailing \0
      position: state.position,
      line: state.line,
      column: state.position - state.lineStart
    };
    mark.snippet = snippet(mark);
    return new exception(message, mark);
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, "tag prefix is malformed: " + prefix);
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      if (keyNode === "__proto__") {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 9 && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common.repeat("\n", count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      } else if (ch === 44) {
        throwError(state, "expected the node content, but found ','");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common.repeat("\n", emptyLines);
        }
      } else {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.firstTabInLine !== -1) return false;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, "tab characters must not be used in indentation");
      }
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          break;
        }
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33) return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38) return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    } else if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state.implicitTypes[typeIndex];
        if (type2.resolve(state.result)) {
          state.result = type2.construct(state.result);
          state.tag = type2.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== "!") {
      if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type2 = state.typeMap[state.kind || "fallback"][state.tag];
      } else {
        type2 = null;
        typeList = state.typeMap.multi[state.kind || "fallback"];
        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
        }
      }
      if (!type2) {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
      if (state.result !== null && type2.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
      }
      if (!type2.resolve(state.result, state.tag)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type2.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = /* @__PURE__ */ Object.create(null);
    state.anchorMap = /* @__PURE__ */ Object.create(null);
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch)) break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0) readLineBreak(state);
      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State$1(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, "null byte is not allowed in input");
    }
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load$1(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new exception("expected a single document in the stream, but found more");
  }
  var loadAll_1 = loadAll$1;
  var load_1 = load$1;
  var loader = {
    loadAll: loadAll_1,
    load: load_1
  };
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 65279;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema2, map2) {
    var result, keys, index, length, tag, style, type2;
    if (map2 === null) return {};
    result = {};
    keys = Object.keys(map2);
    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map2[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type2 = schema2.compiledTypeMap["fallback"][tag];
      if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
        style = type2.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string.length) + string;
  }
  var QUOTING_TYPE_SINGLE = 1;
  var QUOTING_TYPE_DOUBLE = 2;
  function State(options) {
    this.schema = options["schema"] || _default;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options["forceQuotes"] || false;
    this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while (position < length) {
      next = string.indexOf("\n", position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n") result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index, length, type2;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type2 = state.implicitTypes[index];
      if (type2.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }
  function isPrintable(c) {
    return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
  }
  function isNsCharOrWhitespace(c) {
    return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return (
      // ns-plain-safe
      (inblock ? (
        // c = flow-in
        cIsNsCharOrWhitespace
      ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
    );
  }
  function isPlainSafeFirst(c) {
    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c) {
    return !isWhitespace(c) && c !== CHAR_COLON;
  }
  function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1;
  var STYLE_SINGLE = 2;
  var STYLE_LITERAL = 3;
  var STYLE_FOLDED = 4;
  var STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes) {
      for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = function() {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
        }
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(
        string,
        singleLineOnly,
        state.indent,
        lineWidth,
        testAmbiguity,
        state.quotingType,
        state.forceQuotes && !iskey,
        inblock
      )) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new exception("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = "";
    var char = 0;
    var escapeSeq;
    for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      escapeSeq = ESCAPE_SEQUENCES[char];
      if (!escapeSeq && isPrintable(char)) {
        result += string[i];
        if (char >= 65536) result += string[i + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
        if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length, value;
    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];
      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }
      if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
        if (!compact || _result !== "") {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (_result !== "") pairBuffer += ", ";
      if (state.condenseFlow) pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024) pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new exception("sortKeys must be a boolean or a function");
    }
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (!compact || _result !== "") {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type2, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length; index < length; index += 1) {
      type2 = typeList[index];
      if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (explicit) {
          if (type2.multi && type2.representName) {
            state.tag = type2.representName(object);
          } else {
            state.tag = type2.tag;
          }
        } else {
          state.tag = "?";
        }
        if (type2.represent) {
          style = state.styleMap[type2.tag] || type2.defaultStyle;
          if (_toString.call(type2.represent) === "[object Function]") {
            _result = type2.represent(object, style);
          } else if (_hasOwnProperty.call(type2.represent, style)) {
            _result = type2.represent[style](object, style);
          } else {
            throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type2 = _toString.call(state.dump);
    var inblock = block;
    var tagStr;
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type2 === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object Array]") {
        if (block && state.dump.length !== 0) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type2 === "[object Undefined]") {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new exception("unacceptable kind of an object to dump " + type2);
      }
      if (state.tag !== null && state.tag !== "?") {
        tagStr = encodeURI(
          state.tag[0] === "!" ? state.tag.slice(1) : state.tag
        ).replace(/!/g, "%21");
        if (state.tag[0] === "!") {
          tagStr = "!" + tagStr;
        } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
          tagStr = "!!" + tagStr.slice(18);
        } else {
          tagStr = "!<" + tagStr + ">";
        }
        state.dump = tagStr + " " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump$1(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    var value = input;
    if (state.replacer) {
      value = state.replacer.call({ "": value }, "", value);
    }
    if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
    return "";
  }
  var dump_1 = dump$1;
  var dumper = {
    dump: dump_1
  };
  function renamed(from, to) {
    return function() {
      throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
    };
  }
  var Type = type;
  var Schema = schema;
  var FAILSAFE_SCHEMA = failsafe;
  var JSON_SCHEMA = json;
  var CORE_SCHEMA = core;
  var DEFAULT_SCHEMA = _default;
  var load = loader.load;
  var loadAll = loader.loadAll;
  var dump = dumper.dump;
  var YAMLException = exception;
  var types = {
    binary,
    float,
    map,
    null: _null,
    pairs,
    set,
    timestamp,
    bool,
    int,
    merge,
    omap,
    seq,
    str
  };
  var safeLoad = renamed("safeLoad", "load");
  var safeLoadAll = renamed("safeLoadAll", "loadAll");
  var safeDump = renamed("safeDump", "dump");
  var jsYaml = {
    Type,
    Schema,
    FAILSAFE_SCHEMA,
    JSON_SCHEMA,
    CORE_SCHEMA,
    DEFAULT_SCHEMA,
    load,
    loadAll,
    dump,
    YAMLException,
    types,
    safeLoad,
    safeLoadAll,
    safeDump
  };
  var js_yaml_default = jsYaml;

  // src/components/NoCodeView/CodeView.tsx
  var import_jsx_runtime15 = __toESM(require_jsx_runtime());
  function generateLayoutSpecYaml(constraints, directives) {
    function toYamlConstraintType(type2) {
      if (type2 === "cyclic") {
        return "cyclic";
      }
      if (type2 === "orientation") {
        return "orientation";
      }
      if (type2 === "groupfield" || type2 === "groupselector") {
        return "group";
      }
      return "unknown";
    }
    const yamlConstraints = constraints.map((c) => {
      return {
        [toYamlConstraintType(c.type)]: c.params
      };
    });
    const yamlDirectives = directives.map((d) => {
      if (d.type === "flag") {
        return {
          [d.type]: d.params.flag
        };
      }
      return {
        [d.type]: d.params
      };
    });
    let combinedSpec = {};
    if (constraints.length > 0) {
      combinedSpec.constraints = yamlConstraints;
    }
    if (directives.length > 0) {
      combinedSpec.directives = yamlDirectives;
    }
    let yamlStr = "";
    if (Object.keys(combinedSpec).length > 0) {
      yamlStr = js_yaml_default.dump(combinedSpec);
    }
    return yamlStr;
  }
  var CodeView = (props) => {
    return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: "cnd-layout-interface__code-view", role: "region", "aria-label": "YAML Code Editor", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "mb-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { id: "cnd-layout-yaml-help", className: "form-text text-muted fst-italic pb-3", children: "Enter your CND layout specification in YAML format. Use the toggle above to switch to the visual editor." }),
      /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
        "textarea",
        {
          id: "webcola-cnd",
          className: "form-control cnd-layout-interface__textarea",
          value: props.yamlValue,
          onChange: props.handleTextareaChange,
          disabled: props.disabled,
          rows: 12,
          spellCheck: false,
          "aria-label": "CND Layout Specification YAML",
          "aria-describedby": "cnd-layout-yaml-help",
          style: { minHeight: "400px", resize: "vertical" }
        }
      )
    ] }) });
  };

  // src/components/NoCodeView/hooks.ts
  var import_react = __toESM(require_react());
  var useHighlight = (duration = 1e3) => {
    const [isHighlighted, setIsHighlighted] = (0, import_react.useState)(true);
    (0, import_react.useEffect)(() => {
      const timer = setTimeout(() => {
        setIsHighlighted(false);
      }, duration);
      return () => clearTimeout(timer);
    }, [duration]);
    return { isHighlighted };
  };

  // src/components/NoCodeView/ConstraintCard.tsx
  var import_jsx_runtime16 = __toESM(require_jsx_runtime());
  var ConstraintCard = (props) => {
    const constraintsToSelectorComponentMap = {
      cyclic: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(CyclicSelector, { constraintData: props.constraintData, onUpdate: props.onUpdate }),
      orientation: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(OrientationSelector, { constraintData: props.constraintData, onUpdate: props.onUpdate }),
      groupfield: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(GroupByFieldSelector, { constraintData: props.constraintData, onUpdate: props.onUpdate }),
      groupselector: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(GroupBySelectorSelector, { constraintData: props.constraintData, onUpdate: props.onUpdate })
    };
    const [cardHTML, setCardHTML] = (0, import_react2.useState)(constraintsToSelectorComponentMap[props.constraintData.type]);
    const { isHighlighted } = useHighlight(1e3);
    const updateFields = (0, import_react2.useCallback)((event) => {
      const selectElement = event.target;
      const selectedValue = selectElement.value;
      setCardHTML(constraintsToSelectorComponentMap[selectedValue]);
      props.onUpdate({ type: selectedValue, params: {} });
    }, [props.onUpdate, props.constraintData]);
    const classes = [
      props.className ? props.className : "",
      isHighlighted ? "highlight" : "",
      "noCodeCard"
    ].filter(Boolean).join(" ");
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: classes, children: [
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("button", { className: "closeButton", title: "Remove constraint", "aria-label": "Remove constraint", type: "button", onClick: props.onRemove, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("span", { "aria-hidden": "true", children: "\xD7" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("span", { className: "input-group-text", title: "Choose constraint type", children: "Constraint" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("select", { onChange: updateFields, value: props.constraintData.type, children: [
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("option", { value: "orientation", title: ORIENTATION_DESCRIPTION, children: "Orientation" }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("option", { value: "cyclic", title: CYCLIC_DESCRIPTION, children: "Cyclic" }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("option", { value: "groupfield", title: GROUPING_FIELD_DESCRIPTION, children: "Group by field" }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("option", { value: "groupselector", title: GROUPING_SELECTOR_DESCRIPTION, children: "Group by selector" })
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "params", children: cardHTML })
    ] });
  };

  // src/components/NoCodeView/DirectiveCard.tsx
  var import_react3 = __toESM(require_react());
  var import_jsx_runtime17 = __toESM(require_jsx_runtime());
  var DirectiveCard = (props) => {
    const directiveToSelectorComponentMap = {
      "attribute": /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(AttributeSelector, { directiveData: props.directiveData, onUpdate: props.onUpdate }),
      "hideField": /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(HideFieldSelector, { directiveData: props.directiveData, onUpdate: props.onUpdate }),
      "hideAtom": /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(HideAtomSelector, { directiveData: props.directiveData, onUpdate: props.onUpdate }),
      "icon": /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(IconSelector, { directiveData: props.directiveData, onUpdate: props.onUpdate }),
      "atomColor": /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(ColorAtomSelector, { directiveData: props.directiveData, onUpdate: props.onUpdate }),
      "edgeColor": /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(ColorEdgeSelector, { directiveData: props.directiveData, onUpdate: props.onUpdate }),
      "size": /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(SizeSelector, { directiveData: props.directiveData, onUpdate: props.onUpdate }),
      "projection": /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(ProjectionSelector, { directiveData: props.directiveData, onUpdate: props.onUpdate }),
      "flag": /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(FlagSelector, { directiveData: props.directiveData, onUpdate: props.onUpdate }),
      "inferredEdge": /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(HelperEdgeSelector, { directiveData: props.directiveData, onUpdate: props.onUpdate })
    };
    const [cardHTML, setCardHTML] = (0, import_react3.useState)(directiveToSelectorComponentMap[props.directiveData.type]);
    const { isHighlighted } = useHighlight(1e3);
    const updateFields = (0, import_react3.useCallback)((event) => {
      const selectElement = event.target;
      const selectedValue = selectElement.value;
      setCardHTML(directiveToSelectorComponentMap[selectedValue]);
      props.onUpdate({ type: selectedValue, params: {} });
    }, [props.onUpdate, props.directiveData]);
    const classes = [
      isHighlighted && "highlight",
      "noCodeCard"
    ].filter(Boolean).join(" ");
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: classes, children: [
      /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("button", { className: "closeButton", title: "Remove directive", "aria-label": "Remove directive", type: "button", onClick: props.onRemove, children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("span", { "aria-hidden": "true", children: "\xD7" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "input-group", children: [
        /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "input-group-prepend", children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("span", { className: "input-group-text", children: "Directive" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("select", { onChange: updateFields, value: props.directiveData.type, children: [
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("option", { value: "flag", children: "Visibility Flag" }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("option", { value: "hideAtom", children: "Hide Atom" }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("option", { value: "attribute", children: "Attribute" }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("option", { value: "hideField", children: "Hide Field" }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("option", { value: "icon", children: "Icon" }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("option", { value: "atomColor", children: "Color (Atom)" }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("option", { value: "edgeColor", children: "Color (Edge)" }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("option", { value: "size", children: "Size" }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("option", { value: "projection", children: "Projection" }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("option", { value: "inferredEdge", children: "Inferred Edge" })
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "params", children: cardHTML })
    ] });
  };

  // src/components/NoCodeView/NoCodeView.tsx
  var import_jsx_runtime18 = __toESM(require_jsx_runtime());
  function generateId() {
    if (typeof window !== "undefined" && window.crypto && window.crypto.randomUUID) {
      return window.crypto.randomUUID();
    }
    console.error("Web Crypto API not available, falling back to Math.random for ID generation");
    const timestamp2 = Date.now().toString(36);
    const randomPart = Math.random().toString(36).substring(2, 15);
    const extraRandom = Math.random().toString(36).substring(2, 15);
    return `${timestamp2}-${randomPart}-${extraRandom}`;
  }
  function parseLayoutSpecToData(yamlString) {
    let constraints = [];
    let directives = [];
    const parsedYaml = js_yaml_default.load(yamlString);
    const yamlConstraints = parsedYaml?.constraints;
    const yamlDirectives = parsedYaml?.directives;
    function get_constraint_type_from_yaml(constraint) {
      const type2 = Object.keys(constraint)[0];
      const params = constraint[type2];
      if (type2 === "cyclic" || type2 === "orientation") {
        return type2;
      }
      if (type2 === "group") {
        if (params["selector"]) {
          return "groupselector";
        }
        if (params["field"]) {
          return "groupfield";
        }
      }
      return "unknown";
    }
    if (yamlConstraints) {
      if (!Array.isArray(yamlConstraints)) {
        throw new Error("Invalid YAML: 'constraints' should be an array");
      }
      constraints = yamlConstraints.map((constraint) => {
        const type2 = get_constraint_type_from_yaml(constraint);
        if (type2 === "unknown") {
          throw new Error(`Unsupported constraint type in YAML: ${JSON.stringify(constraint)}`);
        }
        const params = constraint[Object.keys(constraint)[0]];
        return {
          id: generateId(),
          type: type2,
          params
        };
      });
    }
    if (yamlDirectives) {
      if (!Array.isArray(yamlDirectives)) {
        throw new Error("Invalid YAML: 'directives' should be an array");
      }
      directives = yamlDirectives.map((directive) => {
        const type2 = Object.keys(directive)[0];
        let params = directive[type2];
        if (typeof params === "string") {
          params = { [type2]: params };
        }
        return {
          id: generateId(),
          type: type2,
          params
        };
      });
    }
    return {
      constraints,
      directives
    };
  }
  var NoCodeView = ({
    yamlValue,
    constraints,
    setConstraints,
    directives,
    setDirectives,
    disabled = false
  }) => {
    const addConstraint = () => {
      const newConstraint = {
        id: generateId(),
        type: "orientation",
        params: {}
      };
      setConstraints((prev) => [newConstraint, ...prev]);
    };
    const updateConstraint = (0, import_react4.useCallback)((constraintId, updates) => {
      setConstraints((prevConstraints) => prevConstraints.map((constraint) => {
        if (constraint.id === constraintId) {
          return {
            ...constraint,
            ...updates,
            params: {
              ...constraint.params,
              ...updates.params
            }
          };
        }
        return constraint;
      }));
    }, [setConstraints]);
    const addDirective = () => {
      const newDirective = {
        id: generateId(),
        type: "flag",
        params: {}
      };
      setDirectives((prev) => [newDirective, ...prev]);
    };
    const updateDirective = (0, import_react4.useCallback)((directiveId, updates) => {
      setDirectives((prevDirectives) => prevDirectives.map(
        (directive) => directive.id === directiveId ? {
          ...directive,
          ...updates,
          params: {
            ...directive.params,
            ...updates.params
          }
        } : directive
      ));
    }, [setDirectives]);
    const loadStateFromYaml = (yamlString) => {
      const { constraints: newConstraints, directives: newDirectives } = parseLayoutSpecToData(yamlString);
      setConstraints((prev) => newConstraints);
      setDirectives((prev) => newDirectives);
    };
    (0, import_react4.useEffect)(() => {
      console.log(yamlValue);
      if (yamlValue) {
        try {
          loadStateFromYaml(yamlValue);
        } catch (error) {
          console.error("Failed to load YAML into No Code View:", error);
        }
      }
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("section", { id: "noCodeViewContainer", "aria-label": "No Code View Container", children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("h5", { children: [
          "Constraints  ",
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("button", { type: "button", onClick: addConstraint, title: "Click to add a new constraint", "aria-label": "Click to add a new constraint", disabled, children: "+" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("section", { className: "cardContainer", id: "constraintContainer", "aria-label": "Constraints List", children: constraints.map((cd1) => /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          ConstraintCard,
          {
            constraintData: cd1,
            onUpdate: (updates) => updateConstraint(cd1.id, updates),
            onRemove: () => {
              setConstraints((prev) => prev.filter((cd2) => cd2.id !== cd1.id));
            }
          },
          cd1.id
        )) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("hr", {}),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("h5", { children: [
          "Directives  ",
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("button", { type: "button", onClick: addDirective, title: "Click to add a new directive", "aria-label": "Click to add a new directive", disabled, children: "+" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("section", { className: "cardContainer", id: "directiveContainer", "aria-label": "Directives List", children: directives.map((dd1) => /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          DirectiveCard,
          {
            directiveData: dd1,
            onUpdate: (updates) => updateDirective(dd1.id, updates),
            onRemove: () => {
              setDirectives((prev) => prev.filter((dd2) => dd2.id !== dd1.id));
            }
          },
          dd1.id
        )) })
      ] })
    ] });
  };

  // src/components/CndLayoutInterface.tsx
  var import_jsx_runtime19 = __toESM(require_jsx_runtime());
  var CndLayoutInterface = ({
    yamlValue,
    onChange,
    isNoCodeView,
    onViewChange,
    constraints,
    setConstraints,
    directives,
    setDirectives,
    className = "",
    disabled = false,
    "aria-label": ariaLabel = "CND Layout Specification Interface"
  }) => {
    const handleToggleChange = (0, import_react5.useCallback)((event) => {
      if (disabled) return;
      if (!event.target.checked) {
        const generatedYaml = generateLayoutSpecYaml(constraints, directives);
        onChange(generatedYaml);
      }
      onViewChange(event.target.checked);
    }, [disabled, onViewChange, onChange, constraints, directives]);
    const handleTextareaChange = (0, import_react5.useCallback)((event) => {
      if (disabled) return;
      onChange(event.target.value);
    }, [disabled, onChange]);
    const containerClasses = [
      "cnd-layout-interface",
      "container-fluid",
      // Bootstrap fluid container
      disabled && "cnd-layout-interface--disabled",
      className
    ].filter(Boolean).join(" ");
    const toggleLabelCodeClasses = [
      "cnd-layout-interface__toggle-label",
      "small",
      // Bootstrap small text
      !isNoCodeView && "text-primary fw-semibold"
      // Bootstrap active styling
    ].filter(Boolean).join(" ");
    const toggleLabelNoCodeClasses = [
      "cnd-layout-interface__toggle-label",
      "small",
      // Bootstrap small text
      isNoCodeView && "text-primary fw-semibold"
      // Bootstrap active styling
    ].filter(Boolean).join(" ");
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("section", { id: "cnd-layout-interface-container", className: containerClasses, "aria-label": ariaLabel, children: [
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "d-flex justify-content-between align-items-center mb-3 pb-2 border-bottom", children: /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: "d-flex align-items-center gap-3", children: [
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("span", { className: toggleLabelCodeClasses, children: "Code View" }),
        /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("label", { className: "cnd-layout-interface__toggle", htmlFor: "cnd-layout-toggle", children: [
          /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
            "input",
            {
              id: "cnd-layout-toggle",
              type: "checkbox",
              checked: isNoCodeView,
              onChange: handleToggleChange,
              disabled,
              className: "cnd-layout-interface__toggle-input",
              "aria-describedby": "cnd-layout-toggle-description",
              role: "switch"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("span", { className: "cnd-layout-interface__toggle-slider" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("span", { className: toggleLabelNoCodeClasses, children: "No Code View" })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { id: "cnd-layout-toggle-description", className: "visually-hidden", children: "Toggle between Code View (text editor) and No Code View (visual editor) for CND layout specification" }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "cnd-layout-interface__content", children: isNoCodeView ? (
        // No Code View - Bootstrap card layout
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(NoCodeView, { yamlValue, constraints, setConstraints, directives, setDirectives })
      ) : (
        // Code View - Bootstrap form styling
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(CodeView, { constraints, directives, yamlValue, handleTextareaChange, disabled })
      ) })
    ] });
  };

  // src/components/InstanceBuilder/InstanceBuilder.tsx
  var import_react6 = __toESM(require_react());
  var import_jsx_runtime20 = __toESM(require_jsx_runtime());
  function generateAtomId(instance, typeName) {
    const existingAtoms = instance.getAtoms();
    const existingIds = new Set(existingAtoms.map((atom) => atom.id));
    let counter = 1;
    let candidateId = `${typeName}-${counter}`;
    while (existingIds.has(candidateId)) {
      counter++;
      candidateId = `${typeName}-${counter}`;
    }
    return candidateId;
  }
  var InstanceBuilder = ({
    instance,
    onChange,
    disabled = false,
    className = ""
  }) => {
    const [atomForm, setAtomForm] = (0, import_react6.useState)({
      id: "",
      label: "",
      type: "Entity"
    });
    const suggestedId = generateAtomId(instance, atomForm.type.trim() || "Entity");
    const [relationForm, setRelationForm] = (0, import_react6.useState)({
      name: "",
      atomIds: ["", ""]
      // Start with binary relation
    });
    const [error, setError] = (0, import_react6.useState)("");
    const atoms = instance.getAtoms();
    const relations = instance.getRelations();
    const notifyChange = (0, import_react6.useCallback)(() => {
      if (onChange) {
        onChange(instance);
      }
    }, [instance, onChange]);
    const handleAddAtom = (0, import_react6.useCallback)((e) => {
      e.preventDefault();
      if (!atomForm.label.trim()) {
        setError("Atom label is required");
        return;
      }
      const typeInfo = atomForm.type.trim() || "Entity";
      const id = atomForm.id.trim() || generateAtomId(instance, typeInfo);
      if (!id) {
        setError("Atom ID could not be generated");
        return;
      }
      if (instance.getAtoms().some((atom) => atom.id === id)) {
        setError("Atom ID already exists");
        return;
      }
      try {
        const newAtom = {
          id,
          label: atomForm.label.trim(),
          type: typeInfo
        };
        instance.addAtom(newAtom);
        setAtomForm({ id: "", label: "", type: "Entity" });
        setError("");
        notifyChange();
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to add atom");
      }
    }, [atomForm, instance, notifyChange]);
    const handleRemoveAtom = (0, import_react6.useCallback)((atomId) => {
      try {
        instance.removeAtom(atomId);
        setError("");
        notifyChange();
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to remove atom");
      }
    }, [instance, notifyChange]);
    const handleAddAtomPosition = (0, import_react6.useCallback)(() => {
      setRelationForm((prev) => ({
        ...prev,
        atomIds: [...prev.atomIds, ""]
      }));
    }, []);
    const handleRemoveAtomPosition = (0, import_react6.useCallback)(() => {
      setRelationForm((prev) => ({
        ...prev,
        atomIds: prev.atomIds.length > 2 ? prev.atomIds.slice(0, -1) : prev.atomIds
      }));
    }, []);
    const handleUpdateAtomId = (0, import_react6.useCallback)((index, atomId) => {
      setRelationForm((prev) => ({
        ...prev,
        atomIds: prev.atomIds.map((id, i) => i === index ? atomId : id)
      }));
    }, []);
    const handleAddRelation = (0, import_react6.useCallback)((e) => {
      e.preventDefault();
      if (!relationForm.name.trim()) {
        setError("Relation name is required");
        return;
      }
      const cleanAtomIds = relationForm.atomIds.map((id) => id.trim()).filter((id) => id !== "");
      if (cleanAtomIds.length < 2) {
        setError("At least 2 atoms are required for a relation");
        return;
      }
      if (cleanAtomIds.length !== relationForm.atomIds.length) {
        setError("All atom positions must be selected");
        return;
      }
      try {
        const tuple = {
          atoms: cleanAtomIds,
          types: cleanAtomIds.map(() => "unknown")
          // Types will be inferred from actual atoms
        };
        instance.addRelationTuple(relationForm.name.trim(), tuple);
        setRelationForm({ name: "", atomIds: ["", ""] });
        setError("");
        notifyChange();
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to add relation");
      }
    }, [relationForm, instance, notifyChange]);
    const handleRemoveRelationTuple = (0, import_react6.useCallback)((relationId, tuple) => {
      try {
        instance.removeRelationTuple(relationId, tuple);
        setError("");
        notifyChange();
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to remove relation");
      }
    }, [instance, notifyChange]);
    const handleClear = (0, import_react6.useCallback)(() => {
      try {
        const atomIds = instance.getAtoms().map((atom) => atom.id);
        atomIds.forEach((id) => instance.removeAtom(id));
        const relationIds = instance.getRelations().map((rel) => rel.id);
        relationIds.forEach((id) => {
          const relation = instance.getRelations().find((r) => r.id === id);
          if (relation) {
            relation.tuples.forEach((tuple) => instance.removeRelationTuple(id, tuple));
          }
        });
        setError("");
        notifyChange();
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to clear instance");
      }
    }, [instance, notifyChange]);
    const [reifyResult, setReifyResult] = (0, import_react6.useState)(null);
    const handleReify = (0, import_react6.useCallback)(() => {
      console.log("Instance in handleReify:", instance);
      console.log("typeof instance.reify:", typeof instance.reify);
      if (typeof instance.reify === "function") {
        try {
          const result = instance.reify();
          setReifyResult(result);
        } catch (err) {
          setReifyResult("Re-ify failed: " + (err instanceof Error ? err.message : String(err)));
        }
      } else {
        setReifyResult("Re-ify not supported on this instance.");
      }
    }, [instance]);
    const formatTupleDisplay = (0, import_react6.useCallback)((tuple) => {
      if (tuple.atoms.length === 2) {
        return `${tuple.atoms[0]} \u2192 ${tuple.atoms[1]}`;
      }
      return `(${tuple.atoms.join(", ")})`;
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: `instance-builder ${className}`, children: [
      /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "instance-builder__header", children: [
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("h2", { children: "Instance Builder" }),
        /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "instance-builder__stats", children: [
          /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("span", { children: [
            atoms.length,
            " atoms"
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("span", { children: [
            relations.reduce((sum, rel) => sum + rel.tuples.length, 0),
            " relations"
          ] })
        ] })
      ] }),
      error && /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "instance-builder__error", children: [
        error,
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
          "button",
          {
            type: "button",
            onClick: () => setError(""),
            "aria-label": "Clear error",
            children: "\xD7"
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "instance-builder__content", children: [
        /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("section", { className: "instance-builder__section", children: [
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("h3", { children: "Atoms" }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("form", { onSubmit: handleAddAtom, className: "instance-builder__form", children: [
            /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "form-row", children: [
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
                "input",
                {
                  type: "text",
                  placeholder: `ID (suggested: ${suggestedId})`,
                  value: atomForm.id,
                  onChange: (e) => setAtomForm((prev) => ({ ...prev, id: e.target.value })),
                  disabled,
                  "aria-label": "Atom ID"
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
                "input",
                {
                  type: "text",
                  placeholder: "Label",
                  value: atomForm.label,
                  onChange: (e) => setAtomForm((prev) => ({ ...prev, label: e.target.value })),
                  disabled,
                  required: true
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
                "input",
                {
                  type: "text",
                  placeholder: "Type",
                  value: atomForm.type,
                  onChange: (e) => setAtomForm((prev) => ({ ...prev, type: e.target.value })),
                  disabled
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("button", { type: "submit", disabled, children: "Add Atom" })
            ] }),
            atomForm.id === "" && /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { style: { fontSize: "0.85em", color: "#888", marginTop: 2 }, children: [
              "Suggested ID: ",
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("code", { children: suggestedId })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("div", { className: "instance-builder__list", children: atoms.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("p", { className: "empty-state", children: "No atoms yet. Add one above." }) : atoms.map((atom) => /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "list-item", children: [
            /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "item-info", children: [
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("strong", { children: atom.id }),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("span", { className: "item-label", children: atom.label }),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("span", { className: "item-type", children: atom.type })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
              "button",
              {
                type: "button",
                onClick: () => handleRemoveAtom(atom.id),
                disabled,
                className: "remove-button",
                "aria-label": `Remove atom ${atom.id}`,
                children: "Remove"
              }
            )
          ] }, atom.id)) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("section", { className: "instance-builder__section", children: [
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("h3", { children: "Relations (N-ary Support)" }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("form", { onSubmit: handleAddRelation, className: "instance-builder__form", children: [
            /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("div", { className: "form-row", children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
              "input",
              {
                type: "text",
                placeholder: "Relation Name",
                value: relationForm.name,
                onChange: (e) => setRelationForm((prev) => ({ ...prev, name: e.target.value })),
                disabled,
                required: true
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "relation-atoms", children: [
              /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { style: { fontSize: "0.9em", color: "#666", marginBottom: 8 }, children: [
                "Atoms (arity: ",
                relationForm.atomIds.length,
                "):"
              ] }),
              relationForm.atomIds.map((atomId, index) => /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "atom-selector", children: [
                /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("label", { style: { fontSize: "0.85em", color: "#666" }, children: [
                  "Position ",
                  index + 1,
                  ":"
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(
                  "select",
                  {
                    value: atomId,
                    onChange: (e) => handleUpdateAtomId(index, e.target.value),
                    disabled,
                    required: true,
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("option", { value: "", children: "Select Atom" }),
                      atoms.map((atom) => /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("option", { value: atom.id, children: [
                        atom.id,
                        " (",
                        atom.label,
                        ")"
                      ] }, atom.id))
                    ]
                  }
                )
              ] }, index)),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "arity-controls", style: { marginTop: 8 }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
                  "button",
                  {
                    type: "button",
                    onClick: handleAddAtomPosition,
                    disabled,
                    style: { marginRight: 8 },
                    children: "+ Add Position"
                  }
                ),
                relationForm.atomIds.length > 2 && /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
                  "button",
                  {
                    type: "button",
                    onClick: handleRemoveAtomPosition,
                    disabled,
                    children: "- Remove Position"
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("div", { className: "form-row", style: { marginTop: 12 }, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("button", { type: "submit", disabled: disabled || relationForm.atomIds.some((id) => !id.trim()), children: "Add Relation" }) })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("div", { className: "instance-builder__list", children: relations.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("p", { className: "empty-state", children: "No relations yet. Add one above." }) : relations.map((relation) => /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "relation-group", children: [
            /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("h4", { children: relation.name }),
            relation.tuples.map((tuple, tupleIndex) => /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "list-item", children: [
              /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "item-info", children: [
                /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("span", { children: formatTupleDisplay(tuple) }),
                /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("span", { className: "item-type", style: { fontSize: "0.8em", color: "#666" }, children: [
                  "arity: ",
                  tuple.atoms.length
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
                "button",
                {
                  type: "button",
                  onClick: () => handleRemoveRelationTuple(relation.id, tuple),
                  disabled,
                  className: "remove-button",
                  "aria-label": `Remove relation ${relation.name} tuple`,
                  children: "Remove"
                }
              )
            ] }, tupleIndex))
          ] }, relation.id)) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("section", { className: "instance-builder__actions", children: [
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
            "button",
            {
              type: "button",
              onClick: handleClear,
              disabled,
              className: "clear-button",
              children: "Clear All"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
            "button",
            {
              type: "button",
              onClick: handleReify,
              disabled,
              className: "reify-button",
              style: { marginLeft: 8 },
              children: "Re-ify"
            }
          )
        ] }),
        reifyResult !== null && /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("section", { className: "instance-builder__reify-result", style: { marginTop: 12, background: "#f8f8f8", border: "1px solid #eee", borderRadius: 4, padding: 10 }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("strong", { children: "Re-ify Result:" }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("pre", { style: { whiteSpace: "pre-wrap", wordBreak: "break-all", margin: 0 }, children: typeof reifyResult === "string" ? reifyResult : JSON.stringify(reifyResult, null, 2) })
        ] })
      ] })
    ] });
  };

  // src/data-instance/alloy/alloy-instance/src/relation.ts
  function getRelationTuples(relation) {
    return relation.tuples;
  }

  // src/data-instance/alloy/alloy-instance/src/type.ts
  function getTopLevelTypeId(type2) {
    return type2.types[type2.types.length - 1];
  }
  function getTypeAtoms(type2) {
    return type2.atoms;
  }
  function isBuiltin(type2) {
    return type2.meta !== void 0 && type2.meta.builtin === true;
  }
  function typeIsOfType(instance, type2, isOfType) {
    if (typeof type2 === "string") type2 = getInstanceType(instance, type2);
    if (typeof isOfType !== "string") isOfType = isOfType.id;
    return type2.types.includes(isOfType);
  }

  // src/data-instance/alloy/alloy-instance/src/instance.ts
  function getInstanceAtom(instance, atomId) {
    const foundAtom = getInstanceAtoms(instance).find(
      (atom) => atom.id === atomId
    );
    if (!foundAtom) throw new Error(`Could not find atom with id ${atomId}`);
    return foundAtom;
  }
  function getInstanceAtoms(instance) {
    return getInstanceTypes(instance).map(getTypeAtoms).reduce((prev, curr) => prev.concat(curr), []);
  }
  function removeInstanceAtom(instance, atomId) {
    const atom = getInstanceAtom(instance, atomId);
    const newTypes = { ...instance.types };
    const newRelations = { ...instance.relations };
    const newSkolems = { ...instance.skolems };
    const type2 = newTypes[atom.type];
    if (type2) {
      type2.atoms = type2.atoms.filter((a) => a.id !== atomId);
      if (type2.atoms.length === 0) {
        delete newTypes[type2.id];
      }
      Object.values(newRelations).forEach((relation) => {
        relation.tuples = relation.tuples.filter((tuple) => !tuple.atoms.includes(atomId));
      });
      Object.values(newSkolems).forEach((skolem) => {
        skolem.tuples = skolem.tuples.filter((tuple) => !tuple.atoms.includes(atomId));
      });
      return {
        types: newTypes,
        relations: newRelations,
        skolems: newSkolems
      };
    } else {
      throw new Error(`Could not find type for atom ${atomId}`);
    }
  }
  function addInstanceAtom(instance, atom) {
    const newTypes = { ...instance.types };
    const type2 = newTypes[atom.type];
    if (!type2) {
      const newType = {
        _: "type",
        id: atom.type,
        types: [atom.type, "univ"],
        // The type hierarchy is just the atom's type for now
        atoms: [atom]
      };
      newTypes[newType.id] = newType;
    } else {
      type2.atoms.push(atom);
    }
    return {
      ...instance,
      types: newTypes
    };
  }
  function removeInstanceRelationTuple(instance, relationId, tuple) {
    const relation = getInstanceRelation(instance, relationId);
    const newRelations = { ...instance.relations };
    const newSkolems = { ...instance.skolems };
    relation.tuples = relation.tuples.filter((t) => t !== tuple);
    if (relation.tuples.length === 0) {
      delete newRelations[relation.id];
    } else {
      newRelations[relation.id] = relation;
    }
    Object.values(newSkolems).forEach((skolem) => {
      skolem.tuples = skolem.tuples.filter((t) => t !== tuple);
      if (skolem.tuples.length === 0) {
        delete newSkolems[skolem.id];
      } else {
        newSkolems[skolem.id] = skolem;
      }
    });
    return {
      ...instance,
      relations: newRelations,
      skolems: newSkolems
    };
  }
  function addInstanceRelationTuple(instance, relationId, tuple) {
    let relation = instance.relations[relationId];
    const newRelations = { ...instance.relations };
    const newSkolems = { ...instance.skolems };
    if (!relation) {
      relation = {
        id: relationId,
        name: relationId,
        tuples: [tuple],
        types: tuple.types,
        _: "relation"
      };
      newRelations[relationId] = relation;
    } else {
      relation.tuples.push(tuple);
      newRelations[relation.id] = relation;
    }
    return {
      ...instance,
      relations: newRelations,
      skolems: newSkolems
    };
  }
  function getInstanceRelation(instance, relation) {
    const rel = instance.relations[relation];
    if (!rel) throw new Error(`Could not find relation ${relation}`);
    return rel;
  }
  function getInstanceRelations(instance) {
    return Object.values(instance.relations);
  }
  function getInstanceType(instance, typeId) {
    const type2 = instance.types[typeId];
    if (!type2) throw new Error(`Could not find type with id ${typeId}`);
    return type2;
  }
  function getInstanceTypes(instance) {
    return Object.values(instance.types);
  }

  // src/data-instance/alloy/alloy-instance/src/atom.ts
  function atomIsBuiltin(instance, atom) {
    if (typeof atom === "string") atom = getInstanceAtom(instance, atom);
    const atomType = getAtomType(instance, atom);
    const atomTypeHierarchy = atomType.types;
    return atomTypeHierarchy.map((typeId) => getInstanceType(instance, typeId)).some(isBuiltin);
  }
  function getAtomType(instance, atom) {
    if (typeof atom === "string") atom = getInstanceAtom(instance, atom);
    const type2 = instance.types[atom.type];
    if (!type2)
      throw new Error(
        `The atom's type is not part of the instance: ${atom.type}`
      );
    return instance.types[atom.type];
  }

  // src/data-instance/alloy/alloy-instance/src/projection.ts
  function applyProjections(instance, atomIds) {
    const projections = {};
    atomIds.forEach((atomId) => {
      const type2 = getAtomType(instance, atomId);
      const topType = getTopLevelTypeId(type2);
      if (!projections[topType]) {
        projections[topType] = atomId;
      } else {
        throw new Error(
          `Cannot project ${atomId} and ${projections[topType]}. Both are of type ${topType}`
        );
      }
    });
    return {
      types: projectTypes(instance, projections),
      relations: projectRelations(instance, projections),
      skolems: instance.skolems
    };
  }
  function projectTypes(instance, projections) {
    const types2 = {};
    const projectedTypes = Object.keys(projections);
    for (const typeId in instance.types) {
      const type2 = instance.types[typeId];
      const isProjected = projectedTypes.some(
        (projectedType) => typeIsOfType(instance, type2, projectedType)
      );
      types2[typeId] = {
        _: "type",
        id: type2.id,
        types: type2.types,
        atoms: isProjected ? [] : type2.atoms,
        meta: type2.meta
      };
    }
    return types2;
  }
  function projectRelations(instance, projections) {
    const relations = {};
    const projectedTypes = Object.keys(projections);
    const projectedAtoms = Object.values(projections);
    for (const relationId in instance.relations) {
      const relation = instance.relations[relationId];
      const isProjected = relation.types.some(
        (relationType) => projectedTypes.some(
          (projectedType) => typeIsOfType(instance, relationType, projectedType)
        )
      );
      const projectedIndices = isProjected ? getProjectedTypeIndices(instance, relation.types, projectedTypes) : [];
      relations[relationId] = {
        _: "relation",
        id: relation.id,
        name: relation.name,
        types: isProjected ? removeIndices(relation.types, projectedIndices) : relation.types,
        tuples: isProjected ? projectTuples(relation.tuples, projectedIndices, projectedAtoms) : relation.tuples
      };
      if (isProjected) {
      } else {
        relations[relationId] = relation;
      }
    }
    return relations;
  }
  function getProjectedTypeIndices(instance, types2, projectedTypes) {
    const indices = [];
    types2.forEach((type2, index) => {
      if (projectedTypes.some(
        (projectedType) => typeIsOfType(instance, type2, projectedType)
      )) {
        indices.push(index);
      }
    });
    return indices;
  }
  function projectTuples(tuples, projectedIndices, projectedAtoms) {
    return tuples.filter(
      (tuple) => tuple.atoms.some((atom) => projectedAtoms.includes(atom))
    ).map((tuple) => {
      return {
        _: "tuple",
        types: removeIndices(tuple.types, projectedIndices),
        atoms: removeIndices(tuple.atoms, projectedIndices)
      };
    }).filter((tuple) => tuple.atoms.length > 1);
  }
  function removeIndices(array, indices) {
    const result = [];
    for (let i = 0; i < array.length; i++) {
      if (!indices.includes(i)) {
        result.push(array[i]);
      }
    }
    return result;
  }

  // src/data-instance/alloy/alloy-graph/src/ids.ts
  function generateNodeId(atom) {
    return atom.id;
  }
  function generateEdgeId(relation, tuple) {
    const relationId = relation.id;
    const atoms = tuple.atoms;
    return `${relationId}:${atoms.join("->")}`;
  }

  // src/data-instance/alloy/alloy-graph/src/generateGraph.ts
  var import_graphlib = __toESM(require_graphlib());
  function getRelationSTIndexes(_relation, arity) {
    if (arity < 2) return [0, 0];
    return [0, arity - 1];
  }
  function generateGraph(instance, hideDisconnected, hideDisconnectedBuiltins) {
    const graph = new import_graphlib.Graph({ directed: true, multigraph: true });
    const { nodeIds, edgeIds } = getVisibleGraphComponents(
      instance,
      hideDisconnected,
      hideDisconnectedBuiltins
    );
    getInstanceAtoms(instance).forEach((atom) => {
      const nodeId = generateNodeId(atom);
      if (nodeIds.has(nodeId))
        graph.setNode(nodeId, nodeId);
    });
    getInstanceRelations(instance).forEach((relation) => {
      const isAttribute = false;
      if (!isAttribute) {
        getRelationTuples(relation).forEach((tuple) => {
          const edgeId = generateEdgeId(relation, tuple);
          const atoms = tuple.atoms;
          const [sourceIndex, targetIndex] = getRelationSTIndexes(relation.id, atoms.length);
          const source = sourceIndex ? atoms[sourceIndex] : atoms[0];
          const target = targetIndex ? atoms[targetIndex] : atoms[atoms.length - 1];
          if (source && target && edgeIds.has(edgeId)) {
            let betweenTuples = atoms.slice(1, -1).join(",");
            let tupleSuffix = betweenTuples.length > 0 ? `[${betweenTuples}]` : "";
            let label = relation.name + tupleSuffix;
            let source_node_id = generateNodeId(getInstanceAtom(instance, source));
            let target_node_id = generateNodeId(getInstanceAtom(instance, target));
            graph.setEdge(source_node_id, target_node_id, label, edgeId);
          }
        });
      }
    });
    return graph;
  }
  function getVisibleGraphComponents(instance, hideDisconnected, hideDisconnectedBuiltins) {
    const nodeIds = /* @__PURE__ */ new Set();
    const edgeIds = /* @__PURE__ */ new Set();
    getInstanceRelations(instance).forEach((relation) => {
      getRelationTuples(relation).forEach((tuple) => {
        const atoms = tuple.atoms.map(
          (atomId) => getInstanceAtom(instance, atomId)
        );
        const [source, target] = resolveSourceAndTarget(relation, atoms);
        if (source && target) {
          nodeIds.add(generateNodeId(source));
          nodeIds.add(generateNodeId(target));
          edgeIds.add(generateEdgeId(relation, tuple));
        }
      });
    });
    getInstanceAtoms(instance).forEach((atom) => {
      const nodeId = generateNodeId(atom);
      if (!nodeIds.has(nodeId)) {
        if (!hideDisconnected) {
          const isBuiltin2 = atomIsBuiltin(instance, atom);
          if (!isBuiltin2 || !hideDisconnectedBuiltins) {
            nodeIds.add(nodeId);
          }
        }
      }
    });
    return {
      nodeIds,
      edgeIds
    };
  }
  function resolveSourceAndTarget(_relation, atoms) {
    const source = atoms[0];
    const target = atoms[atoms.length - 1];
    return [source, target];
  }

  // src/data-instance/alloy-data-instance.ts
  var AlloyDataInstance = class _AlloyDataInstance {
    constructor(alloyInstance) {
      this.alloyInstance = alloyInstance;
      /** Event listeners for data instance changes */
      this.eventListeners = /* @__PURE__ */ new Map();
    }
    /**
     * Add an event listener for data instance changes
     */
    addEventListener(type2, listener) {
      if (!this.eventListeners.has(type2)) {
        this.eventListeners.set(type2, /* @__PURE__ */ new Set());
      }
      this.eventListeners.get(type2).add(listener);
    }
    /**
     * Remove an event listener for data instance changes
     */
    removeEventListener(type2, listener) {
      const listeners = this.eventListeners.get(type2);
      if (listeners) {
        listeners.delete(listener);
      }
    }
    /**
     * Emit an event to all registered listeners
     */
    emitEvent(event) {
      const listeners = this.eventListeners.get(event.type);
      if (listeners) {
        listeners.forEach((listener) => {
          try {
            listener(event);
          } catch (error) {
            console.error("Error in data instance event listener:", error);
          }
        });
      }
    }
    /**
     * Get type information for a specific atom
     * 
     * @param atomId - ID of the atom
     * @returns Type information implementing IType interface
     */
    getAtomType(atomId) {
      const alloyType = getAtomType(this.alloyInstance, atomId);
      return {
        id: alloyType.id,
        types: alloyType.types,
        atoms: alloyType.atoms.map((atom) => ({
          id: atom.id,
          label: atom.id,
          // Label is the same as ID in Alloy
          type: atom.type,
          name: atom.id
          // In Alloy, atoms are identified by their ID.
        })),
        isBuiltin: isBuiltin(alloyType)
      };
    }
    /**
     * Get all types defined in this instance
     * 
     * @returns Array of all types implementing IType interface
     */
    getTypes() {
      const alloyTypes = getInstanceTypes(this.alloyInstance);
      return alloyTypes.map((alloyType) => ({
        id: alloyType.id,
        types: alloyType.types,
        atoms: alloyType.atoms.map((atom) => ({
          id: atom.id,
          type: atom.type,
          label: atom.id,
          // Label is the same as ID in Alloy
          name: atom.id
          // In Alloy, atoms are identified by their ID.
        })),
        isBuiltin: isBuiltin(alloyType)
      }));
    }
    /**
     * Get all atoms in this instance
     * 
     * @returns Array of all atoms implementing IAtom interface
     */
    getAtoms() {
      const alloyAtoms = getInstanceAtoms(this.alloyInstance);
      return alloyAtoms.map((alloyAtom) => ({
        id: alloyAtom.id,
        type: alloyAtom.type,
        label: alloyAtom.id
      }));
    }
    /**
     * Get all relations in this instance
     * 
     * @returns Array of all relations implementing IRelation interface
     */
    getRelations() {
      const alloyRelations = getInstanceRelations(this.alloyInstance);
      return alloyRelations.map((alloyRelation) => ({
        id: alloyRelation.id,
        name: alloyRelation.name,
        types: alloyRelation.types,
        tuples: alloyRelation.tuples.map((tuple) => ({
          atoms: tuple.atoms,
          types: tuple.types
        }))
      }));
    }
    /**
     * Apply projections to filter/transform the instance
     * Creates a new instance with filtered data based on provided atom IDs
     * 
     * @param atomIds - Array of atom IDs to project onto
     * @returns New filtered AlloyDataInstance
     */
    applyProjections(atomIds) {
      const projectedAlloyInstance = applyProjections(this.alloyInstance, atomIds);
      return new _AlloyDataInstance(projectedAlloyInstance);
    }
    /**
     * Generate graph representation of this instance
     * Uses the existing alloy-graph generateGraph function
     * 
     * @param hideDisconnected - Whether to hide disconnected nodes
     * @param hideDisconnectedBuiltIns - Whether to hide disconnected built-in nodes
     * @returns Graph representation using graphlib.Graph
     */
    generateGraph(hideDisconnected, hideDisconnectedBuiltIns) {
      return generateGraph(this.alloyInstance, hideDisconnected, hideDisconnectedBuiltIns);
    }
    /**
     * Get the underlying AlloyInstance for backward compatibility
     * 
     * @returns The wrapped AlloyInstance
     */
    getAlloyInstance() {
      return this.alloyInstance;
    }
    /**
     * Reify the instance to a Forge INST.
     * 
     * @returns An inst string representation of the AlloyInstance
     */
    reify() {
      let inst = "";
      const instName = "builtinstance";
      const PREFIX = `inst ${instName} {`;
      const POSTFIX = "}";
      let instanceTypes = this.alloyInstance.types;
      let typeAtoms = {};
      for (let typeId in instanceTypes) {
        let type2 = instanceTypes[typeId];
        let atoms = type2.atoms;
        typeAtoms[typeId] = atoms.map((atom) => `\`${atom.id}`);
      }
      let instanceRelations = this.alloyInstance.relations;
      let relationDecls = {};
      for (let relationId in instanceRelations) {
        let relation = instanceRelations[relationId];
        let tuples = relation.tuples;
        let tupleStrings = tuples.map((tuple) => {
          let tupleString = tuple.atoms.map((a) => `\`${a}`).join("->");
          return `(${tupleString})`;
        });
        let relName = relation.name;
        relationDecls[relName] = tupleStrings;
      }
      for (let typeId in typeAtoms) {
        let atoms = typeAtoms[typeId];
        if (atoms.length > 0) {
          inst += `${typeId} = ${atoms.join("+")}
`;
        }
      }
      for (let relationId in relationDecls) {
        let tuples = relationDecls[relationId];
        if (tuples.length > 0) {
          inst += `${relationId} = ${tuples.join("+")}
`;
        } else {
          inst += `no ${relationId}
`;
        }
      }
      return `${PREFIX}
${inst}
${POSTFIX}`;
    }
    /**
     * Remove an atom by ID
     * 
     * @param id - ID of the atom to remove
     */
    removeAtom(id) {
      this.alloyInstance = removeInstanceAtom(this.alloyInstance, id);
      this.emitEvent({
        type: "atomRemoved",
        data: { atomId: id }
      });
    }
    addAtom(atom) {
      const alloyAtom = {
        _: "atom",
        id: atom.id,
        type: atom.type
      };
      this.alloyInstance = addInstanceAtom(this.alloyInstance, alloyAtom);
      this.emitEvent({
        type: "atomAdded",
        data: { atom }
      });
    }
    addRelationTuple(relationId, tuple) {
      const alloyTuple = {
        _: "tuple",
        atoms: tuple.atoms,
        types: tuple.types
      };
      this.alloyInstance = addInstanceRelationTuple(this.alloyInstance, relationId, alloyTuple);
      this.emitEvent({
        type: "relationTupleAdded",
        data: { relationId, tuple }
      });
    }
    removeRelationTuple(relationId, t) {
      const alloyTuple = {
        _: "tuple",
        atoms: t.atoms,
        types: t.types
      };
      this.alloyInstance = removeInstanceRelationTuple(this.alloyInstance, relationId, alloyTuple);
      this.emitEvent({
        type: "relationTupleRemoved",
        data: { relationId, tuple: t }
      });
    }
    /**
     * Adds data from another AlloyDataInstance to this instance.
     * 
     * @param dataInstance - The data instance to add from.
     * @param unifyBuiltIns - Whether to unify built-in types (reuse existing ones).
     * @returns True if the operation is successful, false otherwise.
     */
    addFromDataInstance(dataInstance, unifyBuiltIns) {
      if (!isAlloyDataInstance(dataInstance)) {
        return false;
      }
      const alloyInstance = dataInstance.getAlloyInstance();
      const reIdMap = /* @__PURE__ */ new Map();
      getInstanceAtoms(alloyInstance).forEach((atom) => {
        const isBuiltin2 = this.getAtomType(atom.id).isBuiltin;
        if (unifyBuiltIns && isBuiltin2) {
          const existingAtom = this.getAtoms().find(
            (existing) => existing.type === atom.type && existing.label === atom.id
          );
          if (existingAtom) {
            reIdMap.set(atom.id, existingAtom.id);
            return;
          }
        }
        const newId = `atom_${this.getAtoms().length + 1}`;
        reIdMap.set(atom.id, newId);
        this.addAtom({
          id: newId,
          type: atom.type,
          label: atom.id
          // Use the original ID as the label
        });
      });
      getInstanceRelations(alloyInstance).forEach((relation) => {
        relation.tuples.forEach((tuple) => {
          const mappedTuple = {
            atoms: tuple.atoms.map((atomId) => reIdMap.get(atomId) || atomId),
            types: tuple.types
          };
          this.addRelationTuple(relation.id, mappedTuple);
        });
      });
      getInstanceTypes(alloyInstance).forEach((type2) => {
        const existingType = this.getTypes().find((t) => t.id === type2.id);
        if (!existingType) {
          this.alloyInstance.types[type2.id] = {
            _: "type",
            id: type2.id,
            types: type2.types,
            atoms: type2.atoms.map((atom) => ({
              _: "atom",
              id: reIdMap.get(atom.id) || atom.id,
              type: atom.type
            })),
            meta: {
              builtin: false,
              abstract: false,
              enum: false,
              one: false,
              private: false
            }
          };
        } else {
        }
      });
      return true;
    }
  };
  function isAlloyDataInstance(instance) {
    return instance instanceof AlloyDataInstance;
  }
  function createEmptyAlloyDataInstance() {
    const defaultTypes = {
      "univ": {
        _: "type",
        id: "univ",
        types: [],
        atoms: [],
        meta: {
          builtin: true,
          abstract: false,
          enum: false,
          one: false,
          private: false
        }
      },
      "Int": {
        _: "type",
        id: "Int",
        types: ["Int", "univ"],
        atoms: [],
        meta: {
          builtin: true,
          abstract: false,
          enum: false,
          one: false,
          private: false
        }
      },
      "seq/Int": {
        _: "type",
        id: "seq/Int",
        types: ["seq/Int", "univ"],
        atoms: [],
        meta: {
          builtin: true,
          abstract: false,
          enum: false,
          one: false,
          private: false
        }
      }
    };
    const emptyAlloyInstance = {
      types: defaultTypes,
      relations: {},
      skolems: {}
    };
    return new AlloyDataInstance(emptyAlloyInstance);
  }

  // src/components/ErrorMessageModal/ErrorMessageModal.tsx
  var import_react7 = __toESM(require_react());
  var import_jsx_runtime21 = __toESM(require_jsx_runtime());
  var ErrorMessageModal = ({ systemError }) => {
    const [highlightState, setHighlightState] = (0, import_react7.useState)({ ids: [], source: null });
    const handleMouseEnter = (node, source) => {
      setHighlightState({ ids: [node.id, ...node.relatedIds], source });
    };
    const handleMouseLeave = () => setHighlightState({ ids: [], source: null });
    const getHighlightClass = (nodeId) => {
      if (!highlightState.ids.includes(nodeId)) return "";
      return highlightState.source === "source" ? "highlight-source" : "highlight-diagram";
    };
    const isOtherError = systemError && (systemError.type === "parse-error" || systemError.type === "general-error" || systemError.type === "group-overlap-error");
    const isPositionalError = systemError && systemError.type === "positional-error" && systemError.messages;
    if (!isOtherError && !isPositionalError) {
      console.error("Cannot display the following error:", systemError);
      return null;
    }
    const errorHeader = (0, import_react7.useMemo)(() => {
      const errorType = systemError.type;
      if (errorType === "parse-error") {
        return `Parse Error ${systemError.source ? `(${systemError.source})` : ""}`;
      } else if (errorType === "group-overlap-error") {
        return `Group Overlap Error ${systemError.source ? `(${systemError.source})` : ""}`;
      } else {
        return "Error";
      }
    }, [systemError]);
    const constraintData = (0, import_react7.useMemo)(() => {
      const messages = isPositionalError ? systemError.messages : void 0;
      if (!messages) return { sourceConstraints: [], diagramConstraints: [] };
      function buildConstraintsMap(messages2) {
        const copy = /* @__PURE__ */ new Map();
        messages2.minimalConflictingConstraints.forEach((value, key) => {
          if (!copy.has(key)) {
            copy.set(key, /* @__PURE__ */ new Set());
          }
          value.forEach((val) => copy.get(key).add(val));
        });
        if (!copy.has(messages2.conflictingSourceConstraint)) {
          copy.set(messages2.conflictingSourceConstraint, /* @__PURE__ */ new Set([messages2.conflictingConstraint]));
        } else {
          copy.get(messages2.conflictingSourceConstraint).add(messages2.conflictingConstraint);
        }
        return copy;
      }
      const constraintsMap = buildConstraintsMap(messages);
      const sourceConstraints2 = [];
      const diagramConstraints2 = [];
      const diagramMap = /* @__PURE__ */ new Map();
      [...constraintsMap.values()].forEach((constraints, groupIdx) => {
        [...constraints.values()].map((content, idx) => {
          const id = `diagram-${groupIdx}-${idx}`;
          diagramMap.set(content, id);
          diagramConstraints2.push({ id, content, relatedIds: [] });
        });
      });
      [...constraintsMap.entries()].forEach(([sourceContent, relatedContents], idx) => {
        const id = `source-${idx}`;
        const relatedIds = [...relatedContents.values()].map((content) => diagramMap.get(content));
        sourceConstraints2.push({ id, content: sourceContent, relatedIds });
        relatedIds.forEach((relatedId) => {
          const diagNode = diagramConstraints2.find((d) => d.id === relatedId);
          if (diagNode) diagNode.relatedIds.push(id);
        });
      });
      return { sourceConstraints: sourceConstraints2, diagramConstraints: diagramConstraints2 };
    }, [systemError]);
    const { sourceConstraints, diagramConstraints } = constraintData;
    return /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("div", { id: "error-message-modal", className: "mt-3 d-flex flex-column overflow-x-auto p-3 rounded border border-danger border-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("h4", { style: { color: "var(--bs-danger)" }, children: "Could not produce a diagram" }),
      /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("p", { children: "Your data cannot be visualized due to the following conflicting constraints." }),
      isOtherError && /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(import_jsx_runtime21.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("div", { className: "card error-card", children: [
        /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("div", { className: "card-header bg-light", children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("strong", { children: errorHeader }) }),
        /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("div", { className: "card-body", children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("code", { dangerouslySetInnerHTML: { __html: systemError.message } }) })
      ] }) }),
      isPositionalError && /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)(import_jsx_runtime21.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("p", { id: "hover-instructions", children: "Hover over the conflicting constraints to see the corresponding diagram elements that cannot be visualized. " }),
        /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("div", { className: "constraint-relationship-table", children: /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("table", { className: "table table-bordered", children: [
          /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("thead", { children: /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("tr", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("th", { children: "Source Constraints" }),
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("th", { children: "Diagram Elements" })
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("tbody", { children: /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("tr", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("td", { className: "source-constraints-cell p-0", children: sourceConstraints.map((node) => /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
              "div",
              {
                "data-constraint-id": node.id,
                className: `constraint-item ${getHighlightClass(node.id)}`,
                onMouseEnter: () => handleMouseEnter(node, "source"),
                onMouseLeave: handleMouseLeave,
                children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("code", { dangerouslySetInnerHTML: { __html: node.content } })
              },
              node.id
            )) }),
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("td", { className: "diagram-constraints-cell p-0", children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("div", { className: "d-flex flex-column h-100", children: diagramConstraints.map((node) => /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
              "div",
              {
                "data-constraint-id": node.id,
                className: `constraint-item ${getHighlightClass(node.id)}`,
                onMouseEnter: () => handleMouseEnter(node, "diagram"),
                onMouseLeave: handleMouseLeave,
                children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("code", { dangerouslySetInnerHTML: { __html: node.content } })
              },
              node.id
            )) }) })
          ] }) })
        ] }) })
      ] })
    ] });
  };

  // src/components/ErrorMessageModal/ErrorMessageContainer.tsx
  var import_react8 = __toESM(require_react());
  var import_jsx_runtime22 = __toESM(require_jsx_runtime());
  var ErrorMessageContainer = ({
    errorManager,
    className = ""
  }) => {
    const [currentError, setCurrentError] = (0, import_react8.useState)(
      errorManager.getCurrentError()
    );
    (0, import_react8.useEffect)(() => {
      errorManager.onErrorChange(setCurrentError);
    }, [errorManager]);
    if (!currentError) {
      return null;
    }
    const containerClassName = `error-message-container ${className}`.trim();
    return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { className: containerClassName, children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
      ErrorMessageModal,
      {
        systemError: currentError
      }
    ) });
  };

  // src/components/ErrorMessageModal/ErrorStateManager.ts
  var ErrorStateManager = class {
    constructor() {
      this.currentError = null;
      this.errorCallbacks = [];
    }
    /**
     * Set the current error state
     * @param error - The error to set, or null to clear
     */
    setError(error) {
      this.currentError = error;
      this.notifyCallbacks();
    }
    /**
     * Clear the current error state
     */
    clearError() {
      this.currentError = null;
      this.notifyCallbacks();
    }
    /**
     * Get the current error state
     * @returns Current error or null if no error
     */
    getCurrentError() {
      return this.currentError;
    }
    /**
     * Subscribe to error state changes
     * @param callback - Function to call when error state changes
     */
    onErrorChange(callback) {
      this.errorCallbacks.push(callback);
    }
    /**
     * Check if there's currently an error
     * @returns True if there's an active error
     */
    hasError() {
      return this.currentError !== null;
    }
    /**
     * Notify all subscribed callbacks of error state change
     */
    notifyCallbacks() {
      this.errorCallbacks.forEach((callback) => callback(this.currentError));
    }
  };

  // src/components/ReplInterface/PyretReplInterface.tsx
  var import_react10 = __toESM(require_react());

  // src/components/ReplInterface/ReplInterface.tsx
  var import_react9 = __toESM(require_react());

  // src/components/ReplInterface/parsers/CoreParsers.ts
  var RemoveCommandParser = class {
    canHandle(command) {
      const trimmed = command.trim();
      return trimmed.startsWith("remove ") && trimmed.length > 7;
    }
    getPriority() {
      return 200;
    }
    getCommandPatterns() {
      return [
        "remove ID",
        "remove Label:Type",
        "remove source.relation=target",
        "remove relation",
        "remove Atom.REL",
        "remove edge_id"
      ];
    }
    execute(command, instance) {
      const trimmed = command.trim();
      const args = trimmed.substring(7);
      try {
        if (args.includes(".") && args.includes("=")) {
          return this.handleRemoveRelationTuple(args, instance);
        }
        if (args.includes(".") && !args.includes("=")) {
          return this.handleRemoveAtomRelation(args, instance);
        }
        if (args.includes(":") && !args.includes("->")) {
          return this.handleRemoveAtomByLabelType(args, instance);
        }
        if (this.looksLikeEdgeId(args, instance)) {
          return this.handleRemoveEdgeById(args, instance);
        }
        if (/^[^\s:->().]+$/.test(args)) {
          const atoms = instance.getAtoms();
          const atomToRemove = atoms.find((a) => a.id === args);
          if (atomToRemove) {
            return this.handleRemoveAtomById(args, instance);
          } else {
            const relations = instance.getRelations();
            const relationToRemove = relations.find((r) => r.name === args);
            if (relationToRemove) {
              return this.handleRemoveRelation(args, instance);
            } else {
              return {
                success: false,
                message: `Atom or relation not found: ${args}`
              };
            }
          }
        }
        return {
          success: false,
          message: `Invalid remove syntax: ${args}`
        };
      } catch (error) {
        return {
          success: false,
          message: error instanceof Error ? error.message : "Failed to remove"
        };
      }
    }
    handleRemoveAtomById(id, instance) {
      const atoms = instance.getAtoms();
      const atomToRemove = atoms.find((a) => a.id === id);
      if (!atomToRemove) {
        return {
          success: false,
          message: `Atom not found with ID: ${id}`
        };
      }
      instance.removeAtom(atomToRemove.id);
      return {
        success: true,
        message: `[${atomToRemove.id}] Removed atom: ${atomToRemove.label}:${atomToRemove.type}`,
        action: "remove"
      };
    }
    handleRemoveAtomByLabelType(args, instance) {
      const [label, type2] = args.split(":");
      const atoms = instance.getAtoms();
      const atomToRemove = atoms.find((a) => a.label === label.trim() && a.type === type2.trim());
      if (!atomToRemove) {
        return {
          success: false,
          message: `Atom not found: ${args}`
        };
      }
      instance.removeAtom(atomToRemove.id);
      return {
        success: true,
        message: `[${atomToRemove.id}] Removed atom: ${atomToRemove.label}:${atomToRemove.type}`,
        action: "remove"
      };
    }
    handleRemoveRelationTuple(args, instance) {
      const match = args.match(/^([^.]+)\.([^=]+)=(.+)$/);
      if (!match) {
        return {
          success: false,
          message: `Invalid relation format: ${args}`
        };
      }
      const sourceId = match[1].trim();
      const relationName = match[2].trim();
      const targetId = match[3].trim();
      const relation = instance.getRelations().find((r) => r.name === relationName);
      if (!relation) {
        return {
          success: false,
          message: `Relation '${relationName}' not found`
        };
      }
      const tuple = relation.tuples.find(
        (t) => t.atoms.length === 2 && t.atoms[0] === sourceId && t.atoms[1] === targetId
      );
      if (!tuple) {
        return {
          success: false,
          message: `Tuple not found: ${sourceId}.${relationName}=${targetId}`
        };
      }
      instance.removeRelationTuple(relationName, tuple);
      return {
        success: true,
        message: `[${sourceId}.${relationName}=${targetId}] Removed tuple: ${relationName}(${sourceId}, ${targetId})`,
        action: "remove"
      };
    }
    handleRemoveRelation(relationName, instance) {
      const relation = instance.getRelations().find((r) => r.name === relationName);
      if (!relation) {
        return {
          success: false,
          message: `Relation '${relationName}' not found`
        };
      }
      const tupleCount = relation.tuples.length;
      relation.tuples.slice().forEach((tuple) => {
        instance.removeRelationTuple(relationName, tuple);
      });
      return {
        success: true,
        message: `[${relationName}] Removed relation '${relationName}' (${tupleCount} tuples)`,
        action: "remove"
      };
    }
    handleRemoveAtomRelation(args, instance) {
      const match = args.match(/^([^.]+)\.([^.]+)$/);
      if (!match) {
        return {
          success: false,
          message: `Invalid atom.relation syntax: ${args}`
        };
      }
      const [, atomId, relationName] = match;
      const atom = instance.getAtoms().find((a) => a.id === atomId);
      if (!atom) {
        return {
          success: false,
          message: `Atom '${atomId}' not found`
        };
      }
      const relation = instance.getRelations().find((r) => r.name === relationName);
      if (!relation) {
        return {
          success: false,
          message: `Relation '${relationName}' not found`
        };
      }
      const originalTupleCount = relation.tuples.length;
      const tuplesToRemove = relation.tuples.filter((tuple) => tuple.atoms[0] === atomId);
      if (tuplesToRemove.length === 0) {
        return {
          success: false,
          message: `No ${relationName} relations found for atom '${atomId}'`
        };
      }
      tuplesToRemove.forEach((tuple) => {
        instance.removeRelationTuple(relationName, tuple);
      });
      return {
        success: true,
        message: `[${atomId}.${relationName}] Removed ${tuplesToRemove.length} ${relationName} relations from '${atomId}'`,
        action: "remove"
      };
    }
    looksLikeEdgeId(args, instance) {
      return args.includes(":") && args.includes("->");
    }
    handleRemoveEdgeById(edgeId, instance) {
      const colonIndex = edgeId.indexOf(":");
      if (colonIndex === -1) {
        return {
          success: false,
          message: `Invalid edge ID format: ${edgeId}. Expected format: relationName:atom1->atom2`
        };
      }
      const relationName = edgeId.substring(0, colonIndex);
      const atomChain = edgeId.substring(colonIndex + 1);
      const atoms = atomChain.split("->");
      const relation = instance.getRelations().find((r) => r.name === relationName);
      if (!relation) {
        return {
          success: false,
          message: `Relation '${relationName}' not found`
        };
      }
      const targetTuple = relation.tuples.find(
        (tuple) => tuple.atoms.length === atoms.length && tuple.atoms.every((atomId, index) => atomId === atoms[index])
      );
      if (!targetTuple) {
        return {
          success: false,
          message: `Edge '${edgeId}' not found`
        };
      }
      instance.removeRelationTuple(relationName, targetTuple);
      return {
        success: true,
        message: `[${edgeId}] Removed edge: ${relationName}(${atoms.join(", ")})`,
        action: "remove"
      };
    }
    getHelp() {
      return [
        "Remove Commands (sugar syntax):",
        "  remove ID                           - Remove atom by ID",
        "  remove Label:Type                   - Remove atom by label and type",
        "  remove source.relation=target       - Remove specific relation tuple",
        "  remove Atom.REL                     - Remove all REL relations from Atom",
        "  remove edge_id                      - Remove specific edge by ID",
        "  remove relation                     - Remove entire relation",
        "",
        "Examples:",
        '  remove alice                        - Remove atom with ID "alice"',
        "  remove Alice:Person                 - Remove Alice:Person atom",
        "  remove alice.friend=bob             - Remove friend(alice, bob) tuple",
        "  remove alice.friend                 - Remove all friend relations from alice",
        "  remove friend:alice->bob            - Remove edge by ID",
        "  remove friend                       - Remove entire friend relation"
      ];
    }
  };
  var AtomCommandParser = class {
    canHandle(command) {
      const trimmed = command.trim();
      if (trimmed.startsWith("remove ")) {
        return false;
      }
      if (trimmed.startsWith("add ")) {
        return false;
      }
      const utilityCommands = ["help", "info", "status", "list", "clear", "reify"];
      if (utilityCommands.includes(trimmed.toLowerCase())) {
        return false;
      }
      if (trimmed.startsWith("[list:")) {
        return false;
      }
      if (trimmed.includes(".") && trimmed.includes("=")) {
        return false;
      }
      if (trimmed.includes("(") && trimmed.includes(")")) {
        return false;
      }
      if (/^[^:]+:.+$/.test(trimmed) && !trimmed.includes("->")) {
        return true;
      }
      if (/^[^=]+=.+:.+$/.test(trimmed) && !trimmed.includes("->")) {
        return true;
      }
      return false;
    }
    getPriority() {
      return 100;
    }
    getCommandPatterns() {
      return [
        "Label:Type",
        "id=Label:Type"
      ];
    }
    execute(command, instance) {
      const trimmed = command.trim();
      return this.handleAdd(trimmed, instance);
    }
    handleAdd(args, instance) {
      try {
        const match = args.match(/^(?:([^=]+)=)?([^:]+):(.+)$/);
        if (!match) {
          return {
            success: false,
            message: "Invalid syntax. Use: add Label:Type or add id=Label:Type"
          };
        }
        const [, explicitId, label, type2] = match;
        const atomLabel = label.trim();
        const atomType = type2.trim();
        if (!atomLabel || !atomType) {
          return {
            success: false,
            message: "Label and type cannot be empty"
          };
        }
        let atomId = explicitId?.trim() || this.generateAtomId(atomLabel, instance);
        const atom = {
          id: atomId,
          label: atomLabel,
          type: atomType
        };
        instance.addAtom(atom);
        let message;
        if (explicitId?.trim()) {
          message = `[${atomId}] Added atom: ${atomLabel}:${atomType}`;
        } else {
          message = `[${atomId}] Added atom: ${atomLabel}:${atomType}`;
        }
        return {
          success: true,
          message,
          action: "add"
        };
      } catch (error) {
        return {
          success: false,
          message: error instanceof Error ? error.message : "Failed to add atom"
        };
      }
    }
    generateAtomId(candidateId, instance) {
      const existingIds = new Set(instance.getAtoms().map((a) => a.id));
      if (!existingIds.has(candidateId)) {
        return candidateId;
      }
      let counter = 1;
      let uniqueId = `${candidateId}$${counter}`;
      while (existingIds.has(uniqueId)) {
        counter++;
        uniqueId = `${candidateId}$${counter}`;
      }
      return uniqueId;
    }
    getHelp() {
      return [
        "Atom Commands (sugar syntax):",
        "  Label:Type                   - Add atom with generated ID",
        "  id=Label:Type                - Add atom with explicit ID",
        "",
        "Examples:",
        "  Alice:Person                 - Creates [Alice] Alice:Person",
        "  p1=Alice:Person              - Creates [p1] Alice:Person",
        "",
        "Note: IDs are shown in [brackets] for easy referencing",
        "All syntax is sugar that gets desugared to internal operations"
      ];
    }
  };
  var BatchCommandParser = class {
    constructor() {
      this.atomParser = new AtomCommandParser();
      this.dotRelationParser = new DotNotationRelationParser();
    }
    canHandle(command) {
      const trimmed = command.trim();
      if (this.isCommaSeperatedAtoms(trimmed)) {
        return true;
      }
      if (trimmed.includes(";")) {
        const subCommands = trimmed.split(";").map((cmd) => cmd.trim()).filter((cmd) => cmd);
        return subCommands.length >= 2 && subCommands.some(
          (cmd) => this.atomParser.canHandle(cmd) || this.dotRelationParser.canHandle(cmd)
        );
      }
      return false;
    }
    isCommaSeperatedAtoms(command) {
      return false;
    }
    getPriority() {
      return 115;
    }
    getCommandPatterns() {
      return [
        "Alice:Person; bob=Bob:Person; alice.friend=bob"
      ];
    }
    execute(command, instance) {
      const trimmed = command.trim();
      try {
        if (trimmed.includes(";")) {
          return this.handleSemicolonSeperatedCommands(trimmed, instance);
        }
        return {
          success: false,
          message: "Unable to parse batch command"
        };
      } catch (error) {
        return {
          success: false,
          message: error instanceof Error ? error.message : "Failed to execute batch command"
        };
      }
    }
    handleSemicolonSeperatedCommands(command, instance) {
      const subCommands = command.split(";").map((cmd) => cmd.trim()).filter((cmd) => cmd);
      const results = [];
      const errors = [];
      let successCount = 0;
      let addCount = 0;
      let removeCount = 0;
      for (const subCommand of subCommands) {
        try {
          let result = null;
          if (this.atomParser.canHandle(subCommand)) {
            result = this.atomParser.execute(subCommand, instance);
          } else if (this.dotRelationParser.canHandle(subCommand)) {
            result = this.dotRelationParser.execute(subCommand, instance);
          }
          if (result) {
            if (result.success) {
              results.push(result.message);
              successCount++;
              if (result.action === "add") addCount++;
              if (result.action === "remove") removeCount++;
            } else {
              errors.push(`"${subCommand}": ${result.message}`);
            }
          } else {
            errors.push(`"${subCommand}": No parser can handle this command`);
          }
        } catch (error) {
          errors.push(`"${subCommand}": ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      const actionSummary = [];
      if (addCount > 0) actionSummary.push(`${addCount} added`);
      if (removeCount > 0) actionSummary.push(`${removeCount} removed`);
      if (successCount === subCommands.length) {
        return {
          success: true,
          message: `Batch command completed (${actionSummary.join(", ")}):
${results.join("\n")}`,
          action: addCount > 0 ? "add" : removeCount > 0 ? "remove" : "info"
        };
      } else if (successCount > 0) {
        return {
          success: true,
          message: `Batch command partially completed (${successCount}/${subCommands.length} commands):

Successful:
${results.join("\n")}

Errors:
${errors.join("\n")}`,
          action: addCount > 0 ? "add" : removeCount > 0 ? "remove" : "info"
        };
      } else {
        return {
          success: false,
          message: `Batch command failed:
${errors.join("\n")}`
        };
      }
    }
    getHelp() {
      return [
        "Batch Commands (sugar syntax):",
        "  command1; command2; command3               - Execute multiple sugar commands",
        "",
        "Examples:",
        "  Alice:Person; bob=Bob:Person; alice.friend=bob",
        "  1:Number; 2:Number; 3:Number",
        "",
        "Note: Semicolon-separated commands support any mix of atom/relation sugar syntax"
      ];
    }
  };
  var DotNotationRelationParser = class {
    canHandle(command) {
      const trimmed = command.trim();
      if (trimmed.startsWith("remove ")) {
        return false;
      }
      if (trimmed.startsWith("add ")) {
        return false;
      }
      if (trimmed.includes(".") && trimmed.includes("=")) {
        return /^[^.]+\.[^=]+=.+$/.test(trimmed);
      }
      return false;
    }
    getPriority() {
      return 115;
    }
    getCommandPatterns() {
      return [
        "source.relation=target"
      ];
    }
    execute(command, instance) {
      const trimmed = command.trim();
      return this.handleAdd(trimmed, instance);
    }
    handleAdd(args, instance) {
      try {
        const match = args.match(/^([^.]+)\.([^=]+)=(.+)$/);
        if (!match) {
          return {
            success: false,
            message: "Invalid syntax. Use: source.relation=target"
          };
        }
        const sourceId = match[1].trim();
        const relationName = match[2].trim();
        const targetId = match[3].trim();
        if (!sourceId || !relationName || !targetId) {
          return {
            success: false,
            message: "Source, relation, and target cannot be empty"
          };
        }
        const existingAtoms = instance.getAtoms();
        const existingAtomIds = new Set(existingAtoms.map((a) => a.id));
        if (!existingAtomIds.has(sourceId)) {
          return {
            success: false,
            message: `Source atom '${sourceId}' does not exist`
          };
        }
        if (!existingAtomIds.has(targetId)) {
          return {
            success: false,
            message: `Target atom '${targetId}' does not exist`
          };
        }
        const sourceAtom = existingAtoms.find((a) => a.id === sourceId);
        const targetAtom = existingAtoms.find((a) => a.id === targetId);
        const tuple = {
          atoms: [sourceId, targetId],
          types: [sourceAtom.type, targetAtom.type]
        };
        instance.addRelationTuple(relationName, tuple);
        return {
          success: true,
          message: `[${sourceId}.${relationName}=${targetId}] Added relation: ${relationName}(${sourceId}, ${targetId})`,
          action: "add"
        };
      } catch (error) {
        return {
          success: false,
          message: error instanceof Error ? error.message : "Failed to add relation"
        };
      }
    }
    getHelp() {
      return [
        "Dot Notation Relation Commands (sugar syntax):",
        "  source.relation=target              - Add binary relation",
        "",
        "Examples:",
        "  alice.friend=bob                    - Creates friend(alice, bob)",
        "  alice.knows=charlie                 - Creates knows(alice, charlie)",
        "",
        "Note: Atoms must exist before creating relations",
        "All syntax is sugar that gets desugared to internal operations"
      ];
    }
  };

  // src/data-instance/pyret/pyret-data-instance.ts
  var import_graphlib2 = __toESM(require_graphlib());
  function generateEdgeId2(relation, tuple) {
    const relationId = relation.id;
    const atoms = tuple.atoms;
    return `${relationId}:${atoms.join("->")}`;
  }
  var _PyretDataInstance = class _PyretDataInstance {
    /*
      TODO: List handling
      - Handle Pyret Lists and Tables as special cases. They currently show as (link (link (link (link )))) etc.
    */
    /**
     * Creates a PyretDataInstance from a Pyret runtime object
     * 
     * @param pyretData - The root Pyret object to parse, or null/undefined for an empty instance
     * @param options - Configuration options for primitive handling and other behaviors
     * @param externalEvaluator - Optional external Pyret evaluator for enhanced features
     */
    constructor(pyretData, options = {}, externalEvaluator) {
      this.atoms = /* @__PURE__ */ new Map();
      this.relations = /* @__PURE__ */ new Map();
      this.types = /* @__PURE__ */ new Map();
      this.objectToAtomId = /* @__PURE__ */ new WeakMap();
      this.atomCounter = 0;
      /** Map to keep track of label counts per type */
      this.typeLabelCounters = /* @__PURE__ */ new Map();
      /** Map to store the original Pyret objects with their dict key order */
      this.originalObjects = /* @__PURE__ */ new Map();
      /** Event listeners for data instance changes */
      this.eventListeners = /* @__PURE__ */ new Map();
      /** Optional external Pyret evaluator for enhanced features */
      this.externalEvaluator = null;
      this.options = {
        stringsIdempotent: options.stringsIdempotent ?? true,
        numbersIdempotent: options.numbersIdempotent ?? true,
        booleansIdempotent: options.booleansIdempotent ?? true,
        showFunctions: options.showFunctions ?? false
      };
      this.externalEvaluator = externalEvaluator || null;
      this.initializeBuiltinTypes();
      if (pyretData) {
        this.parseObjectIteratively(pyretData);
      }
    }
    /**
     * Set an external Pyret evaluator for enhanced features
     * @param evaluator - External Pyret evaluator (e.g., window.__internalRepl)
     */
    setExternalEvaluator(evaluator) {
      this.externalEvaluator = evaluator;
    }
    /**
     * Get the current external evaluator
     */
    getExternalEvaluator() {
      return this.externalEvaluator;
    }
    /**
     * Get the current primitive idempotency configuration
     */
    getOptions() {
      return { ...this.options };
    }
    /**
     * Cache constructor field order for a type when we successfully parse an original object
     * This now uses a global cache with instantiation-based priority where newer patterns
     * can override older ones for the same constructor name
     */
    cacheConstructorPattern(typeName, fieldOrder) {
      if (fieldOrder.length === 0) return;
      const currentEntry = _PyretDataInstance.globalConstructorCache.get(typeName);
      const newInstantiation = ++_PyretDataInstance.instantiationCounter;
      if (!currentEntry || newInstantiation > currentEntry.instantiation) {
        _PyretDataInstance.globalConstructorCache.set(typeName, {
          pattern: [...fieldOrder],
          instantiation: newInstantiation
        });
      }
    }
    /**
     * Get cached constructor pattern for a type from the global cache
     */
    getCachedConstructorPattern(typeName) {
      const entry = _PyretDataInstance.globalConstructorCache.get(typeName);
      return entry ? entry.pattern : null;
    }
    /**
     * Get the global constructor cache (for debugging or advanced use cases)
     * Returns a map of type names to their patterns
     */
    static getGlobalConstructorCache() {
      const result = /* @__PURE__ */ new Map();
      for (const [typeName, entry] of _PyretDataInstance.globalConstructorCache) {
        result.set(typeName, [...entry.pattern]);
      }
      return result;
    }
    /**
     * Get the global constructor cache with instantiation info (for debugging)
     * Returns the raw cache with instantiation numbers
     */
    static getGlobalConstructorCacheWithPriority() {
      return new Map(_PyretDataInstance.globalConstructorCache);
    }
    /**
     * Clear the global constructor cache (for testing or reset scenarios)
     */
    static clearGlobalConstructorCache() {
      _PyretDataInstance.globalConstructorCache.clear();
    }
    /**
     * Creates a PyretDataInstance from a Pyret expression.
     * 
     * @param expr - The Pyret expression to evaluate.
     * @param options - Configuration options for primitive handling and other behaviors
     * @param externalEvaluator - External Pyret evaluator with a `run` method for enhanced features.
     * @returns A new PyretDataInstance created from the evaluated expression.
     * @throws {Error} If the expression cannot be evaluated or parsed.
     */
    static async fromExpression(expr, options = {}, externalEvaluator) {
      const evaluationResult = await _PyretDataInstance.evaluateExpression(expr, externalEvaluator);
      if (!evaluationResult.success) {
        throw new Error(`Failed to evaluate Pyret expression: ${_PyretDataInstance.formatError(evaluationResult.exn)}`);
      }
      if (_PyretDataInstance.isPrimitive(evaluationResult.result)) {
        const instance = new _PyretDataInstance(null, options, externalEvaluator);
        const atomType = typeof evaluationResult.result === "string" ? "String" : typeof evaluationResult.result === "number" ? "Number" : "Boolean";
        const primitiveAtom = {
          id: `result_${evaluationResult.result}`,
          label: String(evaluationResult.result),
          type: atomType
        };
        instance.addAtom(primitiveAtom);
        return instance;
      }
      return new _PyretDataInstance(evaluationResult.result, options, externalEvaluator);
    }
    /**
     * Evaluates a Pyret expression using an external evaluator
     * 
     * @param expr - The Pyret expression to evaluate
     * @param externalEvaluator - External Pyret evaluator with a `run` method
     * @returns Promise resolving to evaluation result
     */
    static async evaluateExpression(expr, externalEvaluator) {
      try {
        const result = await externalEvaluator.run(expr);
        const exnValue = _PyretDataInstance.findKeyAtAnyLevel(result, "exn");
        if (exnValue !== void 0) {
          return {
            success: false,
            exn: exnValue
          };
        }
        const answerValue = _PyretDataInstance.findKeyAtAnyLevel(result, "answer");
        if (answerValue !== void 0) {
          return {
            success: true,
            result: answerValue
          };
        }
        if (_PyretDataInstance.isPrimitive(result)) {
          return {
            success: true,
            result
          };
        }
        return {
          success: false,
          exn: "Unable to find answer or exn in evaluation result"
        };
      } catch (error) {
        return {
          success: false,
          exn: error instanceof Error ? error.message : "Unknown evaluation error"
        };
      }
    }
    /**
     * Recursively searches for a key at any level in an object
     */
    static findKeyAtAnyLevel(obj, keyName) {
      if (!obj || typeof obj !== "object") {
        return void 0;
      }
      if (keyName in obj) {
        return obj[keyName];
      }
      for (const value of Object.values(obj)) {
        if (value && typeof value === "object") {
          const found = _PyretDataInstance.findKeyAtAnyLevel(value, keyName);
          if (found !== void 0) {
            return found;
          }
        }
      }
      return void 0;
    }
    /**
     * Checks if a value is a primitive type (string, number, boolean)
     */
    static isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
    }
    /**
     * Format Pyret evaluation errors for display
     */
    static formatError(error) {
      if (!error) {
        return "Unknown error";
      }
      if (typeof error === "string") {
        return error;
      }
      if (typeof error === "object" && error !== null) {
        const errorObj = error;
        if (errorObj.message) {
          return errorObj.message;
        }
        if (errorObj.toString && typeof errorObj.toString === "function") {
          return errorObj.toString();
        }
      }
      return String(error);
    }
    /**
     * Try to rebuild constructor arguments from relations using cached patterns
     * Only uses patterns from previously seen constructor instances - no heuristics
     */
    tryReconstructFromRelations(atom, visited) {
      const relationMap = /* @__PURE__ */ new Map();
      this.relations.forEach((relation) => {
        relation.tuples.forEach((tuple) => {
          if (tuple.atoms.length >= 2 && tuple.atoms[0] === atom.id) {
            const relationName = relation.name;
            if (!relationMap.has(relationName)) {
              relationMap.set(relationName, []);
            }
            relationMap.get(relationName).push(...tuple.atoms.slice(1));
          }
        });
      });
      if (relationMap.size === 0) {
        return atom.type;
      }
      const cachedPattern = this.getCachedConstructorPattern(atom.type);
      if (cachedPattern) {
        const args2 = [];
        for (const fieldName of cachedPattern) {
          const targetIds = relationMap.get(fieldName) || [];
          for (const targetId of targetIds) {
            args2.push(this.reifyAtom(targetId, visited));
          }
        }
        if (args2.length > 0) {
          return `${atom.type}(${args2.join(", ")})`;
        }
      }
      const sameTypeAtoms = Array.from(this.atoms.values()).filter((a) => a.type === atom.type);
      for (const sameTypeAtom of sameTypeAtoms) {
        const originalObj = this.originalObjects.get(sameTypeAtom.id);
        if (originalObj && originalObj.dict) {
          const orderedKeys = Object.keys(originalObj.dict);
          this.cacheConstructorPattern(atom.type, orderedKeys);
          const args2 = [];
          for (const fieldName of orderedKeys) {
            const targetIds = relationMap.get(fieldName) || [];
            for (const targetId of targetIds) {
              args2.push(this.reifyAtom(targetId, visited));
            }
          }
          if (args2.length > 0) {
            return `${atom.type}(${args2.join(", ")})`;
          }
          break;
        }
      }
      console.error(`[PyretDataInstance] Could not determine constructor pattern for type '${atom.type}'. Falling back to sorted field order.`);
      const relationNames = Array.from(relationMap.keys()).sort();
      const args = [];
      for (const relationName of relationNames) {
        const targetIds = relationMap.get(relationName) || [];
        for (const targetId of targetIds) {
          args.push(this.reifyAtom(targetId, visited));
        }
      }
      if (args.length > 0) {
        return `${atom.type}(${args.join(", ")})`;
      }
      return atom.type;
    }
    hasExternalEvaluator() {
      return this.externalEvaluator !== null;
    }
    addEventListener(type2, listener) {
      if (!this.eventListeners.has(type2)) {
        this.eventListeners.set(type2, /* @__PURE__ */ new Set());
      }
      this.eventListeners.get(type2).add(listener);
    }
    /**
     * Remove an event listener for data instance changes
     */
    removeEventListener(type2, listener) {
      const listeners = this.eventListeners.get(type2);
      if (listeners) {
        listeners.delete(listener);
      }
    }
    /**
     * Emit an event to all registered listeners
     */
    emitEvent(event) {
      const listeners = this.eventListeners.get(event.type);
      if (listeners) {
        listeners.forEach((listener) => {
          try {
            listener(event);
          } catch (error) {
            console.error("Error in data instance event listener:", error);
          }
        });
      }
    }
    /**
     * Adds an atom to the instance, updating types accordingly.
     * If the atom already exists, it is replaced.
     * @param atom - The atom to add
     */
    addAtom(atom) {
      this.atoms.set(atom.id, atom);
      this.ensureTypeExists(atom.type);
      const type2 = this.types.get(atom.type);
      if (type2 && !type2.atoms.some((a) => a.id === atom.id)) {
        type2.atoms.push(atom);
      }
      this.emitEvent({
        type: "atomAdded",
        data: { atom }
      });
    }
    /**
     * Removes an atom by id, and removes it from all types and relations.
     * @param id - The atom id to remove
     */
    removeAtom(id) {
      const removedAtom = this.atoms.get(id);
      this.atoms.delete(id);
      this.types.forEach((type2) => {
        type2.atoms = type2.atoms.filter((atom) => atom.id !== id);
      });
      this.relations.forEach((relation) => {
        relation.tuples = relation.tuples.filter((tuple) => !tuple.atoms.includes(id));
      });
      if (removedAtom) {
        this.emitEvent({
          type: "atomRemoved",
          data: { atomId: id }
        });
      }
    }
    removeRelationTuple(relationId, t) {
      const relation = this.relations.get(relationId);
      if (relation) {
        const oldLength = relation.tuples.length;
        relation.tuples = relation.tuples.filter(
          (tuple) => !tuple.atoms.every((atomId, index) => atomId === t.atoms[index])
        );
        if (relation.tuples.length < oldLength) {
          this.emitEvent({
            type: "relationTupleRemoved",
            data: { relationId, tuple: t }
          });
        }
      }
    }
    /**
     * Converts the current data instance back to Pyret constructor notation
     * 
     * If an external evaluator is available, it may provide enhanced type information
     * for more accurate reification in the future.
     * 
     * @returns A string representation of the data in Pyret constructor syntax
     * 
     * @example
     * ```typescript
     * const pyretCode = instance.reify();
     * ```
     */
    reify() {
      let result = "";
      const referencedAtoms = /* @__PURE__ */ new Set();
      this.relations.forEach((relation) => {
        relation.tuples.forEach((tuple) => {
          for (let i = 1; i < tuple.atoms.length; i++) {
            referencedAtoms.add(tuple.atoms[i]);
          }
        });
      });
      const rootAtoms = Array.from(this.atoms.values()).filter((atom) => !referencedAtoms.has(atom.id));
      if (rootAtoms.length === 0) {
        return result + "# No root atoms found";
      }
      if (rootAtoms.length > 1) {
        const rootExpressions = rootAtoms.map((atom) => this.reifyAtom(atom.id, /* @__PURE__ */ new Set()));
        return result + `[list-set: ${rootExpressions.join(", ")}]`;
      }
      return result + this.reifyAtom(rootAtoms[0].id, /* @__PURE__ */ new Set());
    }
    /**
     * Recursively reifies a single atom and its relations, preserving constructor argument order
     * 
     * @param atomId - The atom ID to reify
     * @param visited - Set of visited atom IDs to prevent infinite recursion
     * @returns Pyret constructor notation for this atom
     */
    reifyAtom(atomId, visited) {
      if (visited.has(atomId)) {
        return `/* cycle: ${atomId} */`;
      }
      const atom = this.atoms.get(atomId);
      if (!atom) {
        return `/* missing atom: ${atomId} */`;
      }
      visited.add(atomId);
      if (this.isBuiltinType(atom.type)) {
        const result = this.reifyPrimitive(atom);
        visited.delete(atomId);
        return result;
      }
      const originalObject = this.originalObjects.get(atomId);
      if (!originalObject || !originalObject.dict) {
        visited.delete(atomId);
        return this.tryReconstructFromRelations(atom, visited);
      }
      const orderedKeys = Object.keys(originalObject.dict);
      this.cacheConstructorPattern(atom.type, orderedKeys);
      const isListLike = orderedKeys.every((key) => /^\d+$/.test(key));
      if (isListLike && orderedKeys.length > 0) {
        const sortedKeys = orderedKeys.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
        const listItems = sortedKeys.map((key) => {
          const targetAtomIds = this.getRelationTargets(atomId, key);
          return targetAtomIds.map((targetId) => this.reifyAtom(targetId, visited));
        }).flat();
        visited.delete(atomId);
        return `[list: ${listItems.join(", ")}]`;
      }
      const args = [];
      for (const relationName of orderedKeys) {
        const targetAtomIds = this.getRelationTargets(atomId, relationName);
        for (const targetId of targetAtomIds) {
          args.push(this.reifyAtom(targetId, visited));
        }
      }
      visited.delete(atomId);
      if (args.length === 0) {
        return atom.type;
      }
      return `${atom.type}(${args.join(", ")})`;
    }
    /**
     * Reifies primitive values with appropriate Pyret syntax
     */
    reifyPrimitive(atom) {
      switch (atom.type) {
        case "String":
          return `"${atom.label.replace(/"/g, '\\"')}"`;
        case "Number":
          return atom.label;
        case "Boolean":
          return atom.label;
        default:
          return atom.label;
      }
    }
    /**
     * Parses Pyret objects iteratively to avoid stack overflow and handle cycles
     */
    parseObjectIteratively(rootObject) {
      const processingQueue = [
        { obj: rootObject }
      ];
      while (processingQueue.length > 0) {
        const { obj, parentInfo } = processingQueue.shift();
        if (this.objectToAtomId.has(obj)) {
          if (parentInfo) {
            const existingAtomId = this.objectToAtomId.get(obj);
            this.addRelationTuple(
              parentInfo.relationName,
              { atoms: [parentInfo.parentId, existingAtomId], types: ["PyretObject", "PyretObject"] }
            );
          }
          continue;
        }
        const atomId = this.createAtomFromObject(obj);
        this.originalObjects.set(atomId, obj);
        if (obj.dict && typeof obj.dict === "object") {
          const type2 = this.extractType(obj);
          const fieldOrder = Object.keys(obj.dict);
          this.cacheConstructorPattern(type2, fieldOrder);
        }
        if (parentInfo) {
          this.addRelationTuple(
            parentInfo.relationName,
            { atoms: [parentInfo.parentId, atomId], types: ["PyretObject", "PyretObject"] }
          );
        }
        if (obj.dict && typeof obj.dict === "object") {
          Object.entries(obj.dict).forEach(([relationName, fieldValue]) => {
            if (!this.options.showFunctions && fieldValue && typeof fieldValue === "object" && "meth" in fieldValue && "full_meth" in fieldValue) {
              return;
            }
            if (this.isAtomicValue(fieldValue)) {
              const valueAtomId = this.createAtomFromPrimitive(fieldValue);
              this.addRelationTuple(
                relationName,
                { atoms: [atomId, valueAtomId], types: ["PyretObject", "PyretObject"] }
              );
            } else if (this.isPyretObject(fieldValue)) {
              processingQueue.push({
                obj: fieldValue,
                parentInfo: { parentId: atomId, relationName }
              });
            }
          });
        }
      }
    }
    /**
     * Creates an atom from a Pyret object and stores the mapping
     */
    createAtomFromObject(obj) {
      const type2 = this.extractType(obj);
      const atomId = this.generateAtomId(type2);
      const atom = {
        id: atomId,
        type: type2,
        label: this.extractLabel(obj)
      };
      this.atoms.set(atomId, atom);
      this.objectToAtomId.set(obj, atomId);
      this.ensureTypeExists(type2);
      return atomId;
    }
    /**
     * Creates an atom from a primitive value, optionally reusing existing atoms based on configuration
     */
    createAtomFromPrimitive(value) {
      const type2 = this.mapPrimitiveType(value);
      const label = String(value);
      const shouldReuse = type2 === "String" && this.options.stringsIdempotent || type2 === "Number" && this.options.numbersIdempotent || type2 === "Boolean" && this.options.booleansIdempotent;
      if (shouldReuse) {
        const existingAtom = Array.from(this.atoms.values()).find((atom2) => atom2.label === label && atom2.type === type2);
        if (existingAtom) {
          return existingAtom.id;
        }
      }
      const atomId = this.generateAtomId(type2);
      const atom = {
        id: atomId,
        type: type2,
        label
      };
      this.atoms.set(atomId, atom);
      this.ensureTypeExists(type2);
      return atomId;
    }
    /**
     * Maps JavaScript primitive types to Pyret-appropriate type names
     */
    mapPrimitiveType(value) {
      switch (typeof value) {
        case "number":
          return "Number";
        case "string":
          return "String";
        case "boolean":
          return "Boolean";
        default:
          return "Value";
      }
    }
    /**
     * Extracts the most specific brand name from a Pyret brands object.
     * Returns the brand with the highest trailing number, with prefix and number removed.
     * If no brands have trailing numbers, returns the lexicographically last brand.
     *
     * @param brands - The brands object from a Pyret object
     * @returns The most specific brand name (without $brand and trailing number), or undefined if none found
     */
    extractMostSpecificBrand(brands) {
      let maxNum = -1;
      let result = void 0;
      let fallbackResult = void 0;
      for (const brand of Object.keys(brands)) {
        const matchWithNumber = /^\$brand([a-zA-Z_]+)(\d+)$/.exec(brand);
        if (matchWithNumber) {
          const [, name, numStr] = matchWithNumber;
          const num3 = parseInt(numStr, 10);
          if (num3 > maxNum) {
            maxNum = num3;
            result = name;
          }
        } else {
          const matchWithoutNumber = /^\$brand_?([a-zA-Z_]+)$/.exec(brand);
          if (matchWithoutNumber) {
            const [, name] = matchWithoutNumber;
            if (!fallbackResult || name > fallbackResult) {
              fallbackResult = name;
            }
          }
        }
      }
      return result || fallbackResult;
    }
    /**
     * Extracts the type name from a Pyret object
     */
    extractType(obj) {
      if (obj.$name && typeof obj.$name === "string") {
        return obj.$name;
      }
      if (obj.brands && typeof obj.brands === "object") {
        const brand = this.extractMostSpecificBrand(obj.brands);
        if (brand) {
          return brand;
        }
      }
      return "PyretObject";
    }
    /**
     * Extracts a display label from a Pyret object, using a per-type counter.
     * Labels will be of the form Type$<num>
     */
    extractLabel(obj) {
      if (obj.$name && typeof obj.$name === "string") {
        return obj.$name;
      }
      const type2 = this.extractType(obj);
      const current = this.typeLabelCounters.get(type2) ?? 0;
      const next = current + 1;
      this.typeLabelCounters.set(type2, next);
      return `${type2}$${next}`;
    }
    /**
     * Adds a tuple to a relation, creating the relation if it doesn't exist
     */
    addRelationTuple(relationId, tuple) {
      const sourceId = tuple.atoms[0];
      const targetId = tuple.atoms[tuple.atoms.length - 1];
      const middleAtoms = tuple.atoms.slice(1, -1);
      const sourceAtom = this.atoms.get(sourceId);
      const targetAtom = this.atoms.get(targetId);
      if (!sourceAtom || !targetAtom) {
        console.warn(`Cannot create relation ${relationId}: missing atoms ${sourceId} or ${targetId}`);
        return;
      }
      let relation = this.relations.get(relationId);
      let name = relationId + (middleAtoms.length > 0 ? `[${middleAtoms.join(", ")}]` : "");
      if (!relation) {
        relation = {
          id: relationId,
          name,
          types: [sourceAtom.type, targetAtom.type],
          tuples: []
        };
        this.relations.set(relationId, relation);
      }
      const isDuplicate = relation.tuples.some(
        (t) => t.atoms[0] === sourceId && t.atoms[1] === targetId
      );
      if (!isDuplicate) {
        relation.tuples.push(tuple);
        this.emitEvent({
          type: "relationTupleAdded",
          data: { relationId, tuple }
        });
      }
    }
    /**
     * Ensures a type exists in the types map
     */
    ensureTypeExists(typeName) {
      if (!this.types.has(typeName)) {
        const type2 = {
          id: typeName,
          types: [typeName, "PyretObject"],
          // All types inherit from PyretObject
          atoms: [],
          isBuiltin: this.isBuiltinType(typeName)
        };
        this.types.set(typeName, type2);
      }
    }
    /**
     * Initializes common builtin types
     */
    initializeBuiltinTypes() {
      const builtinTypes = ["Number", "String", "Boolean", "PyretObject"];
      builtinTypes.forEach((typeName) => {
        const type2 = {
          id: typeName,
          types: typeName === "PyretObject" ? ["PyretObject"] : [typeName, "PyretObject"],
          // All types inherit from PyretObject
          atoms: [],
          isBuiltin: true
        };
        this.types.set(typeName, type2);
      });
    }
    /**
     * Checks if a type is a builtin type
     */
    isBuiltinType(typeName) {
      return ["Number", "String", "Boolean", "PyretObject"].includes(typeName);
    }
    /**
     * Type guard for atomic values
     */
    isAtomicValue(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
    }
    /**
     * Type guard for Pyret objects
     */
    isPyretObject(obj) {
      return typeof obj === "object" && obj !== null && ("dict" in obj || "brands" in obj || "$name" in obj);
    }
    /**
     * Generates a unique atom ID
     */
    generateAtomId(type2) {
      const prefix = type2 ? type2.toLowerCase().substring(0, 3) : "atom";
      return `${prefix}_${++this.atomCounter}`;
    }
    // IDataInstance implementation
    getAtoms() {
      return Array.from(this.atoms.values());
    }
    getRelations() {
      const values = this.relations.values();
      return Array.from(values);
    }
    getTypes() {
      this.types.forEach((type2) => {
        type2.atoms = this.getAtoms().filter((atom) => atom.type === type2.id);
      });
      return Array.from(this.types.values());
    }
    getAtomType(atomId) {
      const atom = this.atoms.get(atomId);
      if (!atom) {
        throw new Error(`Atom with id '${atomId}' not found`);
      }
      const type2 = this.types.get(atom.type);
      if (!type2) {
        this.ensureTypeExists(atom.type);
        return this.types.get(atom.type);
      }
      return type2;
    }
    /**
     * Generates a graphlib Graph representation of this data instance.
     * 
     * This method creates a directed multigraph where:
     * - Each atom becomes a node with its label and type as metadata
     * - Each relation tuple becomes an edge between atoms
     * - Multi-atom tuples (arity > 2) are handled by connecting first to last atom
     * - Disconnected nodes can be optionally filtered out
     * 
     * @param hideDisconnected - Whether to hide atoms with no relations
     * @param hideDisconnectedBuiltIns - Whether to hide disconnected built-in types
     * @returns A graphlib Graph object ready for layout algorithms
     * 
     * @example
     * ```typescript
     * const graph = instance.generateGraph(true, true);
     * // Use with WebCola or other layout algorithms
     * const layout = new cola.Layout().nodes(graph.nodes()).edges(graph.edges());
     * ```
     */
    generateGraph(hideDisconnected = false, hideDisconnectedBuiltIns = false) {
      const graph = new import_graphlib2.Graph({ directed: true, multigraph: true });
      this.getAtoms().forEach((atom) => {
        graph.setNode(atom.id, {
          label: atom.label
        });
      });
      this.getRelations().forEach((relation) => {
        relation.tuples.forEach((tuple) => {
          if (tuple.atoms.length >= 2) {
            const sourceId = tuple.atoms[0];
            const targetId = tuple.atoms[tuple.atoms.length - 1];
            const middleAtoms = tuple.atoms.slice(1, -1);
            let edgeLabel = relation.name;
            if (middleAtoms.length > 0) {
              const middleLabels = middleAtoms.map((atomId) => {
                const atom = this.atoms.get(atomId);
                return atom ? atom.label : atomId;
              });
              edgeLabel = `${relation.name}[${middleLabels.join(", ")}]`;
            }
            const edgeId = generateEdgeId2(relation, tuple);
            graph.setEdge(sourceId, targetId, edgeLabel, edgeId);
          }
        });
      });
      if (hideDisconnected || hideDisconnectedBuiltIns) {
        const nodesToRemove = [];
        graph.nodes().forEach((nodeId) => {
          const inEdges = graph.inEdges(nodeId) || [];
          const outEdges = graph.outEdges(nodeId) || [];
          const isDisconnected = inEdges.length === 0 && outEdges.length === 0;
          if (isDisconnected) {
            const atom = this.atoms.get(nodeId);
            if (atom) {
              const atomType = this.getAtomType(nodeId);
              const isBuiltin2 = atomType.isBuiltin;
              if (hideDisconnected || isBuiltin2 && hideDisconnectedBuiltIns) {
                nodesToRemove.push(nodeId);
              }
            }
          }
        });
        nodesToRemove.forEach((nodeId) => graph.removeNode(nodeId));
      }
      return graph;
    }
    /**
     * Applies projections to filter the data instance
     */
    applyProjections(atomIds) {
      if (atomIds.length === 0) {
        return this;
      }
      const projected = Object.create(_PyretDataInstance.prototype);
      projected.atoms = new Map([...this.atoms].filter(([id]) => atomIds.includes(id)));
      projected.relations = /* @__PURE__ */ new Map();
      projected.types = /* @__PURE__ */ new Map();
      projected.atomCounter = projected.atoms.size;
      this.relations.forEach((relation, name) => {
        const filteredTuples = relation.tuples.filter(
          (tuple) => tuple.atoms.every((atomId) => atomIds.includes(atomId))
        );
        if (filteredTuples.length > 0) {
          projected.relations.set(name, {
            ...relation,
            tuples: filteredTuples
          });
        }
      });
      this.types.forEach((type2, typeName) => {
        const filteredAtoms = type2.atoms.filter((atom) => atomIds.includes(atom.id));
        if (filteredAtoms.length > 0) {
          projected.types.set(typeName, {
            ...type2,
            atoms: filteredAtoms
          });
        }
      });
      return projected;
    }
    /**
     * Gets target atom IDs for a specific relation from a source atom
     * 
     * @param sourceAtomId - The source atom ID
     * @param relationName - The relation name
     * @returns Array of target atom IDs
     */
    getRelationTargets(sourceAtomId, relationName) {
      const targets = [];
      this.relations.forEach((relation) => {
        if (relation.name === relationName) {
          relation.tuples.forEach((tuple) => {
            if (tuple.atoms[0] === sourceAtomId && tuple.atoms.length >= 2) {
              targets.push(tuple.atoms[1]);
            }
          });
        }
      });
      return targets;
    }
    /**
     * Adds a PyretDataInstance to this instance, optionally unifying built-in types
     * 
     * @param dataInstance - The PyretDataInstance to add
     * @param unifyBuiltIns - Whether to unify built-in atoms
     * @returns True if the instance was added successfully, false otherwise
     */
    addFromDataInstance(dataInstance, unifyBuiltIns) {
      if (!(dataInstance instanceof _PyretDataInstance)) {
        return false;
      }
      const pyretInstance = dataInstance;
      const reIdMap = /* @__PURE__ */ new Map();
      pyretInstance.getAtoms().forEach((atom) => {
        const isBuiltin2 = this.isBuiltinType(atom.type);
        if (unifyBuiltIns && isBuiltin2) {
          const shouldUnify = atom.type === "String" && this.options.stringsIdempotent || atom.type === "Number" && this.options.numbersIdempotent || atom.type === "Boolean" && this.options.booleansIdempotent;
          if (shouldUnify) {
            const existingAtom = Array.from(this.atoms.values()).find(
              (existing) => existing.type === atom.type && existing.label === atom.label
            );
            if (existingAtom) {
              reIdMap.set(atom.id, existingAtom.id);
              return;
            }
          }
        }
        const newId = this.generateAtomId(atom.type);
        reIdMap.set(atom.id, newId);
        const newAtom = { ...atom, id: newId };
        this.addAtom(newAtom);
        const originalObject = pyretInstance.originalObjects.get(atom.id);
        if (originalObject) {
          this.originalObjects.set(newId, originalObject);
        }
      });
      pyretInstance.getTypes().forEach((type2) => {
        if (!this.types.has(type2.id)) {
          this.types.set(type2.id, {
            ...type2,
            atoms: type2.atoms.map((atom) => ({
              ...atom,
              id: reIdMap.get(atom.id) || atom.id
            }))
          });
        } else {
          const existingType = this.types.get(type2.id);
          const newAtoms = type2.atoms.map((atom) => ({
            ...atom,
            id: reIdMap.get(atom.id) || atom.id
          }));
          existingType.atoms.push(...newAtoms);
        }
      });
      pyretInstance.getRelations().forEach((relation) => {
        const newTuples = relation.tuples.map((tuple) => ({
          atoms: tuple.atoms.map((atomId) => reIdMap.get(atomId) || atomId),
          types: tuple.types
        }));
        const existingRelation = this.relations.get(relation.id);
        if (existingRelation) {
          existingRelation.tuples.push(...newTuples);
        } else {
          this.relations.set(relation.id, {
            ...relation,
            tuples: newTuples
          });
        }
      });
      return true;
    }
  };
  /** Global map to store constructor patterns and field order for types across all instances */
  _PyretDataInstance.globalConstructorCache = /* @__PURE__ */ new Map();
  /** Global counter for instantiation priority - higher numbers mean newer/higher priority */
  _PyretDataInstance.instantiationCounter = 0;
  var PyretDataInstance = _PyretDataInstance;

  // src/components/ReplInterface/parsers/ExtensibleParsers.ts
  var PyretListParser = class {
    canHandle(command) {
      const trimmed = command.trim();
      if (trimmed.startsWith("add ") || trimmed.startsWith("remove ")) {
        return false;
      }
      if (trimmed.startsWith("[list:") && trimmed.includes("]:")) {
        return true;
      }
      return false;
    }
    getPriority() {
      return 120;
    }
    getCommandPatterns() {
      return [
        "[list: item1,item2,item3]:type",
        "[list: 1,2,3,4]:numbers"
      ];
    }
    execute(command, instance) {
      const trimmed = command.trim();
      return this.handleAdd(trimmed, instance);
    }
    handleAdd(args, instance) {
      try {
        const match = args.match(/^\[list:\s*([^\]]+)\]:(.+)$/);
        if (!match) {
          return {
            success: false,
            message: "Invalid syntax. Use: add [list: item1,item2,item3]:type"
          };
        }
        const [, itemsStr, listTypeName] = match;
        const items = itemsStr.split(",").map((item) => item.trim()).filter((item) => item);
        const listType = listTypeName.trim();
        if (items.length === 0) {
          return {
            success: false,
            message: "List cannot be empty"
          };
        }
        let itemType = "String";
        const existingAtoms = instance.getAtoms();
        const existingAtomIds = new Set(existingAtoms.map((a) => a.id));
        if (items.every((item) => /^\d+$/.test(item))) {
          itemType = "Number";
        } else if (items.every((item) => /^".*"$/.test(item))) {
          itemType = "String";
          for (let i = 0; i < items.length; i++) {
            items[i] = items[i].slice(1, -1);
          }
        } else if (items.every((item) => existingAtomIds.has(item))) {
          const firstAtom = existingAtoms.find((a) => a.id === items[0]);
          itemType = firstAtom?.type || "Entity";
        }
        const results = [];
        const atomsAdded = [];
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (!existingAtomIds.has(item)) {
            const atom = {
              id: item,
              label: item,
              type: itemType
            };
            try {
              instance.addAtom(atom);
              atomsAdded.push(item);
              existingAtomIds.add(item);
            } catch (error) {
            }
          }
        }
        const listId = this.generateListId(instance, listType);
        const listAtom = {
          id: listId,
          label: `[${items.join(", ")}]`,
          type: listType
        };
        instance.addAtom(listAtom);
        atomsAdded.push(listId);
        this.addListRelations(instance, listId, items);
        const addedCount = atomsAdded.length;
        const relationCount = items.length > 0 ? items.length : 0;
        return {
          success: true,
          message: `Added Pyret list: ${listId} with ${items.length} items (${addedCount} atoms, ${relationCount} relations)`,
          action: "add"
        };
      } catch (error) {
        return {
          success: false,
          message: error instanceof Error ? error.message : "Failed to add Pyret list"
        };
      }
    }
    generateListId(instance, typeName) {
      const existingIds = new Set(instance.getAtoms().map((a) => a.id));
      let counter = 1;
      let candidateId = `${typeName}-${counter}`;
      while (existingIds.has(candidateId)) {
        counter++;
        candidateId = `${typeName}-${counter}`;
      }
      return candidateId;
    }
    addListRelations(instance, listId, items) {
      if (items.length === 0) return;
      let currentRest = "empty";
      for (let i = items.length - 1; i >= 0; i--) {
        const currentItem = items[i];
        const linkId = `${listId}-link-${i + 1}`;
        const linkAtom = {
          id: linkId,
          label: `link(${currentItem}, ${currentRest})`,
          type: "link"
        };
        instance.addAtom(linkAtom);
        const linkTuple = {
          atoms: [currentItem, currentRest],
          types: ["Item", "link"]
        };
        try {
          instance.addRelationTuple("link", linkTuple);
        } catch (error) {
        }
        currentRest = linkId;
      }
      const topLevelTuple = {
        atoms: [listId, currentRest],
        types: ["List", "link"]
      };
      try {
        instance.addRelationTuple("link", topLevelTuple);
      } catch (error) {
      }
    }
    getHelp() {
      return [
        "Pyret List Commands (sugar syntax):",
        "  [list: item1,item2,item3]:list_type    - Add list with items",
        "  [list: 1,2,3,4]:numbers               - Add number list",
        "",
        "This automatically creates:",
        "  - Individual atoms for each item (if they don't exist)",
        "  - A list atom containing all items",
        "  - first/rest relations for list structure",
        "",
        "Examples:",
        "  [list: 1,2,3,4]:numberList           - Creates numberList-1 as list ID",
        "  [list: alice,bob,charlie]:personList - Creates personList-1 as list ID",
        "  [list: red,green,blue]:colors        - Creates colors-1 as list ID",
        "",
        "Note: All syntax is sugar that gets desugared to internal operations.",
        "The list type name is used as-is to generate unique list IDs (type-1, type-2, etc.)"
      ];
    }
  };
  var InfoCommandParser = class {
    canHandle(command) {
      const trimmed = command.trim().toLowerCase();
      const utilityCommands = ["help", "info", "status", "list", "clear", "reify", "list-ids", "list-edges"];
      return utilityCommands.includes(trimmed);
    }
    getPriority() {
      return 50;
    }
    getCommandPatterns() {
      return [
        "help",
        "info",
        "status",
        "list",
        "list-ids",
        "list-edges",
        "clear",
        "reify"
      ];
    }
    execute(command, instance) {
      const trimmed = command.trim().toLowerCase();
      switch (trimmed) {
        case "help":
          return {
            success: true,
            message: this.getGeneralHelp(),
            action: "help"
          };
        case "info":
        case "status":
          return this.getStatus(instance);
        case "list":
          return this.listContents(instance);
        case "list-ids":
          return this.listAtomIds(instance);
        case "list-edges":
          return this.listEdgeIds(instance);
        case "clear":
          return this.clearInstance(instance);
        case "reify":
          return this.reifyInstance(instance);
        default:
          return {
            success: false,
            message: "Unknown info command"
          };
      }
    }
    listAtomIds(instance) {
      const atoms = instance.getAtoms();
      if (atoms.length === 0) {
        return {
          success: true,
          message: "No atoms found in instance.",
          action: "info"
        };
      }
      let message = "Internal Atom IDs:\n\n";
      const atomsByType = atoms.reduce((acc, atom) => {
        if (!acc[atom.type]) {
          acc[atom.type] = [];
        }
        acc[atom.type].push(atom);
        return acc;
      }, {});
      Object.entries(atomsByType).forEach(([type2, typeAtoms]) => {
        message += `${type2}:
`;
        typeAtoms.forEach((atom) => {
          message += `  ID: ${atom.id}  Label: ${atom.label}
`;
        });
        message += "\n";
      });
      message += `Total: ${atoms.length} atoms`;
      return {
        success: true,
        message,
        action: "info"
      };
    }
    listEdgeIds(instance) {
      const relations = instance.getRelations();
      if (relations.length === 0) {
        return {
          success: true,
          message: "No relations/edges found in instance.",
          action: "info"
        };
      }
      let message = "Internal Edge IDs:\n\n";
      let totalEdges = 0;
      relations.forEach((relation) => {
        if (relation.tuples.length > 0) {
          message += `Relation: ${relation.name}
`;
          relation.tuples.forEach((tuple, index) => {
            const edgeId = `${relation.name}:${tuple.atoms.join("->")}`;
            message += `  Edge ID: ${edgeId}
`;
            message += `  Tuple: (${tuple.atoms.join(", ")})
`;
            totalEdges++;
          });
          message += "\n";
        }
      });
      message += `Total: ${totalEdges} edges across ${relations.length} relations`;
      return {
        success: true,
        message,
        action: "info"
      };
    }
    getStatus(instance) {
      const atoms = instance.getAtoms();
      const relations = instance.getRelations();
      const tupleCount = relations.reduce((sum, r) => sum + r.tuples.length, 0);
      const typeStats = atoms.reduce((acc, atom) => {
        acc[atom.type] = (acc[atom.type] || 0) + 1;
        return acc;
      }, {});
      const relationStats = relations.reduce((acc, rel) => {
        acc[rel.name] = rel.tuples.length;
        return acc;
      }, {});
      let message = `Instance Status:
`;
      message += `  Atoms: ${atoms.length}
`;
      message += `  Relations: ${relations.length}
`;
      message += `  Tuples: ${tupleCount}

`;
      if (Object.keys(typeStats).length > 0) {
        message += `Types:
`;
        Object.entries(typeStats).forEach(([type2, count]) => {
          message += `  ${type2}: ${count}
`;
        });
        message += "\n";
      }
      if (Object.keys(relationStats).length > 0) {
        message += `Relations:
`;
        Object.entries(relationStats).forEach(([name, count]) => {
          message += `  ${name}: ${count} tuples
`;
        });
      }
      return {
        success: true,
        message,
        action: "info"
      };
    }
    listContents(instance) {
      const atoms = instance.getAtoms();
      const relations = instance.getRelations();
      let message = "Instance Contents:\n\n";
      if (atoms.length > 0) {
        message += "Atoms:\n";
        atoms.forEach((atom) => {
          message += `  [${atom.id}] ${atom.label}:${atom.type}
`;
        });
        message += "\n";
      }
      if (relations.length > 0) {
        message += "Relations:\n";
        relations.forEach((rel) => {
          message += `  ${rel.name}:
`;
          rel.tuples.forEach((tuple) => {
            message += `    (${tuple.atoms.join(", ")})
`;
          });
        });
      }
      if (atoms.length === 0 && relations.length === 0) {
        message += "Empty instance - no atoms or relations defined.";
      }
      return {
        success: true,
        message,
        action: "info"
      };
    }
    clearInstance(instance) {
      try {
        const atomIds = instance.getAtoms().map((a) => a.id);
        atomIds.forEach((id) => instance.removeAtom(id));
        return {
          success: true,
          message: `Cleared instance (removed ${atomIds.length} atoms)`,
          action: "remove"
        };
      } catch (error) {
        return {
          success: false,
          message: error instanceof Error ? error.message : "Failed to clear instance"
        };
      }
    }
    reifyInstance(instance) {
      try {
        if (instance instanceof PyretDataInstance) {
          const reifiedCode = instance.reify();
          return {
            success: true,
            message: `Pyret Constructor Notation:

${reifiedCode}`,
            action: "info"
          };
        } else {
          const atoms = instance.getAtoms();
          const relations = instance.getRelations();
          let result = "Data Instance Structure:\n\n";
          if (atoms.length > 0) {
            result += "Atoms:\n";
            atoms.forEach((atom) => {
              result += `  [${atom.id}] ${atom.label}:${atom.type}
`;
            });
            result += "\n";
          }
          if (relations.length > 0) {
            result += "Relations:\n";
            relations.forEach((rel) => {
              result += `  ${rel.name}:
`;
              rel.tuples.forEach((tuple) => {
                result += `    (${tuple.atoms.join(", ")})
`;
              });
            });
          }
          return {
            success: true,
            message: result,
            action: "info"
          };
        }
      } catch (error) {
        return {
          success: false,
          message: error instanceof Error ? error.message : "Failed to reify instance"
        };
      }
    }
    getGeneralHelp() {
      return `REPL Interface Help:

Available commands across all terminals:
  help       - Show this help
  info       - Show instance status  
  status     - Same as info
  list       - List all atoms and relations
  list-ids   - List internal atom IDs grouped by type
  list-edges - List internal edge IDs for all relations
  clear      - Clear entire instance
  reify      - Generate Pyret constructor notation (or generic representation)

Terminal-specific commands vary by terminal type.
Click the "?" button in each terminal header for specific help.`;
    }
    getHelp() {
      return [
        "Utility Commands:",
        "  help       - Show general help",
        "  info       - Show instance status",
        "  status     - Same as info",
        "  list       - List all contents",
        "  list-ids   - List internal atom IDs",
        "  list-edges - List internal edge IDs",
        "  clear      - Clear entire instance",
        "  reify      - Generate Pyret constructor notation"
      ];
    }
  };

  // src/components/ReplInterface/ReplInterface.tsx
  var import_jsx_runtime23 = __toESM(require_jsx_runtime());
  var DEFAULT_TERMINALS = [
    {
      id: "unified",
      title: "",
      description: "Supports atoms, relations, and extensions in one terminal",
      parsers: [
        new RemoveCommandParser(),
        // Priority 200 - highest priority for remove commands
        new PyretListParser(),
        // Priority 120 - most specific pattern
        new BatchCommandParser(),
        // Priority 115 - multi-command patterns  
        new DotNotationRelationParser(),
        // Priority 115 - dot notation relations
        new AtomCommandParser(),
        // Priority 100 - standard priority
        new InfoCommandParser()
        // Priority 50 - fallback utility commands
      ].sort((a, b) => b.getPriority() - a.getPriority()),
      // Sort by priority descending
      placeholder: ""
    }
  ];
  var ReplInterface = ({
    instance,
    onChange,
    onCndSpecExtracted,
    disabled = false,
    className = "",
    terminals = DEFAULT_TERMINALS
  }) => {
    const [terminalStates, setTerminalStates] = (0, import_react9.useState)(() => {
      const initialState = {};
      terminals.forEach((terminal) => {
        initialState[terminal.id] = {
          input: "",
          output: [],
          // No welcome message - keep it minimal
          isExecuting: false
        };
      });
      return initialState;
    });
    const [drawersOpen, setDrawersOpen] = (0, import_react9.useState)({
      nodes: false,
      edges: false
    });
    const outputRefs = (0, import_react9.useRef)({});
    const atoms = instance.getAtoms();
    const relations = instance.getRelations();
    const tupleCount = relations.reduce((sum, rel) => sum + rel.tuples.length, 0);
    const scrollToBottom = (0, import_react9.useCallback)((terminalId) => {
      const outputRef = outputRefs.current[terminalId];
      if (outputRef) {
        outputRef.scrollTop = outputRef.scrollHeight;
      }
    }, []);
    const addOutputLine = (0, import_react9.useCallback)((terminalId, line) => {
      setTerminalStates((prev) => ({
        ...prev,
        [terminalId]: {
          ...prev[terminalId],
          output: [
            ...prev[terminalId].output,
            {
              ...line,
              id: `${Date.now()}-${Math.random()}`,
              timestamp: /* @__PURE__ */ new Date()
            }
          ]
        }
      }));
      setTimeout(() => scrollToBottom(terminalId), 0);
    }, [scrollToBottom]);
    const notifyChange = (0, import_react9.useCallback)(() => {
      if (onChange) {
        onChange(instance);
      }
    }, [instance, onChange]);
    const toggleDrawer = (0, import_react9.useCallback)((drawerName) => {
      setDrawersOpen((prev) => ({
        ...prev,
        [drawerName]: !prev[drawerName]
      }));
    }, []);
    const executeCommand = (0, import_react9.useCallback)(async (terminalId, command) => {
      const terminal = terminals.find((t) => t.id === terminalId);
      if (!terminal) return;
      const trimmedCommand = command.trim();
      if (!trimmedCommand) return;
      setTerminalStates((prev) => ({
        ...prev,
        [terminalId]: {
          ...prev[terminalId],
          isExecuting: true
        }
      }));
      addOutputLine(terminalId, {
        type: "command",
        message: trimmedCommand
      });
      let result = null;
      let handlingParser = null;
      for (const parser of terminal.parsers) {
        if (parser.canHandle(trimmedCommand)) {
          handlingParser = parser;
          try {
            const executeResult = parser.execute(trimmedCommand, instance);
            result = await Promise.resolve(executeResult);
            break;
          } catch (error) {
            result = {
              success: false,
              message: error instanceof Error ? error.message : "Execution failed"
            };
            break;
          }
        }
      }
      if (!result) {
        const availablePatterns = terminal.parsers.flatMap((parser) => parser.getCommandPatterns()).slice(0, 8).join("\n  ");
        result = {
          success: false,
          message: `Unknown command: ${trimmedCommand}

Available patterns:
  ${availablePatterns}

Type 'help' for detailed information.`
        };
      }
      if (!result.success || result.action === "help" || result.action === "info") {
        addOutputLine(terminalId, {
          type: result.success ? result.action === "help" ? "help" : result.action === "info" ? "info" : "success" : "error",
          message: result.message
        });
      }
      setTerminalStates((prev) => ({
        ...prev,
        [terminalId]: {
          ...prev[terminalId],
          input: "",
          isExecuting: false
        }
      }));
      if (result.success && (result.action === "add" || result.action === "remove")) {
        notifyChange();
      }
      if (result.success && result.extractedCndSpec && onCndSpecExtracted) {
        onCndSpecExtracted(result.extractedCndSpec);
      }
    }, [terminals, instance, addOutputLine, notifyChange, onCndSpecExtracted]);
    const handleInputChange = (0, import_react9.useCallback)((terminalId, value) => {
      setTerminalStates((prev) => ({
        ...prev,
        [terminalId]: {
          ...prev[terminalId],
          input: value
        }
      }));
    }, []);
    const handleExecute = (0, import_react9.useCallback)(async (terminalId) => {
      const state = terminalStates[terminalId];
      if (!state || state.isExecuting) return;
      const commands = state.input.split("\n").map((cmd) => cmd.trim()).filter((cmd) => cmd);
      for (const command of commands) {
        await executeCommand(terminalId, command);
      }
    }, [terminalStates, executeCommand]);
    const handleKeyPress = (0, import_react9.useCallback)((e, terminalId) => {
      if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        handleExecute(terminalId);
      }
    }, [handleExecute]);
    const clearTerminal = (0, import_react9.useCallback)((terminalId) => {
      setTerminalStates((prev) => ({
        ...prev,
        [terminalId]: {
          ...prev[terminalId],
          output: []
        }
      }));
    }, []);
    const showHelp = (0, import_react9.useCallback)((terminalId) => {
      const terminal = terminals.find((t) => t.id === terminalId);
      if (!terminal) return;
      let helpText = `${terminal.title} Help:

`;
      terminal.parsers.forEach((parser) => {
        const help = parser.getHelp();
        helpText += help.join("\n") + "\n\n";
      });
      addOutputLine(terminalId, {
        type: "help",
        message: helpText.trim()
      });
    }, [terminals, addOutputLine]);
    const clearAll = (0, import_react9.useCallback)(() => {
      try {
        const atomIds = instance.getAtoms().map((a) => a.id);
        atomIds.forEach((id) => instance.removeAtom(id));
        terminals.forEach((terminal) => {
          addOutputLine(terminal.id, {
            type: "success",
            message: `Instance cleared (removed ${atomIds.length} atoms)`
          });
        });
        notifyChange();
      } catch (error) {
        terminals.forEach((terminal) => {
          addOutputLine(terminal.id, {
            type: "error",
            message: error instanceof Error ? error.message : "Failed to clear instance"
          });
        });
      }
    }, [instance, terminals, addOutputLine, notifyChange]);
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: `repl-interface ${className}`, children: [
      /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "repl-interface__main", children: [
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__header", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { style: { display: "flex", gap: "8px" }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
            "button",
            {
              onClick: () => toggleDrawer("nodes"),
              style: {
                background: drawersOpen.nodes ? "#4ec9b0" : "#2d2d30",
                color: drawersOpen.nodes ? "#1e1e1e" : "#cccccc",
                border: "1px solid #3c3c3c",
                padding: "3px 6px",
                borderRadius: "3px",
                cursor: "pointer",
                fontSize: "0.75rem"
              },
              children: atoms.length
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
            "button",
            {
              onClick: () => toggleDrawer("edges"),
              style: {
                background: drawersOpen.edges ? "#4ec9b0" : "#2d2d30",
                color: drawersOpen.edges ? "#1e1e1e" : "#cccccc",
                border: "1px solid #3c3c3c",
                padding: "3px 6px",
                borderRadius: "3px",
                cursor: "pointer",
                fontSize: "0.75rem"
              },
              children: relations.length
            }
          )
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__terminals", children: terminals.map((terminal) => {
          const state = terminalStates[terminal.id];
          if (!state) return null;
          return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "repl-terminal", children: [
            /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
              "div",
              {
                className: "repl-terminal__output",
                ref: (ref) => {
                  outputRefs.current[terminal.id] = ref;
                },
                children: state.output.map((line) => /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: `repl-output-line ${line.type}`, children: line.message.split("\n").map((textLine, index) => /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { children: textLine }, index)) }, line.id))
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "repl-terminal__input", children: [
              /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
                "textarea",
                {
                  value: state.input,
                  onChange: (e) => handleInputChange(terminal.id, e.target.value),
                  onKeyDown: (e) => handleKeyPress(e, terminal.id),
                  placeholder: terminal.placeholder,
                  disabled: disabled || state.isExecuting,
                  rows: 2
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "repl-terminal__controls", children: [
                /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
                  "button",
                  {
                    className: "repl-interface__action-button danger",
                    onClick: clearAll,
                    disabled,
                    title: "Clear all data",
                    style: { marginRight: "4px", fontSize: "10px", padding: "2px 6px" },
                    children: "Clear"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
                  "button",
                  {
                    className: "repl-interface__action-button",
                    onClick: () => showHelp("unified"),
                    disabled,
                    title: "Show help",
                    style: { marginRight: "4px", fontSize: "10px", padding: "2px 6px" },
                    children: "?"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
                  "button",
                  {
                    className: "repl-terminal__execute",
                    onClick: () => handleExecute(terminal.id),
                    disabled: disabled || state.isExecuting || !state.input.trim(),
                    title: "Execute commands (Ctrl+Enter)",
                    children: state.isExecuting ? "..." : "\u25B6"
                  }
                )
              ] })
            ] })
          ] }, terminal.id);
        }) })
      ] }),
      (drawersOpen.nodes || drawersOpen.edges) && /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "repl-interface__drawers", children: [
        drawersOpen.nodes && /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "repl-interface__drawer", children: [
          /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(
            "div",
            {
              className: "repl-interface__drawer-header",
              onClick: () => toggleDrawer("nodes"),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("span", { children: [
                  "Atoms (",
                  atoms.length,
                  ")"
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("span", { className: "repl-interface__drawer-toggle", children: "\u25BC" })
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__drawer-content", children: atoms.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__drawer-empty", children: "No atoms" }) : atoms.map((atom) => /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__drawer-item", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__drawer-item-content", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "repl-interface__drawer-item-header", children: [
            atom.label,
            ":",
            atom.type
          ] }) }) }, atom.id)) })
        ] }),
        drawersOpen.edges && /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "repl-interface__drawer", children: [
          /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(
            "div",
            {
              className: "repl-interface__drawer-header",
              onClick: () => toggleDrawer("edges"),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("span", { children: [
                  "Relations (",
                  relations.length,
                  ")"
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("span", { className: "repl-interface__drawer-toggle", children: "\u25BC" })
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__drawer-content", children: relations.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__drawer-empty", children: "No relations" }) : relations.map((relation) => /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { style: { marginBottom: "6px" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__drawer-item", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__drawer-item-content", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "repl-interface__drawer-item-header", children: [
              relation.name,
              " (",
              relation.tuples.length,
              ")"
            ] }) }) }),
            relation.tuples.slice(0, 3).map((tuple, index) => /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
              "div",
              {
                className: "repl-interface__drawer-item",
                style: { marginLeft: "8px", fontSize: "0.7rem" },
                children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__drawer-item-content", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "repl-interface__drawer-item-detail", children: tuple.atoms.join(" \u2192 ") }) })
              },
              index
            )),
            relation.tuples.length > 3 && /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { style: { marginLeft: "8px", fontSize: "0.7rem", color: "#6a737d" }, children: [
              "... and ",
              relation.tuples.length - 3,
              " more"
            ] })
          ] }, relation.name)) })
        ] })
      ] })
    ] });
  };

  // src/components/ReplInterface/parsers/PyretExpressionParser.ts
  var PyretExpressionParser = class {
    constructor(evaluator) {
      this.evaluator = evaluator || null;
    }
    /**
     * Update the external evaluator
     */
    setEvaluator(evaluator) {
      this.evaluator = evaluator;
    }
    /**
     * Recursively searches for a key at any level in an object
     */
    findKeyAtAnyLevel(obj, keyName) {
      if (!obj || typeof obj !== "object") {
        return void 0;
      }
      if (keyName in obj) {
        return obj[keyName];
      }
      for (const value of Object.values(obj)) {
        if (value && typeof value === "object") {
          const found = this.findKeyAtAnyLevel(value, keyName);
          if (found !== void 0) {
            return found;
          }
        }
      }
      return void 0;
    }
    /**
     * Checks if a value is a primitive type (string, number, boolean)
     */
    isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
    }
    async evaluateExpression(command) {
      if (!this.evaluator) {
        throw new Error("No external Pyret evaluator available");
      }
      try {
        const result = await this.evaluator.run(command);
        const exnValue = this.findKeyAtAnyLevel(result, "exn");
        if (exnValue !== void 0) {
          return {
            success: false,
            exn: exnValue
          };
        }
        const answerValue = this.findKeyAtAnyLevel(result, "answer");
        if (answerValue !== void 0) {
          return {
            success: true,
            result: answerValue
          };
        }
        if (this.isPrimitive(result)) {
          return {
            success: true,
            result
          };
        }
        return {
          success: false,
          exn: "Unable to find answer or exn in evaluation result"
        };
      } catch (error) {
        return {
          success: false,
          exn: error instanceof Error ? error.message : "Unknown evaluation error"
        };
      }
    }
    canHandle(command) {
      const trimmed = command.trim();
      if (trimmed.toLowerCase() === "reify") {
        return true;
      }
      if (/^['"`].*['"`]$/.test(trimmed) || /^\d+(\.\d+)?$/.test(trimmed)) {
        return true;
      }
      if (!this.evaluator) {
        return false;
      }
      if (trimmed.startsWith("remove ")) {
        return false;
      }
      const utilityCommands = ["help", "info", "status", "list", "clear"];
      if (utilityCommands.includes(trimmed.toLowerCase())) {
        return false;
      }
      if (/^[^:]+:.+$/.test(trimmed) && !trimmed.includes("(") && !trimmed.includes("[") && !trimmed.includes("table:") && !trimmed.includes("row:")) {
        return false;
      }
      if (trimmed.includes(".") && trimmed.includes("=") && !trimmed.includes("(")) {
        return false;
      }
      if (trimmed.includes("(") && trimmed.includes(")")) {
        return true;
      }
      if (trimmed.includes("[") && trimmed.includes("]")) {
        return true;
      }
      if (trimmed.includes("table:") || trimmed.includes("row:")) {
        return true;
      }
      return false;
    }
    getPriority() {
      return 90;
    }
    getCommandPatterns() {
      return [
        "reify",
        "[list: 1, 2, 3, 4]",
        'edge("id", "label", weight)'
      ];
    }
    execute(command, instance) {
      const trimmed = command.trim();
      if (trimmed.toLowerCase() === "reify") {
        return this.reifyInstance(instance).then((lines) => ({
          success: true,
          message: lines.length > 0 ? lines.join("\n") : "No data to reify",
          action: "info"
        }));
      }
      if (!this.evaluator) {
        return Promise.resolve({
          success: false,
          message: "No external Pyret evaluator available. Cannot evaluate Pyret expressions.\n\nTo enable this feature, ensure window.__internalRepl is available."
        });
      }
      return this.evaluateExpression(trimmed).then(async (evaluationResult) => {
        if (evaluationResult.success) {
          const result = await this.addPyretResultToInstance(evaluationResult.result, instance, trimmed);
          return result;
        } else {
          return {
            success: false,
            message: `Evaluation failed: ${this.formatError(evaluationResult.exn)}`
          };
        }
      }).catch((error) => {
        return {
          success: false,
          message: `Unexpected error during evaluation: ${this.formatError(error)}`
        };
      });
    }
    /**
     * Re-ify data instance back to Pyret expressions using the external evaluator
     * This leverages the external evaluator for converting internal data back to Pyret form
     */
    async reifyInstance(instance) {
      if (!this.evaluator) {
        return ["// No external Pyret evaluator available for reification"];
      }
      const reifyLines = [];
      try {
        const atoms = instance.getAtoms();
        for (const atom of atoms) {
          if (atom.type) {
            reifyLines.push(`${atom.label}:${atom.type}`);
          } else {
            reifyLines.push(atom.label);
          }
        }
        const relations = instance.getRelations();
        for (const relation of relations) {
          for (const tuple of relation.tuples) {
            if (tuple.atoms.length === 2) {
              reifyLines.push(`${tuple.atoms[0]}.${relation.name}=${tuple.atoms[1]}`);
            } else {
              const args = tuple.atoms.map((a) => `"${a}"`).join(", ");
              reifyLines.push(`${relation.name}(${args})`);
            }
          }
        }
        return reifyLines;
      } catch (error) {
        return [
          "// Error during reification:",
          `// ${error instanceof Error ? error.message : "Unknown error"}`
        ];
      }
    }
    /**
     * Extract CnD specification from an expression by creating a faux expression and running it in the external evaluator
     */
    async extractCndSpec(pyretResult, originalExpression) {
      try {
        if (!this.evaluator) {
          return void 0;
        }
        const cndSpecCode = `(${originalExpression})._cndspec()`;
        const specResult = await this.evaluateExpression(cndSpecCode);
        if (specResult.success && specResult.result) {
          if (typeof specResult.result === "string") {
            return specResult.result;
          }
        }
      } catch (error) {
        console.error("Error extracting CnD spec:", this.formatError(error));
      }
      return void 0;
    }
    async addPyretResultToInstance(pyretResult, instance, originalExpression) {
      try {
        const extractedCndSpec = await this.extractCndSpec(pyretResult, originalExpression);
        if (!this.evaluator) {
          throw new Error("No external Pyret evaluator available");
        }
        const tempInstance = await PyretDataInstance.fromExpression(
          originalExpression,
          {},
          // showFunctions
          this.evaluator
        );
        if (tempInstance.getAtoms().length === 0) {
          return {
            success: false,
            message: "Pyret expression did not produce any data structures",
            extractedCndSpec
          };
        }
        const success = instance.addFromDataInstance?.(tempInstance, true);
        if (!success) {
          return this.fallbackAddToInstance(tempInstance, instance, originalExpression, extractedCndSpec);
        }
        const atomCount = tempInstance.getAtoms().length;
        const relationCount = tempInstance.getRelations().reduce((sum, rel) => sum + rel.tuples.length, 0);
        const message = `Evaluated Pyret expression: ${originalExpression}
Added ${atomCount} atoms and ${relationCount} relation tuples` + (extractedCndSpec ? "\nExtracted CnD specification from result" : "");
        return {
          success: true,
          message,
          action: "add",
          extractedCndSpec
        };
      } catch (error) {
        return {
          success: false,
          message: `Failed to convert Pyret result to data instance: ${this.formatError(error)}`
        };
      }
    }
    /**
     * Fallback method for adding data when addFromDataInstance is not available
     */
    fallbackAddToInstance(tempInstance, instance, originalExpression, extractedCndSpec) {
      let atomsAdded = 0;
      let relationsAdded = 0;
      for (const atom of tempInstance.getAtoms()) {
        try {
          let uniqueId = atom.id;
          const existingIds = new Set(instance.getAtoms().map((a) => a.id));
          let counter = 1;
          while (existingIds.has(uniqueId)) {
            uniqueId = `${atom.id}_${counter}`;
            counter++;
          }
          const atomToAdd = { ...atom, id: uniqueId };
          instance.addAtom(atomToAdd);
          atomsAdded++;
        } catch (error) {
          console.warn("Failed to add atom:", error);
        }
      }
      for (const relation of tempInstance.getRelations()) {
        for (const tuple of relation.tuples) {
          try {
            instance.addRelationTuple(relation.name, tuple);
            relationsAdded++;
          } catch (error) {
            console.warn("Failed to add relation tuple:", error);
          }
        }
      }
      const message = `Evaluated Pyret expression: ${originalExpression}
Added ${atomsAdded} atoms and ${relationsAdded} relation tuples` + (extractedCndSpec ? "\nExtracted CnD specification from result" : "");
      return {
        success: true,
        message,
        action: "add",
        extractedCndSpec
      };
    }
    /**
     * Format Pyret evaluation errors for display
     */
    formatError(error) {
      if (!error) {
        return "Unknown error";
      }
      if (typeof error === "string") {
        return error;
      }
      if (typeof error === "object" && error !== null) {
        const errorObj = error;
        if (errorObj.message) {
          return errorObj.message;
        }
        if (errorObj.toString && typeof errorObj.toString === "function") {
          return errorObj.toString();
        }
      }
      return String(error);
    }
    getHelp() {
      const baseHelp = [
        "Pyret Expression Commands (requires external evaluator):",
        "  reify                                - Convert current data instance back to Pyret expressions",
        '  edge("id", "label", weight)          - Add edge data structure',
        "  [list: 1, 2, 3, 4]                  - Add Pyret list",
        "  tree(left, right)                   - Add tree data structure",
        "  table: col1, col2 row: val1, val2 end - Add table data structure",
        "",
        "This parser can evaluate arbitrary Pyret expressions and convert",
        "the results into atoms and relations in the data instance."
      ];
      if (!this.evaluator) {
        return [
          ...baseHelp,
          "",
          "\u26A0\uFE0F  External Pyret evaluator not available.",
          "This parser requires window.__internalRepl or similar.",
          'The "reify" command works without external evaluator.'
        ];
      }
      return [
        ...baseHelp,
        "",
        "\u2713 External Pyret evaluator is available.",
        "You can use any valid Pyret expression."
      ];
    }
  };

  // src/components/ReplInterface/parsers/PyretIdAllocationParser.ts
  var PyretIdAllocationParser = class {
    constructor(evaluator) {
      this.evaluator = evaluator || null;
    }
    /**
     * Update the external evaluator
     */
    setEvaluator(evaluator) {
      this.evaluator = evaluator;
    }
    canHandle(command) {
      const trimmed = command.trim();
      if (!trimmed.includes("=")) {
        return false;
      }
      if (trimmed.startsWith("remove ")) {
        return false;
      }
      const utilityCommands = ["help", "info", "status", "list", "clear", "reify"];
      if (utilityCommands.includes(trimmed.toLowerCase())) {
        return false;
      }
      if (trimmed.includes(".") && trimmed.includes("=")) {
        const dotIndex = trimmed.indexOf(".");
        const equalsIndex = trimmed.indexOf("=");
        if (dotIndex < equalsIndex) {
          return false;
        }
      }
      const assignmentMatch = trimmed.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s*=(?!=)\s*(.+)$/);
      if (!assignmentMatch) {
        return false;
      }
      const [, id, expression] = assignmentMatch;
      if (!this.isValidId(id)) {
        return false;
      }
      return this.looksLikePyretExpression(expression);
    }
    getPriority() {
      return 110;
    }
    getCommandPatterns() {
      return [
        "x = 1",
        'alice = "Alice"',
        "node = Black(...)",
        "mylist = [list: 1, 2, 3]",
        "tree = node(1, empty, empty)"
      ];
    }
    async execute(command, instance) {
      const trimmed = command.trim();
      const assignmentMatch = trimmed.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s*=(?!=)\s*(.+)$/);
      if (!assignmentMatch) {
        return {
          success: false,
          message: "Invalid assignment syntax. Use: id = expression"
        };
      }
      const [, assignedId, expression] = assignmentMatch;
      try {
        const existingAtom = instance.getAtoms().find((a) => a.id === assignedId);
        if (existingAtom) {
          return {
            success: false,
            message: `ID '${assignedId}' is already in use. Use a different ID or remove the existing atom first.`
          };
        }
        if (this.isPrimitiveExpression(expression)) {
          return this.handlePrimitiveAssignment(assignedId, expression, instance);
        }
        if (!this.evaluator) {
          return {
            success: false,
            message: "No external Pyret evaluator available. Cannot evaluate complex expressions.\n\nTo enable this feature, ensure window.__internalRepl is available."
          };
        }
        return await this.handleComplexAssignment(assignedId, expression, instance);
      } catch (error) {
        return {
          success: false,
          message: `Failed to assign '${assignedId}': ${error instanceof Error ? error.message : "Unknown error"}`
        };
      }
    }
    isValidId(id) {
      const reservedWords = ["add", "remove", "help", "info", "list", "clear", "reify"];
      return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(id) && !reservedWords.includes(id.toLowerCase());
    }
    looksLikePyretExpression(expression) {
      const trimmed = expression.trim();
      if (this.isPrimitiveExpression(trimmed)) {
        return true;
      }
      return (
        // Function calls or constructors
        trimmed.includes("(") && trimmed.includes(")") || // Lists or collections
        trimmed.includes("[") && trimmed.includes("]") || // Tables
        trimmed.includes("table:") || trimmed.includes("row:")
      );
    }
    isPrimitiveExpression(expression) {
      const trimmed = expression.trim();
      return (
        // Numbers (including floats)
        /^\d+(\.\d+)?$/.test(trimmed) || // Strings
        /^['"`].*['"`]$/.test(trimmed) || // Booleans
        trimmed === "true" || trimmed === "false"
      );
    }
    handlePrimitiveAssignment(assignedId, expression, instance) {
      const trimmed = expression.trim();
      let value;
      let type2;
      if (/^\d+(\.\d+)?$/.test(trimmed)) {
        value = trimmed.includes(".") ? parseFloat(trimmed) : parseInt(trimmed);
        type2 = "Number";
      } else if (/^['"`](.*)['"`]$/.test(trimmed)) {
        value = trimmed.slice(1, -1);
        type2 = "String";
      } else if (trimmed === "true" || trimmed === "false") {
        value = trimmed === "true";
        type2 = "Boolean";
      } else {
        return {
          success: false,
          message: `Cannot parse primitive value: ${expression}`
        };
      }
      const atom = {
        id: assignedId,
        label: String(value),
        type: type2
      };
      instance.addAtom(atom);
      return {
        success: true,
        message: `[${assignedId}] Assigned ${assignedId} = ${value} (${type2})`,
        action: "add"
      };
    }
    async handleComplexAssignment(assignedId, expression, instance) {
      if (!this.evaluator) {
        throw new Error("External evaluator not available");
      }
      try {
        const evaluationResult = await this.evaluator.run(expression);
        if (!this.evaluator.runtime.isSuccessResult(evaluationResult)) {
          return {
            success: false,
            message: `Failed to evaluate expression '${expression}': ${this.formatError(evaluationResult.exn)}`
          };
        }
        const tempInstance = await PyretDataInstance.fromExpression(
          expression,
          false,
          // showFunctions
          this.evaluator
        );
        if (tempInstance.getAtoms().length === 0) {
          return {
            success: false,
            message: `Expression '${expression}' did not produce any data structures`
          };
        }
        const rootAtoms = tempInstance.getAtoms();
        const rootAtom = rootAtoms[0];
        const assignedAtom = {
          id: assignedId,
          label: rootAtom.label,
          type: rootAtom.type
        };
        instance.addAtom(assignedAtom);
        if (rootAtoms.length > 1 || tempInstance.getRelations().length > 0) {
          await this.mergeInstanceWithIdMapping(tempInstance, instance, rootAtom.id, assignedId);
        }
        const atomCount = rootAtoms.length;
        const relationCount = tempInstance.getRelations().reduce((sum, rel) => sum + rel.tuples.length, 0);
        return {
          success: true,
          message: `[${assignedId}] Assigned ${assignedId} = ${expression}
Added ${atomCount} atoms and ${relationCount} relation tuples`,
          action: "add"
        };
      } catch (error) {
        return {
          success: false,
          message: `Failed to evaluate and assign '${expression}': ${error instanceof Error ? error.message : "Unknown error"}`
        };
      }
    }
    async mergeInstanceWithIdMapping(sourceInstance, targetInstance, oldRootId, newRootId) {
      const idMapping = /* @__PURE__ */ new Map();
      idMapping.set(oldRootId, newRootId);
      for (const atom of sourceInstance.getAtoms()) {
        if (atom.id === oldRootId) continue;
        let uniqueId = atom.id;
        const existingIds = new Set(targetInstance.getAtoms().map((a) => a.id));
        let counter = 1;
        while (existingIds.has(uniqueId)) {
          uniqueId = `${atom.id}_${counter}`;
          counter++;
        }
        idMapping.set(atom.id, uniqueId);
        const mappedAtom = {
          id: uniqueId,
          label: atom.label,
          type: atom.type
        };
        targetInstance.addAtom(mappedAtom);
      }
      for (const relation of sourceInstance.getRelations()) {
        for (const tuple of relation.tuples) {
          const mappedAtoms = tuple.atoms.map((atomId) => idMapping.get(atomId) || atomId);
          targetInstance.addRelationTuple(relation.name, {
            atoms: mappedAtoms
          });
        }
      }
    }
    formatError(error) {
      if (error && typeof error === "object" && "message" in error) {
        return String(error.message);
      }
      return String(error);
    }
    getHelp() {
      const baseHelp = [
        "ID Allocation Commands (Pyret-style):",
        "  id = expression                 - Assign specific ID to expression result",
        "",
        "Primitive Examples:",
        '  x = 1                           - Assign ID "x" to number 1',
        '  name = "Alice"                  - Assign ID "name" to string "Alice"',
        '  flag = true                     - Assign ID "flag" to boolean true'
      ];
      if (this.evaluator) {
        baseHelp.push(
          "",
          "Complex Examples (with external evaluator):",
          '  node = Black(1, 2)              - Assign ID "node" to constructor result',
          '  mylist = [list: 1, 2, 3]        - Assign ID "mylist" to list',
          '  tree = node(1, empty, empty)    - Assign ID "tree" to tree structure'
        );
      } else {
        baseHelp.push(
          "",
          "Note: Complex expressions require external Pyret evaluator",
          "      Only primitive values (numbers, strings, booleans) are supported"
        );
      }
      return baseHelp;
    }
  };

  // src/components/ReplInterface/PyretReplInterface.tsx
  var import_jsx_runtime24 = __toESM(require_jsx_runtime());
  function createEmptyPyretDataInstance() {
    const emptyPyretObject = {
      dict: {},
      brands: {}
    };
    return new PyretDataInstance(emptyPyretObject);
  }
  var PyretReplInterface = ({
    initialInstance,
    onChange,
    onCndSpecExtracted,
    externalEvaluator,
    ...replProps
  }) => {
    const [instance, setInstance] = (0, import_react10.useState)(
      () => initialInstance || createEmptyPyretDataInstance()
    );
    const terminals = (0, import_react10.useMemo)(() => {
      const pyretExpressionParser = new PyretExpressionParser(externalEvaluator);
      const pyretIdAllocationParser = new PyretIdAllocationParser(externalEvaluator);
      const baseTerminals = [
        {
          id: "unified",
          title: externalEvaluator ? "Full Pyret REPL" : "Enhanced REPL",
          description: externalEvaluator ? "Supports ID allocation (x=1), expression evaluation, and enhanced remove commands" : "Supports ID allocation (x=1), enhanced remove commands, and basic operations",
          parsers: [
            new RemoveCommandParser(),
            // Priority 200 - highest priority for remove commands
            new DotNotationRelationParser(),
            // Priority 115 - dot notation relations
            pyretIdAllocationParser,
            // Priority 110 - ID allocation syntax (x=1)
            new AtomCommandParser(),
            // Priority 100 - standard atom commands (Label:Type)
            pyretExpressionParser,
            // Priority 90 - Pyret expressions (only if evaluator available)
            new InfoCommandParser()
            // Priority 50 - fallback utility commands
          ].filter((parser) => {
            if (parser instanceof PyretExpressionParser && !externalEvaluator) {
              return false;
            }
            return true;
          }).sort((a, b) => b.getPriority() - a.getPriority()),
          // Sort by priority descending
          placeholder: 'x = 1\nalice = "Alice"\nremove alice.friend\nlist-ids'
        }
      ];
      return baseTerminals;
    }, [externalEvaluator]);
    const handleInstanceChange = (updatedInstance) => {
      if (updatedInstance instanceof PyretDataInstance) {
        setInstance(updatedInstance);
        onChange?.(updatedInstance);
      }
    };
    (0, import_react10.useEffect)(() => {
      if (initialInstance && initialInstance !== instance) {
        setInstance(initialInstance);
      }
    }, [initialInstance]);
    return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
      ReplInterface,
      {
        instance,
        onChange: handleInstanceChange,
        onCndSpecExtracted,
        terminals,
        ...replProps
      }
    );
  };

  // src/components/ReplInterface/ReplWithVisualization.tsx
  var import_react11 = __toESM(require_react());
  var import_jsx_runtime25 = __toESM(require_jsx_runtime());
  var ReplWithVisualization = ({
    instance,
    onChange,
    initialCndSpec = "",
    showLayoutInterface = true,
    style,
    replHeight = "300px",
    visualizationHeight = "400px"
  }) => {
    const [currentInstance, setCurrentInstance] = (0, import_react11.useState)(instance);
    const [cndSpec, setCndSpec] = (0, import_react11.useState)(initialCndSpec);
    (0, import_react11.useEffect)(() => {
      setCurrentInstance(instance);
    }, [instance]);
    const handleInstanceChange = (updatedInstance) => {
      setCurrentInstance(updatedInstance);
      onChange?.(updatedInstance);
    };
    const handleCndSpecChange = (newSpec) => {
      setCndSpec(newSpec);
    };
    const containerStyle = {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      backgroundColor: "#f8f9fa",
      border: "1px solid #dee2e6",
      borderRadius: "8px",
      overflow: "hidden",
      ...style
    };
    const sectionStyle = {
      padding: "16px",
      borderBottom: "1px solid #dee2e6"
    };
    const headerStyle = {
      margin: "0 0 12px 0",
      fontSize: "14px",
      fontWeight: "bold",
      color: "#495057"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { style: containerStyle, children: [
      /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { style: { ...sectionStyle, height: replHeight, minHeight: "250px" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("h3", { style: headerStyle, children: "Command Interface" }),
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("div", { style: { height: `calc(${replHeight} - 40px)` }, children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
          ReplInterface,
          {
            instance: currentInstance,
            onChange: handleInstanceChange
          }
        ) })
      ] }),
      showLayoutInterface && /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { style: { ...sectionStyle, height: "200px", minHeight: "150px" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("h3", { style: headerStyle, children: "Layout Specification" }),
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("div", { style: { height: "calc(200px - 40px)" }, children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
          CndLayoutInterface,
          {
            instance: currentInstance,
            value: cndSpec,
            onChange: handleCndSpecChange
          }
        ) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { style: {
        ...sectionStyle,
        height: visualizationHeight,
        minHeight: "300px",
        borderBottom: "none",
        flex: 1
      }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("h3", { style: headerStyle, children: "Visualization" }),
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("div", { style: {
          height: `calc(${visualizationHeight} - 40px)`,
          backgroundColor: "white",
          border: "1px solid #ccc",
          borderRadius: "4px",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          color: "#6c757d"
        }, children: /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { style: { textAlign: "center" }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("div", { style: { fontSize: "48px", marginBottom: "16px" }, children: "\u{1F4CA}" }),
          /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("div", { children: "Visualization area ready for webcola-cnd-graph integration" }),
          /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { style: { marginTop: "8px", fontSize: "12px" }, children: [
            "Current data: ",
            currentInstance.getAtoms().length,
            " atoms, ",
            currentInstance.getRelations().length,
            " relations"
          ] }),
          cndSpec && /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { style: { marginTop: "8px", fontSize: "12px", color: "#28a745" }, children: [
            "CND spec: ",
            cndSpec.length,
            " characters"
          ] })
        ] }) })
      ] })
    ] });
  };

  // src/components/CombinedInput/mounting.tsx
  var import_client = __toESM(require_client());

  // src/components/CombinedInput/CombinedInputComponent.tsx
  var import_react12 = __toESM(require_react());

  // src/evaluators/sgq-evaluator.ts
  var import_simple_graph_query = __toESM(require_simple_graph_query_bundle());
  function isDataInstance(value) {
    return value.getAtoms !== void 0 && value.getRelations !== void 0 && value.getTypes !== void 0 && value.applyProjections !== void 0 && value.generateGraph !== void 0;
  }
  function isErrorResult(result) {
    return result.error !== void 0;
  }
  function isSingleValue(value) {
    return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
  }
  function singleValueToString(value) {
    if (typeof value === "string") {
      return value;
    } else if (typeof value === "number") {
      return value.toString();
    } else if (typeof value === "boolean") {
      return value ? "true" : "false";
    }
    throw new Error("Invalid SingleValue type");
  }
  var SGQEvaluatorResult = class {
    constructor(result, expr) {
      this.isErrorResult = false;
      this.isSingletonResult = false;
      this.result = result;
      this.expr = expr;
      this.isErrorResult = isErrorResult(result);
      this.isSingletonResult = isSingleValue(result);
    }
    isError() {
      return this.isErrorResult;
    }
    isSingleton() {
      return this.isSingletonResult;
    }
    getExpression() {
      return this.expr;
    }
    noResult() {
      return !this.isErrorResult && (Array.isArray(this.result) && this.result.length === 0);
    }
    getRawResult() {
      if (this.isErrorResult) {
        const errorResult = this.result;
        return {
          error: {
            message: errorResult.error.message,
            code: "FORGE_ERROR"
          }
        };
      }
      if (this.isSingletonResult) {
        return this.result;
      }
      return this.result;
    }
    prettyPrint() {
      if (typeof this.result === "string") {
        return this.result;
      } else if (typeof this.result === "number") {
        return this.result.toString();
      } else if (typeof this.result === "boolean") {
        return this.result ? "true" : "false";
      } else if (this.isErrorResult) {
        let errorResult = this.result;
        return `Error: ${errorResult.error.message}`;
      } else {
        let tupleStringArray = [];
        let asTuple = this.result;
        for (let i = 0; i < asTuple.length; i++) {
          let tuple = asTuple[i];
          let tupleString = tuple.join("->");
          tupleStringArray.push(tupleString);
        }
        let resultString = tupleStringArray.join(" , ");
        return resultString;
      }
    }
    singleResult() {
      if (!this.isSingletonResult) {
        let pp = this.prettyPrint();
        throw new Error(`Expected selector ${this.expr} to evaluate to a single value. Instead:${pp}`);
      }
      return this.result;
    }
    selectedAtoms() {
      if (this.isSingletonResult || this.isErrorResult) {
        let pp = this.prettyPrint();
        throw new Error(`Expected selector ${this.expr} to evaluate to values of arity 1. Instead: ${pp}`);
      }
      let asTuple = this.result;
      let selectedElements = asTuple.filter((element) => element.length > 0);
      if (selectedElements.length === 0) {
        return [];
      }
      selectedElements = selectedElements.filter((element) => element.length === 1);
      let flattened = selectedElements.flat().map((element) => singleValueToString(element));
      let uniqueElements = Array.from(new Set(flattened));
      return uniqueElements;
    }
    selectedTwoples() {
      if (this.isSingletonResult || this.isErrorResult) {
        let pp = this.prettyPrint();
        throw new Error(`Expected selector ${this.expr} to evaluate to values of arity 2. Instead:${pp}`);
      }
      let asTuple = this.result;
      let selectedElements = asTuple.filter((element) => element.length > 1);
      if (selectedElements.length === 0) {
        return [];
      }
      let selectedTuples = selectedElements.map((element) => {
        return [element[0], element[element.length - 1]];
      }).map((element) => {
        return element.map((e) => singleValueToString(e));
      });
      return selectedTuples;
    }
    selectedTuplesAll() {
      if (this.isSingletonResult || this.isErrorResult) {
        let pp = this.prettyPrint();
        throw new Error(`Expected selector ${this.expr} to evaluate to values of arity 2. Instead:${pp}`);
      }
      let asTuple = this.result;
      let selectedElements = asTuple.filter((element) => element.length > 1);
      if (selectedElements.length === 0) {
        return [];
      }
      let selectedTuples = selectedElements.map((element) => {
        return element.map((e) => singleValueToString(e));
      });
      return selectedTuples;
    }
  };
  var SGraphQueryEvaluator = class {
    constructor() {
      this.ready = false;
    }
    initialize(context) {
      this.context = context;
      console.log("Initializing SimpleGraphQueryEvaluator with context.sourceData:", context.sourceData);
      if (!context.sourceData || !isDataInstance(context.sourceData)) {
        console.log("Invalid context.sourceData:", context.sourceData);
        throw new Error("Invalid context.sourceData: Expected an instance of IDataInstance");
      }
      const id = context.sourceData;
      this.eval = new import_simple_graph_query.SimpleGraphQueryEvaluator(id);
      console.log("SimpleGraphQueryEvaluator initialized with context:", context);
      this.ready = true;
    }
    isReady() {
      return this.ready;
    }
    evaluate(expression, config) {
      if (!this.isReady()) {
        throw new Error("Evaluator not initialized");
      }
      const result = this.eval.evaluateExpression(expression);
      const wrappedResult = new SGQEvaluatorResult(result, expression);
      return wrappedResult;
    }
  };

  // node_modules/kiwi.js/es/maptype.js
  function createMap() {
    return new IndexedMap();
  }
  var IndexedMap = (
    /** @class */
    function() {
      function IndexedMap2() {
        this.index = {};
        this.array = [];
      }
      IndexedMap2.prototype.size = function() {
        return this.array.length;
      };
      IndexedMap2.prototype.empty = function() {
        return this.array.length === 0;
      };
      IndexedMap2.prototype.itemAt = function(index) {
        return this.array[index];
      };
      IndexedMap2.prototype.contains = function(key) {
        return this.index[key.id()] !== void 0;
      };
      IndexedMap2.prototype.find = function(key) {
        var i = this.index[key.id()];
        return i === void 0 ? void 0 : this.array[i];
      };
      IndexedMap2.prototype.setDefault = function(key, factory) {
        var i = this.index[key.id()];
        if (i === void 0) {
          var pair = new Pair(key, factory());
          this.index[key.id()] = this.array.length;
          this.array.push(pair);
          return pair;
        } else {
          return this.array[i];
        }
      };
      IndexedMap2.prototype.insert = function(key, value) {
        var pair = new Pair(key, value);
        var i = this.index[key.id()];
        if (i === void 0) {
          this.index[key.id()] = this.array.length;
          this.array.push(pair);
        } else {
          this.array[i] = pair;
        }
        return pair;
      };
      IndexedMap2.prototype.erase = function(key) {
        var i = this.index[key.id()];
        if (i === void 0) {
          return void 0;
        }
        this.index[key.id()] = void 0;
        var pair = this.array[i];
        var last = this.array.pop();
        if (pair !== last) {
          this.array[i] = last;
          this.index[last.first.id()] = i;
        }
        return pair;
      };
      IndexedMap2.prototype.copy = function() {
        var copy = new IndexedMap2();
        for (var i = 0; i < this.array.length; i++) {
          var pair = this.array[i].copy();
          copy.array[i] = pair;
          copy.index[pair.first.id()] = i;
        }
        return copy;
      };
      return IndexedMap2;
    }()
  );
  var Pair = (
    /** @class */
    function() {
      function Pair2(first, second) {
        this.first = first;
        this.second = second;
      }
      Pair2.prototype.copy = function() {
        return new Pair2(this.first, this.second);
      };
      return Pair2;
    }()
  );

  // node_modules/kiwi.js/es/variable.js
  var Variable = (
    /** @class */
    function() {
      function Variable2(name) {
        if (name === void 0) {
          name = "";
        }
        this._value = 0;
        this._context = null;
        this._id = VarId++;
        this._name = name;
      }
      Variable2.prototype.id = function() {
        return this._id;
      };
      Variable2.prototype.name = function() {
        return this._name;
      };
      Variable2.prototype.setName = function(name) {
        this._name = name;
      };
      Variable2.prototype.context = function() {
        return this._context;
      };
      Variable2.prototype.setContext = function(context) {
        this._context = context;
      };
      Variable2.prototype.value = function() {
        return this._value;
      };
      Variable2.prototype.setValue = function(value) {
        this._value = value;
      };
      Variable2.prototype.plus = function(value) {
        return new Expression(this, value);
      };
      Variable2.prototype.minus = function(value) {
        return new Expression(this, typeof value === "number" ? -value : [-1, value]);
      };
      Variable2.prototype.multiply = function(coefficient) {
        return new Expression([coefficient, this]);
      };
      Variable2.prototype.divide = function(coefficient) {
        return new Expression([1 / coefficient, this]);
      };
      Variable2.prototype.toJSON = function() {
        return {
          name: this._name,
          value: this._value
        };
      };
      Variable2.prototype.toString = function() {
        return this._context + "[" + this._name + ":" + this._value + "]";
      };
      return Variable2;
    }()
  );
  var VarId = 0;

  // node_modules/kiwi.js/es/expression.js
  var Expression = (
    /** @class */
    function() {
      function Expression3() {
        var parsed = parseArgs(arguments);
        this._terms = parsed.terms;
        this._constant = parsed.constant;
      }
      Expression3.prototype.terms = function() {
        return this._terms;
      };
      Expression3.prototype.constant = function() {
        return this._constant;
      };
      Expression3.prototype.value = function() {
        var result = this._constant;
        for (var i = 0, n = this._terms.size(); i < n; i++) {
          var pair = this._terms.itemAt(i);
          result += pair.first.value() * pair.second;
        }
        return result;
      };
      Expression3.prototype.plus = function(value) {
        return new Expression3(this, value);
      };
      Expression3.prototype.minus = function(value) {
        return new Expression3(this, typeof value === "number" ? -value : [-1, value]);
      };
      Expression3.prototype.multiply = function(coefficient) {
        return new Expression3([coefficient, this]);
      };
      Expression3.prototype.divide = function(coefficient) {
        return new Expression3([1 / coefficient, this]);
      };
      Expression3.prototype.isConstant = function() {
        return this._terms.size() == 0;
      };
      Expression3.prototype.toString = function() {
        var result = this._terms.array.map(function(pair) {
          return pair.second + "*" + pair.first.toString();
        }).join(" + ");
        if (!this.isConstant() && this._constant !== 0) {
          result += " + ";
        }
        result += this._constant;
        return result;
      };
      return Expression3;
    }()
  );
  function parseArgs(args) {
    var constant = 0;
    var factory = function() {
      return 0;
    };
    var terms = createMap();
    for (var i = 0, n = args.length; i < n; ++i) {
      var item = args[i];
      if (typeof item === "number") {
        constant += item;
      } else if (item instanceof Variable) {
        terms.setDefault(item, factory).second += 1;
      } else if (item instanceof Expression) {
        constant += item.constant();
        var terms2 = item.terms();
        for (var j = 0, k = terms2.size(); j < k; j++) {
          var termPair = terms2.itemAt(j);
          terms.setDefault(termPair.first, factory).second += termPair.second;
        }
      } else if (item instanceof Array) {
        if (item.length !== 2) {
          throw new Error("array must have length 2");
        }
        var value = item[0];
        var value2 = item[1];
        if (typeof value !== "number") {
          throw new Error("array item 0 must be a number");
        }
        if (value2 instanceof Variable) {
          terms.setDefault(value2, factory).second += value;
        } else if (value2 instanceof Expression) {
          constant += value2.constant() * value;
          var terms2 = value2.terms();
          for (var j = 0, k = terms2.size(); j < k; j++) {
            var termPair = terms2.itemAt(j);
            terms.setDefault(termPair.first, factory).second += termPair.second * value;
          }
        } else {
          throw new Error("array item 1 must be a variable or expression");
        }
      } else {
        throw new Error("invalid Expression argument: " + item);
      }
    }
    return { terms, constant };
  }

  // node_modules/kiwi.js/es/strength.js
  var Strength = (
    /** @class */
    function() {
      function Strength2() {
      }
      Strength2.create = function(a, b, c, w) {
        if (w === void 0) {
          w = 1;
        }
        var result = 0;
        result += Math.max(0, Math.min(1e3, a * w)) * 1e6;
        result += Math.max(0, Math.min(1e3, b * w)) * 1e3;
        result += Math.max(0, Math.min(1e3, c * w));
        return result;
      };
      Strength2.clip = function(value) {
        return Math.max(0, Math.min(Strength2.required, value));
      };
      Strength2.required = Strength2.create(1e3, 1e3, 1e3);
      Strength2.strong = Strength2.create(1, 0, 0);
      Strength2.medium = Strength2.create(0, 1, 0);
      Strength2.weak = Strength2.create(0, 0, 1);
      return Strength2;
    }()
  );

  // node_modules/kiwi.js/es/constraint.js
  var Operator;
  (function(Operator2) {
    Operator2[Operator2["Le"] = 0] = "Le";
    Operator2[Operator2["Ge"] = 1] = "Ge";
    Operator2[Operator2["Eq"] = 2] = "Eq";
  })(Operator || (Operator = {}));
  var Constraint = (
    /** @class */
    function() {
      function Constraint2(expression, operator, rhs, strength) {
        if (strength === void 0) {
          strength = Strength.required;
        }
        this._id = CnId++;
        this._operator = operator;
        this._strength = Strength.clip(strength);
        if (rhs === void 0 && expression instanceof Expression) {
          this._expression = expression;
        } else {
          this._expression = expression.minus(rhs);
        }
      }
      Constraint2.prototype.id = function() {
        return this._id;
      };
      Constraint2.prototype.expression = function() {
        return this._expression;
      };
      Constraint2.prototype.op = function() {
        return this._operator;
      };
      Constraint2.prototype.strength = function() {
        return this._strength;
      };
      Constraint2.prototype.toString = function() {
        return this._expression.toString() + " " + ["<=", ">=", "="][this._operator] + " 0 (" + this._strength.toString() + ")";
      };
      return Constraint2;
    }()
  );
  var CnId = 0;

  // node_modules/kiwi.js/es/solver.js
  var Solver = (
    /** @class */
    function() {
      function Solver2() {
        this._cnMap = createCnMap();
        this._rowMap = createRowMap();
        this._varMap = createVarMap();
        this._editMap = createEditMap();
        this._infeasibleRows = [];
        this._objective = new Row();
        this._artificial = null;
        this._idTick = 0;
      }
      Solver2.prototype.createConstraint = function(lhs, operator, rhs, strength) {
        if (strength === void 0) {
          strength = Strength.required;
        }
        var cn = new Constraint(lhs, operator, rhs, strength);
        this.addConstraint(cn);
        return cn;
      };
      Solver2.prototype.addConstraint = function(constraint) {
        var cnPair = this._cnMap.find(constraint);
        if (cnPair !== void 0) {
          throw new Error("duplicate constraint");
        }
        var data = this._createRow(constraint);
        var row = data.row;
        var tag = data.tag;
        var subject = this._chooseSubject(row, tag);
        if (subject.type() === SymbolType.Invalid && row.allDummies()) {
          if (!nearZero(row.constant())) {
            throw new Error("unsatisfiable constraint");
          } else {
            subject = tag.marker;
          }
        }
        if (subject.type() === SymbolType.Invalid) {
          if (!this._addWithArtificialVariable(row)) {
            throw new Error("unsatisfiable constraint");
          }
        } else {
          row.solveFor(subject);
          this._substitute(subject, row);
          this._rowMap.insert(subject, row);
        }
        this._cnMap.insert(constraint, tag);
        this._optimize(this._objective);
      };
      Solver2.prototype.removeConstraint = function(constraint) {
        var cnPair = this._cnMap.erase(constraint);
        if (cnPair === void 0) {
          throw new Error("unknown constraint");
        }
        this._removeConstraintEffects(constraint, cnPair.second);
        var marker = cnPair.second.marker;
        var rowPair = this._rowMap.erase(marker);
        if (rowPair === void 0) {
          var leaving = this._getMarkerLeavingSymbol(marker);
          if (leaving.type() === SymbolType.Invalid) {
            throw new Error("failed to find leaving row");
          }
          rowPair = this._rowMap.erase(leaving);
          rowPair.second.solveForEx(leaving, marker);
          this._substitute(marker, rowPair.second);
        }
        this._optimize(this._objective);
      };
      Solver2.prototype.hasConstraint = function(constraint) {
        return this._cnMap.contains(constraint);
      };
      Solver2.prototype.addEditVariable = function(variable, strength) {
        var editPair = this._editMap.find(variable);
        if (editPair !== void 0) {
          throw new Error("duplicate edit variable");
        }
        strength = Strength.clip(strength);
        if (strength === Strength.required) {
          throw new Error("bad required strength");
        }
        var expr = new Expression(variable);
        var cn = new Constraint(expr, Operator.Eq, void 0, strength);
        this.addConstraint(cn);
        var tag = this._cnMap.find(cn).second;
        var info = { tag, constraint: cn, constant: 0 };
        this._editMap.insert(variable, info);
      };
      Solver2.prototype.removeEditVariable = function(variable) {
        var editPair = this._editMap.erase(variable);
        if (editPair === void 0) {
          throw new Error("unknown edit variable");
        }
        this.removeConstraint(editPair.second.constraint);
      };
      Solver2.prototype.hasEditVariable = function(variable) {
        return this._editMap.contains(variable);
      };
      Solver2.prototype.suggestValue = function(variable, value) {
        var editPair = this._editMap.find(variable);
        if (editPair === void 0) {
          throw new Error("unknown edit variable");
        }
        var rows = this._rowMap;
        var info = editPair.second;
        var delta = value - info.constant;
        info.constant = value;
        var marker = info.tag.marker;
        var rowPair = rows.find(marker);
        if (rowPair !== void 0) {
          if (rowPair.second.add(-delta) < 0) {
            this._infeasibleRows.push(marker);
          }
          this._dualOptimize();
          return;
        }
        var other = info.tag.other;
        rowPair = rows.find(other);
        if (rowPair !== void 0) {
          if (rowPair.second.add(delta) < 0) {
            this._infeasibleRows.push(other);
          }
          this._dualOptimize();
          return;
        }
        for (var i = 0, n = rows.size(); i < n; ++i) {
          var rowPair_1 = rows.itemAt(i);
          var row = rowPair_1.second;
          var coeff = row.coefficientFor(marker);
          if (coeff !== 0 && row.add(delta * coeff) < 0 && rowPair_1.first.type() !== SymbolType.External) {
            this._infeasibleRows.push(rowPair_1.first);
          }
        }
        this._dualOptimize();
      };
      Solver2.prototype.updateVariables = function() {
        var vars = this._varMap;
        var rows = this._rowMap;
        for (var i = 0, n = vars.size(); i < n; ++i) {
          var pair = vars.itemAt(i);
          var rowPair = rows.find(pair.second);
          if (rowPair !== void 0) {
            pair.first.setValue(rowPair.second.constant());
          } else {
            pair.first.setValue(0);
          }
        }
      };
      Solver2.prototype._getVarSymbol = function(variable) {
        var _this = this;
        var factory = function() {
          return _this._makeSymbol(SymbolType.External);
        };
        return this._varMap.setDefault(variable, factory).second;
      };
      Solver2.prototype._createRow = function(constraint) {
        var expr = constraint.expression();
        var row = new Row(expr.constant());
        var terms = expr.terms();
        for (var i = 0, n = terms.size(); i < n; ++i) {
          var termPair = terms.itemAt(i);
          if (!nearZero(termPair.second)) {
            var symbol = this._getVarSymbol(termPair.first);
            var basicPair = this._rowMap.find(symbol);
            if (basicPair !== void 0) {
              row.insertRow(basicPair.second, termPair.second);
            } else {
              row.insertSymbol(symbol, termPair.second);
            }
          }
        }
        var objective = this._objective;
        var strength = constraint.strength();
        var tag = { marker: INVALID_SYMBOL, other: INVALID_SYMBOL };
        switch (constraint.op()) {
          case Operator.Le:
          case Operator.Ge: {
            var coeff = constraint.op() === Operator.Le ? 1 : -1;
            var slack = this._makeSymbol(SymbolType.Slack);
            tag.marker = slack;
            row.insertSymbol(slack, coeff);
            if (strength < Strength.required) {
              var error = this._makeSymbol(SymbolType.Error);
              tag.other = error;
              row.insertSymbol(error, -coeff);
              objective.insertSymbol(error, strength);
            }
            break;
          }
          case Operator.Eq: {
            if (strength < Strength.required) {
              var errplus = this._makeSymbol(SymbolType.Error);
              var errminus = this._makeSymbol(SymbolType.Error);
              tag.marker = errplus;
              tag.other = errminus;
              row.insertSymbol(errplus, -1);
              row.insertSymbol(errminus, 1);
              objective.insertSymbol(errplus, strength);
              objective.insertSymbol(errminus, strength);
            } else {
              var dummy = this._makeSymbol(SymbolType.Dummy);
              tag.marker = dummy;
              row.insertSymbol(dummy);
            }
            break;
          }
        }
        if (row.constant() < 0) {
          row.reverseSign();
        }
        return { row, tag };
      };
      Solver2.prototype._chooseSubject = function(row, tag) {
        var cells = row.cells();
        for (var i = 0, n = cells.size(); i < n; ++i) {
          var pair = cells.itemAt(i);
          if (pair.first.type() === SymbolType.External) {
            return pair.first;
          }
        }
        var type2 = tag.marker.type();
        if (type2 === SymbolType.Slack || type2 === SymbolType.Error) {
          if (row.coefficientFor(tag.marker) < 0) {
            return tag.marker;
          }
        }
        type2 = tag.other.type();
        if (type2 === SymbolType.Slack || type2 === SymbolType.Error) {
          if (row.coefficientFor(tag.other) < 0) {
            return tag.other;
          }
        }
        return INVALID_SYMBOL;
      };
      Solver2.prototype._addWithArtificialVariable = function(row) {
        var art = this._makeSymbol(SymbolType.Slack);
        this._rowMap.insert(art, row.copy());
        this._artificial = row.copy();
        this._optimize(this._artificial);
        var success = nearZero(this._artificial.constant());
        this._artificial = null;
        var pair = this._rowMap.erase(art);
        if (pair !== void 0) {
          var basicRow = pair.second;
          if (basicRow.isConstant()) {
            return success;
          }
          var entering = this._anyPivotableSymbol(basicRow);
          if (entering.type() === SymbolType.Invalid) {
            return false;
          }
          basicRow.solveForEx(art, entering);
          this._substitute(entering, basicRow);
          this._rowMap.insert(entering, basicRow);
        }
        var rows = this._rowMap;
        for (var i = 0, n = rows.size(); i < n; ++i) {
          rows.itemAt(i).second.removeSymbol(art);
        }
        this._objective.removeSymbol(art);
        return success;
      };
      Solver2.prototype._substitute = function(symbol, row) {
        var rows = this._rowMap;
        for (var i = 0, n = rows.size(); i < n; ++i) {
          var pair = rows.itemAt(i);
          pair.second.substitute(symbol, row);
          if (pair.second.constant() < 0 && pair.first.type() !== SymbolType.External) {
            this._infeasibleRows.push(pair.first);
          }
        }
        this._objective.substitute(symbol, row);
        if (this._artificial) {
          this._artificial.substitute(symbol, row);
        }
      };
      Solver2.prototype._optimize = function(objective) {
        while (true) {
          var entering = this._getEnteringSymbol(objective);
          if (entering.type() === SymbolType.Invalid) {
            return;
          }
          var leaving = this._getLeavingSymbol(entering);
          if (leaving.type() === SymbolType.Invalid) {
            throw new Error("the objective is unbounded");
          }
          var row = this._rowMap.erase(leaving).second;
          row.solveForEx(leaving, entering);
          this._substitute(entering, row);
          this._rowMap.insert(entering, row);
        }
      };
      Solver2.prototype._dualOptimize = function() {
        var rows = this._rowMap;
        var infeasible = this._infeasibleRows;
        while (infeasible.length !== 0) {
          var leaving = infeasible.pop();
          var pair = rows.find(leaving);
          if (pair !== void 0 && pair.second.constant() < 0) {
            var entering = this._getDualEnteringSymbol(pair.second);
            if (entering.type() === SymbolType.Invalid) {
              throw new Error("dual optimize failed");
            }
            var row = pair.second;
            rows.erase(leaving);
            row.solveForEx(leaving, entering);
            this._substitute(entering, row);
            rows.insert(entering, row);
          }
        }
      };
      Solver2.prototype._getEnteringSymbol = function(objective) {
        var cells = objective.cells();
        for (var i = 0, n = cells.size(); i < n; ++i) {
          var pair = cells.itemAt(i);
          var symbol = pair.first;
          if (pair.second < 0 && symbol.type() !== SymbolType.Dummy) {
            return symbol;
          }
        }
        return INVALID_SYMBOL;
      };
      Solver2.prototype._getDualEnteringSymbol = function(row) {
        var ratio = Number.MAX_VALUE;
        var entering = INVALID_SYMBOL;
        var cells = row.cells();
        for (var i = 0, n = cells.size(); i < n; ++i) {
          var pair = cells.itemAt(i);
          var symbol = pair.first;
          var c = pair.second;
          if (c > 0 && symbol.type() !== SymbolType.Dummy) {
            var coeff = this._objective.coefficientFor(symbol);
            var r = coeff / c;
            if (r < ratio) {
              ratio = r;
              entering = symbol;
            }
          }
        }
        return entering;
      };
      Solver2.prototype._getLeavingSymbol = function(entering) {
        var ratio = Number.MAX_VALUE;
        var found = INVALID_SYMBOL;
        var rows = this._rowMap;
        for (var i = 0, n = rows.size(); i < n; ++i) {
          var pair = rows.itemAt(i);
          var symbol = pair.first;
          if (symbol.type() !== SymbolType.External) {
            var row = pair.second;
            var temp2 = row.coefficientFor(entering);
            if (temp2 < 0) {
              var temp_ratio = -row.constant() / temp2;
              if (temp_ratio < ratio) {
                ratio = temp_ratio;
                found = symbol;
              }
            }
          }
        }
        return found;
      };
      Solver2.prototype._getMarkerLeavingSymbol = function(marker) {
        var dmax = Number.MAX_VALUE;
        var r1 = dmax;
        var r2 = dmax;
        var invalid = INVALID_SYMBOL;
        var first = invalid;
        var second = invalid;
        var third = invalid;
        var rows = this._rowMap;
        for (var i = 0, n = rows.size(); i < n; ++i) {
          var pair = rows.itemAt(i);
          var row = pair.second;
          var c = row.coefficientFor(marker);
          if (c === 0) {
            continue;
          }
          var symbol = pair.first;
          if (symbol.type() === SymbolType.External) {
            third = symbol;
          } else if (c < 0) {
            var r = -row.constant() / c;
            if (r < r1) {
              r1 = r;
              first = symbol;
            }
          } else {
            var r = row.constant() / c;
            if (r < r2) {
              r2 = r;
              second = symbol;
            }
          }
        }
        if (first !== invalid) {
          return first;
        }
        if (second !== invalid) {
          return second;
        }
        return third;
      };
      Solver2.prototype._removeConstraintEffects = function(cn, tag) {
        if (tag.marker.type() === SymbolType.Error) {
          this._removeMarkerEffects(tag.marker, cn.strength());
        }
        if (tag.other.type() === SymbolType.Error) {
          this._removeMarkerEffects(tag.other, cn.strength());
        }
      };
      Solver2.prototype._removeMarkerEffects = function(marker, strength) {
        var pair = this._rowMap.find(marker);
        if (pair !== void 0) {
          this._objective.insertRow(pair.second, -strength);
        } else {
          this._objective.insertSymbol(marker, -strength);
        }
      };
      Solver2.prototype._anyPivotableSymbol = function(row) {
        var cells = row.cells();
        for (var i = 0, n = cells.size(); i < n; ++i) {
          var pair = cells.itemAt(i);
          var type2 = pair.first.type();
          if (type2 === SymbolType.Slack || type2 === SymbolType.Error) {
            return pair.first;
          }
        }
        return INVALID_SYMBOL;
      };
      Solver2.prototype._makeSymbol = function(type2) {
        return new Symbol2(type2, this._idTick++);
      };
      return Solver2;
    }()
  );
  function nearZero(value) {
    var eps = 1e-8;
    return value < 0 ? -value < eps : value < eps;
  }
  function createCnMap() {
    return createMap();
  }
  function createRowMap() {
    return createMap();
  }
  function createVarMap() {
    return createMap();
  }
  function createEditMap() {
    return createMap();
  }
  var SymbolType;
  (function(SymbolType2) {
    SymbolType2[SymbolType2["Invalid"] = 0] = "Invalid";
    SymbolType2[SymbolType2["External"] = 1] = "External";
    SymbolType2[SymbolType2["Slack"] = 2] = "Slack";
    SymbolType2[SymbolType2["Error"] = 3] = "Error";
    SymbolType2[SymbolType2["Dummy"] = 4] = "Dummy";
  })(SymbolType || (SymbolType = {}));
  var Symbol2 = (
    /** @class */
    function() {
      function Symbol3(type2, id) {
        this._id = id;
        this._type = type2;
      }
      Symbol3.prototype.id = function() {
        return this._id;
      };
      Symbol3.prototype.type = function() {
        return this._type;
      };
      return Symbol3;
    }()
  );
  var INVALID_SYMBOL = new Symbol2(SymbolType.Invalid, -1);
  var Row = (
    /** @class */
    function() {
      function Row2(constant) {
        if (constant === void 0) {
          constant = 0;
        }
        this._cellMap = createMap();
        this._constant = constant;
      }
      Row2.prototype.cells = function() {
        return this._cellMap;
      };
      Row2.prototype.constant = function() {
        return this._constant;
      };
      Row2.prototype.isConstant = function() {
        return this._cellMap.empty();
      };
      Row2.prototype.allDummies = function() {
        var cells = this._cellMap;
        for (var i = 0, n = cells.size(); i < n; ++i) {
          var pair = cells.itemAt(i);
          if (pair.first.type() !== SymbolType.Dummy) {
            return false;
          }
        }
        return true;
      };
      Row2.prototype.copy = function() {
        var theCopy = new Row2(this._constant);
        theCopy._cellMap = this._cellMap.copy();
        return theCopy;
      };
      Row2.prototype.add = function(value) {
        return this._constant += value;
      };
      Row2.prototype.insertSymbol = function(symbol, coefficient) {
        if (coefficient === void 0) {
          coefficient = 1;
        }
        var pair = this._cellMap.setDefault(symbol, function() {
          return 0;
        });
        if (nearZero(pair.second += coefficient)) {
          this._cellMap.erase(symbol);
        }
      };
      Row2.prototype.insertRow = function(other, coefficient) {
        if (coefficient === void 0) {
          coefficient = 1;
        }
        this._constant += other._constant * coefficient;
        var cells = other._cellMap;
        for (var i = 0, n = cells.size(); i < n; ++i) {
          var pair = cells.itemAt(i);
          this.insertSymbol(pair.first, pair.second * coefficient);
        }
      };
      Row2.prototype.removeSymbol = function(symbol) {
        this._cellMap.erase(symbol);
      };
      Row2.prototype.reverseSign = function() {
        this._constant = -this._constant;
        var cells = this._cellMap;
        for (var i = 0, n = cells.size(); i < n; ++i) {
          var pair = cells.itemAt(i);
          pair.second = -pair.second;
        }
      };
      Row2.prototype.solveFor = function(symbol) {
        var cells = this._cellMap;
        var pair = cells.erase(symbol);
        var coeff = -1 / pair.second;
        this._constant *= coeff;
        for (var i = 0, n = cells.size(); i < n; ++i) {
          cells.itemAt(i).second *= coeff;
        }
      };
      Row2.prototype.solveForEx = function(lhs, rhs) {
        this.insertSymbol(lhs, -1);
        this.solveFor(rhs);
      };
      Row2.prototype.coefficientFor = function(symbol) {
        var pair = this._cellMap.find(symbol);
        return pair !== void 0 ? pair.second : 0;
      };
      Row2.prototype.substitute = function(symbol, row) {
        var pair = this._cellMap.erase(symbol);
        if (pair !== void 0) {
          this.insertRow(row, pair.second);
        }
      };
      return Row2;
    }()
  );

  // src/layout/interfaces.ts
  var ImplicitConstraint = class {
    constructor(c, reason) {
      this.c = c;
      this.reason = reason;
    }
    toHTML() {
      const origHTML = this.c.toHTML();
      return `Implicit constraint ${origHTML} because ${this.reason}`;
    }
  };
  function isTopConstraint(constraint) {
    return constraint.top !== void 0;
  }
  function isLeftConstraint(constraint) {
    return constraint.left !== void 0;
  }
  function isAlignmentConstraint(constraint) {
    return constraint.axis !== void 0;
  }

  // src/layout/layoutspec.ts
  var ConstraintOperation = class {
    constructor(selector) {
      this.selector = selector;
    }
    isInternallyConsistent() {
      return true;
    }
    inconsistencyMessage() {
      return `Inconsistent Constraint Operation: ${this.selector}`;
    }
    toHTML() {
      return `ConstraintOperation with selector <code>${this.selector} </code>.`;
    }
  };
  var RelativeOrientationConstraint = class extends ConstraintOperation {
    constructor(directions, selector) {
      super(selector);
      this.directions = directions;
    }
    isInternallyConsistent() {
      if (this.directions.includes("above") && this.directions.includes("below")) {
        return false;
      }
      if (this.directions.includes("left") && this.directions.includes("right")) {
        return false;
      }
      if (this.directions.includes("directlyLeft")) {
        if (!this.directions.every((direction) => direction === "left" || direction === "directlyLeft")) {
          return false;
        }
      }
      if (this.directions.includes("directlyRight")) {
        if (!this.directions.every((direction) => direction === "right" || direction === "directlyRight")) {
          return false;
        }
      }
      if (this.directions.includes("directlyAbove")) {
        if (!this.directions.every((direction) => direction === "above" || direction === "directlyAbove")) {
          return false;
        }
      }
      if (this.directions.includes("directlyBelow")) {
        if (!this.directions.every((direction) => direction === "below" || direction === "directlyBelow")) {
          return false;
        }
      }
      return true;
    }
    inconsistencyMessage() {
      let dirStr = this.directions.join(", ");
      return `Orientation Constraint with directions [${dirStr}] and selector <code>${this.selector}</code> is internally inconsistent.`;
    }
    toHTML() {
      let directions = this.directions.join(", ");
      return `OrientationConstraint with directions [${directions}] and selector <code>${this.selector}</code>`;
    }
  };
  var GroupBySelector = class extends ConstraintOperation {
    constructor(selector, name) {
      super(selector);
      this.name = name;
    }
    toHTML() {
      return `GroupBySelector with selector <pre>${this.selector}</pre> 
        and name <pre>${this.name}</pre>.`;
    }
  };
  var GroupByField = class {
    constructor(field, groupOn, addToGroup, selector) {
      this.field = field;
      this.groupOn = groupOn;
      this.addToGroup = addToGroup;
      this.selector = selector;
    }
  };
  var CyclicOrientationConstraint = class extends ConstraintOperation {
    constructor(direction, selector) {
      super(selector);
      this.direction = direction;
    }
    inconsistencyMessage() {
      return `Cyclic constraint with direction [${this.direction}] with selector <code>${this.selector}</code> is inconsistent.`;
    }
    toHTML() {
      return `Cyclic constraint with direction [${this.direction}] and selector <code>${this.selector}</code>`;
    }
  };
  function DEFAULT_LAYOUT() {
    return {
      constraints: {
        orientation: {
          relative: [],
          cyclic: []
        },
        grouping: {
          byfield: [],
          byselector: []
        }
      },
      directives: {
        atomColors: [],
        sizes: [],
        icons: [],
        edgeColors: [],
        projections: [],
        attributes: [],
        hiddenFields: [],
        inferredEdges: [],
        hiddenAtoms: [],
        hideDisconnected: false,
        hideDisconnectedBuiltIns: false
      }
    };
  }
  function parseLayoutSpec(s) {
    if (!s) {
      return DEFAULT_LAYOUT();
    }
    let parsed = load(s);
    let constraints = parsed?.constraints;
    let directives = parsed?.directives;
    let layoutSpec = DEFAULT_LAYOUT();
    if (constraints && Array.isArray(constraints)) {
      try {
        let constraintsParsed = parseConstraints(constraints);
        layoutSpec.constraints = constraintsParsed;
      } catch (e) {
        const errorMessage = e instanceof Error ? e.message : String(e);
        throw new Error(`${errorMessage}`);
      }
    }
    if (directives && Array.isArray(directives)) {
      try {
        let directivesParsed = parseDirectives(directives);
        layoutSpec.directives = directivesParsed;
      } catch (e) {
        const errorMessage = e instanceof Error ? e.message : String(e);
        throw new Error(`${errorMessage}`);
      }
    }
    return layoutSpec;
  }
  function parseConstraints(constraints) {
    const typedConstraints = constraints;
    let cyclicConstraints = typedConstraints.filter((c) => c.cyclic).map((c) => {
      if (!c.cyclic.selector) {
        throw new Error("Cyclic constraint must have a selector");
      }
      return new CyclicOrientationConstraint(
        c.cyclic.direction || "clockwise",
        c.cyclic.selector
      );
    });
    let cyclicDirectionsBySelector = {};
    cyclicConstraints.forEach((c) => {
      let k = c.selector.trim();
      if (!cyclicDirectionsBySelector[k]) {
        cyclicDirectionsBySelector[k] = c.direction;
      } else if (cyclicDirectionsBySelector[k] !== c.direction) {
        throw new Error(`Inconsistent cyclic constraint for selector ${k}: ${cyclicDirectionsBySelector[k]}, ${c.direction}`);
      }
    });
    let relativeOrientationConstraints = typedConstraints.filter((c) => c.orientation).map((c) => {
      var isInternallyConsistent = true;
      let constr = c.orientation;
      if (!constr.selector) {
        throw new Error("Orientation constraint must have selector field");
      }
      if (!constr.directions) {
        throw new Error("Orientation constraint must have directions field");
      }
      let roc = new RelativeOrientationConstraint(
        constr.directions,
        constr.selector
      );
      isInternallyConsistent = roc.isInternallyConsistent();
      if (!isInternallyConsistent) {
        throw new Error(roc.inconsistencyMessage());
      }
      return roc;
    });
    let byfield = typedConstraints.filter((c) => c.group).filter((c) => c.group.field).map((c) => {
      if (c.group.groupOn == void 0) {
        throw new Error("Grouping constraint must have groupOn field");
      }
      if (c.group.field == void 0) {
        throw new Error("Grouping constraint must specify a field");
      }
      if (c.group.addToGroup == void 0) {
        throw new Error("Grouping constraint must specify addToGroup");
      }
      return new GroupByField(
        c.group.field,
        c.group.groupOn,
        c.group.addToGroup,
        c.group.selector
      );
    });
    let byselector = typedConstraints.filter((c) => c.group).filter((c) => c.group.selector && c.group.name && !c.group.field).map((c) => {
      if (!c.group.selector) {
        throw new Error("Grouping constraint must have a selector.");
      }
      if (!c.group.name) {
        throw new Error("Grouping constraint must have a name.");
      }
      return new GroupBySelector(c.group.selector, c.group.name);
    });
    return {
      orientation: {
        relative: relativeOrientationConstraints,
        cyclic: cyclicConstraints
      },
      grouping: {
        byfield,
        byselector
      }
    };
  }
  function parseDirectives(directives) {
    const typedDirectives = directives;
    let icons = typedDirectives.filter((d) => d.icon).map((d) => {
      return {
        path: d.icon.path,
        selector: d.icon.selector,
        showLabels: d.icon.showLabels || false
      };
    });
    let atomColors = typedDirectives.filter((d) => d.atomColor).map((d) => {
      return {
        color: d.atomColor.value,
        selector: d.atomColor.selector
      };
    });
    let sizes = typedDirectives.filter((d) => d.size).map((d) => {
      return {
        height: d.size.height,
        width: d.size.width,
        selector: d.size.selector
      };
    });
    let edgeColors = typedDirectives.filter((d) => d.edgeColor).map((d) => {
      return {
        color: d.edgeColor.value,
        field: d.edgeColor.field,
        selector: d.edgeColor.selector
      };
    });
    let attributes = typedDirectives.filter((d) => d.attribute).map((d) => {
      return {
        field: d.attribute.field,
        selector: d.attribute.selector
      };
    });
    let hiddenFields = typedDirectives.filter((d) => d.hideField).map((d) => {
      return {
        field: d.hideField.field,
        selector: d.hideField.selector
      };
    });
    let projections = typedDirectives.filter((d) => d.projection).map(
      (d) => {
        return {
          sig: d.projection.sig
        };
      }
    );
    let flags = typedDirectives.filter((d) => d.flag).map((d) => d.flag);
    let hideDisconnected = flags.includes("hideDisconnected");
    let hideDisconnectedBuiltIns = flags.includes("hideDisconnectedBuiltIns");
    let inferredEdges = typedDirectives.filter((d) => d.inferredEdge).map((d) => {
      return {
        name: d.inferredEdge.name,
        selector: d.inferredEdge.selector
      };
    });
    let hiddenAtoms = typedDirectives.filter((d) => d.hideAtom).map((d) => {
      return {
        selector: d.hideAtom.selector
      };
    });
    return {
      atomColors,
      sizes,
      icons,
      edgeColors,
      projections,
      attributes,
      hiddenFields,
      inferredEdges,
      hiddenAtoms,
      hideDisconnected,
      hideDisconnectedBuiltIns
    };
  }

  // src/layout/constraint-validator.ts
  function isPositionalConstraintError(error) {
    return error.type === "positional-conflict";
  }
  function isGroupOverlapError(error) {
    return error.type === "group-overlap";
  }
  function orientationConstraintToString(constraint) {
    const nodeLabel = (node) => node.label && node.label !== node.id ? `${node.label} (${node.id})` : node.id;
    if (isTopConstraint(constraint)) {
      let tc = constraint;
      return `${nodeLabel(tc.top)} must be above ${nodeLabel(tc.bottom)}`;
    } else if (isLeftConstraint(constraint)) {
      let lc = constraint;
      return `${nodeLabel(lc.left)} must be to the left of ${nodeLabel(lc.right)}`;
    } else if (isAlignmentConstraint(constraint)) {
      let ac = constraint;
      let axis = ac.axis;
      let node1 = ac.node1;
      let node2 = ac.node2;
      if (axis === "x") {
        return `${nodeLabel(node1)} must be vertically aligned with ${nodeLabel(node2)}`;
      } else if (axis === "y") {
        return `${nodeLabel(node1)} must be horizontally aligned with ${nodeLabel(node2)}`;
      }
      return `${nodeLabel(node1)} must be aligned with ${nodeLabel(node2)} along the ${axis} axis`;
    }
    return `Unknown constraint type: ${constraint}`;
  }
  var ConstraintValidator = class {
    constructor(layout) {
      this.minPadding = 15;
      this.horizontallyAligned = [];
      this.verticallyAligned = [];
      this.layout = layout;
      this.solver = new Solver();
      this.nodes = layout.nodes;
      this.edges = layout.edges;
      this.orientationConstraints = layout.constraints;
      this.variables = {};
      this.groups = layout.groups;
      this.added_constraints = [];
    }
    validateConstraints() {
      return this.validateGroupConstraints() || this.validatePositionalConstraints();
    }
    validatePositionalConstraints() {
      this.nodes.forEach((node) => {
        let index = this.getNodeIndex(node.id);
        this.variables[index] = {
          x: new Variable(`${node.id}_x`),
          y: new Variable(`${node.id}_y`)
        };
      });
      for (let i = 0; i < this.orientationConstraints.length; i++) {
        let constraint = this.orientationConstraints[i];
        let error = this.addConstraintToSolver(constraint);
        if (error) {
          return error;
        }
      }
      this.solver.updateVariables();
      let and_more_constraints = this.getAlignmentOrders();
      this.layout.constraints = this.layout.constraints.concat(and_more_constraints);
      return null;
    }
    /**
     * Validates group constraints and returns the first overlap error found
     * @returns GroupOverlapError if groups overlap, null otherwise
     */
    validateGroupConstraints() {
      for (let i = 0; i < this.groups.length; i++) {
        const group = this.groups[i];
        for (let j = i + 1; j < this.groups.length; j++) {
          const otherGroup = this.groups[j];
          if (this.isSubGroup(group, otherGroup) || this.isSubGroup(otherGroup, group)) {
            continue;
          }
          const intersection = this.groupIntersection(group, otherGroup);
          if (intersection.length > 0) {
            const overlappingNodes = intersection.map((nodeId) => this.nodes.find((n) => n.id === nodeId)).filter((node) => node !== void 0);
            const intersectionDisplay = overlappingNodes.map(
              (node) => node.label && node.label !== node.id ? `${node.label} (${node.id})` : node.id
            );
            const groupOverlapError = {
              name: "GroupOverlapError",
              type: "group-overlap",
              message: `Groups <b>"${group.name}"</b> and <b>"${otherGroup.name}"</b> overlap with nodes: ${intersectionDisplay.join(", ")}`,
              group1: group,
              group2: otherGroup,
              overlappingNodes
            };
            return groupOverlapError;
          }
        }
      }
      return null;
    }
    getNodeIndex(nodeId) {
      return this.nodes.findIndex((node) => node.id === nodeId);
    }
    //Find the SMALLEST subset of consistentConstraints that is inconsistent with conflictingConstraint
    // This is still only LOCALLY minimal.
    getMinimalConflictingConstraints(consistentConstraints, conflictingConstraint) {
      let core2 = [...consistentConstraints, conflictingConstraint];
      let changed = true;
      while (changed) {
        changed = false;
        for (let i = 0; i < core2.length - 1; i++) {
          let testSet = core2.slice(0, i).concat(core2.slice(i + 1));
          let solver = new Solver();
          try {
            for (const c of testSet) {
              let cassowaryConstraints = this.constraintToKiwi(c);
              cassowaryConstraints.forEach((cassowaryConstraint) => {
                solver.addConstraint(cassowaryConstraint);
              });
            }
            solver.updateVariables();
          } catch {
            core2 = testSet;
            changed = true;
            break;
          }
        }
      }
      return core2.filter((c) => c !== conflictingConstraint);
    }
    constraintToKiwi(constraint) {
      if (isTopConstraint(constraint)) {
        let tc = constraint;
        let top = tc.top;
        let bottom = tc.bottom;
        let minDistance = tc.minDistance;
        const topId = this.getNodeIndex(top.id);
        const bottomId = this.getNodeIndex(bottom.id);
        let topVar = this.variables[topId].y;
        let bottomVar = this.variables[bottomId].y;
        let kiwiConstraint = new Constraint(topVar.plus(minDistance), Operator.Le, bottomVar, Strength.required);
        return [kiwiConstraint];
      } else if (isLeftConstraint(constraint)) {
        let lc = constraint;
        let left = lc.left;
        let right = lc.right;
        let minDistance = lc.minDistance;
        const leftId = this.getNodeIndex(left.id);
        const rightId = this.getNodeIndex(right.id);
        let leftVar = this.variables[leftId].x;
        let rightVar = this.variables[rightId].x;
        let kiwiConstraint = new Constraint(leftVar.plus(minDistance), Operator.Le, rightVar, Strength.required);
        return [kiwiConstraint];
      } else if (isAlignmentConstraint(constraint)) {
        let ac = constraint;
        let axis = ac.axis;
        let node1 = ac.node1;
        let node2 = ac.node2;
        const node1Id = this.getNodeIndex(node1.id);
        const node2Id = this.getNodeIndex(node2.id);
        let node1Var = this.variables[node1Id][axis];
        let node2Var = this.variables[node2Id][axis];
        if (axis === "x") {
          this.verticallyAligned.push([node1, node2]);
        } else if (axis === "y") {
          this.horizontallyAligned.push([node1, node2]);
        }
        return [new Constraint(node1Var, Operator.Eq, node2Var, Strength.required)];
      } else {
        console.log(constraint, "Unknown constraint type");
        return [];
      }
    }
    // TODO: Factor out the constraintToCassowary bit. from the ADD to solver.
    addConstraintToSolver(constraint) {
      try {
        let cassowaryConstraints = this.constraintToKiwi(constraint);
        cassowaryConstraints.forEach((cassowaryConstraint) => {
          this.solver.addConstraint(cassowaryConstraint);
        });
        this.added_constraints.push(constraint);
      } catch (e) {
        const minimal_conflicting_constraints = this.getMinimalConflictingConstraints(this.added_constraints, constraint);
        let sourceConstraintToLayoutConstraints = /* @__PURE__ */ new Map();
        let sourceConstraintHTMLToLayoutConstraintsHTML = /* @__PURE__ */ new Map();
        minimal_conflicting_constraints.forEach((c) => {
          const sourceConstraint = c.sourceConstraint;
          if (!sourceConstraintToLayoutConstraints.has(sourceConstraint)) {
            sourceConstraintToLayoutConstraints.set(sourceConstraint, []);
          }
          if (!sourceConstraintHTMLToLayoutConstraintsHTML.has(sourceConstraint.toHTML())) {
            sourceConstraintHTMLToLayoutConstraintsHTML.set(sourceConstraint.toHTML(), []);
          }
          sourceConstraintToLayoutConstraints.get(sourceConstraint).push(c);
          sourceConstraintHTMLToLayoutConstraintsHTML.get(sourceConstraint.toHTML()).push(orientationConstraintToString(c));
        });
        const positionalConstraintError = {
          name: "PositionalConstraintError",
          // Add this required property
          type: "positional-conflict",
          message: `Constraint "${orientationConstraintToString(constraint)}" conflicts with existing constraints`,
          conflictingConstraint: constraint,
          conflictingSourceConstraint: constraint.sourceConstraint,
          minimalConflictingSet: sourceConstraintToLayoutConstraints,
          // TODO: Migrate this to `webcola-demo.html`
          errorMessages: {
            conflictingConstraint: `${orientationConstraintToString(constraint)}`,
            conflictingSourceConstraint: `${constraint.sourceConstraint.toHTML()}`,
            minimalConflictingConstraints: sourceConstraintHTMLToLayoutConstraintsHTML
          }
        };
        return positionalConstraintError;
      }
      return null;
    }
    getAlignmentOrders() {
      this.solver.updateVariables();
      this.horizontallyAligned = this.normalizeAlignment(this.horizontallyAligned);
      this.verticallyAligned = this.normalizeAlignment(this.verticallyAligned);
      let implicitAlignmentConstraints = [];
      for (let i = 0; i < this.horizontallyAligned.length; i++) {
        this.horizontallyAligned[i].sort((a, b) => {
          const aValue = this.variables[this.getNodeIndex(a.id)].x.value();
          const bValue = this.variables[this.getNodeIndex(b.id)].x.value();
          return aValue - bValue;
        });
      }
      this.horizontallyAligned.forEach((alignedLeftToRight) => {
        for (let i = 0; i < alignedLeftToRight.length - 1; i++) {
          let node1 = alignedLeftToRight[i];
          let node2 = alignedLeftToRight[i + 1];
          let roc = new RelativeOrientationConstraint(["directlyLeft"], `${node1.id}->${node2.id}`);
          let sourceConstraint = new ImplicitConstraint(roc, "Preventing Overlap");
          let lc = {
            left: node1,
            right: node2,
            minDistance: this.minPadding,
            // sourceConstraint is ``implied'' or ``implicit'' here, since it is derived from the alignment order. That's tricky.
            sourceConstraint
          };
          implicitAlignmentConstraints.push(lc);
        }
      });
      for (let i = 0; i < this.verticallyAligned.length; i++) {
        this.verticallyAligned[i].sort((a, b) => {
          const aValue = this.variables[this.getNodeIndex(a.id)].y.value();
          const bValue = this.variables[this.getNodeIndex(b.id)].y.value();
          return aValue - bValue;
        });
      }
      this.verticallyAligned.forEach((alignedTopToBottom) => {
        for (let i = 0; i < alignedTopToBottom.length - 1; i++) {
          let node1 = alignedTopToBottom[i];
          let node2 = alignedTopToBottom[i + 1];
          let roc = new RelativeOrientationConstraint(["directlyAbove"], `${node1.id}->${node2.id}`);
          let sourceConstraint = new ImplicitConstraint(roc, "Preventing Overlap");
          let tc = {
            top: node1,
            bottom: node2,
            minDistance: this.minPadding,
            sourceConstraint
          };
          implicitAlignmentConstraints.push(tc);
        }
      });
      return implicitAlignmentConstraints;
    }
    normalizeAlignment(aligned) {
      const merged = [];
      for (const group of aligned) {
        let mergedWithExisting = false;
        for (const existing of merged) {
          if (group.some((item) => existing.includes(item))) {
            existing.push(...group.filter((item) => !existing.includes(item)));
            mergedWithExisting = true;
            break;
          }
        }
        if (!mergedWithExisting) {
          merged.push([...group]);
        }
      }
      let changed = true;
      while (changed) {
        changed = false;
        for (let i = 0; i < merged.length; i++) {
          for (let j = i + 1; j < merged.length; j++) {
            if (merged[i].some((item) => merged[j].includes(item))) {
              merged[i].push(...merged[j].filter((item) => !merged[i].includes(item)));
              merged.splice(j, 1);
              changed = true;
              break;
            }
          }
          if (changed) break;
        }
      }
      return merged;
    }
    isSubGroup(subgroup, group) {
      const sgElements = subgroup.nodeIds;
      const gElements = group.nodeIds;
      return sgElements.every((element) => gElements.includes(element));
    }
    groupIntersection(group1, group2) {
      const g1Elements = group1.nodeIds;
      const g2Elements = group2.nodeIds;
      const commonElements = g1Elements.filter((element) => g2Elements.includes(element));
      return commonElements;
    }
  };

  // node_modules/chroma-js/src/utils/limit.js
  var { min, max } = Math;
  var limit_default = (x, low = 0, high = 1) => {
    return min(max(low, x), high);
  };

  // node_modules/chroma-js/src/utils/clip_rgb.js
  var clip_rgb_default = (rgb3) => {
    rgb3._clipped = false;
    rgb3._unclipped = rgb3.slice(0);
    for (let i = 0; i <= 3; i++) {
      if (i < 3) {
        if (rgb3[i] < 0 || rgb3[i] > 255) rgb3._clipped = true;
        rgb3[i] = limit_default(rgb3[i], 0, 255);
      } else if (i === 3) {
        rgb3[i] = limit_default(rgb3[i], 0, 1);
      }
    }
    return rgb3;
  };

  // node_modules/chroma-js/src/utils/type.js
  var classToType = {};
  for (let name of [
    "Boolean",
    "Number",
    "String",
    "Function",
    "Array",
    "Date",
    "RegExp",
    "Undefined",
    "Null"
  ]) {
    classToType[`[object ${name}]`] = name.toLowerCase();
  }
  function type_default(obj) {
    return classToType[Object.prototype.toString.call(obj)] || "object";
  }

  // node_modules/chroma-js/src/utils/unpack.js
  var unpack_default = (args, keyOrder = null) => {
    if (args.length >= 3) return Array.prototype.slice.call(args);
    if (type_default(args[0]) == "object" && keyOrder) {
      return keyOrder.split("").filter((k) => args[0][k] !== void 0).map((k) => args[0][k]);
    }
    return args[0].slice(0);
  };

  // node_modules/chroma-js/src/utils/last.js
  var last_default = (args) => {
    if (args.length < 2) return null;
    const l = args.length - 1;
    if (type_default(args[l]) == "string") return args[l].toLowerCase();
    return null;
  };

  // node_modules/chroma-js/src/utils/index.js
  var { PI, min: min2, max: max2 } = Math;
  var rnd2 = (a) => Math.round(a * 100) / 100;
  var rnd3 = (a) => Math.round(a * 100) / 100;
  var TWOPI = PI * 2;
  var PITHIRD = PI / 3;
  var DEG2RAD = PI / 180;
  var RAD2DEG = 180 / PI;
  function reverse3(arr) {
    return [...arr.slice(0, 3).reverse(), ...arr.slice(3)];
  }

  // node_modules/chroma-js/src/io/input.js
  var input_default = {
    format: {},
    autodetect: []
  };

  // node_modules/chroma-js/src/Color.js
  var Color = class {
    constructor(...args) {
      const me = this;
      if (type_default(args[0]) === "object" && args[0].constructor && args[0].constructor === this.constructor) {
        return args[0];
      }
      let mode = last_default(args);
      let autodetect = false;
      if (!mode) {
        autodetect = true;
        if (!input_default.sorted) {
          input_default.autodetect = input_default.autodetect.sort((a, b) => b.p - a.p);
          input_default.sorted = true;
        }
        for (let chk of input_default.autodetect) {
          mode = chk.test(...args);
          if (mode) break;
        }
      }
      if (input_default.format[mode]) {
        const rgb3 = input_default.format[mode].apply(
          null,
          autodetect ? args : args.slice(0, -1)
        );
        me._rgb = clip_rgb_default(rgb3);
      } else {
        throw new Error("unknown format: " + args);
      }
      if (me._rgb.length === 3) me._rgb.push(1);
    }
    toString() {
      if (type_default(this.hex) == "function") return this.hex();
      return `[${this._rgb.join(",")}]`;
    }
  };
  var Color_default = Color;

  // node_modules/chroma-js/src/version.js
  var version = "3.1.2";

  // node_modules/chroma-js/src/chroma.js
  var chroma = (...args) => {
    return new Color_default(...args);
  };
  chroma.version = version;
  var chroma_default = chroma;

  // node_modules/chroma-js/src/colors/w3cx11.js
  var w3cx11 = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    laserlemon: "#ffff54",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrod: "#fafad2",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    maroon2: "#7f0000",
    maroon3: "#b03060",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    purple2: "#7f007f",
    purple3: "#a020f0",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
  var w3cx11_default = w3cx11;

  // node_modules/chroma-js/src/io/hex/hex2rgb.js
  var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
  var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;
  var hex2rgb = (hex2) => {
    if (hex2.match(RE_HEX)) {
      if (hex2.length === 4 || hex2.length === 7) {
        hex2 = hex2.substr(1);
      }
      if (hex2.length === 3) {
        hex2 = hex2.split("");
        hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2];
      }
      const u = parseInt(hex2, 16);
      const r = u >> 16;
      const g = u >> 8 & 255;
      const b = u & 255;
      return [r, g, b, 1];
    }
    if (hex2.match(RE_HEXA)) {
      if (hex2.length === 5 || hex2.length === 9) {
        hex2 = hex2.substr(1);
      }
      if (hex2.length === 4) {
        hex2 = hex2.split("");
        hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2] + hex2[3] + hex2[3];
      }
      const u = parseInt(hex2, 16);
      const r = u >> 24 & 255;
      const g = u >> 16 & 255;
      const b = u >> 8 & 255;
      const a = Math.round((u & 255) / 255 * 100) / 100;
      return [r, g, b, a];
    }
    throw new Error(`unknown hex color: ${hex2}`);
  };
  var hex2rgb_default = hex2rgb;

  // node_modules/chroma-js/src/io/hex/rgb2hex.js
  var { round } = Math;
  var rgb2hex = (...args) => {
    let [r, g, b, a] = unpack_default(args, "rgba");
    let mode = last_default(args) || "auto";
    if (a === void 0) a = 1;
    if (mode === "auto") {
      mode = a < 1 ? "rgba" : "rgb";
    }
    r = round(r);
    g = round(g);
    b = round(b);
    const u = r << 16 | g << 8 | b;
    let str2 = "000000" + u.toString(16);
    str2 = str2.substr(str2.length - 6);
    let hxa = "0" + round(a * 255).toString(16);
    hxa = hxa.substr(hxa.length - 2);
    switch (mode.toLowerCase()) {
      case "rgba":
        return `#${str2}${hxa}`;
      case "argb":
        return `#${hxa}${str2}`;
      default:
        return `#${str2}`;
    }
  };
  var rgb2hex_default = rgb2hex;

  // node_modules/chroma-js/src/io/named/index.js
  Color_default.prototype.name = function() {
    const hex2 = rgb2hex_default(this._rgb, "rgb");
    for (let n of Object.keys(w3cx11_default)) {
      if (w3cx11_default[n] === hex2) return n.toLowerCase();
    }
    return hex2;
  };
  input_default.format.named = (name) => {
    name = name.toLowerCase();
    if (w3cx11_default[name]) return hex2rgb_default(w3cx11_default[name]);
    throw new Error("unknown color name: " + name);
  };
  input_default.autodetect.push({
    p: 5,
    test: (h, ...rest) => {
      if (!rest.length && type_default(h) === "string" && w3cx11_default[h.toLowerCase()]) {
        return "named";
      }
    }
  });

  // node_modules/chroma-js/src/ops/alpha.js
  Color_default.prototype.alpha = function(a, mutate = false) {
    if (a !== void 0 && type_default(a) === "number") {
      if (mutate) {
        this._rgb[3] = a;
        return this;
      }
      return new Color_default([this._rgb[0], this._rgb[1], this._rgb[2], a], "rgb");
    }
    return this._rgb[3];
  };

  // node_modules/chroma-js/src/ops/clipped.js
  Color_default.prototype.clipped = function() {
    return this._rgb._clipped || false;
  };

  // node_modules/chroma-js/src/io/lab/lab-constants.js
  var labConstants = {
    // Corresponds roughly to RGB brighter/darker
    Kn: 18,
    // D65 standard referent
    labWhitePoint: "d65",
    Xn: 0.95047,
    Yn: 1,
    Zn: 1.08883,
    t0: 0.137931034,
    // 4 / 29
    t1: 0.206896552,
    // 6 / 29
    t2: 0.12841855,
    // 3 * t1 * t1
    t3: 8856452e-9,
    // t1 * t1 * t1,
    kE: 216 / 24389,
    kKE: 8,
    kK: 24389 / 27,
    RefWhiteRGB: {
      // sRGB
      X: 0.95047,
      Y: 1,
      Z: 1.08883
    },
    MtxRGB2XYZ: {
      m00: 0.4124564390896922,
      m01: 0.21267285140562253,
      m02: 0.0193338955823293,
      m10: 0.357576077643909,
      m11: 0.715152155287818,
      m12: 0.11919202588130297,
      m20: 0.18043748326639894,
      m21: 0.07217499330655958,
      m22: 0.9503040785363679
    },
    MtxXYZ2RGB: {
      m00: 3.2404541621141045,
      m01: -0.9692660305051868,
      m02: 0.055643430959114726,
      m10: -1.5371385127977166,
      m11: 1.8760108454466942,
      m12: -0.2040259135167538,
      m20: -0.498531409556016,
      m21: 0.041556017530349834,
      m22: 1.0572251882231791
    },
    // used in rgb2xyz
    As: 0.9414285350000001,
    Bs: 1.040417467,
    Cs: 1.089532651,
    MtxAdaptMa: {
      m00: 0.8951,
      m01: -0.7502,
      m02: 0.0389,
      m10: 0.2664,
      m11: 1.7135,
      m12: -0.0685,
      m20: -0.1614,
      m21: 0.0367,
      m22: 1.0296
    },
    MtxAdaptMaI: {
      m00: 0.9869929054667123,
      m01: 0.43230526972339456,
      m02: -0.008528664575177328,
      m10: -0.14705425642099013,
      m11: 0.5183602715367776,
      m12: 0.04004282165408487,
      m20: 0.15996265166373125,
      m21: 0.0492912282128556,
      m22: 0.9684866957875502
    }
  };
  var lab_constants_default = labConstants;
  var ILLUMINANTS = /* @__PURE__ */ new Map([
    // ASTM E308-01
    ["a", [1.0985, 0.35585]],
    // Wyszecki & Stiles, p. 769
    ["b", [1.0985, 0.35585]],
    // C ASTM E308-01
    ["c", [0.98074, 1.18232]],
    // D50 (ASTM E308-01)
    ["d50", [0.96422, 0.82521]],
    // D55 (ASTM E308-01)
    ["d55", [0.95682, 0.92149]],
    // D65 (ASTM E308-01)
    ["d65", [0.95047, 1.08883]],
    // E (ASTM E308-01)
    ["e", [1, 1, 1]],
    // F2 (ASTM E308-01)
    ["f2", [0.99186, 0.67393]],
    // F7 (ASTM E308-01)
    ["f7", [0.95041, 1.08747]],
    // F11 (ASTM E308-01)
    ["f11", [1.00962, 0.6435]],
    ["icc", [0.96422, 0.82521]]
  ]);
  function setLabWhitePoint(name) {
    const ill = ILLUMINANTS.get(String(name).toLowerCase());
    if (!ill) {
      throw new Error("unknown Lab illuminant " + name);
    }
    labConstants.labWhitePoint = name;
    labConstants.Xn = ill[0];
    labConstants.Zn = ill[1];
  }
  function getLabWhitePoint() {
    return labConstants.labWhitePoint;
  }

  // node_modules/chroma-js/src/io/lab/lab2rgb.js
  var lab2rgb = (...args) => {
    args = unpack_default(args, "lab");
    const [L, a, b] = args;
    const [x, y, z] = lab2xyz(L, a, b);
    const [r, g, b_] = xyz2rgb(x, y, z);
    return [r, g, b_, args.length > 3 ? args[3] : 1];
  };
  var lab2xyz = (L, a, b) => {
    const { kE, kK, kKE, Xn, Yn, Zn } = lab_constants_default;
    const fy = (L + 16) / 116;
    const fx = 2e-3 * a + fy;
    const fz = fy - 5e-3 * b;
    const fx3 = fx * fx * fx;
    const fz3 = fz * fz * fz;
    const xr = fx3 > kE ? fx3 : (116 * fx - 16) / kK;
    const yr = L > kKE ? Math.pow((L + 16) / 116, 3) : L / kK;
    const zr = fz3 > kE ? fz3 : (116 * fz - 16) / kK;
    const x = xr * Xn;
    const y = yr * Yn;
    const z = zr * Zn;
    return [x, y, z];
  };
  var compand = (linear) => {
    const sign = Math.sign(linear);
    linear = Math.abs(linear);
    return (linear <= 31308e-7 ? linear * 12.92 : 1.055 * Math.pow(linear, 1 / 2.4) - 0.055) * sign;
  };
  var xyz2rgb = (x, y, z) => {
    const { MtxAdaptMa, MtxAdaptMaI, MtxXYZ2RGB, RefWhiteRGB, Xn, Yn, Zn } = lab_constants_default;
    const As = Xn * MtxAdaptMa.m00 + Yn * MtxAdaptMa.m10 + Zn * MtxAdaptMa.m20;
    const Bs = Xn * MtxAdaptMa.m01 + Yn * MtxAdaptMa.m11 + Zn * MtxAdaptMa.m21;
    const Cs = Xn * MtxAdaptMa.m02 + Yn * MtxAdaptMa.m12 + Zn * MtxAdaptMa.m22;
    const Ad = RefWhiteRGB.X * MtxAdaptMa.m00 + RefWhiteRGB.Y * MtxAdaptMa.m10 + RefWhiteRGB.Z * MtxAdaptMa.m20;
    const Bd = RefWhiteRGB.X * MtxAdaptMa.m01 + RefWhiteRGB.Y * MtxAdaptMa.m11 + RefWhiteRGB.Z * MtxAdaptMa.m21;
    const Cd = RefWhiteRGB.X * MtxAdaptMa.m02 + RefWhiteRGB.Y * MtxAdaptMa.m12 + RefWhiteRGB.Z * MtxAdaptMa.m22;
    const X1 = (x * MtxAdaptMa.m00 + y * MtxAdaptMa.m10 + z * MtxAdaptMa.m20) * (Ad / As);
    const Y1 = (x * MtxAdaptMa.m01 + y * MtxAdaptMa.m11 + z * MtxAdaptMa.m21) * (Bd / Bs);
    const Z1 = (x * MtxAdaptMa.m02 + y * MtxAdaptMa.m12 + z * MtxAdaptMa.m22) * (Cd / Cs);
    const X2 = X1 * MtxAdaptMaI.m00 + Y1 * MtxAdaptMaI.m10 + Z1 * MtxAdaptMaI.m20;
    const Y2 = X1 * MtxAdaptMaI.m01 + Y1 * MtxAdaptMaI.m11 + Z1 * MtxAdaptMaI.m21;
    const Z2 = X1 * MtxAdaptMaI.m02 + Y1 * MtxAdaptMaI.m12 + Z1 * MtxAdaptMaI.m22;
    const r = compand(
      X2 * MtxXYZ2RGB.m00 + Y2 * MtxXYZ2RGB.m10 + Z2 * MtxXYZ2RGB.m20
    );
    const g = compand(
      X2 * MtxXYZ2RGB.m01 + Y2 * MtxXYZ2RGB.m11 + Z2 * MtxXYZ2RGB.m21
    );
    const b = compand(
      X2 * MtxXYZ2RGB.m02 + Y2 * MtxXYZ2RGB.m12 + Z2 * MtxXYZ2RGB.m22
    );
    return [r * 255, g * 255, b * 255];
  };
  var lab2rgb_default = lab2rgb;

  // node_modules/chroma-js/src/io/lab/rgb2lab.js
  var rgb2lab = (...args) => {
    const [r, g, b, ...rest] = unpack_default(args, "rgb");
    const [x, y, z] = rgb2xyz(r, g, b);
    const [L, a, b_] = xyz2lab(x, y, z);
    return [L, a, b_, ...rest.length > 0 && rest[0] < 1 ? [rest[0]] : []];
  };
  function xyz2lab(x, y, z) {
    const { Xn, Yn, Zn, kE, kK } = lab_constants_default;
    const xr = x / Xn;
    const yr = y / Yn;
    const zr = z / Zn;
    const fx = xr > kE ? Math.pow(xr, 1 / 3) : (kK * xr + 16) / 116;
    const fy = yr > kE ? Math.pow(yr, 1 / 3) : (kK * yr + 16) / 116;
    const fz = zr > kE ? Math.pow(zr, 1 / 3) : (kK * zr + 16) / 116;
    return [116 * fy - 16, 500 * (fx - fy), 200 * (fy - fz)];
  }
  function gammaAdjustSRGB(companded) {
    const sign = Math.sign(companded);
    companded = Math.abs(companded);
    const linear = companded <= 0.04045 ? companded / 12.92 : Math.pow((companded + 0.055) / 1.055, 2.4);
    return linear * sign;
  }
  var rgb2xyz = (r, g, b) => {
    r = gammaAdjustSRGB(r / 255);
    g = gammaAdjustSRGB(g / 255);
    b = gammaAdjustSRGB(b / 255);
    const { MtxRGB2XYZ, MtxAdaptMa, MtxAdaptMaI, Xn, Yn, Zn, As, Bs, Cs } = lab_constants_default;
    let x = r * MtxRGB2XYZ.m00 + g * MtxRGB2XYZ.m10 + b * MtxRGB2XYZ.m20;
    let y = r * MtxRGB2XYZ.m01 + g * MtxRGB2XYZ.m11 + b * MtxRGB2XYZ.m21;
    let z = r * MtxRGB2XYZ.m02 + g * MtxRGB2XYZ.m12 + b * MtxRGB2XYZ.m22;
    const Ad = Xn * MtxAdaptMa.m00 + Yn * MtxAdaptMa.m10 + Zn * MtxAdaptMa.m20;
    const Bd = Xn * MtxAdaptMa.m01 + Yn * MtxAdaptMa.m11 + Zn * MtxAdaptMa.m21;
    const Cd = Xn * MtxAdaptMa.m02 + Yn * MtxAdaptMa.m12 + Zn * MtxAdaptMa.m22;
    let X = x * MtxAdaptMa.m00 + y * MtxAdaptMa.m10 + z * MtxAdaptMa.m20;
    let Y = x * MtxAdaptMa.m01 + y * MtxAdaptMa.m11 + z * MtxAdaptMa.m21;
    let Z = x * MtxAdaptMa.m02 + y * MtxAdaptMa.m12 + z * MtxAdaptMa.m22;
    X *= Ad / As;
    Y *= Bd / Bs;
    Z *= Cd / Cs;
    x = X * MtxAdaptMaI.m00 + Y * MtxAdaptMaI.m10 + Z * MtxAdaptMaI.m20;
    y = X * MtxAdaptMaI.m01 + Y * MtxAdaptMaI.m11 + Z * MtxAdaptMaI.m21;
    z = X * MtxAdaptMaI.m02 + Y * MtxAdaptMaI.m12 + Z * MtxAdaptMaI.m22;
    return [x, y, z];
  };
  var rgb2lab_default = rgb2lab;

  // node_modules/chroma-js/src/io/lab/index.js
  Color_default.prototype.lab = function() {
    return rgb2lab_default(this._rgb);
  };
  var lab = (...args) => new Color_default(...args, "lab");
  Object.assign(chroma_default, { lab, getLabWhitePoint, setLabWhitePoint });
  input_default.format.lab = lab2rgb_default;
  input_default.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack_default(args, "lab");
      if (type_default(args) === "array" && args.length === 3) {
        return "lab";
      }
    }
  });

  // node_modules/chroma-js/src/ops/darken.js
  Color_default.prototype.darken = function(amount = 1) {
    const me = this;
    const lab3 = me.lab();
    lab3[0] -= lab_constants_default.Kn * amount;
    return new Color_default(lab3, "lab").alpha(me.alpha(), true);
  };
  Color_default.prototype.brighten = function(amount = 1) {
    return this.darken(-amount);
  };
  Color_default.prototype.darker = Color_default.prototype.darken;
  Color_default.prototype.brighter = Color_default.prototype.brighten;

  // node_modules/chroma-js/src/ops/get.js
  Color_default.prototype.get = function(mc) {
    const [mode, channel] = mc.split(".");
    const src = this[mode]();
    if (channel) {
      const i = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
      if (i > -1) return src[i];
      throw new Error(`unknown channel ${channel} in mode ${mode}`);
    } else {
      return src;
    }
  };

  // node_modules/chroma-js/src/ops/luminance.js
  var { pow } = Math;
  var EPS = 1e-7;
  var MAX_ITER = 20;
  Color_default.prototype.luminance = function(lum2, mode = "rgb") {
    if (lum2 !== void 0 && type_default(lum2) === "number") {
      if (lum2 === 0) {
        return new Color_default([0, 0, 0, this._rgb[3]], "rgb");
      }
      if (lum2 === 1) {
        return new Color_default([255, 255, 255, this._rgb[3]], "rgb");
      }
      let cur_lum = this.luminance();
      let max_iter = MAX_ITER;
      const test = (low, high) => {
        const mid = low.interpolate(high, 0.5, mode);
        const lm = mid.luminance();
        if (Math.abs(lum2 - lm) < EPS || !max_iter--) {
          return mid;
        }
        return lm > lum2 ? test(low, mid) : test(mid, high);
      };
      const rgb3 = (cur_lum > lum2 ? test(new Color_default([0, 0, 0]), this) : test(this, new Color_default([255, 255, 255]))).rgb();
      return new Color_default([...rgb3, this._rgb[3]]);
    }
    return rgb2luminance(...this._rgb.slice(0, 3));
  };
  var rgb2luminance = (r, g, b) => {
    r = luminance_x(r);
    g = luminance_x(g);
    b = luminance_x(b);
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  };
  var luminance_x = (x) => {
    x /= 255;
    return x <= 0.03928 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);
  };

  // node_modules/chroma-js/src/interpolator/index.js
  var interpolator_default = {};

  // node_modules/chroma-js/src/generator/mix.js
  var mix_default = (col1, col2, f = 0.5, ...rest) => {
    let mode = rest[0] || "lrgb";
    if (!interpolator_default[mode] && !rest.length) {
      mode = Object.keys(interpolator_default)[0];
    }
    if (!interpolator_default[mode]) {
      throw new Error(`interpolation mode ${mode} is not defined`);
    }
    if (type_default(col1) !== "object") col1 = new Color_default(col1);
    if (type_default(col2) !== "object") col2 = new Color_default(col2);
    return interpolator_default[mode](col1, col2, f).alpha(
      col1.alpha() + f * (col2.alpha() - col1.alpha())
    );
  };

  // node_modules/chroma-js/src/ops/mix.js
  Color_default.prototype.mix = Color_default.prototype.interpolate = function(col2, f = 0.5, ...rest) {
    return mix_default(this, col2, f, ...rest);
  };

  // node_modules/chroma-js/src/ops/premultiply.js
  Color_default.prototype.premultiply = function(mutate = false) {
    const rgb3 = this._rgb;
    const a = rgb3[3];
    if (mutate) {
      this._rgb = [rgb3[0] * a, rgb3[1] * a, rgb3[2] * a, a];
      return this;
    } else {
      return new Color_default([rgb3[0] * a, rgb3[1] * a, rgb3[2] * a, a], "rgb");
    }
  };

  // node_modules/chroma-js/src/io/lch/lch2lab.js
  var { sin, cos } = Math;
  var lch2lab = (...args) => {
    let [l, c, h] = unpack_default(args, "lch");
    if (isNaN(h)) h = 0;
    h = h * DEG2RAD;
    return [l, cos(h) * c, sin(h) * c];
  };
  var lch2lab_default = lch2lab;

  // node_modules/chroma-js/src/io/lch/lch2rgb.js
  var lch2rgb = (...args) => {
    args = unpack_default(args, "lch");
    const [l, c, h] = args;
    const [L, a, b_] = lch2lab_default(l, c, h);
    const [r, g, b] = lab2rgb_default(L, a, b_);
    return [r, g, b, args.length > 3 ? args[3] : 1];
  };
  var lch2rgb_default = lch2rgb;

  // node_modules/chroma-js/src/io/lch/hcl2rgb.js
  var hcl2rgb = (...args) => {
    const hcl2 = reverse3(unpack_default(args, "hcl"));
    return lch2rgb_default(...hcl2);
  };
  var hcl2rgb_default = hcl2rgb;

  // node_modules/chroma-js/src/io/lch/lab2lch.js
  var { sqrt, atan2, round: round2 } = Math;
  var lab2lch = (...args) => {
    const [l, a, b] = unpack_default(args, "lab");
    const c = sqrt(a * a + b * b);
    let h = (atan2(b, a) * RAD2DEG + 360) % 360;
    if (round2(c * 1e4) === 0) h = Number.NaN;
    return [l, c, h];
  };
  var lab2lch_default = lab2lch;

  // node_modules/chroma-js/src/io/lch/rgb2lch.js
  var rgb2lch = (...args) => {
    const [r, g, b, ...rest] = unpack_default(args, "rgb");
    const [l, a, b_] = rgb2lab_default(r, g, b);
    const [L, c, h] = lab2lch_default(l, a, b_);
    return [L, c, h, ...rest.length > 0 && rest[0] < 1 ? [rest[0]] : []];
  };
  var rgb2lch_default = rgb2lch;

  // node_modules/chroma-js/src/io/lch/index.js
  Color_default.prototype.lch = function() {
    return rgb2lch_default(this._rgb);
  };
  Color_default.prototype.hcl = function() {
    return reverse3(rgb2lch_default(this._rgb));
  };
  var lch = (...args) => new Color_default(...args, "lch");
  var hcl = (...args) => new Color_default(...args, "hcl");
  Object.assign(chroma_default, { lch, hcl });
  input_default.format.lch = lch2rgb_default;
  input_default.format.hcl = hcl2rgb_default;
  ["lch", "hcl"].forEach(
    (m) => input_default.autodetect.push({
      p: 2,
      test: (...args) => {
        args = unpack_default(args, m);
        if (type_default(args) === "array" && args.length === 3) {
          return m;
        }
      }
    })
  );

  // node_modules/chroma-js/src/ops/saturate.js
  Color_default.prototype.saturate = function(amount = 1) {
    const me = this;
    const lch3 = me.lch();
    lch3[1] += lab_constants_default.Kn * amount;
    if (lch3[1] < 0) lch3[1] = 0;
    return new Color_default(lch3, "lch").alpha(me.alpha(), true);
  };
  Color_default.prototype.desaturate = function(amount = 1) {
    return this.saturate(-amount);
  };

  // node_modules/chroma-js/src/ops/set.js
  Color_default.prototype.set = function(mc, value, mutate = false) {
    const [mode, channel] = mc.split(".");
    const src = this[mode]();
    if (channel) {
      const i = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
      if (i > -1) {
        if (type_default(value) == "string") {
          switch (value.charAt(0)) {
            case "+":
              src[i] += +value;
              break;
            case "-":
              src[i] += +value;
              break;
            case "*":
              src[i] *= +value.substr(1);
              break;
            case "/":
              src[i] /= +value.substr(1);
              break;
            default:
              src[i] = +value;
          }
        } else if (type_default(value) === "number") {
          src[i] = value;
        } else {
          throw new Error(`unsupported value for Color.set`);
        }
        const out = new Color_default(src, mode);
        if (mutate) {
          this._rgb = out._rgb;
          return this;
        }
        return out;
      }
      throw new Error(`unknown channel ${channel} in mode ${mode}`);
    } else {
      return src;
    }
  };

  // node_modules/chroma-js/src/ops/shade.js
  Color_default.prototype.tint = function(f = 0.5, ...rest) {
    return mix_default(this, "white", f, ...rest);
  };
  Color_default.prototype.shade = function(f = 0.5, ...rest) {
    return mix_default(this, "black", f, ...rest);
  };

  // node_modules/chroma-js/src/interpolator/rgb.js
  var rgb = (col1, col2, f) => {
    const xyz0 = col1._rgb;
    const xyz1 = col2._rgb;
    return new Color_default(
      xyz0[0] + f * (xyz1[0] - xyz0[0]),
      xyz0[1] + f * (xyz1[1] - xyz0[1]),
      xyz0[2] + f * (xyz1[2] - xyz0[2]),
      "rgb"
    );
  };
  interpolator_default.rgb = rgb;

  // node_modules/chroma-js/src/interpolator/lrgb.js
  var { sqrt: sqrt2, pow: pow2 } = Math;
  var lrgb = (col1, col2, f) => {
    const [x1, y1, z1] = col1._rgb;
    const [x2, y2, z2] = col2._rgb;
    return new Color_default(
      sqrt2(pow2(x1, 2) * (1 - f) + pow2(x2, 2) * f),
      sqrt2(pow2(y1, 2) * (1 - f) + pow2(y2, 2) * f),
      sqrt2(pow2(z1, 2) * (1 - f) + pow2(z2, 2) * f),
      "rgb"
    );
  };
  interpolator_default.lrgb = lrgb;

  // node_modules/chroma-js/src/interpolator/lab.js
  var lab2 = (col1, col2, f) => {
    const xyz0 = col1.lab();
    const xyz1 = col2.lab();
    return new Color_default(
      xyz0[0] + f * (xyz1[0] - xyz0[0]),
      xyz0[1] + f * (xyz1[1] - xyz0[1]),
      xyz0[2] + f * (xyz1[2] - xyz0[2]),
      "lab"
    );
  };
  interpolator_default.lab = lab2;

  // node_modules/chroma-js/src/interpolator/_hsx.js
  var hsx_default = (col1, col2, f, m) => {
    let xyz0, xyz1;
    if (m === "hsl") {
      xyz0 = col1.hsl();
      xyz1 = col2.hsl();
    } else if (m === "hsv") {
      xyz0 = col1.hsv();
      xyz1 = col2.hsv();
    } else if (m === "hcg") {
      xyz0 = col1.hcg();
      xyz1 = col2.hcg();
    } else if (m === "hsi") {
      xyz0 = col1.hsi();
      xyz1 = col2.hsi();
    } else if (m === "lch" || m === "hcl") {
      m = "hcl";
      xyz0 = col1.hcl();
      xyz1 = col2.hcl();
    } else if (m === "oklch") {
      xyz0 = col1.oklch().reverse();
      xyz1 = col2.oklch().reverse();
    }
    let hue0, hue1, sat0, sat1, lbv0, lbv1;
    if (m.substr(0, 1) === "h" || m === "oklch") {
      [hue0, sat0, lbv0] = xyz0;
      [hue1, sat1, lbv1] = xyz1;
    }
    let sat, hue, lbv, dh;
    if (!isNaN(hue0) && !isNaN(hue1)) {
      if (hue1 > hue0 && hue1 - hue0 > 180) {
        dh = hue1 - (hue0 + 360);
      } else if (hue1 < hue0 && hue0 - hue1 > 180) {
        dh = hue1 + 360 - hue0;
      } else {
        dh = hue1 - hue0;
      }
      hue = hue0 + f * dh;
    } else if (!isNaN(hue0)) {
      hue = hue0;
      if ((lbv1 == 1 || lbv1 == 0) && m != "hsv") sat = sat0;
    } else if (!isNaN(hue1)) {
      hue = hue1;
      if ((lbv0 == 1 || lbv0 == 0) && m != "hsv") sat = sat1;
    } else {
      hue = Number.NaN;
    }
    if (sat === void 0) sat = sat0 + f * (sat1 - sat0);
    lbv = lbv0 + f * (lbv1 - lbv0);
    return m === "oklch" ? new Color_default([lbv, sat, hue], m) : new Color_default([hue, sat, lbv], m);
  };

  // node_modules/chroma-js/src/interpolator/lch.js
  var lch2 = (col1, col2, f) => {
    return hsx_default(col1, col2, f, "lch");
  };
  interpolator_default.lch = lch2;
  interpolator_default.hcl = lch2;

  // node_modules/chroma-js/src/io/num/num2rgb.js
  var num2rgb = (num3) => {
    if (type_default(num3) == "number" && num3 >= 0 && num3 <= 16777215) {
      const r = num3 >> 16;
      const g = num3 >> 8 & 255;
      const b = num3 & 255;
      return [r, g, b, 1];
    }
    throw new Error("unknown num color: " + num3);
  };
  var num2rgb_default = num2rgb;

  // node_modules/chroma-js/src/io/num/rgb2num.js
  var rgb2num = (...args) => {
    const [r, g, b] = unpack_default(args, "rgb");
    return (r << 16) + (g << 8) + b;
  };
  var rgb2num_default = rgb2num;

  // node_modules/chroma-js/src/io/num/index.js
  Color_default.prototype.num = function() {
    return rgb2num_default(this._rgb);
  };
  var num = (...args) => new Color_default(...args, "num");
  Object.assign(chroma_default, { num });
  input_default.format.num = num2rgb_default;
  input_default.autodetect.push({
    p: 5,
    test: (...args) => {
      if (args.length === 1 && type_default(args[0]) === "number" && args[0] >= 0 && args[0] <= 16777215) {
        return "num";
      }
    }
  });

  // node_modules/chroma-js/src/interpolator/num.js
  var num2 = (col1, col2, f) => {
    const c1 = col1.num();
    const c2 = col2.num();
    return new Color_default(c1 + f * (c2 - c1), "num");
  };
  interpolator_default.num = num2;

  // node_modules/chroma-js/src/io/hcg/hcg2rgb.js
  var { floor } = Math;
  var hcg2rgb = (...args) => {
    args = unpack_default(args, "hcg");
    let [h, c, _g] = args;
    let r, g, b;
    _g = _g * 255;
    const _c = c * 255;
    if (c === 0) {
      r = g = b = _g;
    } else {
      if (h === 360) h = 0;
      if (h > 360) h -= 360;
      if (h < 0) h += 360;
      h /= 60;
      const i = floor(h);
      const f = h - i;
      const p = _g * (1 - c);
      const q = p + _c * (1 - f);
      const t = p + _c * f;
      const v = p + _c;
      switch (i) {
        case 0:
          [r, g, b] = [v, t, p];
          break;
        case 1:
          [r, g, b] = [q, v, p];
          break;
        case 2:
          [r, g, b] = [p, v, t];
          break;
        case 3:
          [r, g, b] = [p, q, v];
          break;
        case 4:
          [r, g, b] = [t, p, v];
          break;
        case 5:
          [r, g, b] = [v, p, q];
          break;
      }
    }
    return [r, g, b, args.length > 3 ? args[3] : 1];
  };
  var hcg2rgb_default = hcg2rgb;

  // node_modules/chroma-js/src/io/hcg/rgb2hcg.js
  var rgb2hcg = (...args) => {
    const [r, g, b] = unpack_default(args, "rgb");
    const minRgb = min2(r, g, b);
    const maxRgb = max2(r, g, b);
    const delta = maxRgb - minRgb;
    const c = delta * 100 / 255;
    const _g = minRgb / (255 - delta) * 100;
    let h;
    if (delta === 0) {
      h = Number.NaN;
    } else {
      if (r === maxRgb) h = (g - b) / delta;
      if (g === maxRgb) h = 2 + (b - r) / delta;
      if (b === maxRgb) h = 4 + (r - g) / delta;
      h *= 60;
      if (h < 0) h += 360;
    }
    return [h, c, _g];
  };
  var rgb2hcg_default = rgb2hcg;

  // node_modules/chroma-js/src/io/hcg/index.js
  Color_default.prototype.hcg = function() {
    return rgb2hcg_default(this._rgb);
  };
  var hcg = (...args) => new Color_default(...args, "hcg");
  chroma_default.hcg = hcg;
  input_default.format.hcg = hcg2rgb_default;
  input_default.autodetect.push({
    p: 1,
    test: (...args) => {
      args = unpack_default(args, "hcg");
      if (type_default(args) === "array" && args.length === 3) {
        return "hcg";
      }
    }
  });

  // node_modules/chroma-js/src/interpolator/hcg.js
  var hcg2 = (col1, col2, f) => {
    return hsx_default(col1, col2, f, "hcg");
  };
  interpolator_default.hcg = hcg2;

  // node_modules/chroma-js/src/io/hsi/hsi2rgb.js
  var { cos: cos2 } = Math;
  var hsi2rgb = (...args) => {
    args = unpack_default(args, "hsi");
    let [h, s, i] = args;
    let r, g, b;
    if (isNaN(h)) h = 0;
    if (isNaN(s)) s = 0;
    if (h > 360) h -= 360;
    if (h < 0) h += 360;
    h /= 360;
    if (h < 1 / 3) {
      b = (1 - s) / 3;
      r = (1 + s * cos2(TWOPI * h) / cos2(PITHIRD - TWOPI * h)) / 3;
      g = 1 - (b + r);
    } else if (h < 2 / 3) {
      h -= 1 / 3;
      r = (1 - s) / 3;
      g = (1 + s * cos2(TWOPI * h) / cos2(PITHIRD - TWOPI * h)) / 3;
      b = 1 - (r + g);
    } else {
      h -= 2 / 3;
      g = (1 - s) / 3;
      b = (1 + s * cos2(TWOPI * h) / cos2(PITHIRD - TWOPI * h)) / 3;
      r = 1 - (g + b);
    }
    r = limit_default(i * r * 3);
    g = limit_default(i * g * 3);
    b = limit_default(i * b * 3);
    return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];
  };
  var hsi2rgb_default = hsi2rgb;

  // node_modules/chroma-js/src/io/hsi/rgb2hsi.js
  var { min: min3, sqrt: sqrt3, acos } = Math;
  var rgb2hsi = (...args) => {
    let [r, g, b] = unpack_default(args, "rgb");
    r /= 255;
    g /= 255;
    b /= 255;
    let h;
    const min_ = min3(r, g, b);
    const i = (r + g + b) / 3;
    const s = i > 0 ? 1 - min_ / i : 0;
    if (s === 0) {
      h = NaN;
    } else {
      h = (r - g + (r - b)) / 2;
      h /= sqrt3((r - g) * (r - g) + (r - b) * (g - b));
      h = acos(h);
      if (b > g) {
        h = TWOPI - h;
      }
      h /= TWOPI;
    }
    return [h * 360, s, i];
  };
  var rgb2hsi_default = rgb2hsi;

  // node_modules/chroma-js/src/io/hsi/index.js
  Color_default.prototype.hsi = function() {
    return rgb2hsi_default(this._rgb);
  };
  var hsi = (...args) => new Color_default(...args, "hsi");
  chroma_default.hsi = hsi;
  input_default.format.hsi = hsi2rgb_default;
  input_default.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack_default(args, "hsi");
      if (type_default(args) === "array" && args.length === 3) {
        return "hsi";
      }
    }
  });

  // node_modules/chroma-js/src/interpolator/hsi.js
  var hsi2 = (col1, col2, f) => {
    return hsx_default(col1, col2, f, "hsi");
  };
  interpolator_default.hsi = hsi2;

  // node_modules/chroma-js/src/io/hsl/hsl2rgb.js
  var hsl2rgb = (...args) => {
    args = unpack_default(args, "hsl");
    const [h, s, l] = args;
    let r, g, b;
    if (s === 0) {
      r = g = b = l * 255;
    } else {
      const t3 = [0, 0, 0];
      const c = [0, 0, 0];
      const t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const t1 = 2 * l - t2;
      const h_ = h / 360;
      t3[0] = h_ + 1 / 3;
      t3[1] = h_;
      t3[2] = h_ - 1 / 3;
      for (let i = 0; i < 3; i++) {
        if (t3[i] < 0) t3[i] += 1;
        if (t3[i] > 1) t3[i] -= 1;
        if (6 * t3[i] < 1) c[i] = t1 + (t2 - t1) * 6 * t3[i];
        else if (2 * t3[i] < 1) c[i] = t2;
        else if (3 * t3[i] < 2) c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6;
        else c[i] = t1;
      }
      [r, g, b] = [c[0] * 255, c[1] * 255, c[2] * 255];
    }
    if (args.length > 3) {
      return [r, g, b, args[3]];
    }
    return [r, g, b, 1];
  };
  var hsl2rgb_default = hsl2rgb;

  // node_modules/chroma-js/src/io/hsl/rgb2hsl.js
  var rgb2hsl = (...args) => {
    args = unpack_default(args, "rgba");
    let [r, g, b] = args;
    r /= 255;
    g /= 255;
    b /= 255;
    const minRgb = min2(r, g, b);
    const maxRgb = max2(r, g, b);
    const l = (maxRgb + minRgb) / 2;
    let s, h;
    if (maxRgb === minRgb) {
      s = 0;
      h = Number.NaN;
    } else {
      s = l < 0.5 ? (maxRgb - minRgb) / (maxRgb + minRgb) : (maxRgb - minRgb) / (2 - maxRgb - minRgb);
    }
    if (r == maxRgb) h = (g - b) / (maxRgb - minRgb);
    else if (g == maxRgb) h = 2 + (b - r) / (maxRgb - minRgb);
    else if (b == maxRgb) h = 4 + (r - g) / (maxRgb - minRgb);
    h *= 60;
    if (h < 0) h += 360;
    if (args.length > 3 && args[3] !== void 0) return [h, s, l, args[3]];
    return [h, s, l];
  };
  var rgb2hsl_default = rgb2hsl;

  // node_modules/chroma-js/src/io/hsl/index.js
  Color_default.prototype.hsl = function() {
    return rgb2hsl_default(this._rgb);
  };
  var hsl = (...args) => new Color_default(...args, "hsl");
  chroma_default.hsl = hsl;
  input_default.format.hsl = hsl2rgb_default;
  input_default.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack_default(args, "hsl");
      if (type_default(args) === "array" && args.length === 3) {
        return "hsl";
      }
    }
  });

  // node_modules/chroma-js/src/interpolator/hsl.js
  var hsl2 = (col1, col2, f) => {
    return hsx_default(col1, col2, f, "hsl");
  };
  interpolator_default.hsl = hsl2;

  // node_modules/chroma-js/src/io/hsv/hsv2rgb.js
  var { floor: floor2 } = Math;
  var hsv2rgb = (...args) => {
    args = unpack_default(args, "hsv");
    let [h, s, v] = args;
    let r, g, b;
    v *= 255;
    if (s === 0) {
      r = g = b = v;
    } else {
      if (h === 360) h = 0;
      if (h > 360) h -= 360;
      if (h < 0) h += 360;
      h /= 60;
      const i = floor2(h);
      const f = h - i;
      const p = v * (1 - s);
      const q = v * (1 - s * f);
      const t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          [r, g, b] = [v, t, p];
          break;
        case 1:
          [r, g, b] = [q, v, p];
          break;
        case 2:
          [r, g, b] = [p, v, t];
          break;
        case 3:
          [r, g, b] = [p, q, v];
          break;
        case 4:
          [r, g, b] = [t, p, v];
          break;
        case 5:
          [r, g, b] = [v, p, q];
          break;
      }
    }
    return [r, g, b, args.length > 3 ? args[3] : 1];
  };
  var hsv2rgb_default = hsv2rgb;

  // node_modules/chroma-js/src/io/hsv/rgb2hsv.js
  var { min: min4, max: max3 } = Math;
  var rgb2hsl2 = (...args) => {
    args = unpack_default(args, "rgb");
    let [r, g, b] = args;
    const min_ = min4(r, g, b);
    const max_ = max3(r, g, b);
    const delta = max_ - min_;
    let h, s, v;
    v = max_ / 255;
    if (max_ === 0) {
      h = Number.NaN;
      s = 0;
    } else {
      s = delta / max_;
      if (r === max_) h = (g - b) / delta;
      if (g === max_) h = 2 + (b - r) / delta;
      if (b === max_) h = 4 + (r - g) / delta;
      h *= 60;
      if (h < 0) h += 360;
    }
    return [h, s, v];
  };
  var rgb2hsv_default = rgb2hsl2;

  // node_modules/chroma-js/src/io/hsv/index.js
  Color_default.prototype.hsv = function() {
    return rgb2hsv_default(this._rgb);
  };
  var hsv = (...args) => new Color_default(...args, "hsv");
  chroma_default.hsv = hsv;
  input_default.format.hsv = hsv2rgb_default;
  input_default.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack_default(args, "hsv");
      if (type_default(args) === "array" && args.length === 3) {
        return "hsv";
      }
    }
  });

  // node_modules/chroma-js/src/interpolator/hsv.js
  var hsv2 = (col1, col2, f) => {
    return hsx_default(col1, col2, f, "hsv");
  };
  interpolator_default.hsv = hsv2;

  // node_modules/chroma-js/src/utils/multiply-matrices.js
  function multiplyMatrices(A, B) {
    let m = A.length;
    if (!Array.isArray(A[0])) {
      A = [A];
    }
    if (!Array.isArray(B[0])) {
      B = B.map((x) => [x]);
    }
    let p = B[0].length;
    let B_cols = B[0].map((_, i) => B.map((x) => x[i]));
    let product = A.map(
      (row) => B_cols.map((col) => {
        if (!Array.isArray(row)) {
          return col.reduce((a, c) => a + c * row, 0);
        }
        return row.reduce((a, c, i) => a + c * (col[i] || 0), 0);
      })
    );
    if (m === 1) {
      product = product[0];
    }
    if (p === 1) {
      return product.map((x) => x[0]);
    }
    return product;
  }

  // node_modules/chroma-js/src/io/oklab/oklab2rgb.js
  var oklab2rgb = (...args) => {
    args = unpack_default(args, "lab");
    const [L, a, b, ...rest] = args;
    const [X, Y, Z] = OKLab_to_XYZ([L, a, b]);
    const [r, g, b_] = xyz2rgb(X, Y, Z);
    return [r, g, b_, ...rest.length > 0 && rest[0] < 1 ? [rest[0]] : []];
  };
  function OKLab_to_XYZ(OKLab) {
    var LMStoXYZ = [
      [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],
      [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],
      [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]
    ];
    var OKLabtoLMS = [
      [1, 0.3963377773761749, 0.2158037573099136],
      [1, -0.1055613458156586, -0.0638541728258133],
      [1, -0.0894841775298119, -1.2914855480194092]
    ];
    var LMSnl = multiplyMatrices(OKLabtoLMS, OKLab);
    return multiplyMatrices(
      LMStoXYZ,
      LMSnl.map((c) => c ** 3)
    );
  }
  var oklab2rgb_default = oklab2rgb;

  // node_modules/chroma-js/src/io/oklab/rgb2oklab.js
  var rgb2oklab = (...args) => {
    const [r, g, b, ...rest] = unpack_default(args, "rgb");
    const xyz = rgb2xyz(r, g, b);
    const oklab3 = XYZ_to_OKLab(xyz);
    return [...oklab3, ...rest.length > 0 && rest[0] < 1 ? [rest[0]] : []];
  };
  function XYZ_to_OKLab(XYZ) {
    const XYZtoLMS = [
      [0.819022437996703, 0.3619062600528904, -0.1288737815209879],
      [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],
      [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]
    ];
    const LMStoOKLab = [
      [0.210454268309314, 0.7936177747023054, -0.0040720430116193],
      [1.9779985324311684, -2.42859224204858, 0.450593709617411],
      [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]
    ];
    const LMS = multiplyMatrices(XYZtoLMS, XYZ);
    return multiplyMatrices(
      LMStoOKLab,
      LMS.map((c) => Math.cbrt(c))
    );
  }
  var rgb2oklab_default = rgb2oklab;

  // node_modules/chroma-js/src/io/oklab/index.js
  Color_default.prototype.oklab = function() {
    return rgb2oklab_default(this._rgb);
  };
  var oklab = (...args) => new Color_default(...args, "oklab");
  Object.assign(chroma_default, { oklab });
  input_default.format.oklab = oklab2rgb_default;
  input_default.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack_default(args, "oklab");
      if (type_default(args) === "array" && args.length === 3) {
        return "oklab";
      }
    }
  });

  // node_modules/chroma-js/src/interpolator/oklab.js
  var oklab2 = (col1, col2, f) => {
    const xyz0 = col1.oklab();
    const xyz1 = col2.oklab();
    return new Color_default(
      xyz0[0] + f * (xyz1[0] - xyz0[0]),
      xyz0[1] + f * (xyz1[1] - xyz0[1]),
      xyz0[2] + f * (xyz1[2] - xyz0[2]),
      "oklab"
    );
  };
  interpolator_default.oklab = oklab2;

  // node_modules/chroma-js/src/interpolator/oklch.js
  var oklch = (col1, col2, f) => {
    return hsx_default(col1, col2, f, "oklch");
  };
  interpolator_default.oklch = oklch;

  // node_modules/chroma-js/src/generator/average.js
  var { pow: pow3, sqrt: sqrt4, PI: PI2, cos: cos3, sin: sin2, atan2: atan22 } = Math;
  var average_default = (colors, mode = "lrgb", weights = null) => {
    const l = colors.length;
    if (!weights) weights = Array.from(new Array(l)).map(() => 1);
    const k = l / weights.reduce(function(a, b) {
      return a + b;
    });
    weights.forEach((w, i) => {
      weights[i] *= k;
    });
    colors = colors.map((c) => new Color_default(c));
    if (mode === "lrgb") {
      return _average_lrgb(colors, weights);
    }
    const first = colors.shift();
    const xyz = first.get(mode);
    const cnt = [];
    let dx = 0;
    let dy = 0;
    for (let i = 0; i < xyz.length; i++) {
      xyz[i] = (xyz[i] || 0) * weights[0];
      cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);
      if (mode.charAt(i) === "h" && !isNaN(xyz[i])) {
        const A = xyz[i] / 180 * PI2;
        dx += cos3(A) * weights[0];
        dy += sin2(A) * weights[0];
      }
    }
    let alpha = first.alpha() * weights[0];
    colors.forEach((c, ci) => {
      const xyz2 = c.get(mode);
      alpha += c.alpha() * weights[ci + 1];
      for (let i = 0; i < xyz.length; i++) {
        if (!isNaN(xyz2[i])) {
          cnt[i] += weights[ci + 1];
          if (mode.charAt(i) === "h") {
            const A = xyz2[i] / 180 * PI2;
            dx += cos3(A) * weights[ci + 1];
            dy += sin2(A) * weights[ci + 1];
          } else {
            xyz[i] += xyz2[i] * weights[ci + 1];
          }
        }
      }
    });
    for (let i = 0; i < xyz.length; i++) {
      if (mode.charAt(i) === "h") {
        let A = atan22(dy / cnt[i], dx / cnt[i]) / PI2 * 180;
        while (A < 0) A += 360;
        while (A >= 360) A -= 360;
        xyz[i] = A;
      } else {
        xyz[i] = xyz[i] / cnt[i];
      }
    }
    alpha /= l;
    return new Color_default(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);
  };
  var _average_lrgb = (colors, weights) => {
    const l = colors.length;
    const xyz = [0, 0, 0, 0];
    for (let i = 0; i < colors.length; i++) {
      const col = colors[i];
      const f = weights[i] / l;
      const rgb3 = col._rgb;
      xyz[0] += pow3(rgb3[0], 2) * f;
      xyz[1] += pow3(rgb3[1], 2) * f;
      xyz[2] += pow3(rgb3[2], 2) * f;
      xyz[3] += rgb3[3] * f;
    }
    xyz[0] = sqrt4(xyz[0]);
    xyz[1] = sqrt4(xyz[1]);
    xyz[2] = sqrt4(xyz[2]);
    if (xyz[3] > 0.9999999) xyz[3] = 1;
    return new Color_default(clip_rgb_default(xyz));
  };

  // node_modules/chroma-js/src/generator/scale.js
  var { pow: pow4 } = Math;
  function scale_default(colors) {
    let _mode = "rgb";
    let _nacol = chroma_default("#ccc");
    let _spread = 0;
    let _domain = [0, 1];
    let _pos = [];
    let _padding = [0, 0];
    let _classes = false;
    let _colors = [];
    let _out = false;
    let _min = 0;
    let _max = 1;
    let _correctLightness = false;
    let _colorCache = {};
    let _useCache = true;
    let _gamma = 1;
    const setColors = function(colors2) {
      colors2 = colors2 || ["#fff", "#000"];
      if (colors2 && type_default(colors2) === "string" && chroma_default.brewer && chroma_default.brewer[colors2.toLowerCase()]) {
        colors2 = chroma_default.brewer[colors2.toLowerCase()];
      }
      if (type_default(colors2) === "array") {
        if (colors2.length === 1) {
          colors2 = [colors2[0], colors2[0]];
        }
        colors2 = colors2.slice(0);
        for (let c = 0; c < colors2.length; c++) {
          colors2[c] = chroma_default(colors2[c]);
        }
        _pos.length = 0;
        for (let c = 0; c < colors2.length; c++) {
          _pos.push(c / (colors2.length - 1));
        }
      }
      resetCache();
      return _colors = colors2;
    };
    const getClass = function(value) {
      if (_classes != null) {
        const n = _classes.length - 1;
        let i = 0;
        while (i < n && value >= _classes[i]) {
          i++;
        }
        return i - 1;
      }
      return 0;
    };
    let tMapLightness = (t) => t;
    let tMapDomain = (t) => t;
    const getColor = function(val, bypassMap) {
      let col, t;
      if (bypassMap == null) {
        bypassMap = false;
      }
      if (isNaN(val) || val === null) {
        return _nacol;
      }
      if (!bypassMap) {
        if (_classes && _classes.length > 2) {
          const c = getClass(val);
          t = c / (_classes.length - 2);
        } else if (_max !== _min) {
          t = (val - _min) / (_max - _min);
        } else {
          t = 1;
        }
      } else {
        t = val;
      }
      t = tMapDomain(t);
      if (!bypassMap) {
        t = tMapLightness(t);
      }
      if (_gamma !== 1) {
        t = pow4(t, _gamma);
      }
      t = _padding[0] + t * (1 - _padding[0] - _padding[1]);
      t = limit_default(t, 0, 1);
      const k = Math.floor(t * 1e4);
      if (_useCache && _colorCache[k]) {
        col = _colorCache[k];
      } else {
        if (type_default(_colors) === "array") {
          for (let i = 0; i < _pos.length; i++) {
            const p = _pos[i];
            if (t <= p) {
              col = _colors[i];
              break;
            }
            if (t >= p && i === _pos.length - 1) {
              col = _colors[i];
              break;
            }
            if (t > p && t < _pos[i + 1]) {
              t = (t - p) / (_pos[i + 1] - p);
              col = chroma_default.interpolate(
                _colors[i],
                _colors[i + 1],
                t,
                _mode
              );
              break;
            }
          }
        } else if (type_default(_colors) === "function") {
          col = _colors(t);
        }
        if (_useCache) {
          _colorCache[k] = col;
        }
      }
      return col;
    };
    var resetCache = () => _colorCache = {};
    setColors(colors);
    const f = function(v) {
      const c = chroma_default(getColor(v));
      if (_out && c[_out]) {
        return c[_out]();
      } else {
        return c;
      }
    };
    f.classes = function(classes) {
      if (classes != null) {
        if (type_default(classes) === "array") {
          _classes = classes;
          _domain = [classes[0], classes[classes.length - 1]];
        } else {
          const d = chroma_default.analyze(_domain);
          if (classes === 0) {
            _classes = [d.min, d.max];
          } else {
            _classes = chroma_default.limits(d, "e", classes);
          }
        }
        return f;
      }
      return _classes;
    };
    f.domain = function(domain) {
      if (!arguments.length) {
        return _domain;
      }
      _min = domain[0];
      _max = domain[domain.length - 1];
      _pos = [];
      const k = _colors.length;
      if (domain.length === k && _min !== _max) {
        for (let d of Array.from(domain)) {
          _pos.push((d - _min) / (_max - _min));
        }
      } else {
        for (let c = 0; c < k; c++) {
          _pos.push(c / (k - 1));
        }
        if (domain.length > 2) {
          const tOut = domain.map((d, i) => i / (domain.length - 1));
          const tBreaks = domain.map((d) => (d - _min) / (_max - _min));
          if (!tBreaks.every((val, i) => tOut[i] === val)) {
            tMapDomain = (t) => {
              if (t <= 0 || t >= 1) return t;
              let i = 0;
              while (t >= tBreaks[i + 1]) i++;
              const f2 = (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);
              const out = tOut[i] + f2 * (tOut[i + 1] - tOut[i]);
              return out;
            };
          }
        }
      }
      _domain = [_min, _max];
      return f;
    };
    f.mode = function(_m) {
      if (!arguments.length) {
        return _mode;
      }
      _mode = _m;
      resetCache();
      return f;
    };
    f.range = function(colors2, _pos2) {
      setColors(colors2, _pos2);
      return f;
    };
    f.out = function(_o) {
      _out = _o;
      return f;
    };
    f.spread = function(val) {
      if (!arguments.length) {
        return _spread;
      }
      _spread = val;
      return f;
    };
    f.correctLightness = function(v) {
      if (v == null) {
        v = true;
      }
      _correctLightness = v;
      resetCache();
      if (_correctLightness) {
        tMapLightness = function(t) {
          const L0 = getColor(0, true).lab()[0];
          const L1 = getColor(1, true).lab()[0];
          const pol = L0 > L1;
          let L_actual = getColor(t, true).lab()[0];
          const L_ideal = L0 + (L1 - L0) * t;
          let L_diff = L_actual - L_ideal;
          let t0 = 0;
          let t1 = 1;
          let max_iter = 20;
          while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
            (function() {
              if (pol) {
                L_diff *= -1;
              }
              if (L_diff < 0) {
                t0 = t;
                t += (t1 - t) * 0.5;
              } else {
                t1 = t;
                t += (t0 - t) * 0.5;
              }
              L_actual = getColor(t, true).lab()[0];
              return L_diff = L_actual - L_ideal;
            })();
          }
          return t;
        };
      } else {
        tMapLightness = (t) => t;
      }
      return f;
    };
    f.padding = function(p) {
      if (p != null) {
        if (type_default(p) === "number") {
          p = [p, p];
        }
        _padding = p;
        return f;
      } else {
        return _padding;
      }
    };
    f.colors = function(numColors, out) {
      if (arguments.length < 2) {
        out = "hex";
      }
      let result = [];
      if (arguments.length === 0) {
        result = _colors.slice(0);
      } else if (numColors === 1) {
        result = [f(0.5)];
      } else if (numColors > 1) {
        const dm = _domain[0];
        const dd = _domain[1] - dm;
        result = __range__(0, numColors, false).map(
          (i) => f(dm + i / (numColors - 1) * dd)
        );
      } else {
        colors = [];
        let samples = [];
        if (_classes && _classes.length > 2) {
          for (let i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
            samples.push((_classes[i - 1] + _classes[i]) * 0.5);
          }
        } else {
          samples = _domain;
        }
        result = samples.map((v) => f(v));
      }
      if (chroma_default[out]) {
        result = result.map((c) => c[out]());
      }
      return result;
    };
    f.cache = function(c) {
      if (c != null) {
        _useCache = c;
        return f;
      } else {
        return _useCache;
      }
    };
    f.gamma = function(g) {
      if (g != null) {
        _gamma = g;
        return f;
      } else {
        return _gamma;
      }
    };
    f.nodata = function(d) {
      if (d != null) {
        _nacol = chroma_default(d);
        return f;
      } else {
        return _nacol;
      }
    };
    return f;
  }
  function __range__(left, right, inclusive) {
    let range = [];
    let ascending = left < right;
    let end = !inclusive ? right : ascending ? right + 1 : right - 1;
    for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
      range.push(i);
    }
    return range;
  }

  // node_modules/chroma-js/src/generator/bezier.js
  var binom_row = function(n) {
    let row = [1, 1];
    for (let i = 1; i < n; i++) {
      let newrow = [1];
      for (let j = 1; j <= row.length; j++) {
        newrow[j] = (row[j] || 0) + row[j - 1];
      }
      row = newrow;
    }
    return row;
  };
  var bezier = function(colors) {
    let I, lab0, lab1, lab22;
    colors = colors.map((c) => new Color_default(c));
    if (colors.length === 2) {
      [lab0, lab1] = colors.map((c) => c.lab());
      I = function(t) {
        const lab3 = [0, 1, 2].map((i) => lab0[i] + t * (lab1[i] - lab0[i]));
        return new Color_default(lab3, "lab");
      };
    } else if (colors.length === 3) {
      [lab0, lab1, lab22] = colors.map((c) => c.lab());
      I = function(t) {
        const lab3 = [0, 1, 2].map(
          (i) => (1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab22[i]
        );
        return new Color_default(lab3, "lab");
      };
    } else if (colors.length === 4) {
      let lab3;
      [lab0, lab1, lab22, lab3] = colors.map((c) => c.lab());
      I = function(t) {
        const lab4 = [0, 1, 2].map(
          (i) => (1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab22[i] + t * t * t * lab3[i]
        );
        return new Color_default(lab4, "lab");
      };
    } else if (colors.length >= 5) {
      let labs, row, n;
      labs = colors.map((c) => c.lab());
      n = colors.length - 1;
      row = binom_row(n);
      I = function(t) {
        const u = 1 - t;
        const lab3 = [0, 1, 2].map(
          (i) => labs.reduce(
            (sum, el, j) => sum + row[j] * u ** (n - j) * t ** j * el[i],
            0
          )
        );
        return new Color_default(lab3, "lab");
      };
    } else {
      throw new RangeError("No point in running bezier with only one color.");
    }
    return I;
  };
  var bezier_default = (colors) => {
    const f = bezier(colors);
    f.scale = () => scale_default(f);
    return f;
  };

  // node_modules/chroma-js/src/io/rgb/index.js
  var { round: round3 } = Math;
  Color_default.prototype.rgb = function(rnd = true) {
    if (rnd === false) return this._rgb.slice(0, 3);
    return this._rgb.slice(0, 3).map(round3);
  };
  Color_default.prototype.rgba = function(rnd = true) {
    return this._rgb.slice(0, 4).map((v, i) => {
      return i < 3 ? rnd === false ? v : round3(v) : v;
    });
  };
  var rgb2 = (...args) => new Color_default(...args, "rgb");
  Object.assign(chroma_default, { rgb: rgb2 });
  input_default.format.rgb = (...args) => {
    const rgba = unpack_default(args, "rgba");
    if (rgba[3] === void 0) rgba[3] = 1;
    return rgba;
  };
  input_default.autodetect.push({
    p: 3,
    test: (...args) => {
      args = unpack_default(args, "rgba");
      if (type_default(args) === "array" && (args.length === 3 || args.length === 4 && type_default(args[3]) == "number" && args[3] >= 0 && args[3] <= 1)) {
        return "rgb";
      }
    }
  });

  // node_modules/chroma-js/src/generator/blend.js
  var blend = (bottom, top, mode) => {
    if (!blend[mode]) {
      throw new Error("unknown blend mode " + mode);
    }
    return blend[mode](bottom, top);
  };
  var blend_f = (f) => (bottom, top) => {
    const c0 = chroma_default(top).rgb();
    const c1 = chroma_default(bottom).rgb();
    return chroma_default.rgb(f(c0, c1));
  };
  var each = (f) => (c0, c1) => {
    const out = [];
    out[0] = f(c0[0], c1[0]);
    out[1] = f(c0[1], c1[1]);
    out[2] = f(c0[2], c1[2]);
    return out;
  };
  var normal = (a) => a;
  var multiply = (a, b) => a * b / 255;
  var darken = (a, b) => a > b ? b : a;
  var lighten = (a, b) => a > b ? a : b;
  var screen = (a, b) => 255 * (1 - (1 - a / 255) * (1 - b / 255));
  var overlay = (a, b) => b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
  var burn = (a, b) => 255 * (1 - (1 - b / 255) / (a / 255));
  var dodge = (a, b) => {
    if (a === 255) return 255;
    a = 255 * (b / 255) / (1 - a / 255);
    return a > 255 ? 255 : a;
  };
  blend.normal = blend_f(each(normal));
  blend.multiply = blend_f(each(multiply));
  blend.screen = blend_f(each(screen));
  blend.overlay = blend_f(each(overlay));
  blend.darken = blend_f(each(darken));
  blend.lighten = blend_f(each(lighten));
  blend.dodge = blend_f(each(dodge));
  blend.burn = blend_f(each(burn));
  var blend_default = blend;

  // node_modules/chroma-js/src/generator/cubehelix.js
  var { pow: pow5, sin: sin3, cos: cos4 } = Math;
  function cubehelix_default(start = 300, rotations = -1.5, hue = 1, gamma = 1, lightness = [0, 1]) {
    let dh = 0, dl;
    if (type_default(lightness) === "array") {
      dl = lightness[1] - lightness[0];
    } else {
      dl = 0;
      lightness = [lightness, lightness];
    }
    const f = function(fract) {
      const a = TWOPI * ((start + 120) / 360 + rotations * fract);
      const l = pow5(lightness[0] + dl * fract, gamma);
      const h = dh !== 0 ? hue[0] + fract * dh : hue;
      const amp = h * l * (1 - l) / 2;
      const cos_a = cos4(a);
      const sin_a = sin3(a);
      const r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
      const g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
      const b = l + amp * (1.97294 * cos_a);
      return chroma_default(clip_rgb_default([r * 255, g * 255, b * 255, 1]));
    };
    f.start = function(s) {
      if (s == null) {
        return start;
      }
      start = s;
      return f;
    };
    f.rotations = function(r) {
      if (r == null) {
        return rotations;
      }
      rotations = r;
      return f;
    };
    f.gamma = function(g) {
      if (g == null) {
        return gamma;
      }
      gamma = g;
      return f;
    };
    f.hue = function(h) {
      if (h == null) {
        return hue;
      }
      hue = h;
      if (type_default(hue) === "array") {
        dh = hue[1] - hue[0];
        if (dh === 0) {
          hue = hue[1];
        }
      } else {
        dh = 0;
      }
      return f;
    };
    f.lightness = function(h) {
      if (h == null) {
        return lightness;
      }
      if (type_default(h) === "array") {
        lightness = h;
        dl = h[1] - h[0];
      } else {
        lightness = [h, h];
        dl = 0;
      }
      return f;
    };
    f.scale = () => chroma_default.scale(f);
    f.hue(hue);
    return f;
  }

  // node_modules/chroma-js/src/generator/random.js
  var digits = "0123456789abcdef";
  var { floor: floor3, random } = Math;
  var random_default = () => {
    let code = "#";
    for (let i = 0; i < 6; i++) {
      code += digits.charAt(floor3(random() * 16));
    }
    return new Color_default(code, "hex");
  };

  // node_modules/chroma-js/src/utils/analyze.js
  var { log, pow: pow6, floor: floor4, abs } = Math;
  function analyze(data, key = null) {
    const r = {
      min: Number.MAX_VALUE,
      max: Number.MAX_VALUE * -1,
      sum: 0,
      values: [],
      count: 0
    };
    if (type_default(data) === "object") {
      data = Object.values(data);
    }
    data.forEach((val) => {
      if (key && type_default(val) === "object") val = val[key];
      if (val !== void 0 && val !== null && !isNaN(val)) {
        r.values.push(val);
        r.sum += val;
        if (val < r.min) r.min = val;
        if (val > r.max) r.max = val;
        r.count += 1;
      }
    });
    r.domain = [r.min, r.max];
    r.limits = (mode, num3) => limits(r, mode, num3);
    return r;
  }
  function limits(data, mode = "equal", num3 = 7) {
    if (type_default(data) == "array") {
      data = analyze(data);
    }
    const { min: min6, max: max6 } = data;
    const values = data.values.sort((a, b) => a - b);
    if (num3 === 1) {
      return [min6, max6];
    }
    const limits2 = [];
    if (mode.substr(0, 1) === "c") {
      limits2.push(min6);
      limits2.push(max6);
    }
    if (mode.substr(0, 1) === "e") {
      limits2.push(min6);
      for (let i = 1; i < num3; i++) {
        limits2.push(min6 + i / num3 * (max6 - min6));
      }
      limits2.push(max6);
    } else if (mode.substr(0, 1) === "l") {
      if (min6 <= 0) {
        throw new Error(
          "Logarithmic scales are only possible for values > 0"
        );
      }
      const min_log = Math.LOG10E * log(min6);
      const max_log = Math.LOG10E * log(max6);
      limits2.push(min6);
      for (let i = 1; i < num3; i++) {
        limits2.push(pow6(10, min_log + i / num3 * (max_log - min_log)));
      }
      limits2.push(max6);
    } else if (mode.substr(0, 1) === "q") {
      limits2.push(min6);
      for (let i = 1; i < num3; i++) {
        const p = (values.length - 1) * i / num3;
        const pb = floor4(p);
        if (pb === p) {
          limits2.push(values[pb]);
        } else {
          const pr = p - pb;
          limits2.push(values[pb] * (1 - pr) + values[pb + 1] * pr);
        }
      }
      limits2.push(max6);
    } else if (mode.substr(0, 1) === "k") {
      let cluster;
      const n = values.length;
      const assignments = new Array(n);
      const clusterSizes = new Array(num3);
      let repeat2 = true;
      let nb_iters = 0;
      let centroids = null;
      centroids = [];
      centroids.push(min6);
      for (let i = 1; i < num3; i++) {
        centroids.push(min6 + i / num3 * (max6 - min6));
      }
      centroids.push(max6);
      while (repeat2) {
        for (let j = 0; j < num3; j++) {
          clusterSizes[j] = 0;
        }
        for (let i = 0; i < n; i++) {
          const value = values[i];
          let mindist = Number.MAX_VALUE;
          let best;
          for (let j = 0; j < num3; j++) {
            const dist = abs(centroids[j] - value);
            if (dist < mindist) {
              mindist = dist;
              best = j;
            }
            clusterSizes[best]++;
            assignments[i] = best;
          }
        }
        const newCentroids = new Array(num3);
        for (let j = 0; j < num3; j++) {
          newCentroids[j] = null;
        }
        for (let i = 0; i < n; i++) {
          cluster = assignments[i];
          if (newCentroids[cluster] === null) {
            newCentroids[cluster] = values[i];
          } else {
            newCentroids[cluster] += values[i];
          }
        }
        for (let j = 0; j < num3; j++) {
          newCentroids[j] *= 1 / clusterSizes[j];
        }
        repeat2 = false;
        for (let j = 0; j < num3; j++) {
          if (newCentroids[j] !== centroids[j]) {
            repeat2 = true;
            break;
          }
        }
        centroids = newCentroids;
        nb_iters++;
        if (nb_iters > 200) {
          repeat2 = false;
        }
      }
      const kClusters = {};
      for (let j = 0; j < num3; j++) {
        kClusters[j] = [];
      }
      for (let i = 0; i < n; i++) {
        cluster = assignments[i];
        kClusters[cluster].push(values[i]);
      }
      let tmpKMeansBreaks = [];
      for (let j = 0; j < num3; j++) {
        tmpKMeansBreaks.push(kClusters[j][0]);
        tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);
      }
      tmpKMeansBreaks = tmpKMeansBreaks.sort((a, b) => a - b);
      limits2.push(tmpKMeansBreaks[0]);
      for (let i = 1; i < tmpKMeansBreaks.length; i += 2) {
        const v = tmpKMeansBreaks[i];
        if (!isNaN(v) && limits2.indexOf(v) === -1) {
          limits2.push(v);
        }
      }
    }
    return limits2;
  }

  // node_modules/chroma-js/src/utils/contrast.js
  var contrast_default = (a, b) => {
    a = new Color_default(a);
    b = new Color_default(b);
    const l1 = a.luminance();
    const l2 = b.luminance();
    return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
  };

  // node_modules/chroma-js/src/utils/contrastAPCA.js
  var W_offset = 0.027;
  var P_in = 5e-4;
  var P_out = 0.1;
  var R_scale = 1.14;
  var B_threshold = 0.022;
  var B_exp = 1.414;
  var contrastAPCA_default = (text, bg) => {
    text = new Color_default(text);
    bg = new Color_default(bg);
    if (text.alpha() < 1) {
      text = mix_default(bg, text, text.alpha(), "rgb");
    }
    const l_text = lum(...text.rgb());
    const l_bg = lum(...bg.rgb());
    const Y_text = l_text >= B_threshold ? l_text : l_text + Math.pow(B_threshold - l_text, B_exp);
    const Y_bg = l_bg >= B_threshold ? l_bg : l_bg + Math.pow(B_threshold - l_bg, B_exp);
    const S_norm = Math.pow(Y_bg, 0.56) - Math.pow(Y_text, 0.57);
    const S_rev = Math.pow(Y_bg, 0.65) - Math.pow(Y_text, 0.62);
    const C = Math.abs(Y_bg - Y_text) < P_in ? 0 : Y_text < Y_bg ? S_norm * R_scale : S_rev * R_scale;
    const S_apc = Math.abs(C) < P_out ? 0 : C > 0 ? C - W_offset : C + W_offset;
    return S_apc * 100;
  };
  function lum(r, g, b) {
    return 0.2126729 * Math.pow(r / 255, 2.4) + 0.7151522 * Math.pow(g / 255, 2.4) + 0.072175 * Math.pow(b / 255, 2.4);
  }

  // node_modules/chroma-js/src/utils/delta-e.js
  var { sqrt: sqrt5, pow: pow7, min: min5, max: max4, atan2: atan23, abs: abs2, cos: cos5, sin: sin4, exp, PI: PI3 } = Math;
  function delta_e_default(a, b, Kl = 1, Kc = 1, Kh = 1) {
    var rad2deg = function(rad) {
      return 360 * rad / (2 * PI3);
    };
    var deg2rad = function(deg) {
      return 2 * PI3 * deg / 360;
    };
    a = new Color_default(a);
    b = new Color_default(b);
    const [L1, a1, b1] = Array.from(a.lab());
    const [L2, a2, b2] = Array.from(b.lab());
    const avgL = (L1 + L2) / 2;
    const C1 = sqrt5(pow7(a1, 2) + pow7(b1, 2));
    const C2 = sqrt5(pow7(a2, 2) + pow7(b2, 2));
    const avgC = (C1 + C2) / 2;
    const G = 0.5 * (1 - sqrt5(pow7(avgC, 7) / (pow7(avgC, 7) + pow7(25, 7))));
    const a1p = a1 * (1 + G);
    const a2p = a2 * (1 + G);
    const C1p = sqrt5(pow7(a1p, 2) + pow7(b1, 2));
    const C2p = sqrt5(pow7(a2p, 2) + pow7(b2, 2));
    const avgCp = (C1p + C2p) / 2;
    const arctan1 = rad2deg(atan23(b1, a1p));
    const arctan2 = rad2deg(atan23(b2, a2p));
    const h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
    const h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
    const avgHp = abs2(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;
    const T = 1 - 0.17 * cos5(deg2rad(avgHp - 30)) + 0.24 * cos5(deg2rad(2 * avgHp)) + 0.32 * cos5(deg2rad(3 * avgHp + 6)) - 0.2 * cos5(deg2rad(4 * avgHp - 63));
    let deltaHp = h2p - h1p;
    deltaHp = abs2(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
    deltaHp = 2 * sqrt5(C1p * C2p) * sin4(deg2rad(deltaHp) / 2);
    const deltaL = L2 - L1;
    const deltaCp = C2p - C1p;
    const sl = 1 + 0.015 * pow7(avgL - 50, 2) / sqrt5(20 + pow7(avgL - 50, 2));
    const sc = 1 + 0.045 * avgCp;
    const sh = 1 + 0.015 * avgCp * T;
    const deltaTheta = 30 * exp(-pow7((avgHp - 275) / 25, 2));
    const Rc = 2 * sqrt5(pow7(avgCp, 7) / (pow7(avgCp, 7) + pow7(25, 7)));
    const Rt = -Rc * sin4(2 * deg2rad(deltaTheta));
    const result = sqrt5(
      pow7(deltaL / (Kl * sl), 2) + pow7(deltaCp / (Kc * sc), 2) + pow7(deltaHp / (Kh * sh), 2) + Rt * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh))
    );
    return max4(0, min5(100, result));
  }

  // node_modules/chroma-js/src/utils/distance.js
  function distance_default(a, b, mode = "lab") {
    a = new Color_default(a);
    b = new Color_default(b);
    const l1 = a.get(mode);
    const l2 = b.get(mode);
    let sum_sq = 0;
    for (let i in l1) {
      const d = (l1[i] || 0) - (l2[i] || 0);
      sum_sq += d * d;
    }
    return Math.sqrt(sum_sq);
  }

  // node_modules/chroma-js/src/utils/valid.js
  var valid_default = (...args) => {
    try {
      new Color_default(...args);
      return true;
    } catch (e) {
      return false;
    }
  };

  // node_modules/chroma-js/src/utils/scales.js
  var scales_default = {
    cool() {
      return scale_default([chroma_default.hsl(180, 1, 0.9), chroma_default.hsl(250, 0.7, 0.4)]);
    },
    hot() {
      return scale_default(["#000", "#f00", "#ff0", "#fff"], [0, 0.25, 0.75, 1]).mode(
        "rgb"
      );
    }
  };

  // node_modules/chroma-js/src/colors/colorbrewer.js
  var colorbrewer = {
    // sequential
    OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
    PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
    BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
    Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
    BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
    YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
    YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
    Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
    RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
    Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
    YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
    Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
    GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
    Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
    YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
    PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
    Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
    PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
    Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
    // diverging
    Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
    RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
    RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
    PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
    PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
    RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
    BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
    RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
    PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
    // qualitative
    Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
    Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
    Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
    Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
    Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
    Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
    Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
    Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
  };
  var colorbrewerTypes = Object.keys(colorbrewer);
  var typeMap = new Map(colorbrewerTypes.map((key) => [key.toLowerCase(), key]));
  var colorbrewerProxy = typeof Proxy === "function" ? new Proxy(colorbrewer, {
    get(target, prop) {
      const lower = prop.toLowerCase();
      if (typeMap.has(lower)) {
        return target[typeMap.get(lower)];
      }
    },
    getOwnPropertyNames() {
      return Object.getOwnPropertyNames(colorbrewerTypes);
    }
  }) : colorbrewer;
  var colorbrewer_default = colorbrewerProxy;

  // node_modules/chroma-js/src/io/cmyk/cmyk2rgb.js
  var cmyk2rgb = (...args) => {
    args = unpack_default(args, "cmyk");
    const [c, m, y, k] = args;
    const alpha = args.length > 4 ? args[4] : 1;
    if (k === 1) return [0, 0, 0, alpha];
    return [
      c >= 1 ? 0 : 255 * (1 - c) * (1 - k),
      // r
      m >= 1 ? 0 : 255 * (1 - m) * (1 - k),
      // g
      y >= 1 ? 0 : 255 * (1 - y) * (1 - k),
      // b
      alpha
    ];
  };
  var cmyk2rgb_default = cmyk2rgb;

  // node_modules/chroma-js/src/io/cmyk/rgb2cmyk.js
  var { max: max5 } = Math;
  var rgb2cmyk = (...args) => {
    let [r, g, b] = unpack_default(args, "rgb");
    r = r / 255;
    g = g / 255;
    b = b / 255;
    const k = 1 - max5(r, max5(g, b));
    const f = k < 1 ? 1 / (1 - k) : 0;
    const c = (1 - r - k) * f;
    const m = (1 - g - k) * f;
    const y = (1 - b - k) * f;
    return [c, m, y, k];
  };
  var rgb2cmyk_default = rgb2cmyk;

  // node_modules/chroma-js/src/io/cmyk/index.js
  Color_default.prototype.cmyk = function() {
    return rgb2cmyk_default(this._rgb);
  };
  var cmyk = (...args) => new Color_default(...args, "cmyk");
  Object.assign(chroma_default, { cmyk });
  input_default.format.cmyk = cmyk2rgb_default;
  input_default.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack_default(args, "cmyk");
      if (type_default(args) === "array" && args.length === 4) {
        return "cmyk";
      }
    }
  });

  // node_modules/chroma-js/src/io/css/hsl2css.js
  var hsl2css = (...args) => {
    const hsla = unpack_default(args, "hsla");
    let mode = last_default(args) || "lsa";
    hsla[0] = rnd2(hsla[0] || 0) + "deg";
    hsla[1] = rnd2(hsla[1] * 100) + "%";
    hsla[2] = rnd2(hsla[2] * 100) + "%";
    if (mode === "hsla" || hsla.length > 3 && hsla[3] < 1) {
      hsla[3] = "/ " + (hsla.length > 3 ? hsla[3] : 1);
      mode = "hsla";
    } else {
      hsla.length = 3;
    }
    return `${mode.substr(0, 3)}(${hsla.join(" ")})`;
  };
  var hsl2css_default = hsl2css;

  // node_modules/chroma-js/src/io/css/lab2css.js
  var lab2css = (...args) => {
    const laba = unpack_default(args, "lab");
    let mode = last_default(args) || "lab";
    laba[0] = rnd2(laba[0]) + "%";
    laba[1] = rnd2(laba[1]);
    laba[2] = rnd2(laba[2]);
    if (mode === "laba" || laba.length > 3 && laba[3] < 1) {
      laba[3] = "/ " + (laba.length > 3 ? laba[3] : 1);
    } else {
      laba.length = 3;
    }
    return `lab(${laba.join(" ")})`;
  };
  var lab2css_default = lab2css;

  // node_modules/chroma-js/src/io/css/lch2css.js
  var lch2css = (...args) => {
    const lcha = unpack_default(args, "lch");
    let mode = last_default(args) || "lab";
    lcha[0] = rnd2(lcha[0]) + "%";
    lcha[1] = rnd2(lcha[1]);
    lcha[2] = isNaN(lcha[2]) ? "none" : rnd2(lcha[2]) + "deg";
    if (mode === "lcha" || lcha.length > 3 && lcha[3] < 1) {
      lcha[3] = "/ " + (lcha.length > 3 ? lcha[3] : 1);
    } else {
      lcha.length = 3;
    }
    return `lch(${lcha.join(" ")})`;
  };
  var lch2css_default = lch2css;

  // node_modules/chroma-js/src/io/css/oklab2css.js
  var oklab2css = (...args) => {
    const laba = unpack_default(args, "lab");
    laba[0] = rnd2(laba[0] * 100) + "%";
    laba[1] = rnd3(laba[1]);
    laba[2] = rnd3(laba[2]);
    if (laba.length > 3 && laba[3] < 1) {
      laba[3] = "/ " + (laba.length > 3 ? laba[3] : 1);
    } else {
      laba.length = 3;
    }
    return `oklab(${laba.join(" ")})`;
  };
  var oklab2css_default = oklab2css;

  // node_modules/chroma-js/src/io/oklch/rgb2oklch.js
  var rgb2oklch = (...args) => {
    const [r, g, b, ...rest] = unpack_default(args, "rgb");
    const [l, a, b_] = rgb2oklab_default(r, g, b);
    const [L, c, h] = lab2lch_default(l, a, b_);
    return [L, c, h, ...rest.length > 0 && rest[0] < 1 ? [rest[0]] : []];
  };
  var rgb2oklch_default = rgb2oklch;

  // node_modules/chroma-js/src/io/css/oklch2css.js
  var oklch2css = (...args) => {
    const lcha = unpack_default(args, "lch");
    lcha[0] = rnd2(lcha[0] * 100) + "%";
    lcha[1] = rnd3(lcha[1]);
    lcha[2] = isNaN(lcha[2]) ? "none" : rnd2(lcha[2]) + "deg";
    if (lcha.length > 3 && lcha[3] < 1) {
      lcha[3] = "/ " + (lcha.length > 3 ? lcha[3] : 1);
    } else {
      lcha.length = 3;
    }
    return `oklch(${lcha.join(" ")})`;
  };
  var oklch2css_default = oklch2css;

  // node_modules/chroma-js/src/io/css/rgb2css.js
  var { round: round4 } = Math;
  var rgb2css = (...args) => {
    const rgba = unpack_default(args, "rgba");
    let mode = last_default(args) || "rgb";
    if (mode.substr(0, 3) === "hsl") {
      return hsl2css_default(rgb2hsl_default(rgba), mode);
    }
    if (mode.substr(0, 3) === "lab") {
      const prevWhitePoint = getLabWhitePoint();
      setLabWhitePoint("d50");
      const cssColor = lab2css_default(rgb2lab_default(rgba), mode);
      setLabWhitePoint(prevWhitePoint);
      return cssColor;
    }
    if (mode.substr(0, 3) === "lch") {
      const prevWhitePoint = getLabWhitePoint();
      setLabWhitePoint("d50");
      const cssColor = lch2css_default(rgb2lch_default(rgba), mode);
      setLabWhitePoint(prevWhitePoint);
      return cssColor;
    }
    if (mode.substr(0, 5) === "oklab") {
      return oklab2css_default(rgb2oklab_default(rgba));
    }
    if (mode.substr(0, 5) === "oklch") {
      return oklch2css_default(rgb2oklch_default(rgba));
    }
    rgba[0] = round4(rgba[0]);
    rgba[1] = round4(rgba[1]);
    rgba[2] = round4(rgba[2]);
    if (mode === "rgba" || rgba.length > 3 && rgba[3] < 1) {
      rgba[3] = "/ " + (rgba.length > 3 ? rgba[3] : 1);
      mode = "rgba";
    }
    return `${mode.substr(0, 3)}(${rgba.slice(0, mode === "rgb" ? 3 : 4).join(" ")})`;
  };
  var rgb2css_default = rgb2css;

  // node_modules/chroma-js/src/io/oklch/oklch2rgb.js
  var oklch2rgb = (...args) => {
    args = unpack_default(args, "lch");
    const [l, c, h, ...rest] = args;
    const [L, a, b_] = lch2lab_default(l, c, h);
    const [r, g, b] = oklab2rgb_default(L, a, b_);
    return [r, g, b, ...rest.length > 0 && rest[0] < 1 ? [rest[0]] : []];
  };
  var oklch2rgb_default = oklch2rgb;

  // node_modules/chroma-js/src/io/css/css2rgb.js
  var INT_OR_PCT = /((?:-?\d+)|(?:-?\d+(?:\.\d+)?)%|none)/.source;
  var FLOAT_OR_PCT = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)%?)|none)/.source;
  var PCT = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)%)|none)/.source;
  var RE_S = /\s*/.source;
  var SEP = /\s+/.source;
  var COMMA = /\s*,\s*/.source;
  var ANLGE = /((?:-?(?:\d+(?:\.\d*)?|\.\d+)(?:deg)?)|none)/.source;
  var ALPHA = /\s*(?:\/\s*((?:[01]|[01]?\.\d+)|\d+(?:\.\d+)?%))?/.source;
  var RE_RGB = new RegExp(
    "^rgba?\\(" + RE_S + [INT_OR_PCT, INT_OR_PCT, INT_OR_PCT].join(SEP) + ALPHA + "\\)$"
  );
  var RE_RGB_LEGACY = new RegExp(
    "^rgb\\(" + RE_S + [INT_OR_PCT, INT_OR_PCT, INT_OR_PCT].join(COMMA) + RE_S + "\\)$"
  );
  var RE_RGBA_LEGACY = new RegExp(
    "^rgba\\(" + RE_S + [INT_OR_PCT, INT_OR_PCT, INT_OR_PCT, FLOAT_OR_PCT].join(COMMA) + RE_S + "\\)$"
  );
  var RE_HSL = new RegExp(
    "^hsla?\\(" + RE_S + [ANLGE, PCT, PCT].join(SEP) + ALPHA + "\\)$"
  );
  var RE_HSL_LEGACY = new RegExp(
    "^hsl?\\(" + RE_S + [ANLGE, PCT, PCT].join(COMMA) + RE_S + "\\)$"
  );
  var RE_HSLA_LEGACY = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
  var RE_LAB = new RegExp(
    "^lab\\(" + RE_S + [FLOAT_OR_PCT, FLOAT_OR_PCT, FLOAT_OR_PCT].join(SEP) + ALPHA + "\\)$"
  );
  var RE_LCH = new RegExp(
    "^lch\\(" + RE_S + [FLOAT_OR_PCT, FLOAT_OR_PCT, ANLGE].join(SEP) + ALPHA + "\\)$"
  );
  var RE_OKLAB = new RegExp(
    "^oklab\\(" + RE_S + [FLOAT_OR_PCT, FLOAT_OR_PCT, FLOAT_OR_PCT].join(SEP) + ALPHA + "\\)$"
  );
  var RE_OKLCH = new RegExp(
    "^oklch\\(" + RE_S + [FLOAT_OR_PCT, FLOAT_OR_PCT, ANLGE].join(SEP) + ALPHA + "\\)$"
  );
  var { round: round5 } = Math;
  var roundRGB = (rgb3) => {
    return rgb3.map((v, i) => i <= 2 ? limit_default(round5(v), 0, 255) : v);
  };
  var percentToAbsolute = (pct, min6 = 0, max6 = 100, signed = false) => {
    if (typeof pct === "string" && pct.endsWith("%")) {
      pct = parseFloat(pct.substring(0, pct.length - 1)) / 100;
      if (signed) {
        pct = min6 + (pct + 1) * 0.5 * (max6 - min6);
      } else {
        pct = min6 + pct * (max6 - min6);
      }
    }
    return +pct;
  };
  var noneToValue = (v, noneValue) => {
    return v === "none" ? noneValue : v;
  };
  var css2rgb = (css2) => {
    css2 = css2.toLowerCase().trim();
    if (css2 === "transparent") {
      return [0, 0, 0, 0];
    }
    let m;
    if (input_default.format.named) {
      try {
        return input_default.format.named(css2);
      } catch (e) {
      }
    }
    if ((m = css2.match(RE_RGB)) || (m = css2.match(RE_RGB_LEGACY))) {
      let rgb3 = m.slice(1, 4);
      for (let i = 0; i < 3; i++) {
        rgb3[i] = +percentToAbsolute(noneToValue(rgb3[i], 0), 0, 255);
      }
      rgb3 = roundRGB(rgb3);
      const alpha = m[4] !== void 0 ? +percentToAbsolute(m[4], 0, 1) : 1;
      rgb3[3] = alpha;
      return rgb3;
    }
    if (m = css2.match(RE_RGBA_LEGACY)) {
      const rgb3 = m.slice(1, 5);
      for (let i = 0; i < 4; i++) {
        rgb3[i] = +percentToAbsolute(rgb3[i], 0, 255);
      }
      return rgb3;
    }
    if ((m = css2.match(RE_HSL)) || (m = css2.match(RE_HSL_LEGACY))) {
      const hsl3 = m.slice(1, 4);
      hsl3[0] = +noneToValue(hsl3[0].replace("deg", ""), 0);
      hsl3[1] = +percentToAbsolute(noneToValue(hsl3[1], 0), 0, 100) * 0.01;
      hsl3[2] = +percentToAbsolute(noneToValue(hsl3[2], 0), 0, 100) * 0.01;
      const rgb3 = roundRGB(hsl2rgb_default(hsl3));
      const alpha = m[4] !== void 0 ? +percentToAbsolute(m[4], 0, 1) : 1;
      rgb3[3] = alpha;
      return rgb3;
    }
    if (m = css2.match(RE_HSLA_LEGACY)) {
      const hsl3 = m.slice(1, 4);
      hsl3[1] *= 0.01;
      hsl3[2] *= 0.01;
      const rgb3 = hsl2rgb_default(hsl3);
      for (let i = 0; i < 3; i++) {
        rgb3[i] = round5(rgb3[i]);
      }
      rgb3[3] = +m[4];
      return rgb3;
    }
    if (m = css2.match(RE_LAB)) {
      const lab3 = m.slice(1, 4);
      lab3[0] = percentToAbsolute(noneToValue(lab3[0], 0), 0, 100);
      lab3[1] = percentToAbsolute(noneToValue(lab3[1], 0), -125, 125, true);
      lab3[2] = percentToAbsolute(noneToValue(lab3[2], 0), -125, 125, true);
      const wp = getLabWhitePoint();
      setLabWhitePoint("d50");
      const rgb3 = roundRGB(lab2rgb_default(lab3));
      setLabWhitePoint(wp);
      const alpha = m[4] !== void 0 ? +percentToAbsolute(m[4], 0, 1) : 1;
      rgb3[3] = alpha;
      return rgb3;
    }
    if (m = css2.match(RE_LCH)) {
      const lch3 = m.slice(1, 4);
      lch3[0] = percentToAbsolute(lch3[0], 0, 100);
      lch3[1] = percentToAbsolute(noneToValue(lch3[1], 0), 0, 150, false);
      lch3[2] = +noneToValue(lch3[2].replace("deg", ""), 0);
      const wp = getLabWhitePoint();
      setLabWhitePoint("d50");
      const rgb3 = roundRGB(lch2rgb_default(lch3));
      setLabWhitePoint(wp);
      const alpha = m[4] !== void 0 ? +percentToAbsolute(m[4], 0, 1) : 1;
      rgb3[3] = alpha;
      return rgb3;
    }
    if (m = css2.match(RE_OKLAB)) {
      const oklab3 = m.slice(1, 4);
      oklab3[0] = percentToAbsolute(noneToValue(oklab3[0], 0), 0, 1);
      oklab3[1] = percentToAbsolute(noneToValue(oklab3[1], 0), -0.4, 0.4, true);
      oklab3[2] = percentToAbsolute(noneToValue(oklab3[2], 0), -0.4, 0.4, true);
      const rgb3 = roundRGB(oklab2rgb_default(oklab3));
      const alpha = m[4] !== void 0 ? +percentToAbsolute(m[4], 0, 1) : 1;
      rgb3[3] = alpha;
      return rgb3;
    }
    if (m = css2.match(RE_OKLCH)) {
      const oklch3 = m.slice(1, 4);
      oklch3[0] = percentToAbsolute(noneToValue(oklch3[0], 0), 0, 1);
      oklch3[1] = percentToAbsolute(noneToValue(oklch3[1], 0), 0, 0.4, false);
      oklch3[2] = +noneToValue(oklch3[2].replace("deg", ""), 0);
      const rgb3 = roundRGB(oklch2rgb_default(oklch3));
      const alpha = m[4] !== void 0 ? +percentToAbsolute(m[4], 0, 1) : 1;
      rgb3[3] = alpha;
      return rgb3;
    }
  };
  css2rgb.test = (s) => {
    return (
      // modern
      RE_RGB.test(s) || RE_HSL.test(s) || RE_LAB.test(s) || RE_LCH.test(s) || RE_OKLAB.test(s) || RE_OKLCH.test(s) || // legacy
      RE_RGB_LEGACY.test(s) || RE_RGBA_LEGACY.test(s) || RE_HSL_LEGACY.test(s) || RE_HSLA_LEGACY.test(s) || s === "transparent"
    );
  };
  var css2rgb_default = css2rgb;

  // node_modules/chroma-js/src/io/css/index.js
  Color_default.prototype.css = function(mode) {
    return rgb2css_default(this._rgb, mode);
  };
  var css = (...args) => new Color_default(...args, "css");
  chroma_default.css = css;
  input_default.format.css = css2rgb_default;
  input_default.autodetect.push({
    p: 5,
    test: (h, ...rest) => {
      if (!rest.length && type_default(h) === "string" && css2rgb_default.test(h)) {
        return "css";
      }
    }
  });

  // node_modules/chroma-js/src/io/gl/index.js
  input_default.format.gl = (...args) => {
    const rgb3 = unpack_default(args, "rgba");
    rgb3[0] *= 255;
    rgb3[1] *= 255;
    rgb3[2] *= 255;
    return rgb3;
  };
  var gl = (...args) => new Color_default(...args, "gl");
  chroma_default.gl = gl;
  Color_default.prototype.gl = function() {
    const rgb3 = this._rgb;
    return [rgb3[0] / 255, rgb3[1] / 255, rgb3[2] / 255, rgb3[3]];
  };

  // node_modules/chroma-js/src/io/hex/index.js
  Color_default.prototype.hex = function(mode) {
    return rgb2hex_default(this._rgb, mode);
  };
  var hex = (...args) => new Color_default(...args, "hex");
  chroma_default.hex = hex;
  input_default.format.hex = hex2rgb_default;
  input_default.autodetect.push({
    p: 4,
    test: (h, ...rest) => {
      if (!rest.length && type_default(h) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0) {
        return "hex";
      }
    }
  });

  // node_modules/chroma-js/src/io/temp/temperature2rgb.js
  var { log: log2 } = Math;
  var temperature2rgb = (kelvin) => {
    const temp2 = kelvin / 100;
    let r, g, b;
    if (temp2 < 66) {
      r = 255;
      g = temp2 < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g = temp2 - 2) + 104.49216199393888 * log2(g);
      b = temp2 < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp2 - 10) + 115.67994401066147 * log2(b);
    } else {
      r = 351.97690566805693 + 0.114206453784165 * (r = temp2 - 55) - 40.25366309332127 * log2(r);
      g = 325.4494125711974 + 0.07943456536662342 * (g = temp2 - 50) - 28.0852963507957 * log2(g);
      b = 255;
    }
    return [r, g, b, 1];
  };
  var temperature2rgb_default = temperature2rgb;

  // node_modules/chroma-js/src/io/temp/rgb2temperature.js
  var { round: round6 } = Math;
  var rgb2temperature = (...args) => {
    const rgb3 = unpack_default(args, "rgb");
    const r = rgb3[0], b = rgb3[2];
    let minTemp = 1e3;
    let maxTemp = 4e4;
    const eps = 0.4;
    let temp2;
    while (maxTemp - minTemp > eps) {
      temp2 = (maxTemp + minTemp) * 0.5;
      const rgb4 = temperature2rgb_default(temp2);
      if (rgb4[2] / rgb4[0] >= b / r) {
        maxTemp = temp2;
      } else {
        minTemp = temp2;
      }
    }
    return round6(temp2);
  };
  var rgb2temperature_default = rgb2temperature;

  // node_modules/chroma-js/src/io/temp/index.js
  Color_default.prototype.temp = Color_default.prototype.kelvin = Color_default.prototype.temperature = function() {
    return rgb2temperature_default(this._rgb);
  };
  var temp = (...args) => new Color_default(...args, "temp");
  Object.assign(chroma_default, { temp, kelvin: temp, temperature: temp });
  input_default.format.temp = input_default.format.kelvin = input_default.format.temperature = temperature2rgb_default;

  // node_modules/chroma-js/src/io/oklch/index.js
  Color_default.prototype.oklch = function() {
    return rgb2oklch_default(this._rgb);
  };
  var oklch2 = (...args) => new Color_default(...args, "oklch");
  Object.assign(chroma_default, { oklch: oklch2 });
  input_default.format.oklch = oklch2rgb_default;
  input_default.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack_default(args, "oklch");
      if (type_default(args) === "array" && args.length === 3) {
        return "oklch";
      }
    }
  });

  // node_modules/chroma-js/index.js
  Object.assign(chroma_default, {
    analyze,
    average: average_default,
    bezier: bezier_default,
    blend: blend_default,
    brewer: colorbrewer_default,
    Color: Color_default,
    colors: w3cx11_default,
    contrast: contrast_default,
    contrastAPCA: contrastAPCA_default,
    cubehelix: cubehelix_default,
    deltaE: delta_e_default,
    distance: distance_default,
    input: input_default,
    interpolate: mix_default,
    limits,
    mix: mix_default,
    random: random_default,
    scale: scale_default,
    scales: scales_default,
    valid: valid_default
  });
  var chroma_js_default = chroma_default;

  // src/layout/colorpicker.ts
  var ColorPicker = class {
    constructor(totalColors) {
      this.colors = this.generateColors(totalColors);
      this.index = 0;
    }
    // Generate a specified number of colors using the Phyllotactic Color-Picking Algorithm
    generateColors(totalColors) {
      const colors = [];
      for (let i = 0; i < totalColors; i++) {
        colors.push(this.phyllotacticColor(i));
      }
      return colors;
    }
    // Get the next color in the sequence
    getNextColor() {
      if (this.index >= this.colors.length) {
        this.index = 0;
      }
      return this.colors[this.index++];
    }
    // Phyllotactic Color-Picking Algorithm using CIELAB color space
    phyllotacticColor(index) {
      const goldenAngle = 137.5 * (Math.PI / 180);
      const radius = 100;
      const angle = index * goldenAngle;
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);
      const l = 50;
      const a = x;
      const b = y;
      const color = chroma_js_default.lab(l, a, b).rgb();
      const darkFactor = 1;
      const darkR = Math.round(color[0] * darkFactor);
      const darkG = Math.round(color[1] * darkFactor);
      const darkB = Math.round(color[2] * darkFactor);
      return `rgb(${darkR}, ${darkG}, ${darkB})`;
    }
  };

  // src/layout/layoutinstance.ts
  var UNIVERSAL_TYPE = "univ";
  var LayoutNodePath = class {
    constructor(Path, LoopsTo) {
      this.Path = Path;
      this.LoopsTo = LoopsTo;
    }
    /**
     * Expands the path by unrolling the loop `repeat` times.
     * If there is no loop, returns the plain path.
     */
    expand(repeat2) {
      const ids = this.Path.map((n) => n.id);
      if (!this.LoopsTo) return ids;
      const loopStart = ids.findIndex((id) => id === this.LoopsTo.id);
      if (loopStart === -1) return ids;
      const prefix = ids.slice(0, loopStart);
      const loop = ids.slice(loopStart);
      return prefix.concat(...Array(repeat2).fill(loop));
    }
    /**
     * Returns true if `this` is a superpath that contains `other` as a subpath (after unrolling).
     */
    isSubpathOf(other) {
      const thisUnrolled = this.expand(2);
      const otherUnrolled = other.expand(1);
      if (otherUnrolled.length > thisUnrolled.length) return false;
      for (let i = 0; i <= thisUnrolled.length - otherUnrolled.length; i++) {
        if (otherUnrolled.every((v, j) => v === thisUnrolled[i + j])) {
          return true;
        }
      }
      return false;
    }
    /**
     * Returns true if two paths are equivalent (each is a subpath of the other).
     */
    static areEquivalent(p1, p2) {
      return p1.isSubpathOf(p2) && p2.isSubpathOf(p1);
    }
  };
  var _LayoutInstance = class _LayoutInstance {
    /**
     * Constructs a new `LayoutInstance` object.
     *
     * @param layoutSpec - The layout specification that defines constraints, directives, and other layout-related configurations.
     * @param evaluator - An evaluator instance used to evaluate selectors and constraints within the layout specification.
     * @param instNum - The instance number (default is 0), used to differentiate between multiple instances of the same layout.
     * @param addAlignmentEdges - A boolean flag indicating whether alignment edges should be added to the graph (default is `true`).
     *
     * The `LayoutInstance` class is responsible for generating a layout for a given data instance based on the provided layout specification.
     * It applies constraints, directives, and projections to produce a structured layout that can be rendered using a graph visualization library.
     */
    constructor(layoutSpec, evaluator, instNum = 0, addAlignmentEdges = true) {
      this.hideThisEdge = "_h_";
      this.DEFAULT_NODE_ICON_PATH = "";
      this.DEFAULT_NODE_HEIGHT = 60;
      this.DEFAULT_NODE_WIDTH = 100;
      this.minSepHeight = 15;
      this.minSepWidth = 15;
      this.instanceNum = instNum;
      this.evaluator = evaluator;
      this._layoutSpec = layoutSpec;
      this.addAlignmentEdges = addAlignmentEdges;
    }
    get projectedSigs() {
      if (!this._layoutSpec.directives.projections) {
        return [];
      }
      return this._layoutSpec.directives.projections.map((projection) => projection.sig);
    }
    get hideDisconnected() {
      return this._layoutSpec.directives.hideDisconnected || false;
    }
    get hideDisconnectedBuiltIns() {
      return this._layoutSpec.directives.hideDisconnectedBuiltIns || false;
    }
    /**
     * Gets GroupByField constraints that apply to a specific field and atoms.
     * @param fieldName - The field name to match.
     * @param sourceAtom - The source atom ID.
     * @param targetAtom - The target atom ID.
     * @returns Array of matching GroupByField constraints.
     */
    getConstraintsRelatedToField(fieldName, sourceAtom, targetAtom) {
      const groupByFieldConstraints = this._layoutSpec.constraints.grouping.byfield;
      let fieldConstraints = groupByFieldConstraints.filter((d) => {
        if (d.field !== fieldName) {
          return false;
        }
        if (!d.selector) {
          return true;
        }
        try {
          const selectorResult = this.evaluator.evaluate(d.selector, { instanceIndex: this.instanceNum });
          const selectedAtoms = selectorResult.selectedAtoms();
          return selectedAtoms.includes(sourceAtom);
        } catch (error) {
          console.warn(`Failed to evaluate group by field selector "${d.selector}":`, error);
          return false;
        }
      });
      return fieldConstraints;
    }
    isAttributeField(fieldId, sourceAtom, targetAtom) {
      const matchingDirectives = this._layoutSpec.directives.attributes.filter((ad) => ad.field === fieldId);
      if (matchingDirectives.length === 0) {
        return false;
      }
      if (!sourceAtom || !targetAtom) {
        return matchingDirectives.some((ad) => !ad.selector);
      }
      for (const directive of matchingDirectives) {
        if (!directive.selector) {
          return true;
        }
        try {
          const selectorResult = this.evaluator.evaluate(directive.selector, { instanceIndex: this.instanceNum });
          const selectedAtoms = selectorResult.selectedAtoms();
          if (selectedAtoms.includes(sourceAtom)) {
            return true;
          }
        } catch (error) {
          console.warn(`Failed to evaluate attribute selector "${directive.selector}":`, error);
        }
      }
      return false;
    }
    isHiddenField(fieldId, sourceAtom, targetAtom) {
      const matchingDirectives = this._layoutSpec.directives.hiddenFields.filter((hd) => hd.field === fieldId);
      if (matchingDirectives.length === 0) {
        return false;
      }
      if (!sourceAtom || !targetAtom) {
        return matchingDirectives.some((hd) => !hd.selector);
      }
      for (const directive of matchingDirectives) {
        if (!directive.selector) {
          return true;
        }
        try {
          const selectorResult = this.evaluator.evaluate(directive.selector, { instanceIndex: this.instanceNum });
          const selectedAtoms = selectorResult.selectedAtoms();
          if (selectedAtoms.includes(sourceAtom)) {
            return true;
          }
        } catch (error) {
          console.warn(`Failed to evaluate hidden field selector "${directive.selector}":`, error);
        }
      }
      return false;
    }
    /**
     * Generates groups based on the specified graph.
     * @param g - The graph, which will be modified to remove the edges that are used to generate groups.
     * @param a - The ORIGINAL (pre-projection) Data Instance.
     * @returns A record of groups.
     */
    generateGroups(g, a) {
      let groupByFieldConstraints = this._layoutSpec.constraints.grouping.byfield;
      let groupBySelectorConstraints = this._layoutSpec.constraints.grouping.byselector;
      if (!groupByFieldConstraints && !groupBySelectorConstraints) {
        return [];
      }
      let groups = [];
      for (var gc of groupBySelectorConstraints) {
        let selector = gc.selector;
        let selectorRes = this.evaluator.evaluate(selector, { instanceIndex: this.instanceNum });
        let selectedTwoples = selectorRes.selectedTwoples();
        if (selectedTwoples.length > 0) {
          for (var t of selectedTwoples) {
            let groupOn = t[0];
            let addToGroup = t[1];
            let groupName = `${gc.name}[${groupOn}]`;
            let existingGroup = groups.find((group) => group.name === groupName);
            if (existingGroup) {
              existingGroup.nodeIds.push(addToGroup);
            } else {
              let newGroup = {
                name: groupName,
                nodeIds: [addToGroup],
                keyNodeId: groupOn,
                showLabel: true
              };
              groups.push(newGroup);
            }
          }
        } else {
          let selectedElements = selectorRes.selectedAtoms();
          if (selectedElements.length === 0) {
            continue;
          }
          let keyNode = selectedElements[0];
          let newGroup = {
            name: gc.name,
            nodeIds: selectedElements,
            keyNodeId: keyNode,
            //// TODO: I think introducing this random keynode could be a problem. Not sure why or when though.
            showLabel: true
          };
          groups.push(newGroup);
        }
      }
      let graphEdges = [...g.edges()];
      graphEdges.forEach((edge) => {
        const edgeId = edge.name;
        const relName = this.getRelationName(g, edge);
        let relatedConstraints = this.getConstraintsRelatedToField(relName, edge.v, edge.w);
        if (relatedConstraints.length === 0) {
          return;
        }
        relatedConstraints.forEach((c) => {
          const groupOn = c.groupOn;
          const addToGroup = c.addToGroup;
          const potentialTuples = this.getFieldTuplesForSourceAndTarget(a, relName, edge.v, edge.w);
          if (!potentialTuples || potentialTuples.length === 0) {
            return;
          }
          for (var thisTuple of potentialTuples) {
            let arity = thisTuple?.length || 0;
            if (arity < 2 || (groupOn < 0 || groupOn >= arity) || (addToGroup < 0 || addToGroup >= arity)) {
              throw new Error(`Invalid grouping. groupOn=${groupOn} and addToGroup=${addToGroup} for ${arity}-ary relation ${relName}. These must be between 0 and ${arity - 1}.`);
            }
            let key = thisTuple[groupOn];
            let toAdd = thisTuple[addToGroup];
            let labelString = thisTuple.map((s, idx) => {
              if (idx === groupOn) {
                return s;
              } else return "_";
            }).join(",");
            let groupName = `${relName}[${labelString}]`;
            let existingGroup = groups.find((group) => group.name === groupName);
            if (existingGroup) {
              existingGroup.nodeIds.push(toAdd);
              g.removeEdge(edge.v, edge.w, edgeId);
            } else {
              let newGroup = {
                name: groupName,
                nodeIds: [toAdd],
                keyNodeId: key,
                // What if the key is in the graph?
                showLabel: true
                // For now
              };
              groups.push(newGroup);
              const groupEdgePrefix = `_g_${groupOn}_${addToGroup}_`;
              const newId = groupEdgePrefix + edgeId;
              g.removeEdge(edge.v, edge.w, edgeId);
              g.setEdge(edge.v, edge.w, groupName, newId);
            }
          }
        });
      });
      return groups;
    }
    /**
     * Generates groups based on the specified graph.
     * @param g - The graph, which will be modified to remove the edges that are used to determine attributes.
     * @returns A record of attributes
     */
    generateAttributesAndRemoveEdges(g) {
      let attributes = {};
      let graphEdges = [...g.edges()];
      graphEdges.forEach((edge) => {
        const edgeId = edge.name;
        const relName = this.getRelationName(g, edge);
        const sourceAtom = edge.v;
        const targetAtom = edge.w;
        const isAttributeRel = this.isAttributeField(relName, sourceAtom, targetAtom);
        const isHiddenRel = this.isHiddenField(relName, sourceAtom, targetAtom);
        if (isHiddenRel && isAttributeRel) {
          throw new Error(`${relName} cannot be both an attribute and a hidden field.`);
        }
        if (isHiddenRel) {
          g.removeEdge(edge.v, edge.w, edgeId);
          return;
        }
        if (isAttributeRel) {
          const attributeKey = this.getEdgeLabel(g, edge);
          let source = edge.v;
          let target = edge.w;
          let targetLabel = g.node(target)?.label || target;
          let nodeAttributes = attributes[source] || {};
          if (!nodeAttributes[attributeKey]) {
            nodeAttributes[attributeKey] = [];
            attributes[source] = nodeAttributes;
          }
          nodeAttributes[attributeKey].push(targetLabel);
          g.removeEdge(edge.v, edge.w, edgeId);
        }
      });
      return attributes;
    }
    /**
    * Modifies the graph to remove extraneous nodes (ex. those to be hidden)
    * @param g - The graph, which will be modified to remove extraneous nodes.
    */
    ensureNoExtraNodes(g, a) {
      let nodes = [...g.nodes()];
      nodes.forEach((node) => {
        try {
          const type2 = a.getAtomType(node);
          const isAtomBuiltin = type2?.isBuiltin || false;
          let inEdges = g.inEdges(node) || [];
          let outEdges = g.outEdges(node) || [];
          const isDisconnected = inEdges.length === 0 && outEdges.length === 0;
          const hideLegacy = isDisconnected && (this.hideDisconnectedBuiltIns && isAtomBuiltin || this.hideDisconnected);
          let hideBySelector = false;
          const hiddenAtomDirectives = this._layoutSpec.directives.hiddenAtoms;
          for (const directive of hiddenAtomDirectives) {
            try {
              const selectorResult = this.evaluator.evaluate(directive.selector, { instanceIndex: this.instanceNum });
              const selectedAtoms = selectorResult.selectedAtoms();
              if (selectedAtoms.includes(node)) {
                hideBySelector = true;
                break;
              }
            } catch (error) {
              console.error(`Failed to evaluate hideAtom selector "${directive.selector}":`, error);
            }
          }
          const hideNode = hideLegacy || hideBySelector;
          if (hideNode) {
            g.removeNode(node);
          }
        } catch (error) {
          console.error("Failed to identify node type. Defaulting to showing node.", error);
        }
      });
    }
    getMostSpecificType(node, a) {
      let allTypes = this.getNodeTypes(node, a);
      let mostSpecificType = allTypes[0];
      return mostSpecificType;
    }
    getNodeTypes(node, a) {
      let type2 = a.getAtomType(node);
      let allTypes = type2?.types || [];
      allTypes = allTypes.concat(UNIVERSAL_TYPE);
      return allTypes;
    }
    getRelationName(g, edge) {
      let relNameRaw = this.getEdgeLabel(g, edge);
      try {
        let relName = relNameRaw.split("[")[0];
        return relName;
      } catch {
        console.warn(`Failed to parse relation name from edge label: ${relNameRaw}. Defaulting to empty string.`);
        return relNameRaw;
      }
    }
    getEdgeLabel(g, edge) {
      return g.edge(edge.v, edge.w, edge.name);
    }
    applyLayoutProjections(ai, projections) {
      let projectedSigs = this.projectedSigs;
      let projectedTypes = projectedSigs.map((sig) => ai.getAtomType(sig));
      let atomsPerProjectedType = {};
      projectedTypes.forEach((type2) => {
        atomsPerProjectedType[type2.id] = type2.atoms.map((atom) => atom.id);
      });
      let projectedAtomIds = [];
      Object.entries(atomsPerProjectedType).forEach(([typeId, atomIds]) => {
        if (atomIds.length > 0) {
          if (projections[typeId]) {
            projectedAtomIds.push(projections[typeId]);
          } else {
            let to_project = atomIds[0];
            projections[typeId] = to_project;
            projectedAtomIds.push(to_project);
          }
        }
      });
      let finalProjectionChoices = Object.entries(projections).filter(([typeId]) => projectedSigs.includes(typeId)).map(([typeId, atomId]) => {
        let atoms = atomsPerProjectedType[typeId];
        return { type: typeId, projectedAtom: atomId, atoms };
      });
      let projectedInstance = ai.applyProjections(projectedAtomIds);
      return { projectedInstance, finalProjectionChoices };
    }
    /**
     * Generates the layout for the given data instance and projections.
     * @param a - The data instance to generate the layout for.
     * @param projections - ...
     * @returns An object containing the layout, projection data, and (optionally) an error to be surfaced to the user.
     * @throws {ConstraintError} If the layout cannot be generated due to unsatisfiable constraints and error isn't caught to be surfaced to the user.
     */
    generateLayout(a, projections) {
      let projectionResult = this.applyLayoutProjections(a, projections);
      let ai = projectionResult.projectedInstance;
      let projectionData = projectionResult.finalProjectionChoices;
      let g = ai.generateGraph(this.hideDisconnected, this.hideDisconnectedBuiltIns);
      const attributes = this.generateAttributesAndRemoveEdges(g);
      let nodeIconMap = this.getNodeIconMap(g);
      let nodeColorMap = this.getNodeColorMap(g, ai);
      let nodeSizeMap = this.getNodeSizeMap(g);
      this.addinferredEdges(g);
      let groups = this.generateGroups(g, a);
      this.ensureNoExtraNodes(g, a);
      let dcN = this.getDisconnectedNodes(g);
      let layoutNodes = g.nodes().map((nodeId) => {
        let nodeMetadata = g.node(nodeId);
        let label = nodeMetadata?.label || nodeId;
        let color = nodeColorMap[nodeId] || "black";
        let iconDetails = nodeIconMap[nodeId];
        let iconPath = iconDetails.path;
        let showLabels = iconDetails.showLabels;
        let { height, width } = nodeSizeMap[nodeId] || { height: this.DEFAULT_NODE_HEIGHT, width: this.DEFAULT_NODE_WIDTH };
        const mostSpecificType = this.getMostSpecificType(nodeId, a);
        const allTypes = this.getNodeTypes(nodeId, a);
        let nodeGroups = groups.filter((group) => group.nodeIds.includes(nodeId)).map((group) => group.name);
        let nodeAttributes = attributes[nodeId] || {};
        return {
          id: nodeId,
          label,
          name: label,
          color,
          groups: nodeGroups,
          attributes: nodeAttributes,
          icon: iconPath,
          height,
          width,
          mostSpecificType,
          types: allTypes,
          showLabels
        };
      });
      let constraints = this.applyRelativeOrientationConstraints(layoutNodes, g);
      let layoutEdges = g.edges().map((edge) => {
        const edgeId = edge.name;
        const edgeLabel = g.edge(edge.v, edge.w, edgeId);
        let source = layoutNodes.find((node) => node.id === edge.v);
        let target = layoutNodes.find((node) => node.id === edge.w);
        let relName = this.getRelationName(g, edge);
        let color = this.getEdgeColor(relName, edge.v, edge.w);
        if (!source || !target || !edgeId) {
          return null;
        }
        let e = {
          source,
          target,
          label: edgeLabel,
          relationName: relName,
          id: edgeId,
          color
        };
        return e;
      }).filter((edge) => edge !== null);
      let layoutWithoutCyclicConstraints = { nodes: layoutNodes, edges: layoutEdges, constraints, groups };
      const validatorWithoutCyclic = new ConstraintValidator(layoutWithoutCyclicConstraints);
      const nonCyclicConstraintError = validatorWithoutCyclic.validateConstraints();
      if (nonCyclicConstraintError) {
        if (nonCyclicConstraintError.minimalConflictingSet) {
          return this.handlePositionalConstraintError(
            nonCyclicConstraintError,
            layoutWithoutCyclicConstraints,
            projectionData
          );
        }
        if (nonCyclicConstraintError.overlappingNodes) {
          return this.handleGroupOverlapError(
            nonCyclicConstraintError,
            layoutWithoutCyclicConstraints,
            projectionData
          );
        }
        throw nonCyclicConstraintError;
      }
      constraints = layoutWithoutCyclicConstraints.constraints;
      const layoutWithCyclicConstraints = { nodes: layoutWithoutCyclicConstraints.nodes, edges: layoutWithoutCyclicConstraints.edges, constraints, groups: layoutWithoutCyclicConstraints.groups };
      try {
        let closureConstraints = this.applyCyclicConstraints(layoutNodes, layoutWithoutCyclicConstraints);
        constraints = constraints.concat(closureConstraints);
        layoutWithCyclicConstraints.constraints = constraints;
      } catch (error) {
        if (isPositionalConstraintError(error)) {
          return this.handlePositionalConstraintError(
            error,
            layoutWithCyclicConstraints,
            projectionData
          );
        }
        if (isGroupOverlapError(error)) {
          return this.handleGroupOverlapError(
            error,
            layoutWithCyclicConstraints,
            projectionData
          );
        }
        throw error;
      }
      layoutEdges = layoutEdges.filter((edge) => !edge.id.startsWith(this.hideThisEdge));
      let dcnGroups = dcN.map(
        (node) => {
          return this.singletonGroup(node);
        }
      );
      groups = groups.concat(dcnGroups);
      let layout = { nodes: layoutNodes, edges: layoutEdges, constraints, groups };
      let finalConstraintValidator = new ConstraintValidator(layout);
      let finalLayoutError = finalConstraintValidator.validateConstraints();
      if (finalLayoutError) {
        if (finalLayoutError.minimalConflictingSet) {
          return this.handlePositionalConstraintError(
            finalLayoutError,
            layout,
            projectionData
          );
        }
        if (finalLayoutError.overlappingNodes) {
          return this.handleGroupOverlapError(
            finalLayoutError,
            layout,
            projectionData
          );
        }
        throw finalLayoutError;
      }
      return { layout, projectionData, error: null };
    }
    /**
     * Helper function to handle positional constraint errors by creating a layout with conflicting constraints removed
     * @returns An object containing the layout with error metadata, projection data, and the error itself.
     */
    handlePositionalConstraintError(error, layout, projectionData) {
      const minimalConflictingSet = error.minimalConflictingSet;
      const layoutWithErrorMetadata = {
        nodes: layout.nodes,
        edges: layout.edges,
        // FIXME: This is a hacky way to remove the conflicting constraints.
        // There is some inconsistency between what the graph shows and what the error message shows.
        constraints: layout.constraints.filter(
          (c) => ![...minimalConflictingSet.values()].flat().includes(c)
        ),
        groups: layout.groups,
        conflictingConstraints: [...minimalConflictingSet.values()].flat()
      };
      return {
        layout: layoutWithErrorMetadata,
        projectionData,
        error
      };
    }
    /**
     * Helper function to handle group overlap errors by creating a layout with overlapping nodes metadata
     * @returns An object containing the layout with error metadata, projection data, and the error itself.
     */
    handleGroupOverlapError(error, layout, projectionData) {
      const overlappingGroupNames = error.overlappingNodes.map((node) => node.groups).flat();
      const overlappingGroups = layout.groups.filter(
        (group) => overlappingGroupNames.includes(group.name)
      );
      const relevantNodeIds = overlappingGroups.flatMap((group) => group.nodeIds);
      const relevantNodes = layout.nodes.filter((node) => relevantNodeIds.includes(node.id));
      const edgesWithRelevantNodes = layout.edges.filter(
        (edge) => relevantNodes.some((node) => edge.source.id === node.id) && relevantNodes.some((node) => edge.target.id === node.id)
      );
      const layoutWithErrorMetadata = {
        nodes: relevantNodes,
        edges: edgesWithRelevantNodes,
        constraints: layout.constraints,
        groups: overlappingGroups,
        overlappingNodes: error.overlappingNodes
      };
      return {
        layout: layoutWithErrorMetadata,
        projectionData,
        error
      };
    }
    /**
     * Applies the cyclic orientation constraints to the layout nodes.
     * @param layoutNodes - The layout nodes to which the constraints will be applied.
     * @throws {ConstraintError} If the layout cannot be satisfied with the cyclic constraints.
     * @returns An array of layout constraints.
     */
    applyCyclicConstraints(layoutNodes, layoutWithoutCyclicConstraints) {
      const cyclicConstraints = this._layoutSpec.constraints.orientation.cyclic;
      let constraintFragments = [];
      for (const [, c] of cyclicConstraints.entries()) {
        let selectedTuples = this.evaluator.evaluate(c.selector, { instanceIndex: this.instanceNum }).selectedTwoples();
        let nextNodeMap = /* @__PURE__ */ new Map();
        selectedTuples.forEach((tuple) => {
          let sourceNodeId = tuple[0];
          let targetNodeId = tuple[1];
          let srcN = layoutNodes.find((node) => node.id === sourceNodeId);
          let tgtN = layoutNodes.find((node) => node.id === targetNodeId);
          if (!srcN || !tgtN) {
            return;
          }
          if (nextNodeMap.has(srcN)) {
            nextNodeMap.get(srcN).push(tgtN);
          } else {
            nextNodeMap.set(srcN, [tgtN]);
          }
        });
        let relatedNodeFragments = this.getFragmentsToConstrain(nextNodeMap);
        let relatedNodeIds = relatedNodeFragments.map((p) => p.Path.map((node) => node.id));
        if (c.direction === "counterclockwise") {
          relatedNodeIds = relatedNodeIds.map((fragment) => fragment.reverse());
        }
        relatedNodeIds.forEach((fragment) => {
          constraintFragments.push({
            source: c,
            fragmentList: fragment
          });
        });
      }
      const backtrackSolveFragments = (layoutConstraints, fragmentIdx) => {
        let currentLayoutError = null;
        if (fragmentIdx >= constraintFragments.length) {
          return layoutConstraints;
        }
        let fragment = constraintFragments[fragmentIdx].fragmentList;
        let sourceConstraint = constraintFragments[fragmentIdx].source;
        let fragmentLength = fragment.length;
        for (var perturbation = 0; perturbation < fragmentLength; perturbation++) {
          let fragmentConstraints = this.getCyclicConstraintForFragment(fragment, layoutNodes, perturbation, sourceConstraint);
          let allConstraintsForFragment = layoutConstraints.concat(fragmentConstraints);
          let instanceLayout = {
            nodes: layoutWithoutCyclicConstraints.nodes,
            constraints: allConstraintsForFragment,
            edges: layoutWithoutCyclicConstraints.edges,
            groups: layoutWithoutCyclicConstraints.groups
          };
          let validator = new ConstraintValidator(instanceLayout);
          currentLayoutError = validator.validateConstraints() || null;
          if (!currentLayoutError) {
            return backtrackSolveFragments(
              allConstraintsForFragment,
              fragmentIdx + 1
            );
          }
        }
        if (currentLayoutError) {
          throw currentLayoutError;
        }
        throw new Error(`Failed to find a satisfying layout for cyclic constraints.`);
      };
      const finalConstraints = backtrackSolveFragments(layoutWithoutCyclicConstraints.constraints, 0);
      return finalConstraints;
    }
    getCyclicConstraintForFragment(fragment, layoutNodes, perturbationIdx, c) {
      const minRadius = 100;
      if (fragment.length <= 2) {
        return [];
      }
      const angleStep = 2 * Math.PI / fragment.length;
      let fragmentNodePositions = {};
      for (var i = 0; i < fragment.length; i++) {
        let theta = (i + perturbationIdx) * angleStep;
        let x = minRadius * Math.cos(theta);
        let y = minRadius * Math.sin(theta);
        fragmentNodePositions[fragment[i]] = { x, y };
      }
      let fragmentConstraintsForCurrentOffset = [];
      for (var k = 0; k < fragment.length; k++) {
        for (var j = 0; j < fragment.length; j++) {
          if (k !== j) {
            let node1 = fragment[k];
            let node2 = fragment[j];
            let node1_pos = fragmentNodePositions[node1];
            let node2_pos = fragmentNodePositions[node2];
            if (node1_pos.x > node2_pos.x) {
              fragmentConstraintsForCurrentOffset.push(this.leftConstraint(node2, node1, this.minSepWidth, layoutNodes, c));
            } else if (node1_pos.x < node2_pos.x) {
              fragmentConstraintsForCurrentOffset.push(this.leftConstraint(node1, node2, this.minSepWidth, layoutNodes, c));
            } else {
              fragmentConstraintsForCurrentOffset.push(this.ensureSameXConstraint(node1, node2, layoutNodes, c));
            }
            if (node1_pos.y > node2_pos.y) {
              fragmentConstraintsForCurrentOffset.push(this.topConstraint(node2, node1, this.minSepHeight, layoutNodes, c));
            } else if (node1_pos.y < node2_pos.y) {
              fragmentConstraintsForCurrentOffset.push(this.topConstraint(node1, node2, this.minSepHeight, layoutNodes, c));
            } else {
              fragmentConstraintsForCurrentOffset.push(this.ensureSameYConstraint(node1, node2, layoutNodes, c));
            }
          }
        }
      }
      return fragmentConstraintsForCurrentOffset;
    }
    getAllPaths(nextNodeMap) {
      const allPaths = [];
      const visited = /* @__PURE__ */ new Set();
      function dfs(currentNode, path) {
        path.push(currentNode);
        const neighbors = nextNodeMap.get(currentNode);
        if (!nextNodeMap.has(currentNode) || !neighbors || neighbors.length === 0) {
          let lnp = new LayoutNodePath(path, void 0);
          allPaths.push(lnp);
        } else {
          for (const neighbor of neighbors) {
            if (!path.includes(neighbor)) {
              dfs(neighbor, [...path]);
            } else {
              let lnp = new LayoutNodePath(path, neighbor);
              allPaths.push(lnp);
            }
          }
        }
      }
      for (const startNode of nextNodeMap.keys()) {
        if (!visited.has(startNode)) {
          dfs(startNode, []);
        }
      }
      return allPaths;
    }
    getFragmentsToConstrain(nextNodeMap) {
      const allPaths = this.getAllPaths(nextNodeMap);
      const nonEquivalentPaths = allPaths.filter((p, i) => {
        return !allPaths.some((p2, j) => j < i && LayoutNodePath.areEquivalent(p, p2));
      });
      const nonSubsumedPaths = nonEquivalentPaths.filter((p, i) => {
        return !nonEquivalentPaths.some((p2, j) => i !== j && p2.isSubpathOf(p));
      });
      return nonSubsumedPaths;
    }
    /**
     * Applies the relative orientation constraints to the layout nodes.
     * @param layoutNodes - The layout nodes to which the constraints will be applied.
     * @returns An array of layout constraints.
     */
    applyRelativeOrientationConstraints(layoutNodes, g) {
      let constraints = [];
      let relativeOrientationConstraints = this._layoutSpec.constraints.orientation.relative;
      relativeOrientationConstraints.forEach((c) => {
        let directions = c.directions;
        let selector = c.selector;
        let selectorRes = this.evaluator.evaluate(selector, { instanceIndex: this.instanceNum });
        let selectedTuples = selectorRes.selectedTwoples();
        selectedTuples.forEach((tuple) => {
          let sourceNodeId = tuple[0];
          let targetNodeId = tuple[1];
          directions.forEach((direction) => {
            const edgeExists = g.hasEdge(sourceNodeId, targetNodeId) || g.hasEdge(targetNodeId, sourceNodeId);
            if (direction.startsWith("directly") && this.addAlignmentEdges && !edgeExists) {
              const alignmentEdgeLabel = `_alignment_${sourceNodeId}_${targetNodeId}_`;
              g.setEdge(sourceNodeId, targetNodeId, alignmentEdgeLabel, alignmentEdgeLabel);
            }
            if (direction == "left") {
              constraints.push(this.leftConstraint(targetNodeId, sourceNodeId, this.minSepWidth, layoutNodes, c));
            } else if (direction == "above") {
              constraints.push(this.topConstraint(targetNodeId, sourceNodeId, this.minSepHeight, layoutNodes, c));
            } else if (direction == "right") {
              constraints.push(this.leftConstraint(sourceNodeId, targetNodeId, this.minSepWidth, layoutNodes, c));
            } else if (direction == "below") {
              constraints.push(this.topConstraint(sourceNodeId, targetNodeId, this.minSepHeight, layoutNodes, c));
            } else if (direction == "directlyLeft") {
              constraints.push(this.leftConstraint(targetNodeId, sourceNodeId, this.minSepWidth, layoutNodes, c));
              constraints.push(this.ensureSameYConstraint(targetNodeId, sourceNodeId, layoutNodes, c));
            } else if (direction == "directlyAbove") {
              constraints.push(this.topConstraint(targetNodeId, sourceNodeId, this.minSepHeight, layoutNodes, c));
              constraints.push(this.ensureSameXConstraint(targetNodeId, sourceNodeId, layoutNodes, c));
            } else if (direction == "directlyRight") {
              constraints.push(this.leftConstraint(sourceNodeId, targetNodeId, this.minSepWidth, layoutNodes, c));
              constraints.push(this.ensureSameYConstraint(targetNodeId, sourceNodeId, layoutNodes, c));
            } else if (direction == "directlyBelow") {
              constraints.push(this.topConstraint(sourceNodeId, targetNodeId, this.minSepHeight, layoutNodes, c));
              constraints.push(this.ensureSameXConstraint(targetNodeId, sourceNodeId, layoutNodes, c));
            }
          });
        });
      });
      return constraints;
    }
    getDisconnectedNodes(g) {
      let inNodes = g.edges().map((edge) => edge.w);
      let outNodes = g.edges().map((edge) => edge.v);
      let allNodes = new Set(g.nodes());
      let allConnectedNodes = /* @__PURE__ */ new Set([...inNodes, ...outNodes]);
      let disconnectedNodes = [...allNodes].filter((node) => !allConnectedNodes.has(node));
      return disconnectedNodes;
    }
    getNodeFromId(nodeId, layoutNodes) {
      let node = layoutNodes.find((node2) => node2.id === nodeId);
      if (!node) {
        throw new Error(`Node ${nodeId} not found in graph. Did you hide it? If this is a built-in type, try removing any visibility flags.`);
      }
      return node;
    }
    leftConstraint(leftId, rightId, minDistance, layoutNodes, sourceConstraint) {
      let left = this.getNodeFromId(leftId, layoutNodes);
      let right = this.getNodeFromId(rightId, layoutNodes);
      return { left, right, minDistance, sourceConstraint };
    }
    topConstraint(topId, bottomId, minDistance, layoutNodes, sourceConstraint) {
      let top = this.getNodeFromId(topId, layoutNodes);
      let bottom = this.getNodeFromId(bottomId, layoutNodes);
      return { top, bottom, minDistance, sourceConstraint };
    }
    ensureSameYConstraint(node1Id, node2Id, layoutNodes, sourceConstraint) {
      let node1 = this.getNodeFromId(node1Id, layoutNodes);
      let node2 = this.getNodeFromId(node2Id, layoutNodes);
      return { axis: "y", node1, node2, sourceConstraint };
    }
    ensureSameXConstraint(node1Id, node2Id, layoutNodes, sourceConstraint) {
      let node1 = this.getNodeFromId(node1Id, layoutNodes);
      let node2 = this.getNodeFromId(node2Id, layoutNodes);
      return { axis: "x", node1, node2, sourceConstraint };
    }
    singletonGroup(nodeId) {
      let groupName = `${_LayoutInstance.DISCONNECTED_PREFIX}${nodeId}`;
      return {
        name: groupName,
        nodeIds: [nodeId],
        keyNodeId: nodeId,
        showLabel: false
      };
    }
    getNodeSizeMap(g) {
      let nodeSizeMap = {};
      const DEFAULT_SIZE = { width: this.DEFAULT_NODE_WIDTH, height: this.DEFAULT_NODE_HEIGHT };
      let sizeDirectives = this._layoutSpec.directives.sizes;
      sizeDirectives.forEach((sizeDirective) => {
        let selectedNodes = this.evaluator.evaluate(sizeDirective.selector, { instanceIndex: this.instanceNum }).selectedAtoms();
        let width = sizeDirective.width;
        let height = sizeDirective.height;
        selectedNodes.forEach((nodeId) => {
          if (nodeSizeMap[nodeId]) {
            const existingSize = nodeSizeMap[nodeId];
            if (existingSize.width !== width || existingSize.height !== height) {
              throw new Error(
                `Size Conflict: "${nodeId}" cannot have multiple sizes: ${JSON.stringify(existingSize)}, ${JSON.stringify({ width, height })}.`
              );
            }
          }
          nodeSizeMap[nodeId] = { width, height };
        });
      });
      let graphNodes = [...g.nodes()];
      graphNodes.forEach((nodeId) => {
        if (!nodeSizeMap[nodeId]) {
          nodeSizeMap[nodeId] = DEFAULT_SIZE;
        }
      });
      return nodeSizeMap;
    }
    getNodeColorMap(g, a) {
      let nodeColorMap = {};
      let sigColors = this.getSigColors(a);
      let colorDirectives = this._layoutSpec.directives.atomColors;
      colorDirectives.forEach((colorDirective) => {
        let selected = this.evaluator.evaluate(colorDirective.selector, { instanceIndex: this.instanceNum }).selectedAtoms();
        let color = colorDirective.color;
        selected.forEach((nodeId) => {
          if (nodeColorMap[nodeId]) {
            const existingColor = nodeColorMap[nodeId];
            if (existingColor !== color) {
              throw new Error(
                `Color Conflict: "${nodeId}" cannot have multiple colors: ${existingColor}, ${color}.`
              );
            }
          }
          nodeColorMap[nodeId] = color;
        });
      });
      let graphNodes = [...g.nodes()];
      graphNodes.forEach((nodeId) => {
        if (!nodeColorMap[nodeId]) {
          let mostSpecificType = this.getMostSpecificType(nodeId, a);
          nodeColorMap[nodeId] = sigColors[mostSpecificType];
        }
      });
      return nodeColorMap;
    }
    getNodeIconMap(g) {
      let nodeIconMap = {};
      const DEFAULT_ICON = this.DEFAULT_NODE_ICON_PATH;
      let iconDirectives = this._layoutSpec.directives.icons;
      iconDirectives.forEach((iconDirective) => {
        let selected = this.evaluator.evaluate(iconDirective.selector, { instanceIndex: this.instanceNum }).selectedAtoms();
        let iconPath = iconDirective.path;
        selected.forEach((nodeId) => {
          if (nodeIconMap[nodeId]) {
            const existingIcon = nodeIconMap[nodeId];
            if (existingIcon.path !== iconPath || existingIcon.showLabels !== iconDirective.showLabels) {
              throw new Error(
                `Icon Conflict: "${nodeId}" cannot have multiple icons: ${JSON.stringify(existingIcon)}, ${JSON.stringify({ path: iconPath, showLabels: iconDirective.showLabels })}.`
              );
            }
          }
          nodeIconMap[nodeId] = { path: iconPath, showLabels: iconDirective.showLabels };
        });
      });
      let graphNodes = [...g.nodes()];
      graphNodes.forEach((nodeId) => {
        if (!nodeIconMap[nodeId]) {
          nodeIconMap[nodeId] = { path: DEFAULT_ICON, showLabels: true };
        }
      });
      return nodeIconMap;
    }
    /**
     * Gets the color for a specific edge based on directives.
     * @param relName - The relation name of the edge.
     * @param sourceAtom - The source atom ID.
     * @param targetAtom - The target atom ID.
     * @returns The color for the edge, or "black" as default.
     */
    getEdgeColor(relName, sourceAtom, targetAtom) {
      const colorDirectives = this._layoutSpec.directives.edgeColors;
      for (const directive of colorDirectives) {
        if (directive.field !== relName) {
          continue;
        }
        if (!directive.selector) {
          return directive.color;
        }
        try {
          const selectorResult = this.evaluator.evaluate(directive.selector, { instanceIndex: this.instanceNum });
          const selectedAtoms = selectorResult.selectedAtoms();
          if (selectedAtoms.includes(sourceAtom)) {
            return directive.color;
          }
        } catch (error) {
          console.warn(`Failed to evaluate edge color selector "${directive.selector}":`, error);
        }
      }
      return "black";
    }
    /**
     * Obtains the default sig colors for each sig type.
     * @param ai - The Alloy instance to get the sig colors for.
     * @returns a Record mapping sig types to their colors.
     */
    getSigColors(ai) {
      let sigColors = {};
      let types2 = ai.getTypes();
      let colorPicker = new ColorPicker(types2.length);
      types2.forEach((type2) => {
        sigColors[type2.id] = colorPicker.getNextColor();
      });
      return sigColors;
    }
    getFieldTuples(a, fieldName) {
      let relations = a.getRelations();
      let vals = Object.values(relations);
      let field = Object.values(relations).find((rel) => rel.name === fieldName);
      if (!field) {
        return [];
      }
      let fieldTuples = field.tuples.map((tuple) => {
        return tuple.atoms;
      });
      return fieldTuples;
    }
    getFieldTuplesForSourceAndTarget(a, fieldName, src, tgt) {
      let fieldTuples = this.getFieldTuples(a, fieldName);
      let filteredTuples = fieldTuples.filter((tuple) => {
        let arity = tuple.length;
        if (arity < 1) {
          return false;
        }
        return tuple[0] === src && tuple[arity - 1] === tgt;
      });
      return filteredTuples;
    }
    // g is an inout parameter. I.E. it will be modified.
    addinferredEdges(g) {
      const inferredEdgePrefix = "_inferred_";
      let inferredEdges = this._layoutSpec.directives.inferredEdges;
      inferredEdges.forEach((he) => {
        let res = this.evaluator.evaluate(he.selector, { instanceIndex: this.instanceNum });
        let selectedTuples = res.selectedTuplesAll();
        let edgeIdPrefix = `${inferredEdgePrefix}<:${he.name}`;
        selectedTuples.forEach((tuple) => {
          let n = tuple.length;
          let sourceNodeId = tuple[0];
          let targetNodeId = tuple[n - 1];
          let edgeLabel = he.name;
          if (n > 2) {
            let middleNodeLabels = tuple.slice(1, n - 1).map((nodeId) => {
              const nodeMetadata = g.node(nodeId);
              return nodeMetadata?.label || nodeId;
            }).join(",");
            edgeLabel = `${edgeLabel}[${middleNodeLabels}]`;
          }
          let fullTuple = tuple.join("->");
          let edgeId = `${edgeIdPrefix}<:${fullTuple}`;
          g.setEdge(sourceNodeId, targetNodeId, edgeLabel, edgeId);
        });
      });
    }
  };
  _LayoutInstance.DISCONNECTED_PREFIX = "_d_";
  var LayoutInstance = _LayoutInstance;

  // src/components/CombinedInput/CombinedInputComponent.tsx
  var import_jsx_runtime26 = __toESM(require_jsx_runtime());
  var CombinedInputComponent = ({
    cndSpec = "",
    dataInstance,
    pyretEvaluator,
    projections = {},
    height = "600px",
    width = "100%",
    showLayoutInterface = true,
    autoApplyLayout = true,
    style,
    className,
    onInstanceChange,
    onSpecChange,
    onLayoutApplied
  }) => {
    const [currentInstance, setCurrentInstance] = (0, import_react12.useState)(() => {
      return dataInstance || new PyretDataInstance();
    });
    const [currentSpec, setCurrentSpec] = (0, import_react12.useState)(cndSpec);
    const [extractedSpecs, setExtractedSpecs] = (0, import_react12.useState)([]);
    const [constraints, setConstraints] = (0, import_react12.useState)([]);
    const [directives, setDirectives] = (0, import_react12.useState)([]);
    const [isNoCodeView, setIsNoCodeView] = (0, import_react12.useState)(false);
    const [layoutStale, setLayoutStale] = (0, import_react12.useState)(false);
    const [currentLayout, setCurrentLayout] = (0, import_react12.useState)(null);
    const [replCollapsed, setReplCollapsed] = (0, import_react12.useState)(true);
    const [layoutCollapsed, setLayoutCollapsed] = (0, import_react12.useState)(false);
    const [graphCollapsed, setGraphCollapsed] = (0, import_react12.useState)(false);
    const [reifyHidden, setReifyHidden] = (0, import_react12.useState)(false);
    const graphContainerRef = (0, import_react12.useRef)(null);
    const graphElementRef = (0, import_react12.useRef)(null);
    const currentInstanceRef = (0, import_react12.useRef)(currentInstance);
    (0, import_react12.useEffect)(() => {
      if (dataInstance && dataInstance !== currentInstance) {
        setCurrentInstance(dataInstance);
        currentInstanceRef.current = dataInstance;
      }
    }, [dataInstance, currentInstance]);
    (0, import_react12.useEffect)(() => {
      currentInstanceRef.current = currentInstance;
    }, [currentInstance]);
    const composeCndSpecs = (0, import_react12.useCallback)((baseSpec, extractedSpecs2) => {
      const specs = [baseSpec, ...extractedSpecs2].filter((spec) => spec && spec.trim());
      if (specs.length === 0) {
        return "";
      }
      if (specs.length === 1) {
        return specs[0];
      }
      return specs.join("\n");
    }, []);
    const completeSpec = (0, import_react12.useMemo)(() => {
      return composeCndSpecs(cndSpec, extractedSpecs);
    }, [cndSpec, extractedSpecs]);
    const applyLayout = (0, import_react12.useCallback)(async (instance, spec) => {
      try {
        console.log("Applying layout with SGraphQueryEvaluator...");
        const evaluationContext = {
          sourceData: instance
        };
        const sgqEvaluator = new SGraphQueryEvaluator();
        sgqEvaluator.initialize(evaluationContext);
        const layoutSpec = parseLayoutSpec(spec || "");
        const layoutInstance = new LayoutInstance(layoutSpec, sgqEvaluator, 0, true);
        const layoutResult = layoutInstance.generateLayout(instance, projections);
        const newLayout = layoutResult.layout;
        setCurrentLayout(newLayout);
        setLayoutStale(false);
        onLayoutApplied?.(newLayout);
        if (graphElementRef.current && typeof graphElementRef.current.renderLayout === "function") {
          await graphElementRef.current.renderLayout(newLayout);
          console.log("Graph updated successfully");
        }
      } catch (error) {
        console.error("Failed to apply layout:", error);
        setLayoutStale(true);
      }
    }, [projections, onLayoutApplied]);
    (0, import_react12.useEffect)(() => {
      if (completeSpec !== currentSpec) {
        setCurrentSpec(completeSpec);
        setLayoutStale(true);
        onSpecChange?.(completeSpec);
        if (autoApplyLayout && currentInstance.getAtoms().length > 0) {
          setTimeout(() => applyLayout(currentInstance, completeSpec), 100);
        }
      }
    }, [completeSpec, currentSpec, onSpecChange, autoApplyLayout, currentInstance, applyLayout]);
    const handleInstanceChange = (0, import_react12.useCallback)((newInstance) => {
      setCurrentInstance(newInstance);
      currentInstanceRef.current = newInstance;
      setLayoutStale(true);
      onInstanceChange?.(newInstance);
      if (autoApplyLayout && newInstance.getAtoms().length > 0) {
        setTimeout(() => {
          const finalSpec = composeCndSpecs(cndSpec, extractedSpecs);
          applyLayout(newInstance, finalSpec);
        }, 100);
      }
    }, [autoApplyLayout, cndSpec, extractedSpecs, composeCndSpecs, applyLayout, onInstanceChange]);
    const handleSpecChange = (0, import_react12.useCallback)((newSpec) => {
      setCurrentSpec(newSpec);
      setLayoutStale(true);
      onSpecChange?.(newSpec);
      if (autoApplyLayout && currentInstance.getAtoms().length > 0) {
        setTimeout(() => applyLayout(currentInstance, newSpec), 100);
      }
    }, [autoApplyLayout, currentInstance, applyLayout, onSpecChange]);
    const handleCndSpecExtracted = (0, import_react12.useCallback)((extractedSpec) => {
      console.log("CnD spec extracted from expression:", extractedSpec);
      setExtractedSpecs((prev) => {
        if (!prev.includes(extractedSpec)) {
          console.log("Adding new extracted spec:", extractedSpec, "to list:", prev);
          const newSpecs = [...prev, extractedSpec];
          if (autoApplyLayout && currentInstance.getAtoms().length > 0) {
            setTimeout(() => {
              const finalSpec = composeCndSpecs(cndSpec, newSpecs);
              applyLayout(currentInstance, finalSpec);
            }, 100);
          }
          return newSpecs;
        }
        return prev;
      });
    }, [autoApplyLayout, currentInstance, cndSpec, composeCndSpecs, applyLayout]);
    const handleApplyLayout = (0, import_react12.useCallback)(() => {
      applyLayout(currentInstance, currentSpec);
    }, [applyLayout, currentInstance, currentSpec]);
    const handleClear = (0, import_react12.useCallback)(() => {
      const emptyInstance = new PyretDataInstance();
      setCurrentInstance(emptyInstance);
      currentInstanceRef.current = emptyInstance;
      setCurrentLayout(null);
      setLayoutStale(false);
      onInstanceChange?.(emptyInstance);
      if (graphElementRef.current) {
        if (typeof graphElementRef.current.clear === "function") {
          graphElementRef.current.clear();
        }
        if (typeof graphElementRef.current.renderLayout === "function") {
          graphElementRef.current.renderLayout(null);
        }
      }
    }, [onInstanceChange]);
    (0, import_react12.useEffect)(() => {
      if (graphContainerRef.current && !graphElementRef.current) {
        const graphElement = document.createElement("webcola-cnd-graph");
        graphElement.setAttribute("width", "100%");
        graphElement.setAttribute("height", "400");
        graphElement.setAttribute("layoutFormat", "default");
        graphElement.style.width = "100%";
        graphElement.style.height = "400px";
        graphElement.style.border = "2px solid #007acc";
        graphElement.style.borderRadius = "8px";
        const handleEdgeCreationRequested = (event) => {
          const customEvent = event;
          console.log("\u{1F517} Edge creation requested in CombinedInput:", customEvent.detail);
          const { relationId, sourceNodeId, targetNodeId, tuple } = customEvent.detail;
          try {
            const currentInstanceValue = currentInstanceRef.current;
            currentInstanceValue.addRelationTuple(relationId, tuple);
            console.log(`\u2705 Added relation tuple: ${relationId}(${tuple.atoms.join(", ")})`);
            handleInstanceChange(currentInstanceValue);
          } catch (error) {
            console.error("Failed to add edge relation:", error);
          }
        };
        const handleEdgeModificationRequested = (event) => {
          const customEvent = event;
          console.log("\u{1F517} Edge modification requested in CombinedInput:", customEvent.detail);
          const { oldRelationId, newRelationId, sourceNodeId, targetNodeId, tuple } = customEvent.detail;
          try {
            const currentInstanceValue = currentInstanceRef.current;
            if (oldRelationId.trim() === newRelationId.trim()) {
              console.log("\u23ED\uFE0F Same relation name, no data changes needed");
              return;
            }
            if (oldRelationId.trim()) {
              const oldRelation = currentInstanceValue.getRelations().find((r) => r.id === oldRelationId);
              if (oldRelation) {
                currentInstanceValue.removeRelationTuple(oldRelationId, tuple);
                console.log(`\u{1F5D1}\uFE0F Removed from ${oldRelationId}`);
              }
            }
            if (newRelationId.trim()) {
              currentInstanceValue.addRelationTuple(newRelationId, tuple);
              console.log(`\u2795 Added to ${newRelationId}`);
            }
            handleInstanceChange(currentInstanceValue);
          } catch (error) {
            console.error("Failed to modify edge relation:", error);
          }
        };
        const handleEdgeCreated = (event) => {
          const customEvent = event;
          console.log("\u2705 Edge created confirmation:", customEvent.detail);
        };
        const handleEdgeModified = (event) => {
          const customEvent = event;
          console.log("\u2705 Edge modified confirmation:", customEvent.detail);
        };
        graphElement.addEventListener("edge-creation-requested", handleEdgeCreationRequested);
        graphElement.addEventListener("edge-modification-requested", handleEdgeModificationRequested);
        graphElement.addEventListener("edge-created", handleEdgeCreated);
        graphElement.addEventListener("edge-modified", handleEdgeModified);
        graphContainerRef.current.appendChild(graphElement);
        graphElementRef.current = graphElement;
        return () => {
          if (graphElement) {
            graphElement.removeEventListener("edge-creation-requested", handleEdgeCreationRequested);
            graphElement.removeEventListener("edge-modification-requested", handleEdgeModificationRequested);
            graphElement.removeEventListener("edge-created", handleEdgeCreated);
            graphElement.removeEventListener("edge-modified", handleEdgeModified);
          }
        };
      }
    }, []);
    (0, import_react12.useEffect)(() => {
      if (graphElementRef.current && currentInstance.getAtoms().length > 0 && autoApplyLayout) {
        const finalSpec = composeCndSpecs(cndSpec, extractedSpecs);
        setTimeout(() => applyLayout(currentInstance, finalSpec), 150);
      }
    }, [currentInstance.getAtoms().length, extractedSpecs.length]);
    const containerStyle = {
      width,
      height,
      display: "flex",
      flexDirection: "column",
      gap: "16px",
      padding: "12px",
      border: "1px solid #e0e0e0",
      borderRadius: "6px",
      backgroundColor: "#fafafa",
      ...style
    };
    const isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
    return /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { className, style: containerStyle, children: [
      /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: {
        display: "flex",
        justifyContent: "flex-end",
        alignItems: "center",
        padding: "4px 8px",
        backgroundColor: "transparent",
        gap: "8px"
      }, children: [
        layoutStale && /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
          "button",
          {
            onClick: handleApplyLayout,
            style: {
              backgroundColor: "#ff6b35",
              color: "white",
              border: "none",
              padding: "4px 8px",
              borderRadius: "3px",
              cursor: "pointer",
              fontSize: "11px",
              fontWeight: "500"
            },
            children: "Apply Layout"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
          "button",
          {
            onClick: handleClear,
            style: {
              backgroundColor: "#dc3545",
              color: "white",
              border: "none",
              padding: "4px 8px",
              borderRadius: "3px",
              cursor: "pointer",
              fontSize: "11px",
              fontWeight: "500"
            },
            children: "Clear"
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: { display: "flex", flexDirection: "column", flex: 1, gap: "20px" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: {
          border: "1px solid #ddd",
          borderRadius: "6px",
          backgroundColor: "#fff",
          display: "flex",
          flexDirection: "column"
        }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: {
            padding: "6px 12px",
            backgroundColor: "#f8f9fa",
            borderBottom: replCollapsed ? "none" : "1px solid #e0e0e0",
            borderRadius: "6px 6px 0 0",
            fontSize: "12px",
            fontWeight: "500",
            color: "#495057",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            cursor: "pointer"
          }, onClick: () => setReplCollapsed(!replCollapsed), children: [
            /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("span", { children: "REPL" }),
            /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("span", { style: { fontSize: "10px", color: "#6c757d" }, children: replCollapsed ? "\u25B6" : "\u25BC" })
          ] }),
          !replCollapsed && /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("div", { style: { padding: "12px" }, children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
            PyretReplInterface,
            {
              initialInstance: currentInstance,
              onChange: handleInstanceChange,
              onCndSpecExtracted: handleCndSpecExtracted,
              externalEvaluator: pyretEvaluator
            }
          ) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: {
          border: "1px solid #ddd",
          borderRadius: "6px",
          backgroundColor: "#fff",
          display: "flex",
          flexDirection: "column",
          flex: 1
        }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: {
            padding: "6px 12px",
            backgroundColor: "#f8f9fa",
            borderBottom: graphCollapsed ? "none" : "1px solid #e0e0e0",
            borderRadius: "6px 6px 0 0",
            fontSize: "12px",
            fontWeight: "500",
            color: "#495057",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center"
          }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: { display: "flex", alignItems: "center" }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
                "span",
                {
                  style: { cursor: "pointer", marginRight: "8px" },
                  onClick: () => setGraphCollapsed(!graphCollapsed),
                  children: graphCollapsed ? "\u25B6" : "\u25BC"
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("span", { children: "Diagram" }),
              /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("span", { style: {
                fontSize: "10px",
                fontWeight: "normal",
                color: "#6c757d",
                marginLeft: "8px"
              }, children: [
                currentInstance.getAtoms().length,
                " \u2022 ",
                currentInstance.getRelations().length
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: "12px" }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: { fontSize: "9px", color: "#28a745", fontWeight: "400" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("strong", { children: [
                  isMac ? "Cmd" : "Ctrl",
                  " + Click"
                ] }),
                " between nodes to create edges."
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
                "button",
                {
                  onClick: () => setReplCollapsed(false),
                  style: {
                    backgroundColor: "#007bff",
                    color: "white",
                    border: "none",
                    padding: "4px 8px",
                    borderRadius: "12px",
                    cursor: "pointer",
                    fontSize: "10px",
                    fontWeight: "500"
                  },
                  children: "+ Add / Remove Nodes or Modify Edges"
                }
              )
            ] })
          ] }),
          !graphCollapsed && /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
            "div",
            {
              ref: graphContainerRef,
              style: {
                flex: 1,
                padding: "12px",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                minHeight: "400px"
              },
              children: !graphElementRef.current && /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: { color: "#6c757d", textAlign: "center", fontSize: "13px" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("p", { children: "Add data using the REPL to see visualization" }),
                /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("small", { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("strong", { children: [
                    isMac ? "Cmd" : "Ctrl",
                    " + Click"
                  ] }),
                  " between nodes to create edges.                  "
                ] })
              ] })
            }
          )
        ] }),
        showLayoutInterface && /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: {
          border: "1px solid #ddd",
          borderRadius: "6px",
          backgroundColor: "#fff",
          display: "flex",
          flexDirection: "column"
        }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: {
            padding: "6px 12px",
            backgroundColor: "#f8f9fa",
            borderBottom: layoutCollapsed ? "none" : "1px solid #e0e0e0",
            borderRadius: "6px 6px 0 0",
            fontSize: "12px",
            fontWeight: "500",
            color: "#495057",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            cursor: "pointer"
          }, onClick: () => setLayoutCollapsed(!layoutCollapsed), children: [
            /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("span", { children: "Layout" }),
            /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("span", { style: { fontSize: "10px", color: "#6c757d" }, children: layoutCollapsed ? "\u25B6" : "\u25BC" })
          ] }),
          !layoutCollapsed && /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("div", { style: { padding: "12px" }, children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
            CndLayoutInterface,
            {
              yamlValue: currentSpec,
              onChange: handleSpecChange,
              isNoCodeView,
              onViewChange: setIsNoCodeView,
              constraints,
              setConstraints,
              directives,
              setDirectives
            }
          ) })
        ] })
      ] }),
      !reifyHidden && currentInstance.getAtoms().length > 0 && /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: {
        border: "1px solid #ddd",
        borderRadius: "6px",
        backgroundColor: "#fff",
        display: "flex",
        flexDirection: "column"
      }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: {
          padding: "6px 12px",
          backgroundColor: "#f8f9fa",
          borderBottom: "1px solid #e0e0e0",
          borderRadius: "6px 6px 0 0",
          fontSize: "12px",
          fontWeight: "500",
          color: "#495057",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("span", { children: "Pyret Data" }),
          /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { style: { display: "flex", gap: "6px" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
              "button",
              {
                onClick: () => {
                  const reifiedData = currentInstance.reify();
                  navigator.clipboard.writeText(reifiedData);
                },
                style: {
                  backgroundColor: "#007bff",
                  color: "white",
                  border: "none",
                  padding: "2px 6px",
                  borderRadius: "2px",
                  cursor: "pointer",
                  fontSize: "10px"
                },
                children: "Copy"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
              "button",
              {
                onClick: () => setReifyHidden(true),
                style: {
                  backgroundColor: "#6c757d",
                  color: "white",
                  border: "none",
                  padding: "2px 6px",
                  borderRadius: "2px",
                  cursor: "pointer",
                  fontSize: "10px"
                },
                children: "\xD7"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("div", { style: { padding: "8px" }, children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
          "textarea",
          {
            value: currentInstance.reify(),
            readOnly: true,
            style: {
              width: "100%",
              height: "60px",
              fontSize: "10px",
              fontFamily: 'Monaco, Menlo, "Ubuntu Mono", monospace',
              backgroundColor: "#f8f9fa",
              border: "1px solid #e0e0e0",
              borderRadius: "3px",
              padding: "6px",
              resize: "vertical"
            },
            placeholder: "Pyret data will appear here..."
          }
        ) })
      ] })
    ] });
  };

  // src/components/CombinedInput/mounting.tsx
  var import_jsx_runtime27 = __toESM(require_jsx_runtime());
  function mountCombinedInput(config = {}) {
    const {
      containerId = "combined-input-container",
      onInstanceChange,
      onSpecChange,
      onLayoutApplied,
      ...componentConfig
    } = config;
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`Combined Input: Container '${containerId}' not found`);
      return false;
    }
    try {
      const root = (0, import_client.createRoot)(container);
      root.render(
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
          CombinedInputComponent,
          {
            ...componentConfig,
            onInstanceChange,
            onSpecChange,
            onLayoutApplied
          }
        )
      );
      console.log(`\u2705 Combined Input Component mounted to #${containerId}`, {
        hasDataInstance: !!config.dataInstance,
        hasPyretEvaluator: !!config.pyretEvaluator,
        cndSpecLength: config.cndSpec?.length ?? 0,
        showLayoutInterface: config.showLayoutInterface ?? true,
        autoApplyLayout: config.autoApplyLayout ?? true
      });
      return true;
    } catch (error) {
      console.error("Failed to mount Combined Input Component:", error);
      return false;
    }
  }

  // src/components/EvaluatorRepl/EvaluatorRepl.tsx
  var import_react13 = __toESM(require_react());
  var import_jsx_runtime28 = __toESM(require_jsx_runtime());
  var EvaluatorRepl = ({ evaluator, instanceNumber }) => {
    const [textInput, setTextInput] = import_react13.default.useState("");
    const [evaluatorOutput, setEvaluatorOutput] = import_react13.default.useState([]);
    import_react13.default.useEffect(() => {
      setTextInput("");
      setEvaluatorOutput([]);
    }, [evaluator, instanceNumber]);
    const handleKeyDown = (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        const output = evaluator.evaluate(textInput, { instanceIndex: instanceNumber });
        setEvaluatorOutput((prev) => [[textInput, output.prettyPrint()], ...prev]);
        setTextInput("");
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)("div", { id: "evaluator-repl-container", children: [
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
        "input",
        {
          className: "code-input",
          id: "evaluator-input",
          type: "text",
          placeholder: "Enter expression to evaluate...",
          value: textInput,
          onChange: (e) => setTextInput(e.target.value),
          onKeyDown: handleKeyDown
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { id: "repl-output", children: evaluatorOutput.map(([textInput2, output], index) => /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(import_react13.default.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("p", { className: "repl-output-line", children: `> ${textInput2}` }),
        /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("p", { className: "repl-output-line", children: output })
      ] }, index)) })
    ] });
  };

  // src/components/RelationHighlighter/RelationHighlighter.tsx
  var import_react14 = __toESM(require_react());
  var import_jsx_runtime29 = __toESM(require_jsx_runtime());
  var RelationHighlighter = ({
    graphElementId
  }) => {
    const [relations, setRelations] = (0, import_react14.useState)([]);
    const [isCollapsed, setIsCollapsed] = (0, import_react14.useState)(true);
    const graphElementRef = (0, import_react14.useRef)(null);
    (0, import_react14.useEffect)(() => {
      const element = document.getElementById(graphElementId);
      graphElementRef.current = element;
      if (!graphElementRef.current) {
        console.warn(`RelationHighlighter: Element with id "${graphElementId}" not found`);
        return;
      }
      const handleRelationsAvailable = (event) => {
        const customEvent = event;
        const { relations: availableRelations } = customEvent.detail;
        setRelations(availableRelations || []);
      };
      graphElementRef.current.addEventListener("relations-available", handleRelationsAvailable);
      return () => {
        if (graphElementRef.current) {
          graphElementRef.current.removeEventListener("relations-available", handleRelationsAvailable);
        }
      };
    }, [graphElementId]);
    const handleRelationHover = (event, relationName) => {
      const currentTarget = event.currentTarget;
      const parentList = currentTarget.parentElement;
      if (!parentList) return;
      const rect = parentList.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      if (mouseX >= 0 && mouseX <= parentList.clientWidth && mouseY >= 0 && mouseY <= parentList.clientHeight) {
        if (graphElementRef.current && typeof graphElementRef.current.highlightRelation === "function") {
          graphElementRef.current.highlightRelation(relationName);
        }
      }
    };
    const handleRelationLeave = (relationName) => {
      if (graphElementRef.current && typeof graphElementRef.current.clearHighlightRelation === "function") {
        graphElementRef.current.clearHighlightRelation(relationName);
      }
    };
    const toggleCollapsed = () => {
      setIsCollapsed((prev) => !prev);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: "relation-highlighter", children: [
      /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: "relation-highlighter-header", onClick: toggleCollapsed, children: [
        /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("h3", { className: "relation-highlighter-title", children: [
          "Relations (",
          relations.length,
          ")"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
          "button",
          {
            className: `collapse-toggle ${isCollapsed ? "collapsed" : ""}`,
            "aria-label": isCollapsed ? "Expand relations" : "Collapse relations",
            children: "\u25BC"
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: `relation-highlighter-content ${isCollapsed ? "collapsed" : ""}`, children: relations.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("p", { className: "no-relations", children: "No relations available" }) : /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("ul", { className: "relation-list", children: relations.map((relation) => /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
        "li",
        {
          className: "relation-item",
          onMouseEnter: (event) => handleRelationHover(event, relation),
          onMouseLeave: () => handleRelationLeave(relation),
          children: relation
        },
        relation
      )) }) })
    ] });
  };

  // webcola-demo/react-component-integration.tsx
  var import_jsx_runtime30 = __toESM(require_jsx_runtime());
  var CndLayoutStateManager = class _CndLayoutStateManager {
    constructor() {
      this.constraints = [];
      this.directives = [];
      this.yamlValue = "";
      this.isNoCodeView = false;
    }
    /**
     * Get singleton instance of state manager
     * @returns The global state manager instance
     */
    static getInstance() {
      if (!_CndLayoutStateManager.instance) {
        _CndLayoutStateManager.instance = new _CndLayoutStateManager();
      }
      return _CndLayoutStateManager.instance;
    }
    /**
     * Initialize state manager with configuration values
     * Overrides existing values completely
     * @param config - Configuration object
     * @public
     */
    initializeWithConfig(config) {
      if (config.initialYamlValue !== void 0) {
        this.yamlValue = config.initialYamlValue;
      }
      if (config.initialIsNoCodeView !== void 0) {
        this.isNoCodeView = config.initialIsNoCodeView;
      }
      if (config.initialConstraints !== void 0) {
        this.constraints = [...config.initialConstraints];
      }
      if (config.initialDirectives !== void 0) {
        this.directives = [...config.initialDirectives];
      }
    }
    /**
     * Update constraints array
     * @param constraints - New constraints array
     */
    setConstraints(constraints) {
      this.constraints = constraints;
    }
    /**
     * Update directives array
     * @param directives - New directives array
     */
    setDirectives(directives) {
      this.directives = directives;
    }
    /**
     * Update YAML value
     * @param yamlValue - New YAML string
     */
    setYamlValue(yamlValue) {
      this.yamlValue = yamlValue;
    }
    /**
     * Update layout view mode
     * @param isNoCodeView - Whether to use No-Code view
     * @public
     */
    setIsNoCodeView(isNoCodeView) {
      this.isNoCodeView = isNoCodeView;
    }
    /**
     * Get current layout view mode
     * @returns True if in No-Code view, false for Code view
     * @public
     */
    getIsNoCodeView() {
      return this.isNoCodeView;
    }
    /**
     * Get current constraints
     * @returns Current constraints array
     * @public
     */
    getConstraints() {
      return [...this.constraints];
    }
    /**
     * Get current directives
     * @returns Current directives array
     * @public
     */
    getDirectives() {
      return [...this.directives];
    }
    /**
     * Get current YAML value
     * @returns Current YAML string
     * @public
     */
    getYamlValue() {
      return this.yamlValue;
    }
    /**
     * Generate YAML spec from current constraints and directives
     * @returns Generated YAML specification string
     */
    generateCurrentYamlSpec() {
      try {
        return generateLayoutSpecYaml(this.constraints, this.directives);
      } catch (error) {
        console.error("Failed to generate YAML spec from state:", error);
        return "";
      }
    }
    /**
     * Get the most current CND specification
     * Prioritizes manual YAML input over generated spec
     * @returns Current CND specification string
     */
    getCurrentCndSpec() {
      if (!this.isNoCodeView) {
        return this.yamlValue.trim();
      } else {
        const generatedSpec = this.generateCurrentYamlSpec();
        return generatedSpec.trim();
      }
    }
  };
  var InstanceStateManager = class _InstanceStateManager {
    constructor() {
      this.instanceChangeCallbacks = [];
      this.currentInstance = createEmptyAlloyDataInstance();
    }
    /**
     * Get singleton instance
     * @returns The global instance state manager
     * @public
     */
    static getInstance() {
      if (!_InstanceStateManager.instance) {
        _InstanceStateManager.instance = new _InstanceStateManager();
      }
      return _InstanceStateManager.instance;
    }
    /**
     * Get current data instance
     * @returns Current data instance
     * @public
     */
    getCurrentInstance() {
      return this.currentInstance;
    }
    /**
     * Set current data instance and notify callbacks
     * @param instance - New data instance
     * @public
     */
    setCurrentInstance(instance) {
      this.currentInstance = instance;
      this.notifyInstanceChange();
    }
    /**
     * Register callback for instance changes
     * @param callback - Function to call when instance changes
     * @public
     */
    onInstanceChange(callback) {
      this.instanceChangeCallbacks.push(callback);
    }
    /**
     * Notify all registered callbacks of instance change
     * @private
     */
    notifyInstanceChange() {
      this.instanceChangeCallbacks.forEach((callback) => {
        try {
          callback(this.currentInstance);
        } catch (error) {
          console.error("Error in instance change callback:", error);
        }
      });
    }
  };
  var PyretReplStateManager = class _PyretReplStateManager {
    constructor() {
      this.externalEvaluator = null;
      this.instanceChangeCallbacks = [];
      this.currentInstance = new PyretDataInstance();
    }
    /**
     * Get singleton instance
     * @returns The global Pyret REPL state manager
     * @public
     */
    static getInstance() {
      if (!_PyretReplStateManager.instance) {
        _PyretReplStateManager.instance = new _PyretReplStateManager();
      }
      return _PyretReplStateManager.instance;
    }
    /**
     * Get current Pyret data instance
     * @returns Current Pyret data instance
     * @public
     */
    getCurrentInstance() {
      return this.currentInstance;
    }
    /**
     * Set current Pyret data instance and notify callbacks
     * @param instance - New Pyret data instance
     * @public
     */
    setCurrentInstance(instance) {
      this.currentInstance = instance;
      this.notifyInstanceChange();
    }
    /**
     * Get current external evaluator
     * @returns Current external evaluator or null
     * @public
     */
    getExternalEvaluator() {
      return this.externalEvaluator;
    }
    /**
     * Set external evaluator
     * @param evaluator - External Pyret evaluator
     * @public
     */
    setExternalEvaluator(evaluator) {
      this.externalEvaluator = evaluator;
    }
    /**
     * Register callback for instance changes
     * @param callback - Function to call when instance changes
     * @public
     */
    onInstanceChange(callback) {
      this.instanceChangeCallbacks.push(callback);
    }
    /**
     * Notify all registered callbacks of instance change
     * @private
     */
    notifyInstanceChange() {
      this.instanceChangeCallbacks.forEach((callback) => {
        try {
          callback(this.currentInstance);
        } catch (error) {
          console.error("Error in Pyret instance change callback:", error);
        }
      });
    }
    /**
     * Get Pyret constructor notation (reify) of current instance
     * @returns Pyret constructor notation string
     * @public
     */
    reifyCurrentInstance() {
      try {
        return this.currentInstance.reify();
      } catch (error) {
        console.error("Error reifying current instance:", error);
        return "/* Error generating Pyret notation */";
      }
    }
  };
  var globalErrorManager = new ErrorStateManager();
  var CndLayoutInterfaceWrapper = ({ config }) => {
    const stateManager = (0, import_react15.useMemo)(() => CndLayoutStateManager.getInstance(), []);
    const [yamlValue, setYamlValue] = (0, import_react15.useState)(() => {
      if (config?.initialYamlValue !== void 0) {
        return config.initialYamlValue;
      }
      return stateManager.getYamlValue();
    });
    const [isNoCodeView, setIsNoCodeView] = (0, import_react15.useState)(() => {
      if (config?.initialIsNoCodeView !== void 0) {
        return config.initialIsNoCodeView;
      }
      return stateManager.getIsNoCodeView();
    });
    const [constraints, setConstraints] = (0, import_react15.useState)(() => {
      if (config?.initialConstraints !== void 0) {
        return [...config.initialConstraints];
      }
      return stateManager.getConstraints();
    });
    const [directives, setDirectives] = (0, import_react15.useState)(() => {
      if (config?.initialDirectives !== void 0) {
        return [...config.initialDirectives];
      }
      return stateManager.getDirectives();
    });
    (0, import_react15.useEffect)(() => {
      if (config) {
        stateManager.initializeWithConfig(config);
      }
    }, [config, stateManager]);
    (0, import_react15.useEffect)(() => {
      stateManager.setConstraints(constraints);
    }, [constraints, stateManager]);
    (0, import_react15.useEffect)(() => {
      stateManager.setDirectives(directives);
    }, [directives, stateManager]);
    (0, import_react15.useEffect)(() => {
      stateManager.setYamlValue(yamlValue);
    }, [yamlValue, stateManager]);
    (0, import_react15.useEffect)(() => {
      stateManager.setIsNoCodeView(isNoCodeView);
    }, [isNoCodeView, stateManager]);
    const handleYamlChange = (0, import_react15.useCallback)((newValue) => {
      setYamlValue(newValue);
      window.dispatchEvent(new CustomEvent("cnd-spec-changed", { detail: newValue }));
    }, []);
    const handleViewChange = (0, import_react15.useCallback)((newIsNoCodeView) => {
      setIsNoCodeView(newIsNoCodeView);
      console.log(`Switched to ${newIsNoCodeView ? "No Code" : "Code"} View`);
    }, []);
    const handleSetConstraints = (0, import_react15.useCallback)((updater) => {
      setConstraints(updater);
    }, []);
    const handleSetDirectives = (0, import_react15.useCallback)((updater) => {
      setDirectives(updater);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
      CndLayoutInterface,
      {
        yamlValue,
        onChange: handleYamlChange,
        isNoCodeView,
        onViewChange: handleViewChange,
        constraints,
        setConstraints: handleSetConstraints,
        directives,
        setDirectives: handleSetDirectives,
        "aria-label": "CND Layout Specification Editor"
      }
    );
  };
  var InstanceBuilderWrapper = () => {
    const [instance, setInstance] = (0, import_react15.useState)(
      () => InstanceStateManager.getInstance().getCurrentInstance()
    );
    (0, import_react15.useEffect)(() => {
      const stateManager = InstanceStateManager.getInstance();
      const handleInstanceChange2 = (newInstance) => {
        setInstance(newInstance);
      };
      stateManager.onInstanceChange(handleInstanceChange2);
      window.currentInstance = instance;
      if (window.updateFromBuilder) {
        window.updateFromBuilder();
      }
    }, [instance]);
    const handleInstanceChange = (0, import_react15.useCallback)((newInstance) => {
      setInstance(newInstance);
      InstanceStateManager.getInstance().setCurrentInstance(newInstance);
      window.currentInstance = newInstance;
      if (window.updateFromBuilder) {
        window.updateFromBuilder();
      }
      if (window.autoRenderGraph) {
        setTimeout(() => window.autoRenderGraph(), 50);
      }
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
      InstanceBuilder,
      {
        instance,
        onChange: handleInstanceChange,
        className: "cnd-integrated-builder"
      }
    );
  };
  var PyretReplInterfaceWrapper = ({ config }) => {
    const [instance, setInstance] = (0, import_react15.useState)(() => {
      if (config?.initialInstance) {
        return config.initialInstance;
      }
      return PyretReplStateManager.getInstance().getCurrentInstance();
    });
    const [externalEvaluator, setExternalEvaluator] = (0, import_react15.useState)(() => {
      if (config?.externalEvaluator) {
        return config.externalEvaluator;
      }
      return PyretReplStateManager.getInstance().getExternalEvaluator();
    });
    (0, import_react15.useEffect)(() => {
      const stateManager = PyretReplStateManager.getInstance();
      if (config?.initialInstance) {
        stateManager.setCurrentInstance(config.initialInstance);
      }
      if (config?.externalEvaluator) {
        stateManager.setExternalEvaluator(config.externalEvaluator);
      }
      const handleInstanceChange2 = (newInstance) => {
        setInstance(newInstance);
      };
      stateManager.onInstanceChange(handleInstanceChange2);
      window.currentPyretInstance = instance;
      return () => {
      };
    }, [config, instance]);
    const handleInstanceChange = (0, import_react15.useCallback)((newInstance) => {
      if (newInstance instanceof PyretDataInstance) {
        setInstance(newInstance);
        PyretReplStateManager.getInstance().setCurrentInstance(newInstance);
        window.currentPyretInstance = newInstance;
        window.dispatchEvent(new CustomEvent("pyret-instance-changed", {
          detail: { instance: newInstance }
        }));
      }
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
      PyretReplInterface,
      {
        initialInstance: instance,
        onChange: handleInstanceChange,
        externalEvaluator: externalEvaluator || void 0,
        disabled: config?.disabled,
        className: config?.className
      }
    );
  };
  var ReplWithVisualizationWrapper = ({ config }) => {
    const [instance, setInstance] = (0, import_react15.useState)(() => {
      if (config?.initialInstance) {
        return config.initialInstance;
      }
      return InstanceStateManager.getInstance().getCurrentInstance();
    });
    (0, import_react15.useEffect)(() => {
      const stateManager = InstanceStateManager.getInstance();
      if (config?.initialInstance) {
        stateManager.setCurrentInstance(config.initialInstance);
      }
      const handleInstanceChange2 = (newInstance) => {
        setInstance(newInstance);
      };
      stateManager.onInstanceChange(handleInstanceChange2);
      window.currentVisualizationInstance = instance;
    }, [config, instance]);
    const handleInstanceChange = (0, import_react15.useCallback)((newInstance) => {
      setInstance(newInstance);
      InstanceStateManager.getInstance().setCurrentInstance(newInstance);
      window.currentVisualizationInstance = newInstance;
      if (window.autoRenderGraph) {
        setTimeout(() => window.autoRenderGraph(), 50);
      }
      window.dispatchEvent(new CustomEvent("repl-visualization-changed", {
        detail: { instance: newInstance }
      }));
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
      ReplWithVisualization,
      {
        instance,
        onChange: handleInstanceChange,
        initialCndSpec: config?.initialCndSpec,
        showLayoutInterface: config?.showLayoutInterface,
        replHeight: config?.replHeight,
        visualizationHeight: config?.visualizationHeight,
        style: config?.style
      }
    );
  };
  function mountCndLayoutInterface(containerId = "webcola-cnd-container", config) {
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`CnD Layout Interface: Container '${containerId}' not found`);
      return false;
    }
    function validateYamlValue(yaml) {
      return true;
    }
    if (config?.initialYamlValue && !validateYamlValue(config.initialYamlValue)) {
      console.error("Invalid YAML value provided in configuration");
      return false;
    }
    try {
      const root = (0, import_client2.createRoot)(container);
      root.render(/* @__PURE__ */ (0, import_jsx_runtime30.jsx)(CndLayoutInterfaceWrapper, { config }));
      if (config) {
        console.log(`\u2705 CnD Layout Interface mounted to #${containerId} with initial config:`, {
          yamlValue: config.initialYamlValue ? `${config.initialYamlValue.length} characters` : "none",
          isNoCodeView: config.initialIsNoCodeView ?? "default",
          constraints: config.initialConstraints?.length ?? 0,
          directives: config.initialDirectives?.length ?? 0
        });
      } else {
        console.log(`\u2705 CnD Layout Interface mounted to #${containerId}`);
      }
      return true;
    } catch (error) {
      console.error("Failed to mount CnD Layout Interface:", error);
      return false;
    }
  }
  function mountInstanceBuilder(containerId = "instance-builder-container") {
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`Instance Builder: Container '${containerId}' not found`);
      return false;
    }
    try {
      const root = (0, import_client2.createRoot)(container);
      root.render(/* @__PURE__ */ (0, import_jsx_runtime30.jsx)(InstanceBuilderWrapper, {}));
      console.log(`\u2705 Instance Builder mounted to #${containerId}`);
      window.updateBuilderInstance = (newInstance) => {
        InstanceStateManager.getInstance().setCurrentInstance(newInstance);
      };
      return true;
    } catch (error) {
      console.error("Failed to mount Instance Builder:", error);
      return false;
    }
  }
  function getCurrentInstanceFromReact() {
    try {
      return InstanceStateManager.getInstance().getCurrentInstance();
    } catch (error) {
      console.error("Error accessing InstanceBuilder instance:", error);
      return void 0;
    }
  }
  function getCurrentCNDSpecFromReact() {
    try {
      const stateManager = CndLayoutStateManager.getInstance();
      const currentSpec = stateManager.generateCurrentYamlSpec();
      if (currentSpec.trim()) {
        return currentSpec;
      }
      const reactTextarea = document.querySelector("#webcola-cnd-container textarea");
      if (reactTextarea && reactTextarea instanceof HTMLTextAreaElement) {
        return reactTextarea.value.trim();
      }
      console.warn("CndLayoutInterface textarea not found");
    } catch (error) {
      console.error("Error accessing CndLayoutInterface instance:", error);
    }
  }
  function mountPyretRepl(containerId = "pyret-repl-container", config) {
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`Pyret REPL: Container '${containerId}' not found`);
      return false;
    }
    try {
      const root = (0, import_client2.createRoot)(container);
      root.render(/* @__PURE__ */ (0, import_jsx_runtime30.jsx)(PyretReplInterfaceWrapper, { config }));
      if (config) {
        console.log(`\u2705 Pyret REPL mounted to #${containerId} with config:`, {
          hasInitialInstance: !!config.initialInstance,
          hasExternalEvaluator: !!config.externalEvaluator,
          disabled: config.disabled ?? false,
          className: config.className ?? "default"
        });
      } else {
        console.log(`\u2705 Pyret REPL mounted to #${containerId}`);
      }
      window.getCurrentPyretInstance = () => {
        return PyretReplStateManager.getInstance().getCurrentInstance();
      };
      window.reifyCurrentPyretInstance = () => {
        return PyretReplStateManager.getInstance().reifyCurrentInstance();
      };
      window.updatePyretInstance = (newInstance) => {
        PyretReplStateManager.getInstance().setCurrentInstance(newInstance);
      };
      return true;
    } catch (error) {
      console.error("Failed to mount Pyret REPL:", error);
      return false;
    }
  }
  function mountReplWithVisualization(containerId = "repl-visualization-container", config) {
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`REPL with Visualization: Container '${containerId}' not found`);
      return false;
    }
    try {
      const root = (0, import_client2.createRoot)(container);
      root.render(/* @__PURE__ */ (0, import_jsx_runtime30.jsx)(ReplWithVisualizationWrapper, { config }));
      if (config) {
        console.log(`\u2705 REPL with Visualization mounted to #${containerId} with config:`, {
          hasInitialInstance: !!config.initialInstance,
          initialCndSpec: config.initialCndSpec ? `${config.initialCndSpec.length} characters` : "none",
          showLayoutInterface: config.showLayoutInterface ?? true,
          replHeight: config.replHeight ?? "300px",
          visualizationHeight: config.visualizationHeight ?? "400px"
        });
      } else {
        console.log(`\u2705 REPL with Visualization mounted to #${containerId}`);
      }
      return true;
    } catch (error) {
      console.error("Failed to mount REPL with Visualization:", error);
      return false;
    }
  }
  function mountErrorMessageModal(containerId = "error-messages") {
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`Error Modal: Container '${containerId}' not found`);
      return false;
    }
    try {
      const root = (0, import_client2.createRoot)(container);
      root.render(/* @__PURE__ */ (0, import_jsx_runtime30.jsx)(ErrorMessageContainer, { errorManager: globalErrorManager }));
      console.log(`\u2705 Error Modal mounted to #${containerId}`);
      return true;
    } catch (error) {
      console.error("Failed to mount Error Modal:", error);
      return false;
    }
  }
  function mountEvaluatorRepl(containerId, evaluator, instanceNumber) {
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`Evaluator REPL: Container '${containerId}' not found`);
      return false;
    }
    if (!evaluator) {
      console.error("Evaluator REPL: No evaluator provided");
      return false;
    }
    try {
      const root = (0, import_client2.createRoot)(container);
      root.render(/* @__PURE__ */ (0, import_jsx_runtime30.jsx)(EvaluatorRepl, { evaluator, instanceNumber }));
      console.log(`\u2705 Evaluator REPL mounted to #${containerId}`);
      return true;
    } catch (error) {
      console.error("Failed to mount Evaluator REPL:", error);
      return false;
    }
  }
  function mountRelationHighlighter(containerId, graphElementId) {
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`Relation Highlighter: Container '${containerId}' not found`);
      return false;
    }
    try {
      const root = (0, import_client2.createRoot)(container);
      root.render(/* @__PURE__ */ (0, import_jsx_runtime30.jsx)(RelationHighlighter, { graphElementId }));
      console.log(`\u2705 Relation Highlighter mounted to #${containerId}`);
      return true;
    } catch (error) {
      console.error("Failed to mount Relation Highlighter:", error);
      return false;
    }
  }
  function mountAllComponents() {
    console.log("\u{1F680} Mounting all CnD components...");
    const results = {
      layoutInterface: mountCndLayoutInterface(),
      instanceBuilder: mountInstanceBuilder(),
      errorModal: mountErrorMessageModal()
    };
    const successCount = Object.values(results).filter(Boolean).length;
    console.log(`\u2705 Successfully mounted ${successCount}/3 CnD components`);
    return results;
  }
  function mountCombinedInputComponent(containerId = "combined-input-container", config) {
    return mountCombinedInput({
      containerId,
      ...config
    });
  }
  function mountAllComponentsWithPyret() {
    console.log("\u{1F680} Mounting all CnD components with Pyret REPL and Combined Input...");
    const results = {
      layoutInterface: mountCndLayoutInterface(),
      instanceBuilder: mountInstanceBuilder(),
      errorModal: mountErrorMessageModal(),
      pyretRepl: mountPyretRepl(),
      replWithVisualization: mountReplWithVisualization(),
      combinedInput: mountCombinedInputComponent()
    };
    const successCount = Object.values(results).filter(Boolean).length;
    console.log(`\u2705 Successfully mounted ${successCount}/6 CnD components with Pyret integration and Combined Input`);
    return results;
  }
  var ErrorAPI = {
    /**
     * Display a parse error with optional source context
     * @param message - Error message
     * @param source - Optional source context (e.g., "Layout Specification")
     */
    showParseError: (message, source) => {
      globalErrorManager.setError({
        type: "parse-error",
        message,
        source
      });
    },
    /**
     * Display a group overlap error
     * @param message - Error message
     * @param source - Optional source context
     */
    showGroupOverlapError: (message, source) => {
      globalErrorManager.setError({
        type: "group-overlap-error",
        message,
        source
      });
    },
    /**
     * Display constraint conflict errors
     * @param errorMessages - Detailed constraint conflict information
     */
    showConstraintError: (errorMessages) => {
      globalErrorManager.setError({
        type: "positional-error",
        messages: errorMessages
      });
    },
    /**
     * Display general error message
     * @param message - Error message
     */
    showGeneralError: (message) => {
      globalErrorManager.setError({
        type: "general-error",
        message
      });
    },
    /**
     * Clear all error messages
     */
    clearAllErrors: () => {
      globalErrorManager.clearError();
    },
    /**
     * Check if there are active errors
     * @returns True if there are active errors
     */
    hasActiveErrors: () => {
      return globalErrorManager.hasError();
    }
  };
  var DataAPI = {
    /**
     * Get current CND specification from React component state
     * @returns Current CND specification string or undefined if not available
     */
    getCurrentCndSpec: () => {
      try {
        const stateManager = CndLayoutStateManager.getInstance();
        const currentSpec = stateManager.getCurrentCndSpec();
        if (currentSpec.trim()) {
          return currentSpec;
        }
        const reactTextarea = document.querySelector("#webcola-cnd-container textarea");
        if (reactTextarea instanceof HTMLTextAreaElement) {
          return reactTextarea.value.trim();
        }
        console.warn("CndLayoutInterface not found or empty");
        return void 0;
      } catch (error) {
        console.error("Error accessing CND specification:", error);
        return void 0;
      }
    },
    /**
     * Get current data instance from InstanceBuilder component
     * @returns Current data instance or undefined if not available
     */
    getCurrentInstance: () => {
      try {
        return InstanceStateManager.getInstance().getCurrentInstance();
      } catch (error) {
        console.error("Error accessing current instance:", error);
        return void 0;
      }
    },
    /**
     * Update current data instance programmatically
     * @param instance - New data instance
     */
    updateInstance: (instance) => {
      try {
        InstanceStateManager.getInstance().setCurrentInstance(instance);
      } catch (error) {
        console.error("Error updating instance:", error);
      }
    },
    /**
     * Get current Pyret data instance from PyretReplInterface component
     * @returns Current Pyret data instance or undefined if not available
     */
    getCurrentPyretInstance: () => {
      try {
        return PyretReplStateManager.getInstance().getCurrentInstance();
      } catch (error) {
        console.error("Error accessing current Pyret instance:", error);
        return void 0;
      }
    },
    /**
     * Update current Pyret data instance programmatically
     * @param instance - New Pyret data instance
     */
    updatePyretInstance: (instance) => {
      try {
        PyretReplStateManager.getInstance().setCurrentInstance(instance);
      } catch (error) {
        console.error("Error updating Pyret instance:", error);
      }
    },
    /**
     * Get Pyret constructor notation (reify) of current Pyret instance
     * @returns Pyret constructor notation string
     */
    reifyCurrentPyretInstance: () => {
      try {
        return PyretReplStateManager.getInstance().reifyCurrentInstance();
      } catch (error) {
        console.error("Error reifying current Pyret instance:", error);
        return "/* Error generating Pyret notation */";
      }
    },
    /**
     * Set external Pyret evaluator for enhanced features
     * @param evaluator - External Pyret evaluator (e.g., window.__internalRepl)
     */
    setExternalPyretEvaluator: (evaluator) => {
      try {
        PyretReplStateManager.getInstance().setExternalEvaluator(evaluator);
      } catch (error) {
        console.error("Error setting external Pyret evaluator:", error);
      }
    },
    /**
     * Get current external Pyret evaluator
     * @returns Current external evaluator or null
     */
    getExternalPyretEvaluator: () => {
      try {
        return PyretReplStateManager.getInstance().getExternalEvaluator();
      } catch (error) {
        console.error("Error getting external Pyret evaluator:", error);
        return null;
      }
    }
  };
  var CnDCore = {
    // Mounting functions
    mountCndLayoutInterface,
    mountInstanceBuilder,
    mountErrorMessageModal,
    mountAllComponents,
    mountEvaluatorRepl,
    mountRelationHighlighter,
    // Pyret REPL mounting functions
    mountPyretRepl,
    mountReplWithVisualization,
    mountAllComponentsWithPyret,
    // Combined Input mounting functions
    mountCombinedInput: mountCombinedInputComponent,
    // State managers
    CndLayoutStateManager,
    InstanceStateManager,
    PyretReplStateManager,
    globalErrorManager,
    // API namespaces
    ErrorAPI,
    DataAPI,
    // Direct Pyret utilities for convenience
    PyretDataInstance
  };
  if (typeof window !== "undefined") {
    window.CnDCore = CnDCore;
    window.mountCndLayoutInterface = mountCndLayoutInterface;
    window.mountInstanceBuilder = mountInstanceBuilder;
    window.mountErrorMessageModal = mountErrorMessageModal;
    window.mountIntegratedComponents = mountAllComponents;
    window.mountEvaluatorRepl = mountEvaluatorRepl;
    window.mountRelationHighlighter = mountRelationHighlighter;
    window.mountPyretRepl = mountPyretRepl;
    window.mountReplWithVisualization = mountReplWithVisualization;
    window.mountAllComponentsWithPyret = mountAllComponentsWithPyret;
    window.mountCombinedInput = mountCombinedInputComponent;
    window.getCurrentCNDSpecFromReact = DataAPI.getCurrentCndSpec;
    window.getCurrentInstanceFromReact = DataAPI.getCurrentInstance;
    window.getCurrentPyretInstanceFromReact = DataAPI.getCurrentPyretInstance;
    window.reifyCurrentPyretInstanceFromReact = DataAPI.reifyCurrentPyretInstance;
    window.updatePyretInstanceFromReact = DataAPI.updatePyretInstance;
    window.setExternalPyretEvaluator = DataAPI.setExternalPyretEvaluator;
    window.getExternalPyretEvaluator = DataAPI.getExternalPyretEvaluator;
    window.showParseError = ErrorAPI.showParseError;
    window.showGroupOverlapError = ErrorAPI.showGroupOverlapError;
    window.showPositionalError = ErrorAPI.showConstraintError;
    window.showGeneralError = ErrorAPI.showGeneralError;
    window.clearAllErrors = ErrorAPI.clearAllErrors;
    console.log("\u{1F389} CnD-Core CDN integration ready! Use window.CnDCore to access all features including Pyret REPL.");
  }
  return __toCommonJS(react_component_integration_exports);
})();
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.development.js:
  (**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

simple-graph-query/dist/simple-graph-query.bundle.js:
  (*!
   * Copyright 2016 The ANTLR Project. All rights reserved.
   * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
   *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (**
  * @license
  * Lodash <https://lodash.com/>
  * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
  * Released under MIT license <https://lodash.com/license>
  * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
  * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  *)
  (*!**********************!*\
    !*** ./src/index.ts ***!
    \**********************)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)

chroma-js/src/utils/contrastAPCA.js:
  (**
   * @license
   *
   * The APCA contrast prediction algorithm is based of the formulas published
   * in the APCA-1.0.98G specification by Myndex. The specification is available at:
   * https://raw.githubusercontent.com/Myndex/apca-w3/master/images/APCAw3_0.1.17_APCA0.0.98G.svg
   *
   * Note that the APCA implementation is still beta, so please update to
   * future versions of chroma.js when they become available.
   *
   * You can read more about the APCA Readability Criterion at
   * https://readtech.org/ARC/
   *)
*/
//# sourceMappingURL=react-component-integration.global.js.map